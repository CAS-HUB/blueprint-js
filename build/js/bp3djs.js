var BP3DJS = (function (exports) {
  'use strict';

  

  function __$styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var Version = function () {
  	function Version() {
  		classCallCheck(this, Version);
  	}

  	createClass(Version, null, [{
  		key: 'isVersionHigherThan',
  		value: function isVersionHigherThan(version, checkVersion) {
  			if (version != undefined) {
  				checkVersion = checkVersion.replace(/[^\d.-]/g, '').split('.');
  				var givenVersion = version.replace(/[^\d.-]/g, '').split('.');
  				var flag = true;
  				if (checkVersion.length != givenVersion.length) {
  					return false;
  				}
  				for (var i = 0; i < checkVersion.length; i++) {
  					var a = parseInt(checkVersion[i]);
  					var b = parseInt(givenVersion[i]);
  					flag &= a >= b;
  				}
  				return flag;
  			}
  			return false;
  		}
  	}, {
  		key: 'getInformalVersion',
  		value: function getInformalVersion() {
  			return '0.0.2a';
  		}
  	}, {
  		key: 'getTechnicalVersion',
  		value: function getTechnicalVersion() {
  			return '0.0.2a';
  		}
  	}]);
  	return Version;
  }();

  var EVENT_ACTION = 'ACTION_EVENT';
  var EVENT_DELETED = 'DELETED_EVENT';
  var EVENT_MOVED = 'MOVED_EVENT';
  var EVENT_REDRAW = 'REDRAW_EVENT';
  var EVENT_NEW = 'NEW_EVENT';
  var EVENT_LOADED = 'LOADED_EVENT';
  var EVENT_LOADING = 'LOADING_EVENT';
  var EVENT_UPDATED = 'UPDATED_EVENT';
  var EVENT_SAVED = 'SAVED_EVENT';
  var EVENT_CHANGED = 'CHANGED_EVENT';
  var EVENT_GLTF_READY = 'GLTF_READY_EVENT';

  var EVENT_ITEM_LOADING = 'ITEM_LOADING_EVENT';
  var EVENT_ITEM_LOADED = 'ITEM_LOADED_EVENT';
  var EVENT_ITEM_REMOVED = 'ITEM_REMOVED_EVENT';
  var EVENT_ITEM_SELECTED = 'ITEM_SELECTED_EVENT';
  var EVENT_ITEM_UNSELECTED = 'ITEM_UNSELECTED_EVENT';

  var EVENT_MODE_RESET = 'MODE_RESET_EVENT';
  var EVENT_CAMERA_MOVED = 'CAMERA_MOVED_EVENT';
  var EVENT_CAMERA_ACTIVE_STATUS = 'CAMERA_ACTIVE_STATUS_EVENT';
  var EVENT_CAMERA_VIEW_CHANGE = 'CAMERA_VIEW_CHANGE_EVENT';
  var EVENT_FPS_EXIT = 'CAMERA_FPS_EXIT_EVENT';

  var EVENT_WALL_CLICKED = 'WALL_CLICKED_EVENT';
  var EVENT_ROOM_CLICKED = 'ROOM_CLICKED_EVENT';
  var EVENT_FLOOR_CLICKED = 'FLOOR_CLICKED_EVENT';
  var EVENT_NOTHING_CLICKED = 'NOTHING_CLICKED_EVENT';

  var EVENT_ROOM_NAME_CHANGED = 'CHANGED_ROOM_NAME_EVENT';

  var EVENT_CORNER_ATTRIBUTES_CHANGED = 'CORNER_ATTRIBUTES_CHANGED_EVENT';
  var EVENT_WALL_ATTRIBUTES_CHANGED = 'WALL_ATTRIBUTES_CHANGED_EVENT';
  var EVENT_ROOM_ATTRIBUTES_CHANGED = 'ROOM_ATTRIBUTES_CHANGED_EVENT';

  var EVENT_CORNER_2D_CLICKED = 'CORNER_CLICKED_2D_EVENT';
  var EVENT_WALL_2D_CLICKED = 'WALL_CLICKED_2D_EVENT';
  var EVENT_ROOM_2D_CLICKED = 'ROOM_CLICKED_2D_EVENT';

  var EVENT_CORNER_2D_DOUBLE_CLICKED = 'CORNER_DOUBLE_CLICKED_2D_EVENT';
  var EVENT_WALL_2D_DOUBLE_CLICKED = 'WALL_DOUBLE_CLICKED_2D_EVENT';
  var EVENT_ROOM_2D_DOUBLE_CLICKED = 'ROOM_DOUBLE_CLICKED_2D_EVENT';

  var EVENT_CORNER_2D_HOVER = 'CORNER_HOVER_2D_EVENT';
  var EVENT_WALL_2D_HOVER = 'WALL_HOVER_2D_EVENT';
  var EVENT_ROOM_2D_HOVER = 'ROOM_HOVER_2D_EVENT';

  var EVENT_NEW_ROOMS_ADDED = 'NEW_ROOMS_ADDED_EVENT';

  // Polyfills

  if (Number.EPSILON === undefined) {

      Number.EPSILON = Math.pow(2, -52);

  }

  if (Number.isInteger === undefined) {

      // Missing in IE
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

      Number.isInteger = function(value) {

          return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;

      };

  }

  //

  if (Math.sign === undefined) {

      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

      Math.sign = function(x) {

          return (x < 0) ? -1 : (x > 0) ? 1 : +x;

      };

  }

  if ('name' in Function.prototype === false) {

      // Missing in IE
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

      Object.defineProperty(Function.prototype, 'name', {

          get: function() {

              return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];

          }

      });

  }

  if (Object.assign === undefined) {

      // Missing in IE
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

      Object.assign = function(target) {

          if (target === undefined || target === null) {

              throw new TypeError('Cannot convert undefined or null to object');

          }

          const output = Object(target);

          for (let index = 1; index < arguments.length; index++) {

              const source = arguments[index];

              if (source !== undefined && source !== null) {

                  for (const nextKey in source) {

                      if (Object.prototype.hasOwnProperty.call(source, nextKey)) {

                          output[nextKey] = source[nextKey];

                      }

                  }

              }

          }

          return output;

      };

  }

  const REVISION = '118';
  const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  const CullFaceNone = 0;
  const CullFaceBack = 1;
  const CullFaceFront = 2;
  const CullFaceFrontBack = 3;
  const FrontFaceDirectionCW = 0;
  const FrontFaceDirectionCCW = 1;
  const BasicShadowMap = 0;
  const PCFShadowMap = 1;
  const PCFSoftShadowMap = 2;
  const VSMShadowMap = 3;
  const FrontSide = 0;
  const BackSide = 1;
  const DoubleSide = 2;
  const FlatShading = 1;
  const SmoothShading = 2;
  const NoBlending = 0;
  const NormalBlending = 1;
  const AdditiveBlending = 2;
  const SubtractiveBlending = 3;
  const MultiplyBlending = 4;
  const CustomBlending = 5;
  const AddEquation = 100;
  const SubtractEquation = 101;
  const ReverseSubtractEquation = 102;
  const MinEquation = 103;
  const MaxEquation = 104;
  const ZeroFactor = 200;
  const OneFactor = 201;
  const SrcColorFactor = 202;
  const OneMinusSrcColorFactor = 203;
  const SrcAlphaFactor = 204;
  const OneMinusSrcAlphaFactor = 205;
  const DstAlphaFactor = 206;
  const OneMinusDstAlphaFactor = 207;
  const DstColorFactor = 208;
  const OneMinusDstColorFactor = 209;
  const SrcAlphaSaturateFactor = 210;
  const NeverDepth = 0;
  const AlwaysDepth = 1;
  const LessDepth = 2;
  const LessEqualDepth = 3;
  const EqualDepth = 4;
  const GreaterEqualDepth = 5;
  const GreaterDepth = 6;
  const NotEqualDepth = 7;
  const MultiplyOperation = 0;
  const MixOperation = 1;
  const AddOperation = 2;
  const NoToneMapping = 0;
  const LinearToneMapping = 1;
  const ReinhardToneMapping = 2;
  const CineonToneMapping = 3;
  const ACESFilmicToneMapping = 4;
  const CustomToneMapping = 5;

  const UVMapping = 300;
  const CubeReflectionMapping = 301;
  const CubeRefractionMapping = 302;
  const EquirectangularReflectionMapping = 303;
  const EquirectangularRefractionMapping = 304;
  const CubeUVReflectionMapping = 306;
  const CubeUVRefractionMapping = 307;
  const RepeatWrapping = 1000;
  const ClampToEdgeWrapping = 1001;
  const MirroredRepeatWrapping = 1002;
  const NearestFilter = 1003;
  const NearestMipmapNearestFilter = 1004;
  const NearestMipMapNearestFilter = 1004;
  const NearestMipmapLinearFilter = 1005;
  const NearestMipMapLinearFilter = 1005;
  const LinearFilter = 1006;
  const LinearMipmapNearestFilter = 1007;
  const LinearMipMapNearestFilter = 1007;
  const LinearMipmapLinearFilter = 1008;
  const LinearMipMapLinearFilter = 1008;
  const UnsignedByteType = 1009;
  const ByteType = 1010;
  const ShortType = 1011;
  const UnsignedShortType = 1012;
  const IntType = 1013;
  const UnsignedIntType = 1014;
  const FloatType = 1015;
  const HalfFloatType = 1016;
  const UnsignedShort4444Type = 1017;
  const UnsignedShort5551Type = 1018;
  const UnsignedShort565Type = 1019;
  const UnsignedInt248Type = 1020;
  const AlphaFormat = 1021;
  const RGBFormat = 1022;
  const RGBAFormat = 1023;
  const LuminanceFormat = 1024;
  const LuminanceAlphaFormat = 1025;
  const RGBEFormat = RGBAFormat;
  const DepthFormat = 1026;
  const DepthStencilFormat = 1027;
  const RedFormat = 1028;
  const RedIntegerFormat = 1029;
  const RGFormat = 1030;
  const RGIntegerFormat = 1031;
  const RGBIntegerFormat = 1032;
  const RGBAIntegerFormat = 1033;

  const RGB_S3TC_DXT1_Format = 33776;
  const RGBA_S3TC_DXT1_Format = 33777;
  const RGBA_S3TC_DXT3_Format = 33778;
  const RGBA_S3TC_DXT5_Format = 33779;
  const RGB_PVRTC_4BPPV1_Format = 35840;
  const RGB_PVRTC_2BPPV1_Format = 35841;
  const RGBA_PVRTC_4BPPV1_Format = 35842;
  const RGBA_PVRTC_2BPPV1_Format = 35843;
  const RGB_ETC1_Format = 36196;
  const RGB_ETC2_Format = 37492;
  const RGBA_ETC2_EAC_Format = 37496;
  const RGBA_ASTC_4x4_Format = 37808;
  const RGBA_ASTC_5x4_Format = 37809;
  const RGBA_ASTC_5x5_Format = 37810;
  const RGBA_ASTC_6x5_Format = 37811;
  const RGBA_ASTC_6x6_Format = 37812;
  const RGBA_ASTC_8x5_Format = 37813;
  const RGBA_ASTC_8x6_Format = 37814;
  const RGBA_ASTC_8x8_Format = 37815;
  const RGBA_ASTC_10x5_Format = 37816;
  const RGBA_ASTC_10x6_Format = 37817;
  const RGBA_ASTC_10x8_Format = 37818;
  const RGBA_ASTC_10x10_Format = 37819;
  const RGBA_ASTC_12x10_Format = 37820;
  const RGBA_ASTC_12x12_Format = 37821;
  const RGBA_BPTC_Format = 36492;
  const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
  const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
  const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
  const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
  const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
  const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
  const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
  const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
  const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
  const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
  const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
  const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
  const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
  const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
  const LoopOnce = 2200;
  const LoopRepeat = 2201;
  const LoopPingPong = 2202;
  const InterpolateDiscrete = 2300;
  const InterpolateLinear = 2301;
  const InterpolateSmooth = 2302;
  const ZeroCurvatureEnding = 2400;
  const ZeroSlopeEnding = 2401;
  const WrapAroundEnding = 2402;
  const NormalAnimationBlendMode = 2500;
  const AdditiveAnimationBlendMode = 2501;
  const TrianglesDrawMode = 0;
  const TriangleStripDrawMode = 1;
  const TriangleFanDrawMode = 2;
  const LinearEncoding = 3000;
  const sRGBEncoding = 3001;
  const GammaEncoding = 3007;
  const RGBEEncoding = 3002;
  const LogLuvEncoding = 3003;
  const RGBM7Encoding = 3004;
  const RGBM16Encoding = 3005;
  const RGBDEncoding = 3006;
  const BasicDepthPacking = 3200;
  const RGBADepthPacking = 3201;
  const TangentSpaceNormalMap = 0;
  const ObjectSpaceNormalMap = 1;

  const ZeroStencilOp = 0;
  const KeepStencilOp = 7680;
  const ReplaceStencilOp = 7681;
  const IncrementStencilOp = 7682;
  const DecrementStencilOp = 7683;
  const IncrementWrapStencilOp = 34055;
  const DecrementWrapStencilOp = 34056;
  const InvertStencilOp = 5386;

  const NeverStencilFunc = 512;
  const LessStencilFunc = 513;
  const EqualStencilFunc = 514;
  const LessEqualStencilFunc = 515;
  const GreaterStencilFunc = 516;
  const NotEqualStencilFunc = 517;
  const GreaterEqualStencilFunc = 518;
  const AlwaysStencilFunc = 519;

  const StaticDrawUsage = 35044;
  const DynamicDrawUsage = 35048;
  const StreamDrawUsage = 35040;
  const StaticReadUsage = 35045;
  const DynamicReadUsage = 35049;
  const StreamReadUsage = 35041;
  const StaticCopyUsage = 35046;
  const DynamicCopyUsage = 35050;
  const StreamCopyUsage = 35042;

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  function EventDispatcher() {}

  Object.assign(EventDispatcher.prototype, {

      addEventListener: function(type, listener) {

          if (this._listeners === undefined) this._listeners = {};

          const listeners = this._listeners;

          if (listeners[type] === undefined) {

              listeners[type] = [];

          }

          if (listeners[type].indexOf(listener) === -1) {

              listeners[type].push(listener);

          }

      },

      hasEventListener: function(type, listener) {

          if (this._listeners === undefined) return false;

          const listeners = this._listeners;

          return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;

      },

      removeEventListener: function(type, listener) {

          if (this._listeners === undefined) return;

          const listeners = this._listeners;
          const listenerArray = listeners[type];

          if (listenerArray !== undefined) {

              const index = listenerArray.indexOf(listener);

              if (index !== -1) {

                  listenerArray.splice(index, 1);

              }

          }

      },

      dispatchEvent: function(event) {

          if (this._listeners === undefined) return;

          const listeners = this._listeners;
          const listenerArray = listeners[event.type];

          if (listenerArray !== undefined) {

              event.target = this;

              // Make a copy, in case listeners are removed while iterating.
              const array = listenerArray.slice(0);

              for (let i = 0, l = array.length; i < l; i++) {

                  array[i].call(this, event);

              }

          }

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author thezwap
   */

  const _lut = [];

  for (let i = 0; i < 256; i++) {

      _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);

  }

  const MathUtils = {

      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,

      generateUUID: function() {

          // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

          const d0 = Math.random() * 0xffffffff | 0;
          const d1 = Math.random() * 0xffffffff | 0;
          const d2 = Math.random() * 0xffffffff | 0;
          const d3 = Math.random() * 0xffffffff | 0;
          const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +
              _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +
              _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +
              _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

          // .toUpperCase() here flattens concatenated strings to save heap memory space.
          return uuid.toUpperCase();

      },

      clamp: function(value, min, max) {

          return Math.max(min, Math.min(max, value));

      },

      // compute euclidian modulo of m % n
      // https://en.wikipedia.org/wiki/Modulo_operation

      euclideanModulo: function(n, m) {

          return ((n % m) + m) % m;

      },

      // Linear mapping from range <a1, a2> to range <b1, b2>

      mapLinear: function(x, a1, a2, b1, b2) {

          return b1 + (x - a1) * (b2 - b1) / (a2 - a1);

      },

      // https://en.wikipedia.org/wiki/Linear_interpolation

      lerp: function(x, y, t) {

          return (1 - t) * x + t * y;

      },

      // http://en.wikipedia.org/wiki/Smoothstep

      smoothstep: function(x, min, max) {

          if (x <= min) return 0;
          if (x >= max) return 1;

          x = (x - min) / (max - min);

          return x * x * (3 - 2 * x);

      },

      smootherstep: function(x, min, max) {

          if (x <= min) return 0;
          if (x >= max) return 1;

          x = (x - min) / (max - min);

          return x * x * x * (x * (x * 6 - 15) + 10);

      },

      // Random integer from <low, high> interval

      randInt: function(low, high) {

          return low + Math.floor(Math.random() * (high - low + 1));

      },

      // Random float from <low, high> interval

      randFloat: function(low, high) {

          return low + Math.random() * (high - low);

      },

      // Random float from <-range/2, range/2> interval

      randFloatSpread: function(range) {

          return range * (0.5 - Math.random());

      },

      degToRad: function(degrees) {

          return degrees * MathUtils.DEG2RAD;

      },

      radToDeg: function(radians) {

          return radians * MathUtils.RAD2DEG;

      },

      isPowerOfTwo: function(value) {

          return (value & (value - 1)) === 0 && value !== 0;

      },

      ceilPowerOfTwo: function(value) {

          return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));

      },

      floorPowerOfTwo: function(value) {

          return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));

      },

      setQuaternionFromProperEuler: function(q, a, b, c, order) {

          // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

          // rotations are applied to the axes in the order specified by 'order'
          // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
          // angles are in radians

          const cos = Math.cos;
          const sin = Math.sin;

          const c2 = cos(b / 2);
          const s2 = sin(b / 2);

          const c13 = cos((a + c) / 2);
          const s13 = sin((a + c) / 2);

          const c1_3 = cos((a - c) / 2);
          const s1_3 = sin((a - c) / 2);

          const c3_1 = cos((c - a) / 2);
          const s3_1 = sin((c - a) / 2);

          switch (order) {

              case 'XYX':
                  q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                  break;

              case 'YZY':
                  q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                  break;

              case 'ZXZ':
                  q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                  break;

              case 'XZX':
                  q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                  break;

              case 'YXY':
                  q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                  break;

              case 'ZYZ':
                  q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                  break;

              default:
                  console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);

          }

      }

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author philogb / http://blog.thejit.org/
   * @author egraether / http://egraether.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  function Vector2(x = 0, y = 0) {

      this.x = x;
      this.y = y;

  }

  Object.defineProperties(Vector2.prototype, {

      "width": {

          get: function() {

              return this.x;

          },

          set: function(value) {

              this.x = value;

          }

      },

      "height": {

          get: function() {

              return this.y;

          },

          set: function(value) {

              this.y = value;

          }

      }

  });

  Object.assign(Vector2.prototype, {

      isVector2: true,

      set: function(x, y) {

          this.x = x;
          this.y = y;

          return this;

      },

      setScalar: function(scalar) {

          this.x = scalar;
          this.y = scalar;

          return this;

      },

      setX: function(x) {

          this.x = x;

          return this;

      },

      setY: function(y) {

          this.y = y;

          return this;

      },

      setComponent: function(index, value) {

          switch (index) {

              case 0:
                  this.x = value;
                  break;
              case 1:
                  this.y = value;
                  break;
              default:
                  throw new Error('index is out of range: ' + index);

          }

          return this;

      },

      getComponent: function(index) {

          switch (index) {

              case 0:
                  return this.x;
              case 1:
                  return this.y;
              default:
                  throw new Error('index is out of range: ' + index);

          }

      },

      clone: function() {

          return new this.constructor(this.x, this.y);

      },

      copy: function(v) {

          this.x = v.x;
          this.y = v.y;

          return this;

      },

      add: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
              return this.addVectors(v, w);

          }

          this.x += v.x;
          this.y += v.y;

          return this;

      },

      addScalar: function(s) {

          this.x += s;
          this.y += s;

          return this;

      },

      addVectors: function(a, b) {

          this.x = a.x + b.x;
          this.y = a.y + b.y;

          return this;

      },

      addScaledVector: function(v, s) {

          this.x += v.x * s;
          this.y += v.y * s;

          return this;

      },

      sub: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
              return this.subVectors(v, w);

          }

          this.x -= v.x;
          this.y -= v.y;

          return this;

      },

      subScalar: function(s) {

          this.x -= s;
          this.y -= s;

          return this;

      },

      subVectors: function(a, b) {

          this.x = a.x - b.x;
          this.y = a.y - b.y;

          return this;

      },

      multiply: function(v) {

          this.x *= v.x;
          this.y *= v.y;

          return this;

      },

      multiplyScalar: function(scalar) {

          this.x *= scalar;
          this.y *= scalar;

          return this;

      },

      divide: function(v) {

          this.x /= v.x;
          this.y /= v.y;

          return this;

      },

      divideScalar: function(scalar) {

          return this.multiplyScalar(1 / scalar);

      },

      applyMatrix3: function(m) {

          const x = this.x,
              y = this.y;
          const e = m.elements;

          this.x = e[0] * x + e[3] * y + e[6];
          this.y = e[1] * x + e[4] * y + e[7];

          return this;

      },

      min: function(v) {

          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);

          return this;

      },

      max: function(v) {

          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);

          return this;

      },

      clamp: function(min, max) {

          // assumes min < max, componentwise

          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));

          return this;

      },

      clampScalar: function(minVal, maxVal) {

          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));

          return this;

      },

      clampLength: function(min, max) {

          const length = this.length();

          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));

      },

      floor: function() {

          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);

          return this;

      },

      ceil: function() {

          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);

          return this;

      },

      round: function() {

          this.x = Math.round(this.x);
          this.y = Math.round(this.y);

          return this;

      },

      roundToZero: function() {

          this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);

          return this;

      },

      negate: function() {

          this.x = -this.x;
          this.y = -this.y;

          return this;

      },

      dot: function(v) {

          return this.x * v.x + this.y * v.y;

      },

      cross: function(v) {

          return this.x * v.y - this.y * v.x;

      },

      lengthSq: function() {

          return this.x * this.x + this.y * this.y;

      },

      length: function() {

          return Math.sqrt(this.x * this.x + this.y * this.y);

      },

      manhattanLength: function() {

          return Math.abs(this.x) + Math.abs(this.y);

      },

      normalize: function() {

          return this.divideScalar(this.length() || 1);

      },

      angle: function() {

          // computes the angle in radians with respect to the positive x-axis

          const angle = Math.atan2(-this.y, -this.x) + Math.PI;

          return angle;

      },

      distanceTo: function(v) {

          return Math.sqrt(this.distanceToSquared(v));

      },

      distanceToSquared: function(v) {

          const dx = this.x - v.x,
              dy = this.y - v.y;
          return dx * dx + dy * dy;

      },

      manhattanDistanceTo: function(v) {

          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);

      },

      setLength: function(length) {

          return this.normalize().multiplyScalar(length);

      },

      lerp: function(v, alpha) {

          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;

          return this;

      },

      lerpVectors: function(v1, v2, alpha) {

          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;

          return this;

      },

      equals: function(v) {

          return ((v.x === this.x) && (v.y === this.y));

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          this.x = array[offset];
          this.y = array[offset + 1];

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          array[offset] = this.x;
          array[offset + 1] = this.y;

          return array;

      },

      fromBufferAttribute: function(attribute, index, offset) {

          if (offset !== undefined) {

              console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');

          }

          this.x = attribute.getX(index);
          this.y = attribute.getY(index);

          return this;

      },

      rotateAround: function(center, angle) {

          const c = Math.cos(angle),
              s = Math.sin(angle);

          const x = this.x - center.x;
          const y = this.y - center.y;

          this.x = x * c - y * s + center.x;
          this.y = x * s + y * c + center.y;

          return this;

      },

      random: function() {

          this.x = Math.random();
          this.y = Math.random();

          return this;

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   * @author tschw
   */

  function Matrix3() {

      this.elements = [

          1, 0, 0,
          0, 1, 0,
          0, 0, 1

      ];

      if (arguments.length > 0) {

          console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');

      }

  }

  Object.assign(Matrix3.prototype, {

      isMatrix3: true,

      set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {

          const te = this.elements;

          te[0] = n11;
          te[1] = n21;
          te[2] = n31;
          te[3] = n12;
          te[4] = n22;
          te[5] = n32;
          te[6] = n13;
          te[7] = n23;
          te[8] = n33;

          return this;

      },

      identity: function() {

          this.set(

              1, 0, 0,
              0, 1, 0,
              0, 0, 1

          );

          return this;

      },

      clone: function() {

          return new this.constructor().fromArray(this.elements);

      },

      copy: function(m) {

          const te = this.elements;
          const me = m.elements;

          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];

          return this;

      },

      extractBasis: function(xAxis, yAxis, zAxis) {

          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);

          return this;

      },

      setFromMatrix4: function(m) {

          const me = m.elements;

          this.set(

              me[0], me[4], me[8],
              me[1], me[5], me[9],
              me[2], me[6], me[10]

          );

          return this;

      },

      multiply: function(m) {

          return this.multiplyMatrices(this, m);

      },

      premultiply: function(m) {

          return this.multiplyMatrices(m, this);

      },

      multiplyMatrices: function(a, b) {

          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;

          const a11 = ae[0],
              a12 = ae[3],
              a13 = ae[6];
          const a21 = ae[1],
              a22 = ae[4],
              a23 = ae[7];
          const a31 = ae[2],
              a32 = ae[5],
              a33 = ae[8];

          const b11 = be[0],
              b12 = be[3],
              b13 = be[6];
          const b21 = be[1],
              b22 = be[4],
              b23 = be[7];
          const b31 = be[2],
              b32 = be[5],
              b33 = be[8];

          te[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te[6] = a11 * b13 + a12 * b23 + a13 * b33;

          te[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te[7] = a21 * b13 + a22 * b23 + a23 * b33;

          te[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te[8] = a31 * b13 + a32 * b23 + a33 * b33;

          return this;

      },

      multiplyScalar: function(s) {

          const te = this.elements;

          te[0] *= s;
          te[3] *= s;
          te[6] *= s;
          te[1] *= s;
          te[4] *= s;
          te[7] *= s;
          te[2] *= s;
          te[5] *= s;
          te[8] *= s;

          return this;

      },

      determinant: function() {

          const te = this.elements;

          const a = te[0],
              b = te[1],
              c = te[2],
              d = te[3],
              e = te[4],
              f = te[5],
              g = te[6],
              h = te[7],
              i = te[8];

          return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

      },

      getInverse: function(matrix, throwOnDegenerate) {

          if (throwOnDegenerate !== undefined) {

              console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");

          }

          const me = matrix.elements,
              te = this.elements,

              n11 = me[0],
              n21 = me[1],
              n31 = me[2],
              n12 = me[3],
              n22 = me[4],
              n32 = me[5],
              n13 = me[6],
              n23 = me[7],
              n33 = me[8],

              t11 = n33 * n22 - n32 * n23,
              t12 = n32 * n13 - n33 * n12,
              t13 = n23 * n12 - n22 * n13,

              det = n11 * t11 + n21 * t12 + n31 * t13;

          if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);

          const detInv = 1 / det;

          te[0] = t11 * detInv;
          te[1] = (n31 * n23 - n33 * n21) * detInv;
          te[2] = (n32 * n21 - n31 * n22) * detInv;

          te[3] = t12 * detInv;
          te[4] = (n33 * n11 - n31 * n13) * detInv;
          te[5] = (n31 * n12 - n32 * n11) * detInv;

          te[6] = t13 * detInv;
          te[7] = (n21 * n13 - n23 * n11) * detInv;
          te[8] = (n22 * n11 - n21 * n12) * detInv;

          return this;

      },

      transpose: function() {

          let tmp;
          const m = this.elements;

          tmp = m[1];
          m[1] = m[3];
          m[3] = tmp;
          tmp = m[2];
          m[2] = m[6];
          m[6] = tmp;
          tmp = m[5];
          m[5] = m[7];
          m[7] = tmp;

          return this;

      },

      getNormalMatrix: function(matrix4) {

          return this.setFromMatrix4(matrix4).getInverse(this).transpose();

      },

      transposeIntoArray: function(r) {

          const m = this.elements;

          r[0] = m[0];
          r[1] = m[3];
          r[2] = m[6];
          r[3] = m[1];
          r[4] = m[4];
          r[5] = m[7];
          r[6] = m[2];
          r[7] = m[5];
          r[8] = m[8];

          return this;

      },

      setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {

          const c = Math.cos(rotation);
          const s = Math.sin(rotation);

          this.set(
              sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty,
              0, 0, 1
          );

      },

      scale: function(sx, sy) {

          const te = this.elements;

          te[0] *= sx;
          te[3] *= sx;
          te[6] *= sx;
          te[1] *= sy;
          te[4] *= sy;
          te[7] *= sy;

          return this;

      },

      rotate: function(theta) {

          const c = Math.cos(theta);
          const s = Math.sin(theta);

          const te = this.elements;

          const a11 = te[0],
              a12 = te[3],
              a13 = te[6];
          const a21 = te[1],
              a22 = te[4],
              a23 = te[7];

          te[0] = c * a11 + s * a21;
          te[3] = c * a12 + s * a22;
          te[6] = c * a13 + s * a23;

          te[1] = -s * a11 + c * a21;
          te[4] = -s * a12 + c * a22;
          te[7] = -s * a13 + c * a23;

          return this;

      },

      translate: function(tx, ty) {

          const te = this.elements;

          te[0] += tx * te[2];
          te[3] += tx * te[5];
          te[6] += tx * te[8];
          te[1] += ty * te[2];
          te[4] += ty * te[5];
          te[7] += ty * te[8];

          return this;

      },

      equals: function(matrix) {

          const te = this.elements;
          const me = matrix.elements;

          for (let i = 0; i < 9; i++) {

              if (te[i] !== me[i]) return false;

          }

          return true;

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          for (let i = 0; i < 9; i++) {

              this.elements[i] = array[i + offset];

          }

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          const te = this.elements;

          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];

          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];

          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];

          return array;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   */

  let _canvas;

  const ImageUtils = {

      getDataURL: function(image) {

          if (/^data:/i.test(image.src)) {

              return image.src;

          }

          if (typeof HTMLCanvasElement == 'undefined') {

              return image.src;

          }

          let canvas;

          if (image instanceof HTMLCanvasElement) {

              canvas = image;

          } else {

              if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');

              _canvas.width = image.width;
              _canvas.height = image.height;

              const context = _canvas.getContext('2d');

              if (image instanceof ImageData) {

                  context.putImageData(image, 0, 0);

              } else {

                  context.drawImage(image, 0, 0, image.width, image.height);

              }

              canvas = _canvas;

          }

          if (canvas.width > 2048 || canvas.height > 2048) {

              return canvas.toDataURL('image/jpeg', 0.6);

          } else {

              return canvas.toDataURL('image/png');

          }

      }

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   */

  let textureId = 0;

  function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

      Object.defineProperty(this, 'id', { value: textureId++ });

      this.uuid = MathUtils.generateUUID();

      this.name = '';

      this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
      this.mipmaps = [];

      this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

      this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
      this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

      this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
      this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;

      this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

      this.format = format !== undefined ? format : RGBAFormat;
      this.internalFormat = null;
      this.type = type !== undefined ? type : UnsignedByteType;

      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;

      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();

      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

      // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
      //
      // Also changing the encoding after already used by a Material will not automatically make the Material
      // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
      this.encoding = encoding !== undefined ? encoding : LinearEncoding;

      this.version = 0;
      this.onUpdate = null;

  }

  Texture.DEFAULT_IMAGE = undefined;
  Texture.DEFAULT_MAPPING = UVMapping;

  Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

      constructor: Texture,

      isTexture: true,

      updateMatrix: function() {

          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(source) {

          this.name = source.name;

          this.image = source.image;
          this.mipmaps = source.mipmaps.slice(0);

          this.mapping = source.mapping;

          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;

          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;

          this.anisotropy = source.anisotropy;

          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;

          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;

          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);

          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.encoding = source.encoding;

          return this;

      },

      toJSON: function(meta) {

          const isRootObject = (meta === undefined || typeof meta === 'string');

          if (!isRootObject && meta.textures[this.uuid] !== undefined) {

              return meta.textures[this.uuid];

          }

          const output = {

              metadata: {
                  version: 4.5,
                  type: 'Texture',
                  generator: 'Texture.toJSON'
              },

              uuid: this.uuid,
              name: this.name,

              mapping: this.mapping,

              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,

              wrap: [this.wrapS, this.wrapT],

              format: this.format,
              type: this.type,
              encoding: this.encoding,

              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,

              flipY: this.flipY,

              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment

          };

          if (this.image !== undefined) {

              // TODO: Move to THREE.Image

              const image = this.image;

              if (image.uuid === undefined) {

                  image.uuid = MathUtils.generateUUID(); // UGH

              }

              if (!isRootObject && meta.images[image.uuid] === undefined) {

                  let url;

                  if (Array.isArray(image)) {

                      // process array of images e.g. CubeTexture

                      url = [];

                      for (let i = 0, l = image.length; i < l; i++) {

                          url.push(ImageUtils.getDataURL(image[i]));

                      }

                  } else {

                      // process single image

                      url = ImageUtils.getDataURL(image);

                  }

                  meta.images[image.uuid] = {
                      uuid: image.uuid,
                      url: url
                  };

              }

              output.image = image.uuid;

          }

          if (!isRootObject) {

              meta.textures[this.uuid] = output;

          }

          return output;

      },

      dispose: function() {

          this.dispatchEvent({ type: 'dispose' });

      },

      transformUv: function(uv) {

          if (this.mapping !== UVMapping) return uv;

          uv.applyMatrix3(this.matrix);

          if (uv.x < 0 || uv.x > 1) {

              switch (this.wrapS) {

                  case RepeatWrapping:

                      uv.x = uv.x - Math.floor(uv.x);
                      break;

                  case ClampToEdgeWrapping:

                      uv.x = uv.x < 0 ? 0 : 1;
                      break;

                  case MirroredRepeatWrapping:

                      if (Math.abs(Math.floor(uv.x) % 2) === 1) {

                          uv.x = Math.ceil(uv.x) - uv.x;

                      } else {

                          uv.x = uv.x - Math.floor(uv.x);

                      }

                      break;

              }

          }

          if (uv.y < 0 || uv.y > 1) {

              switch (this.wrapT) {

                  case RepeatWrapping:

                      uv.y = uv.y - Math.floor(uv.y);
                      break;

                  case ClampToEdgeWrapping:

                      uv.y = uv.y < 0 ? 0 : 1;
                      break;

                  case MirroredRepeatWrapping:

                      if (Math.abs(Math.floor(uv.y) % 2) === 1) {

                          uv.y = Math.ceil(uv.y) - uv.y;

                      } else {

                          uv.y = uv.y - Math.floor(uv.y);

                      }

                      break;

              }

          }

          if (this.flipY) {

              uv.y = 1 - uv.y;

          }

          return uv;

      }

  });

  Object.defineProperty(Texture.prototype, "needsUpdate", {

      set: function(value) {

          if (value === true) this.version++;

      }

  });

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector4(x = 0, y = 0, z = 0, w = 1) {

      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;

  }

  Object.defineProperties(Vector4.prototype, {

      "width": {

          get: function() {

              return this.z;

          },

          set: function(value) {

              this.z = value;

          }

      },

      "height": {

          get: function() {

              return this.w;

          },

          set: function(value) {

              this.w = value;

          }

      }

  });

  Object.assign(Vector4.prototype, {

      isVector4: true,

      set: function(x, y, z, w) {

          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;

          return this;

      },

      setScalar: function(scalar) {

          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;

          return this;

      },

      setX: function(x) {

          this.x = x;

          return this;

      },

      setY: function(y) {

          this.y = y;

          return this;

      },

      setZ: function(z) {

          this.z = z;

          return this;

      },

      setW: function(w) {

          this.w = w;

          return this;

      },

      setComponent: function(index, value) {

          switch (index) {

              case 0:
                  this.x = value;
                  break;
              case 1:
                  this.y = value;
                  break;
              case 2:
                  this.z = value;
                  break;
              case 3:
                  this.w = value;
                  break;
              default:
                  throw new Error('index is out of range: ' + index);

          }

          return this;

      },

      getComponent: function(index) {

          switch (index) {

              case 0:
                  return this.x;
              case 1:
                  return this.y;
              case 2:
                  return this.z;
              case 3:
                  return this.w;
              default:
                  throw new Error('index is out of range: ' + index);

          }

      },

      clone: function() {

          return new this.constructor(this.x, this.y, this.z, this.w);

      },

      copy: function(v) {

          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          this.w = (v.w !== undefined) ? v.w : 1;

          return this;

      },

      add: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
              return this.addVectors(v, w);

          }

          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          this.w += v.w;

          return this;

      },

      addScalar: function(s) {

          this.x += s;
          this.y += s;
          this.z += s;
          this.w += s;

          return this;

      },

      addVectors: function(a, b) {

          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          this.w = a.w + b.w;

          return this;

      },

      addScaledVector: function(v, s) {

          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;
          this.w += v.w * s;

          return this;

      },

      sub: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
              return this.subVectors(v, w);

          }

          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          this.w -= v.w;

          return this;

      },

      subScalar: function(s) {

          this.x -= s;
          this.y -= s;
          this.z -= s;
          this.w -= s;

          return this;

      },

      subVectors: function(a, b) {

          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          this.w = a.w - b.w;

          return this;

      },

      multiplyScalar: function(scalar) {

          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;

          return this;

      },

      applyMatrix4: function(m) {

          const x = this.x,
              y = this.y,
              z = this.z,
              w = this.w;
          const e = m.elements;

          this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
          this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
          this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
          this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

          return this;

      },

      divideScalar: function(scalar) {

          return this.multiplyScalar(1 / scalar);

      },

      setAxisAngleFromQuaternion: function(q) {

          // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

          // q is assumed to be normalized

          this.w = 2 * Math.acos(q.w);

          const s = Math.sqrt(1 - q.w * q.w);

          if (s < 0.0001) {

              this.x = 1;
              this.y = 0;
              this.z = 0;

          } else {

              this.x = q.x / s;
              this.y = q.y / s;
              this.z = q.z / s;

          }

          return this;

      },

      setAxisAngleFromRotationMatrix: function(m) {

          // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

          // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

          let angle, x, y, z; // variables for result
          const epsilon = 0.01, // margin to allow for rounding errors
              epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees

              te = m.elements,

              m11 = te[0],
              m12 = te[4],
              m13 = te[8],
              m21 = te[1],
              m22 = te[5],
              m23 = te[9],
              m31 = te[2],
              m32 = te[6],
              m33 = te[10];

          if ((Math.abs(m12 - m21) < epsilon) &&
              (Math.abs(m13 - m31) < epsilon) &&
              (Math.abs(m23 - m32) < epsilon)) {

              // singularity found
              // first check for identity matrix which must have +1 for all terms
              // in leading diagonal and zero in other terms

              if ((Math.abs(m12 + m21) < epsilon2) &&
                  (Math.abs(m13 + m31) < epsilon2) &&
                  (Math.abs(m23 + m32) < epsilon2) &&
                  (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {

                  // this singularity is identity matrix so angle = 0

                  this.set(1, 0, 0, 0);

                  return this; // zero angle, arbitrary axis

              }

              // otherwise this singularity is angle = 180

              angle = Math.PI;

              const xx = (m11 + 1) / 2;
              const yy = (m22 + 1) / 2;
              const zz = (m33 + 1) / 2;
              const xy = (m12 + m21) / 4;
              const xz = (m13 + m31) / 4;
              const yz = (m23 + m32) / 4;

              if ((xx > yy) && (xx > zz)) {

                  // m11 is the largest diagonal term

                  if (xx < epsilon) {

                      x = 0;
                      y = 0.707106781;
                      z = 0.707106781;

                  } else {

                      x = Math.sqrt(xx);
                      y = xy / x;
                      z = xz / x;

                  }

              } else if (yy > zz) {

                  // m22 is the largest diagonal term

                  if (yy < epsilon) {

                      x = 0.707106781;
                      y = 0;
                      z = 0.707106781;

                  } else {

                      y = Math.sqrt(yy);
                      x = xy / y;
                      z = yz / y;

                  }

              } else {

                  // m33 is the largest diagonal term so base result on this

                  if (zz < epsilon) {

                      x = 0.707106781;
                      y = 0.707106781;
                      z = 0;

                  } else {

                      z = Math.sqrt(zz);
                      x = xz / z;
                      y = yz / z;

                  }

              }

              this.set(x, y, z, angle);

              return this; // return 180 deg rotation

          }

          // as we have reached here there are no singularities so we can handle normally

          let s = Math.sqrt((m32 - m23) * (m32 - m23) +
              (m13 - m31) * (m13 - m31) +
              (m21 - m12) * (m21 - m12)); // used to normalize

          if (Math.abs(s) < 0.001) s = 1;

          // prevent divide by zero, should not happen if matrix is orthogonal and should be
          // caught by singularity test above, but I've left it in just in case

          this.x = (m32 - m23) / s;
          this.y = (m13 - m31) / s;
          this.z = (m21 - m12) / s;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

          return this;

      },

      min: function(v) {

          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          this.w = Math.min(this.w, v.w);

          return this;

      },

      max: function(v) {

          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          this.w = Math.max(this.w, v.w);

          return this;

      },

      clamp: function(min, max) {

          // assumes min < max, componentwise

          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          this.w = Math.max(min.w, Math.min(max.w, this.w));

          return this;

      },

      clampScalar: function(minVal, maxVal) {

          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));

          return this;

      },

      clampLength: function(min, max) {

          const length = this.length();

          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));

      },

      floor: function() {

          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);

          return this;

      },

      ceil: function() {

          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);

          return this;

      },

      round: function() {

          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);

          return this;

      },

      roundToZero: function() {

          this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);

          return this;

      },

      negate: function() {

          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;

          return this;

      },

      dot: function(v) {

          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

      },

      lengthSq: function() {

          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

      },

      length: function() {

          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

      },

      manhattanLength: function() {

          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);

      },

      normalize: function() {

          return this.divideScalar(this.length() || 1);

      },

      setLength: function(length) {

          return this.normalize().multiplyScalar(length);

      },

      lerp: function(v, alpha) {

          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          this.w += (v.w - this.w) * alpha;

          return this;

      },

      lerpVectors: function(v1, v2, alpha) {

          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          this.w = v1.w + (v2.w - v1.w) * alpha;

          return this;

      },

      equals: function(v) {

          return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;

          return array;

      },

      fromBufferAttribute: function(attribute, index, offset) {

          if (offset !== undefined) {

              console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');

          }

          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          this.w = attribute.getW(index);

          return this;

      },

      random: function() {

          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();

          return this;

      }

  });

  /**
   * @author szimek / https://github.com/szimek/
   * @author alteredq / http://alteredqualia.com/
   * @author Marius Kintel / https://github.com/kintel
   */

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  function WebGLRenderTarget(width, height, options) {

      this.width = width;
      this.height = height;

      this.scissor = new Vector4(0, 0, width, height);
      this.scissorTest = false;

      this.viewport = new Vector4(0, 0, width, height);

      options = options || {};

      this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

      this.texture.image = {};
      this.texture.image.width = width;
      this.texture.image.height = height;

      this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

      this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
      this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  }

  WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

      constructor: WebGLRenderTarget,

      isWebGLRenderTarget: true,

      setSize: function(width, height) {

          if (this.width !== width || this.height !== height) {

              this.width = width;
              this.height = height;

              this.texture.image.width = width;
              this.texture.image.height = height;

              this.dispose();

          }

          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(source) {

          this.width = source.width;
          this.height = source.height;

          this.viewport.copy(source.viewport);

          this.texture = source.texture.clone();

          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;

          return this;

      },

      dispose: function() {

          this.dispatchEvent({ type: 'dispose' });

      }

  });

  /**
   * @author Mugen87 / https://github.com/Mugen87
   * @author Matt DesLauriers / @mattdesl
   */

  function WebGLMultisampleRenderTarget(width, height, options) {

      WebGLRenderTarget.call(this, width, height, options);

      this.samples = 4;

  }

  WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {

      constructor: WebGLMultisampleRenderTarget,

      isWebGLMultisampleRenderTarget: true,

      copy: function(source) {

          WebGLRenderTarget.prototype.copy.call(this, source);

          this.samples = source.samples;

          return this;

      }

  });

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Quaternion(x = 0, y = 0, z = 0, w = 1) {

      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;

  }

  Object.assign(Quaternion, {

      slerp: function(qa, qb, qm, t) {

          return qm.copy(qa).slerp(qb, t);

      },

      slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {

          // fuzz-free, array-based Quaternion SLERP operation

          let x0 = src0[srcOffset0 + 0],
              y0 = src0[srcOffset0 + 1],
              z0 = src0[srcOffset0 + 2],
              w0 = src0[srcOffset0 + 3];

          const x1 = src1[srcOffset1 + 0],
              y1 = src1[srcOffset1 + 1],
              z1 = src1[srcOffset1 + 2],
              w1 = src1[srcOffset1 + 3];

          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {

              let s = 1 - t,

                  cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

                  dir = (cos >= 0 ? 1 : -1),
                  sqrSin = 1 - cos * cos;

              // Skip the Slerp for tiny steps to avoid numeric problems:
              if (sqrSin > Number.EPSILON) {

                  const sin = Math.sqrt(sqrSin),
                      len = Math.atan2(sin, cos * dir);

                  s = Math.sin(s * len) / sin;
                  t = Math.sin(t * len) / sin;

              }

              const tDir = t * dir;

              x0 = x0 * s + x1 * tDir;
              y0 = y0 * s + y1 * tDir;
              z0 = z0 * s + z1 * tDir;
              w0 = w0 * s + w1 * tDir;

              // Normalize in case we just did a lerp:
              if (s === 1 - t) {

                  const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

                  x0 *= f;
                  y0 *= f;
                  z0 *= f;
                  w0 *= f;

              }

          }

          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;

      },

      multiplyQuaternionsFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {

          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];

          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];

          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

          return dst;

      }

  });

  Object.defineProperties(Quaternion.prototype, {

      x: {

          get: function() {

              return this._x;

          },

          set: function(value) {

              this._x = value;
              this._onChangeCallback();

          }

      },

      y: {

          get: function() {

              return this._y;

          },

          set: function(value) {

              this._y = value;
              this._onChangeCallback();

          }

      },

      z: {

          get: function() {

              return this._z;

          },

          set: function(value) {

              this._z = value;
              this._onChangeCallback();

          }

      },

      w: {

          get: function() {

              return this._w;

          },

          set: function(value) {

              this._w = value;
              this._onChangeCallback();

          }

      }

  });

  Object.assign(Quaternion.prototype, {

      isQuaternion: true,

      set: function(x, y, z, w) {

          this._x = x;
          this._y = y;
          this._z = z;
          this._w = w;

          this._onChangeCallback();

          return this;

      },

      clone: function() {

          return new this.constructor(this._x, this._y, this._z, this._w);

      },

      copy: function(quaternion) {

          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;

          this._onChangeCallback();

          return this;

      },

      setFromEuler: function(euler, update) {

          if (!(euler && euler.isEuler)) {

              throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');

          }

          const x = euler._x,
              y = euler._y,
              z = euler._z,
              order = euler.order;

          // http://www.mathworks.com/matlabcentral/fileexchange/
          // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
          //	content/SpinCalc.m

          const cos = Math.cos;
          const sin = Math.sin;

          const c1 = cos(x / 2);
          const c2 = cos(y / 2);
          const c3 = cos(z / 2);

          const s1 = sin(x / 2);
          const s2 = sin(y / 2);
          const s3 = sin(z / 2);

          switch (order) {

              case 'XYZ':
                  this._x = s1 * c2 * c3 + c1 * s2 * s3;
                  this._y = c1 * s2 * c3 - s1 * c2 * s3;
                  this._z = c1 * c2 * s3 + s1 * s2 * c3;
                  this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;

              case 'YXZ':
                  this._x = s1 * c2 * c3 + c1 * s2 * s3;
                  this._y = c1 * s2 * c3 - s1 * c2 * s3;
                  this._z = c1 * c2 * s3 - s1 * s2 * c3;
                  this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;

              case 'ZXY':
                  this._x = s1 * c2 * c3 - c1 * s2 * s3;
                  this._y = c1 * s2 * c3 + s1 * c2 * s3;
                  this._z = c1 * c2 * s3 + s1 * s2 * c3;
                  this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;

              case 'ZYX':
                  this._x = s1 * c2 * c3 - c1 * s2 * s3;
                  this._y = c1 * s2 * c3 + s1 * c2 * s3;
                  this._z = c1 * c2 * s3 - s1 * s2 * c3;
                  this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;

              case 'YZX':
                  this._x = s1 * c2 * c3 + c1 * s2 * s3;
                  this._y = c1 * s2 * c3 + s1 * c2 * s3;
                  this._z = c1 * c2 * s3 - s1 * s2 * c3;
                  this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;

              case 'XZY':
                  this._x = s1 * c2 * c3 - c1 * s2 * s3;
                  this._y = c1 * s2 * c3 - s1 * c2 * s3;
                  this._z = c1 * c2 * s3 + s1 * s2 * c3;
                  this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;

              default:
                  console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);

          }

          if (update !== false) this._onChangeCallback();

          return this;

      },

      setFromAxisAngle: function(axis, angle) {

          // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

          // assumes axis is normalized

          const halfAngle = angle / 2,
              s = Math.sin(halfAngle);

          this._x = axis.x * s;
          this._y = axis.y * s;
          this._z = axis.z * s;
          this._w = Math.cos(halfAngle);

          this._onChangeCallback();

          return this;

      },

      setFromRotationMatrix: function(m) {

          // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

          // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

          const te = m.elements,

              m11 = te[0],
              m12 = te[4],
              m13 = te[8],
              m21 = te[1],
              m22 = te[5],
              m23 = te[9],
              m31 = te[2],
              m32 = te[6],
              m33 = te[10],

              trace = m11 + m22 + m33;

          if (trace > 0) {

              const s = 0.5 / Math.sqrt(trace + 1.0);

              this._w = 0.25 / s;
              this._x = (m32 - m23) * s;
              this._y = (m13 - m31) * s;
              this._z = (m21 - m12) * s;

          } else if (m11 > m22 && m11 > m33) {

              const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

              this._w = (m32 - m23) / s;
              this._x = 0.25 * s;
              this._y = (m12 + m21) / s;
              this._z = (m13 + m31) / s;

          } else if (m22 > m33) {

              const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

              this._w = (m13 - m31) / s;
              this._x = (m12 + m21) / s;
              this._y = 0.25 * s;
              this._z = (m23 + m32) / s;

          } else {

              const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

              this._w = (m21 - m12) / s;
              this._x = (m13 + m31) / s;
              this._y = (m23 + m32) / s;
              this._z = 0.25 * s;

          }

          this._onChangeCallback();

          return this;

      },

      setFromUnitVectors: function(vFrom, vTo) {

          // assumes direction vectors vFrom and vTo are normalized

          const EPS = 0.000001;

          let r = vFrom.dot(vTo) + 1;

          if (r < EPS) {

              r = 0;

              if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {

                  this._x = -vFrom.y;
                  this._y = vFrom.x;
                  this._z = 0;
                  this._w = r;

              } else {

                  this._x = 0;
                  this._y = -vFrom.z;
                  this._z = vFrom.y;
                  this._w = r;

              }

          } else {

              // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

              this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
              this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
              this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
              this._w = r;

          }

          return this.normalize();

      },

      angleTo: function(q) {

          return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));

      },

      rotateTowards: function(q, step) {

          const angle = this.angleTo(q);

          if (angle === 0) return this;

          const t = Math.min(1, step / angle);

          this.slerp(q, t);

          return this;

      },

      inverse: function() {

          // quaternion is assumed to have unit length

          return this.conjugate();

      },

      conjugate: function() {

          this._x *= -1;
          this._y *= -1;
          this._z *= -1;

          this._onChangeCallback();

          return this;

      },

      dot: function(v) {

          return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

      },

      lengthSq: function() {

          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

      },

      length: function() {

          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);

      },

      normalize: function() {

          let l = this.length();

          if (l === 0) {

              this._x = 0;
              this._y = 0;
              this._z = 0;
              this._w = 1;

          } else {

              l = 1 / l;

              this._x = this._x * l;
              this._y = this._y * l;
              this._z = this._z * l;
              this._w = this._w * l;

          }

          this._onChangeCallback();

          return this;

      },

      multiply: function(q, p) {

          if (p !== undefined) {

              console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
              return this.multiplyQuaternions(q, p);

          }

          return this.multiplyQuaternions(this, q);

      },

      premultiply: function(q) {

          return this.multiplyQuaternions(q, this);

      },

      multiplyQuaternions: function(a, b) {

          // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

          const qax = a._x,
              qay = a._y,
              qaz = a._z,
              qaw = a._w;
          const qbx = b._x,
              qby = b._y,
              qbz = b._z,
              qbw = b._w;

          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

          this._onChangeCallback();

          return this;

      },

      slerp: function(qb, t) {

          if (t === 0) return this;
          if (t === 1) return this.copy(qb);

          const x = this._x,
              y = this._y,
              z = this._z,
              w = this._w;

          // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

          let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

          if (cosHalfTheta < 0) {

              this._w = -qb._w;
              this._x = -qb._x;
              this._y = -qb._y;
              this._z = -qb._z;

              cosHalfTheta = -cosHalfTheta;

          } else {

              this.copy(qb);

          }

          if (cosHalfTheta >= 1.0) {

              this._w = w;
              this._x = x;
              this._y = y;
              this._z = z;

              return this;

          }

          const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

          if (sqrSinHalfTheta <= Number.EPSILON) {

              const s = 1 - t;
              this._w = s * w + t * this._w;
              this._x = s * x + t * this._x;
              this._y = s * y + t * this._y;
              this._z = s * z + t * this._z;

              this.normalize();
              this._onChangeCallback();

              return this;

          }

          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
              ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

          this._w = (w * ratioA + this._w * ratioB);
          this._x = (x * ratioA + this._x * ratioB);
          this._y = (y * ratioA + this._y * ratioB);
          this._z = (z * ratioA + this._z * ratioB);

          this._onChangeCallback();

          return this;

      },

      equals: function(quaternion) {

          return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];

          this._onChangeCallback();

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;

          return array;

      },

      fromBufferAttribute: function(attribute, index) {

          this._x = attribute.getX(index);
          this._y = attribute.getY(index);
          this._z = attribute.getZ(index);
          this._w = attribute.getW(index);

          return this;

      },

      _onChange: function(callback) {

          this._onChangeCallback = callback;

          return this;

      },

      _onChangeCallback: function() {}

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  const _vector = new Vector3();
  const _quaternion = new Quaternion();

  function Vector3(x = 0, y = 0, z = 0) {

      this.x = x;
      this.y = y;
      this.z = z;

  }

  Object.assign(Vector3.prototype, {

      isVector3: true,

      set: function(x, y, z) {

          this.x = x;
          this.y = y;
          this.z = z;

          return this;

      },

      setScalar: function(scalar) {

          this.x = scalar;
          this.y = scalar;
          this.z = scalar;

          return this;

      },

      setX: function(x) {

          this.x = x;

          return this;

      },

      setY: function(y) {

          this.y = y;

          return this;

      },

      setZ: function(z) {

          this.z = z;

          return this;

      },

      setComponent: function(index, value) {

          switch (index) {

              case 0:
                  this.x = value;
                  break;
              case 1:
                  this.y = value;
                  break;
              case 2:
                  this.z = value;
                  break;
              default:
                  throw new Error('index is out of range: ' + index);

          }

          return this;

      },

      getComponent: function(index) {

          switch (index) {

              case 0:
                  return this.x;
              case 1:
                  return this.y;
              case 2:
                  return this.z;
              default:
                  throw new Error('index is out of range: ' + index);

          }

      },

      clone: function() {

          return new this.constructor(this.x, this.y, this.z);

      },

      copy: function(v) {

          this.x = v.x;
          this.y = v.y;
          this.z = v.z;

          return this;

      },

      add: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
              return this.addVectors(v, w);

          }

          this.x += v.x;
          this.y += v.y;
          this.z += v.z;

          return this;

      },

      addScalar: function(s) {

          this.x += s;
          this.y += s;
          this.z += s;

          return this;

      },

      addVectors: function(a, b) {

          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;

          return this;

      },

      addScaledVector: function(v, s) {

          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;

          return this;

      },

      sub: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
              return this.subVectors(v, w);

          }

          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;

          return this;

      },

      subScalar: function(s) {

          this.x -= s;
          this.y -= s;
          this.z -= s;

          return this;

      },

      subVectors: function(a, b) {

          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;

          return this;

      },

      multiply: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
              return this.multiplyVectors(v, w);

          }

          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;

          return this;

      },

      multiplyScalar: function(scalar) {

          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;

          return this;

      },

      multiplyVectors: function(a, b) {

          this.x = a.x * b.x;
          this.y = a.y * b.y;
          this.z = a.z * b.z;

          return this;

      },

      applyEuler: function(euler) {

          if (!(euler && euler.isEuler)) {

              console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');

          }

          return this.applyQuaternion(_quaternion.setFromEuler(euler));

      },

      applyAxisAngle: function(axis, angle) {

          return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));

      },

      applyMatrix3: function(m) {

          const x = this.x,
              y = this.y,
              z = this.z;
          const e = m.elements;

          this.x = e[0] * x + e[3] * y + e[6] * z;
          this.y = e[1] * x + e[4] * y + e[7] * z;
          this.z = e[2] * x + e[5] * y + e[8] * z;

          return this;

      },

      applyNormalMatrix: function(m) {

          return this.applyMatrix3(m).normalize();

      },

      applyMatrix4: function(m) {

          const x = this.x,
              y = this.y,
              z = this.z;
          const e = m.elements;

          const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);

          this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
          this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
          this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;

          return this;

      },

      applyQuaternion: function(q) {

          const x = this.x,
              y = this.y,
              z = this.z;
          const qx = q.x,
              qy = q.y,
              qz = q.z,
              qw = q.w;

          // calculate quat * vector

          const ix = qw * x + qy * z - qz * y;
          const iy = qw * y + qz * x - qx * z;
          const iz = qw * z + qx * y - qy * x;
          const iw = -qx * x - qy * y - qz * z;

          // calculate result * inverse quat

          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

          return this;

      },

      project: function(camera) {

          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);

      },

      unproject: function(camera) {

          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);

      },

      transformDirection: function(m) {

          // input: THREE.Matrix4 affine matrix
          // vector interpreted as a direction

          const x = this.x,
              y = this.y,
              z = this.z;
          const e = m.elements;

          this.x = e[0] * x + e[4] * y + e[8] * z;
          this.y = e[1] * x + e[5] * y + e[9] * z;
          this.z = e[2] * x + e[6] * y + e[10] * z;

          return this.normalize();

      },

      divide: function(v) {

          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;

          return this;

      },

      divideScalar: function(scalar) {

          return this.multiplyScalar(1 / scalar);

      },

      min: function(v) {

          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);

          return this;

      },

      max: function(v) {

          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);

          return this;

      },

      clamp: function(min, max) {

          // assumes min < max, componentwise

          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));

          return this;

      },

      clampScalar: function(minVal, maxVal) {

          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));

          return this;

      },

      clampLength: function(min, max) {

          const length = this.length();

          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));

      },

      floor: function() {

          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);

          return this;

      },

      ceil: function() {

          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);

          return this;

      },

      round: function() {

          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);

          return this;

      },

      roundToZero: function() {

          this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);

          return this;

      },

      negate: function() {

          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;

          return this;

      },

      dot: function(v) {

          return this.x * v.x + this.y * v.y + this.z * v.z;

      },

      // TODO lengthSquared?

      lengthSq: function() {

          return this.x * this.x + this.y * this.y + this.z * this.z;

      },

      length: function() {

          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

      },

      manhattanLength: function() {

          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);

      },

      normalize: function() {

          return this.divideScalar(this.length() || 1);

      },

      setLength: function(length) {

          return this.normalize().multiplyScalar(length);

      },

      lerp: function(v, alpha) {

          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;

          return this;

      },

      lerpVectors: function(v1, v2, alpha) {

          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;

          return this;

      },

      cross: function(v, w) {

          if (w !== undefined) {

              console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
              return this.crossVectors(v, w);

          }

          return this.crossVectors(this, v);

      },

      crossVectors: function(a, b) {

          const ax = a.x,
              ay = a.y,
              az = a.z;
          const bx = b.x,
              by = b.y,
              bz = b.z;

          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;

          return this;

      },

      projectOnVector: function(v) {

          const denominator = v.lengthSq();

          if (denominator === 0) return this.set(0, 0, 0);

          const scalar = v.dot(this) / denominator;

          return this.copy(v).multiplyScalar(scalar);

      },

      projectOnPlane: function(planeNormal) {

          _vector.copy(this).projectOnVector(planeNormal);

          return this.sub(_vector);

      },

      reflect: function(normal) {

          // reflect incident vector off plane orthogonal to normal
          // normal is assumed to have unit length

          return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));

      },

      angleTo: function(v) {

          const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());

          if (denominator === 0) return Math.PI / 2;

          const theta = this.dot(v) / denominator;

          // clamp, to handle numerical problems

          return Math.acos(MathUtils.clamp(theta, -1, 1));

      },

      distanceTo: function(v) {

          return Math.sqrt(this.distanceToSquared(v));

      },

      distanceToSquared: function(v) {

          const dx = this.x - v.x,
              dy = this.y - v.y,
              dz = this.z - v.z;

          return dx * dx + dy * dy + dz * dz;

      },

      manhattanDistanceTo: function(v) {

          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);

      },

      setFromSpherical: function(s) {

          return this.setFromSphericalCoords(s.radius, s.phi, s.theta);

      },

      setFromSphericalCoords: function(radius, phi, theta) {

          const sinPhiRadius = Math.sin(phi) * radius;

          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);

          return this;

      },

      setFromCylindrical: function(c) {

          return this.setFromCylindricalCoords(c.radius, c.theta, c.y);

      },

      setFromCylindricalCoords: function(radius, theta, y) {

          this.x = radius * Math.sin(theta);
          this.y = y;
          this.z = radius * Math.cos(theta);

          return this;

      },

      setFromMatrixPosition: function(m) {

          const e = m.elements;

          this.x = e[12];
          this.y = e[13];
          this.z = e[14];

          return this;

      },

      setFromMatrixScale: function(m) {

          const sx = this.setFromMatrixColumn(m, 0).length();
          const sy = this.setFromMatrixColumn(m, 1).length();
          const sz = this.setFromMatrixColumn(m, 2).length();

          this.x = sx;
          this.y = sy;
          this.z = sz;

          return this;

      },

      setFromMatrixColumn: function(m, index) {

          return this.fromArray(m.elements, index * 4);

      },

      setFromMatrix3Column: function(m, index) {

          return this.fromArray(m.elements, index * 3);

      },

      equals: function(v) {

          return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;

          return array;

      },

      fromBufferAttribute: function(attribute, index, offset) {

          if (offset !== undefined) {

              console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');

          }

          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);

          return this;

      },

      random: function() {

          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();

          return this;

      }

  });

  const _v1 = new Vector3();
  const _m1 = new Matrix4();
  const _zero = new Vector3(0, 0, 0);
  const _one = new Vector3(1, 1, 1);
  const _x = new Vector3();
  const _y = new Vector3();
  const _z = new Vector3();

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author jordi_ros / http://plattsoft.com
   * @author D1plo1d / http://github.com/D1plo1d
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author timknip / http://www.floorplanner.com/
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Matrix4() {

      this.elements = [

          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1

      ];

      if (arguments.length > 0) {

          console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');

      }

  }

  Object.assign(Matrix4.prototype, {

      isMatrix4: true,

      set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

          const te = this.elements;

          te[0] = n11;
          te[4] = n12;
          te[8] = n13;
          te[12] = n14;
          te[1] = n21;
          te[5] = n22;
          te[9] = n23;
          te[13] = n24;
          te[2] = n31;
          te[6] = n32;
          te[10] = n33;
          te[14] = n34;
          te[3] = n41;
          te[7] = n42;
          te[11] = n43;
          te[15] = n44;

          return this;

      },

      identity: function() {

          this.set(

              1, 0, 0, 0,
              0, 1, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1

          );

          return this;

      },

      clone: function() {

          return new Matrix4().fromArray(this.elements);

      },

      copy: function(m) {

          const te = this.elements;
          const me = m.elements;

          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          te[9] = me[9];
          te[10] = me[10];
          te[11] = me[11];
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          te[15] = me[15];

          return this;

      },

      copyPosition: function(m) {

          const te = this.elements,
              me = m.elements;

          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];

          return this;

      },

      extractBasis: function(xAxis, yAxis, zAxis) {

          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);

          return this;

      },

      makeBasis: function(xAxis, yAxis, zAxis) {

          this.set(
              xAxis.x, yAxis.x, zAxis.x, 0,
              xAxis.y, yAxis.y, zAxis.y, 0,
              xAxis.z, yAxis.z, zAxis.z, 0,
              0, 0, 0, 1
          );

          return this;

      },

      extractRotation: function(m) {

          // this method does not support reflection matrices

          const te = this.elements;
          const me = m.elements;

          const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
          const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
          const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[3] = 0;

          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[7] = 0;

          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          te[11] = 0;

          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;

          return this;

      },

      makeRotationFromEuler: function(euler) {

          if (!(euler && euler.isEuler)) {

              console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');

          }

          const te = this.elements;

          const x = euler.x,
              y = euler.y,
              z = euler.z;
          const a = Math.cos(x),
              b = Math.sin(x);
          const c = Math.cos(y),
              d = Math.sin(y);
          const e = Math.cos(z),
              f = Math.sin(z);

          if (euler.order === 'XYZ') {

              const ae = a * e,
                  af = a * f,
                  be = b * e,
                  bf = b * f;

              te[0] = c * e;
              te[4] = -c * f;
              te[8] = d;

              te[1] = af + be * d;
              te[5] = ae - bf * d;
              te[9] = -b * c;

              te[2] = bf - ae * d;
              te[6] = be + af * d;
              te[10] = a * c;

          } else if (euler.order === 'YXZ') {

              const ce = c * e,
                  cf = c * f,
                  de = d * e,
                  df = d * f;

              te[0] = ce + df * b;
              te[4] = de * b - cf;
              te[8] = a * d;

              te[1] = a * f;
              te[5] = a * e;
              te[9] = -b;

              te[2] = cf * b - de;
              te[6] = df + ce * b;
              te[10] = a * c;

          } else if (euler.order === 'ZXY') {

              const ce = c * e,
                  cf = c * f,
                  de = d * e,
                  df = d * f;

              te[0] = ce - df * b;
              te[4] = -a * f;
              te[8] = de + cf * b;

              te[1] = cf + de * b;
              te[5] = a * e;
              te[9] = df - ce * b;

              te[2] = -a * d;
              te[6] = b;
              te[10] = a * c;

          } else if (euler.order === 'ZYX') {

              const ae = a * e,
                  af = a * f,
                  be = b * e,
                  bf = b * f;

              te[0] = c * e;
              te[4] = be * d - af;
              te[8] = ae * d + bf;

              te[1] = c * f;
              te[5] = bf * d + ae;
              te[9] = af * d - be;

              te[2] = -d;
              te[6] = b * c;
              te[10] = a * c;

          } else if (euler.order === 'YZX') {

              const ac = a * c,
                  ad = a * d,
                  bc = b * c,
                  bd = b * d;

              te[0] = c * e;
              te[4] = bd - ac * f;
              te[8] = bc * f + ad;

              te[1] = f;
              te[5] = a * e;
              te[9] = -b * e;

              te[2] = -d * e;
              te[6] = ad * f + bc;
              te[10] = ac - bd * f;

          } else if (euler.order === 'XZY') {

              const ac = a * c,
                  ad = a * d,
                  bc = b * c,
                  bd = b * d;

              te[0] = c * e;
              te[4] = -f;
              te[8] = d * e;

              te[1] = ac * f + bd;
              te[5] = a * e;
              te[9] = ad * f - bc;

              te[2] = bc * f - ad;
              te[6] = b * e;
              te[10] = bd * f + ac;

          }

          // bottom row
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;

          // last column
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;

          return this;

      },

      makeRotationFromQuaternion: function(q) {

          return this.compose(_zero, q, _one);

      },

      lookAt: function(eye, target, up) {

          const te = this.elements;

          _z.subVectors(eye, target);

          if (_z.lengthSq() === 0) {

              // eye and target are in the same position

              _z.z = 1;

          }

          _z.normalize();
          _x.crossVectors(up, _z);

          if (_x.lengthSq() === 0) {

              // up and z are parallel

              if (Math.abs(up.z) === 1) {

                  _z.x += 0.0001;

              } else {

                  _z.z += 0.0001;

              }

              _z.normalize();
              _x.crossVectors(up, _z);

          }

          _x.normalize();
          _y.crossVectors(_z, _x);

          te[0] = _x.x;
          te[4] = _y.x;
          te[8] = _z.x;
          te[1] = _x.y;
          te[5] = _y.y;
          te[9] = _z.y;
          te[2] = _x.z;
          te[6] = _y.z;
          te[10] = _z.z;

          return this;

      },

      multiply: function(m, n) {

          if (n !== undefined) {

              console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
              return this.multiplyMatrices(m, n);

          }

          return this.multiplyMatrices(this, m);

      },

      premultiply: function(m) {

          return this.multiplyMatrices(m, this);

      },

      multiplyMatrices: function(a, b) {

          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;

          const a11 = ae[0],
              a12 = ae[4],
              a13 = ae[8],
              a14 = ae[12];
          const a21 = ae[1],
              a22 = ae[5],
              a23 = ae[9],
              a24 = ae[13];
          const a31 = ae[2],
              a32 = ae[6],
              a33 = ae[10],
              a34 = ae[14];
          const a41 = ae[3],
              a42 = ae[7],
              a43 = ae[11],
              a44 = ae[15];

          const b11 = be[0],
              b12 = be[4],
              b13 = be[8],
              b14 = be[12];
          const b21 = be[1],
              b22 = be[5],
              b23 = be[9],
              b24 = be[13];
          const b31 = be[2],
              b32 = be[6],
              b33 = be[10],
              b34 = be[14];
          const b41 = be[3],
              b42 = be[7],
              b43 = be[11],
              b44 = be[15];

          te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

          te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

          te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

          te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

          return this;

      },

      multiplyScalar: function(s) {

          const te = this.elements;

          te[0] *= s;
          te[4] *= s;
          te[8] *= s;
          te[12] *= s;
          te[1] *= s;
          te[5] *= s;
          te[9] *= s;
          te[13] *= s;
          te[2] *= s;
          te[6] *= s;
          te[10] *= s;
          te[14] *= s;
          te[3] *= s;
          te[7] *= s;
          te[11] *= s;
          te[15] *= s;

          return this;

      },

      determinant: function() {

          const te = this.elements;

          const n11 = te[0],
              n12 = te[4],
              n13 = te[8],
              n14 = te[12];
          const n21 = te[1],
              n22 = te[5],
              n23 = te[9],
              n24 = te[13];
          const n31 = te[2],
              n32 = te[6],
              n33 = te[10],
              n34 = te[14];
          const n41 = te[3],
              n42 = te[7],
              n43 = te[11],
              n44 = te[15];

          //TODO: make this more efficient
          //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

          return (
              n41 * (+n14 * n23 * n32 -
                  n13 * n24 * n32 -
                  n14 * n22 * n33 +
                  n12 * n24 * n33 +
                  n13 * n22 * n34 -
                  n12 * n23 * n34
              ) +
              n42 * (+n11 * n23 * n34 -
                  n11 * n24 * n33 +
                  n14 * n21 * n33 -
                  n13 * n21 * n34 +
                  n13 * n24 * n31 -
                  n14 * n23 * n31
              ) +
              n43 * (+n11 * n24 * n32 -
                  n11 * n22 * n34 -
                  n14 * n21 * n32 +
                  n12 * n21 * n34 +
                  n14 * n22 * n31 -
                  n12 * n24 * n31
              ) +
              n44 * (-n13 * n22 * n31 -
                  n11 * n23 * n32 +
                  n11 * n22 * n33 +
                  n13 * n21 * n32 -
                  n12 * n21 * n33 +
                  n12 * n23 * n31
              )

          );

      },

      transpose: function() {

          const te = this.elements;
          let tmp;

          tmp = te[1];
          te[1] = te[4];
          te[4] = tmp;
          tmp = te[2];
          te[2] = te[8];
          te[8] = tmp;
          tmp = te[6];
          te[6] = te[9];
          te[9] = tmp;

          tmp = te[3];
          te[3] = te[12];
          te[12] = tmp;
          tmp = te[7];
          te[7] = te[13];
          te[13] = tmp;
          tmp = te[11];
          te[11] = te[14];
          te[14] = tmp;

          return this;

      },

      setPosition: function(x, y, z) {

          const te = this.elements;

          if (x.isVector3) {

              te[12] = x.x;
              te[13] = x.y;
              te[14] = x.z;

          } else {

              te[12] = x;
              te[13] = y;
              te[14] = z;

          }

          return this;

      },

      getInverse: function(m, throwOnDegenerate) {

          if (throwOnDegenerate !== undefined) {

              console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");

          }

          // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
          const te = this.elements,
              me = m.elements,

              n11 = me[0],
              n21 = me[1],
              n31 = me[2],
              n41 = me[3],
              n12 = me[4],
              n22 = me[5],
              n32 = me[6],
              n42 = me[7],
              n13 = me[8],
              n23 = me[9],
              n33 = me[10],
              n43 = me[11],
              n14 = me[12],
              n24 = me[13],
              n34 = me[14],
              n44 = me[15],

              t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
              t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
              t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
              t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

          if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

          const detInv = 1 / det;

          te[0] = t11 * detInv;
          te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

          te[4] = t12 * detInv;
          te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

          te[8] = t13 * detInv;
          te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

          te[12] = t14 * detInv;
          te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

          return this;

      },

      scale: function(v) {

          const te = this.elements;
          const x = v.x,
              y = v.y,
              z = v.z;

          te[0] *= x;
          te[4] *= y;
          te[8] *= z;
          te[1] *= x;
          te[5] *= y;
          te[9] *= z;
          te[2] *= x;
          te[6] *= y;
          te[10] *= z;
          te[3] *= x;
          te[7] *= y;
          te[11] *= z;

          return this;

      },

      getMaxScaleOnAxis: function() {

          const te = this.elements;

          const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
          const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
          const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));

      },

      makeTranslation: function(x, y, z) {

          this.set(

              1, 0, 0, x,
              0, 1, 0, y,
              0, 0, 1, z,
              0, 0, 0, 1

          );

          return this;

      },

      makeRotationX: function(theta) {

          const c = Math.cos(theta),
              s = Math.sin(theta);

          this.set(

              1, 0, 0, 0,
              0, c, -s, 0,
              0, s, c, 0,
              0, 0, 0, 1

          );

          return this;

      },

      makeRotationY: function(theta) {

          const c = Math.cos(theta),
              s = Math.sin(theta);

          this.set(

              c, 0, s, 0,
              0, 1, 0, 0, -s, 0, c, 0,
              0, 0, 0, 1

          );

          return this;

      },

      makeRotationZ: function(theta) {

          const c = Math.cos(theta),
              s = Math.sin(theta);

          this.set(

              c, -s, 0, 0,
              s, c, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1

          );

          return this;

      },

      makeRotationAxis: function(axis, angle) {

          // Based on http://www.gamedev.net/reference/articles/article1199.asp

          const c = Math.cos(angle);
          const s = Math.sin(angle);
          const t = 1 - c;
          const x = axis.x,
              y = axis.y,
              z = axis.z;
          const tx = t * x,
              ty = t * y;

          this.set(

              tx * x + c, tx * y - s * z, tx * z + s * y, 0,
              tx * y + s * z, ty * y + c, ty * z - s * x, 0,
              tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
              0, 0, 0, 1

          );

          return this;

      },

      makeScale: function(x, y, z) {

          this.set(

              x, 0, 0, 0,
              0, y, 0, 0,
              0, 0, z, 0,
              0, 0, 0, 1

          );

          return this;

      },

      makeShear: function(x, y, z) {

          this.set(

              1, y, z, 0,
              x, 1, z, 0,
              x, y, 1, 0,
              0, 0, 0, 1

          );

          return this;

      },

      compose: function(position, quaternion, scale) {

          const te = this.elements;

          const x = quaternion._x,
              y = quaternion._y,
              z = quaternion._z,
              w = quaternion._w;
          const x2 = x + x,
              y2 = y + y,
              z2 = z + z;
          const xx = x * x2,
              xy = x * y2,
              xz = x * z2;
          const yy = y * y2,
              yz = y * z2,
              zz = z * z2;
          const wx = w * x2,
              wy = w * y2,
              wz = w * z2;

          const sx = scale.x,
              sy = scale.y,
              sz = scale.z;

          te[0] = (1 - (yy + zz)) * sx;
          te[1] = (xy + wz) * sx;
          te[2] = (xz - wy) * sx;
          te[3] = 0;

          te[4] = (xy - wz) * sy;
          te[5] = (1 - (xx + zz)) * sy;
          te[6] = (yz + wx) * sy;
          te[7] = 0;

          te[8] = (xz + wy) * sz;
          te[9] = (yz - wx) * sz;
          te[10] = (1 - (xx + yy)) * sz;
          te[11] = 0;

          te[12] = position.x;
          te[13] = position.y;
          te[14] = position.z;
          te[15] = 1;

          return this;

      },

      decompose: function(position, quaternion, scale) {

          const te = this.elements;

          let sx = _v1.set(te[0], te[1], te[2]).length();
          let sy = _v1.set(te[4], te[5], te[6]).length();
          let sz = _v1.set(te[8], te[9], te[10]).length();

          // if determine is negative, we need to invert one scale
          const det = this.determinant();
          if (det < 0) sx = -sx;

          position.x = te[12];
          position.y = te[13];
          position.z = te[14];

          // scale the rotation part
          _m1.copy(this);

          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;

          _m1.elements[0] *= invSX;
          _m1.elements[1] *= invSX;
          _m1.elements[2] *= invSX;

          _m1.elements[4] *= invSY;
          _m1.elements[5] *= invSY;
          _m1.elements[6] *= invSY;

          _m1.elements[8] *= invSZ;
          _m1.elements[9] *= invSZ;
          _m1.elements[10] *= invSZ;

          quaternion.setFromRotationMatrix(_m1);

          scale.x = sx;
          scale.y = sy;
          scale.z = sz;

          return this;

      },

      makePerspective: function(left, right, top, bottom, near, far) {

          if (far === undefined) {

              console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');

          }

          const te = this.elements;
          const x = 2 * near / (right - left);
          const y = 2 * near / (top - bottom);

          const a = (right + left) / (right - left);
          const b = (top + bottom) / (top - bottom);
          const c = -(far + near) / (far - near);
          const d = -2 * far * near / (far - near);

          te[0] = x;
          te[4] = 0;
          te[8] = a;
          te[12] = 0;
          te[1] = 0;
          te[5] = y;
          te[9] = b;
          te[13] = 0;
          te[2] = 0;
          te[6] = 0;
          te[10] = c;
          te[14] = d;
          te[3] = 0;
          te[7] = 0;
          te[11] = -1;
          te[15] = 0;

          return this;

      },

      makeOrthographic: function(left, right, top, bottom, near, far) {

          const te = this.elements;
          const w = 1.0 / (right - left);
          const h = 1.0 / (top - bottom);
          const p = 1.0 / (far - near);

          const x = (right + left) * w;
          const y = (top + bottom) * h;
          const z = (far + near) * p;

          te[0] = 2 * w;
          te[4] = 0;
          te[8] = 0;
          te[12] = -x;
          te[1] = 0;
          te[5] = 2 * h;
          te[9] = 0;
          te[13] = -y;
          te[2] = 0;
          te[6] = 0;
          te[10] = -2 * p;
          te[14] = -z;
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[15] = 1;

          return this;

      },

      equals: function(matrix) {

          const te = this.elements;
          const me = matrix.elements;

          for (let i = 0; i < 16; i++) {

              if (te[i] !== me[i]) return false;

          }

          return true;

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          for (let i = 0; i < 16; i++) {

              this.elements[i] = array[i + offset];

          }

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          const te = this.elements;

          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];

          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];

          array[offset + 8] = te[8];
          array[offset + 9] = te[9];
          array[offset + 10] = te[10];
          array[offset + 11] = te[11];

          array[offset + 12] = te[12];
          array[offset + 13] = te[13];
          array[offset + 14] = te[14];
          array[offset + 15] = te[15];

          return array;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  const _matrix = new Matrix4();
  const _quaternion$1 = new Quaternion();

  function Euler(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {

      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;

  }

  Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

  Euler.DefaultOrder = 'XYZ';

  Object.defineProperties(Euler.prototype, {

      x: {

          get: function() {

              return this._x;

          },

          set: function(value) {

              this._x = value;
              this._onChangeCallback();

          }

      },

      y: {

          get: function() {

              return this._y;

          },

          set: function(value) {

              this._y = value;
              this._onChangeCallback();

          }

      },

      z: {

          get: function() {

              return this._z;

          },

          set: function(value) {

              this._z = value;
              this._onChangeCallback();

          }

      },

      order: {

          get: function() {

              return this._order;

          },

          set: function(value) {

              this._order = value;
              this._onChangeCallback();

          }

      }

  });

  Object.assign(Euler.prototype, {

      isEuler: true,

      set: function(x, y, z, order) {

          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order || this._order;

          this._onChangeCallback();

          return this;

      },

      clone: function() {

          return new this.constructor(this._x, this._y, this._z, this._order);

      },

      copy: function(euler) {

          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;

          this._onChangeCallback();

          return this;

      },

      setFromRotationMatrix: function(m, order, update) {

          const clamp = MathUtils.clamp;

          // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

          const te = m.elements;
          const m11 = te[0],
              m12 = te[4],
              m13 = te[8];
          const m21 = te[1],
              m22 = te[5],
              m23 = te[9];
          const m31 = te[2],
              m32 = te[6],
              m33 = te[10];

          order = order || this._order;

          switch (order) {

              case 'XYZ':

                  this._y = Math.asin(clamp(m13, -1, 1));

                  if (Math.abs(m13) < 0.9999999) {

                      this._x = Math.atan2(-m23, m33);
                      this._z = Math.atan2(-m12, m11);

                  } else {

                      this._x = Math.atan2(m32, m22);
                      this._z = 0;

                  }

                  break;

              case 'YXZ':

                  this._x = Math.asin(-clamp(m23, -1, 1));

                  if (Math.abs(m23) < 0.9999999) {

                      this._y = Math.atan2(m13, m33);
                      this._z = Math.atan2(m21, m22);

                  } else {

                      this._y = Math.atan2(-m31, m11);
                      this._z = 0;

                  }

                  break;

              case 'ZXY':

                  this._x = Math.asin(clamp(m32, -1, 1));

                  if (Math.abs(m32) < 0.9999999) {

                      this._y = Math.atan2(-m31, m33);
                      this._z = Math.atan2(-m12, m22);

                  } else {

                      this._y = 0;
                      this._z = Math.atan2(m21, m11);

                  }

                  break;

              case 'ZYX':

                  this._y = Math.asin(-clamp(m31, -1, 1));

                  if (Math.abs(m31) < 0.9999999) {

                      this._x = Math.atan2(m32, m33);
                      this._z = Math.atan2(m21, m11);

                  } else {

                      this._x = 0;
                      this._z = Math.atan2(-m12, m22);

                  }

                  break;

              case 'YZX':

                  this._z = Math.asin(clamp(m21, -1, 1));

                  if (Math.abs(m21) < 0.9999999) {

                      this._x = Math.atan2(-m23, m22);
                      this._y = Math.atan2(-m31, m11);

                  } else {

                      this._x = 0;
                      this._y = Math.atan2(m13, m33);

                  }

                  break;

              case 'XZY':

                  this._z = Math.asin(-clamp(m12, -1, 1));

                  if (Math.abs(m12) < 0.9999999) {

                      this._x = Math.atan2(m32, m22);
                      this._y = Math.atan2(m13, m11);

                  } else {

                      this._x = Math.atan2(-m23, m33);
                      this._y = 0;

                  }

                  break;

              default:

                  console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);

          }

          this._order = order;

          if (update !== false) this._onChangeCallback();

          return this;

      },

      setFromQuaternion: function(q, order, update) {

          _matrix.makeRotationFromQuaternion(q);

          return this.setFromRotationMatrix(_matrix, order, update);

      },

      setFromVector3: function(v, order) {

          return this.set(v.x, v.y, v.z, order || this._order);

      },

      reorder: function(newOrder) {

          // WARNING: this discards revolution information -bhouston

          _quaternion$1.setFromEuler(this);

          return this.setFromQuaternion(_quaternion$1, newOrder);

      },

      equals: function(euler) {

          return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);

      },

      fromArray: function(array) {

          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== undefined) this._order = array[3];

          this._onChangeCallback();

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;

          return array;

      },

      toVector3: function(optionalResult) {

          if (optionalResult) {

              return optionalResult.set(this._x, this._y, this._z);

          } else {

              return new Vector3(this._x, this._y, this._z);

          }

      },

      _onChange: function(callback) {

          this._onChangeCallback = callback;

          return this;

      },

      _onChangeCallback: function() {}

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Layers() {

      this.mask = 1 | 0;

  }

  Object.assign(Layers.prototype, {

      set: function(channel) {

          this.mask = 1 << channel | 0;

      },

      enable: function(channel) {

          this.mask |= 1 << channel | 0;

      },

      enableAll: function() {

          this.mask = 0xffffffff | 0;

      },

      toggle: function(channel) {

          this.mask ^= 1 << channel | 0;

      },

      disable: function(channel) {

          this.mask &= ~(1 << channel | 0);

      },

      disableAll: function() {

          this.mask = 0;

      },

      test: function(layers) {

          return (this.mask & layers.mask) !== 0;

      }

  });

  let _object3DId = 0;

  const _v1$1 = new Vector3();
  const _q1 = new Quaternion();
  const _m1$1 = new Matrix4();
  const _target = new Vector3();

  const _position = new Vector3();
  const _scale = new Vector3();
  const _quaternion$2 = new Quaternion();

  const _xAxis = new Vector3(1, 0, 0);
  const _yAxis = new Vector3(0, 1, 0);
  const _zAxis = new Vector3(0, 0, 1);

  const _addedEvent = { type: 'added' };
  const _removedEvent = { type: 'removed' };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author elephantatwork / www.elephantatwork.ch
   */

  function Object3D() {

      Object.defineProperty(this, 'id', { value: _object3DId++ });

      this.uuid = MathUtils.generateUUID();

      this.name = '';
      this.type = 'Object3D';

      this.parent = null;
      this.children = [];

      this.up = Object3D.DefaultUp.clone();

      const position = new Vector3();
      const rotation = new Euler();
      const quaternion = new Quaternion();
      const scale = new Vector3(1, 1, 1);

      function onRotationChange() {

          quaternion.setFromEuler(rotation, false);

      }

      function onQuaternionChange() {

          rotation.setFromQuaternion(quaternion, undefined, false);

      }

      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);

      Object.defineProperties(this, {
          position: {
              configurable: true,
              enumerable: true,
              value: position
          },
          rotation: {
              configurable: true,
              enumerable: true,
              value: rotation
          },
          quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
          },
          scale: {
              configurable: true,
              enumerable: true,
              value: scale
          },
          modelViewMatrix: {
              value: new Matrix4()
          },
          normalMatrix: {
              value: new Matrix3()
          }
      });

      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();

      this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;

      this.layers = new Layers();
      this.visible = true;

      this.castShadow = false;
      this.receiveShadow = false;

      this.frustumCulled = true;
      this.renderOrder = 0;

      this.userData = {};

  }

  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;

  Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

      constructor: Object3D,

      isObject3D: true,

      onBeforeRender: function() {},
      onAfterRender: function() {},

      applyMatrix4: function(matrix) {

          if (this.matrixAutoUpdate) this.updateMatrix();

          this.matrix.premultiply(matrix);

          this.matrix.decompose(this.position, this.quaternion, this.scale);

      },

      applyQuaternion: function(q) {

          this.quaternion.premultiply(q);

          return this;

      },

      setRotationFromAxisAngle: function(axis, angle) {

          // assumes axis is normalized

          this.quaternion.setFromAxisAngle(axis, angle);

      },

      setRotationFromEuler: function(euler) {

          this.quaternion.setFromEuler(euler, true);

      },

      setRotationFromMatrix: function(m) {

          // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

          this.quaternion.setFromRotationMatrix(m);

      },

      setRotationFromQuaternion: function(q) {

          // assumes q is normalized

          this.quaternion.copy(q);

      },

      rotateOnAxis: function(axis, angle) {

          // rotate object on axis in object space
          // axis is assumed to be normalized

          _q1.setFromAxisAngle(axis, angle);

          this.quaternion.multiply(_q1);

          return this;

      },

      rotateOnWorldAxis: function(axis, angle) {

          // rotate object on axis in world space
          // axis is assumed to be normalized
          // method assumes no rotated parent

          _q1.setFromAxisAngle(axis, angle);

          this.quaternion.premultiply(_q1);

          return this;

      },

      rotateX: function(angle) {

          return this.rotateOnAxis(_xAxis, angle);

      },

      rotateY: function(angle) {

          return this.rotateOnAxis(_yAxis, angle);

      },

      rotateZ: function(angle) {

          return this.rotateOnAxis(_zAxis, angle);

      },

      translateOnAxis: function(axis, distance) {

          // translate object by distance along axis in object space
          // axis is assumed to be normalized

          _v1$1.copy(axis).applyQuaternion(this.quaternion);

          this.position.add(_v1$1.multiplyScalar(distance));

          return this;

      },

      translateX: function(distance) {

          return this.translateOnAxis(_xAxis, distance);

      },

      translateY: function(distance) {

          return this.translateOnAxis(_yAxis, distance);

      },

      translateZ: function(distance) {

          return this.translateOnAxis(_zAxis, distance);

      },

      localToWorld: function(vector) {

          return vector.applyMatrix4(this.matrixWorld);

      },

      worldToLocal: function(vector) {

          return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));

      },

      lookAt: function(x, y, z) {

          // This method does not support objects having non-uniformly-scaled parent(s)

          if (x.isVector3) {

              _target.copy(x);

          } else {

              _target.set(x, y, z);

          }

          const parent = this.parent;

          this.updateWorldMatrix(true, false);

          _position.setFromMatrixPosition(this.matrixWorld);

          if (this.isCamera || this.isLight) {

              _m1$1.lookAt(_position, _target, this.up);

          } else {

              _m1$1.lookAt(_target, _position, this.up);

          }

          this.quaternion.setFromRotationMatrix(_m1$1);

          if (parent) {

              _m1$1.extractRotation(parent.matrixWorld);
              _q1.setFromRotationMatrix(_m1$1);
              this.quaternion.premultiply(_q1.inverse());

          }

      },

      add: function(object) {

          if (arguments.length > 1) {

              for (let i = 0; i < arguments.length; i++) {

                  this.add(arguments[i]);

              }

              return this;

          }

          if (object === this) {

              console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
              return this;

          }

          if ((object && object.isObject3D)) {

              if (object.parent !== null) {

                  object.parent.remove(object);

              }

              object.parent = this;
              this.children.push(object);

              object.dispatchEvent(_addedEvent);

          } else {

              console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);

          }

          return this;

      },

      remove: function(object) {

          if (arguments.length > 1) {

              for (let i = 0; i < arguments.length; i++) {

                  this.remove(arguments[i]);

              }

              return this;

          }

          const index = this.children.indexOf(object);

          if (index !== -1) {

              object.parent = null;
              this.children.splice(index, 1);

              object.dispatchEvent(_removedEvent);

          }

          return this;

      },

      attach: function(object) {

          // adds object as a child of this, while maintaining the object's world transform

          this.updateWorldMatrix(true, false);

          _m1$1.getInverse(this.matrixWorld);

          if (object.parent !== null) {

              object.parent.updateWorldMatrix(true, false);

              _m1$1.multiply(object.parent.matrixWorld);

          }

          object.applyMatrix4(_m1$1);

          object.updateWorldMatrix(false, false);

          this.add(object);

          return this;

      },

      getObjectById: function(id) {

          return this.getObjectByProperty('id', id);

      },

      getObjectByName: function(name) {

          return this.getObjectByProperty('name', name);

      },

      getObjectByProperty: function(name, value) {

          if (this[name] === value) return this;

          for (let i = 0, l = this.children.length; i < l; i++) {

              const child = this.children[i];
              const object = child.getObjectByProperty(name, value);

              if (object !== undefined) {

                  return object;

              }

          }

          return undefined;

      },

      getWorldPosition: function(target) {

          if (target === undefined) {

              console.warn('THREE.Object3D: .getWorldPosition() target is now required');
              target = new Vector3();

          }

          this.updateMatrixWorld(true);

          return target.setFromMatrixPosition(this.matrixWorld);

      },

      getWorldQuaternion: function(target) {

          if (target === undefined) {

              console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
              target = new Quaternion();

          }

          this.updateMatrixWorld(true);

          this.matrixWorld.decompose(_position, target, _scale);

          return target;

      },

      getWorldScale: function(target) {

          if (target === undefined) {

              console.warn('THREE.Object3D: .getWorldScale() target is now required');
              target = new Vector3();

          }

          this.updateMatrixWorld(true);

          this.matrixWorld.decompose(_position, _quaternion$2, target);

          return target;

      },

      getWorldDirection: function(target) {

          if (target === undefined) {

              console.warn('THREE.Object3D: .getWorldDirection() target is now required');
              target = new Vector3();

          }

          this.updateMatrixWorld(true);

          const e = this.matrixWorld.elements;

          return target.set(e[8], e[9], e[10]).normalize();

      },

      raycast: function() {},

      traverse: function(callback) {

          callback(this);

          const children = this.children;

          for (let i = 0, l = children.length; i < l; i++) {

              children[i].traverse(callback);

          }

      },

      traverseVisible: function(callback) {

          if (this.visible === false) return;

          callback(this);

          const children = this.children;

          for (let i = 0, l = children.length; i < l; i++) {

              children[i].traverseVisible(callback);

          }

      },

      traverseAncestors: function(callback) {

          const parent = this.parent;

          if (parent !== null) {

              callback(parent);

              parent.traverseAncestors(callback);

          }

      },

      updateMatrix: function() {

          this.matrix.compose(this.position, this.quaternion, this.scale);

          this.matrixWorldNeedsUpdate = true;

      },

      updateMatrixWorld: function(force) {

          if (this.matrixAutoUpdate) this.updateMatrix();

          if (this.matrixWorldNeedsUpdate || force) {

              if (this.parent === null) {

                  this.matrixWorld.copy(this.matrix);

              } else {

                  this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);

              }

              this.matrixWorldNeedsUpdate = false;

              force = true;

          }

          // update children

          const children = this.children;

          for (let i = 0, l = children.length; i < l; i++) {

              children[i].updateMatrixWorld(force);

          }

      },

      updateWorldMatrix: function(updateParents, updateChildren) {

          const parent = this.parent;

          if (updateParents === true && parent !== null) {

              parent.updateWorldMatrix(true, false);

          }

          if (this.matrixAutoUpdate) this.updateMatrix();

          if (this.parent === null) {

              this.matrixWorld.copy(this.matrix);

          } else {

              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);

          }

          // update children

          if (updateChildren === true) {

              const children = this.children;

              for (let i = 0, l = children.length; i < l; i++) {

                  children[i].updateWorldMatrix(false, true);

              }

          }

      },

      toJSON: function(meta) {

          // meta is a string when called from JSON.stringify
          const isRootObject = (meta === undefined || typeof meta === 'string');

          const output = {};

          // meta is a hash used to collect geometries, materials.
          // not providing it implies that this is the root object
          // being serialized.
          if (isRootObject) {

              // initialize meta obj
              meta = {
                  geometries: {},
                  materials: {},
                  textures: {},
                  images: {},
                  shapes: {}
              };

              output.metadata = {
                  version: 4.5,
                  type: 'Object',
                  generator: 'Object3D.toJSON'
              };

          }

          // standard Object3D serialization

          const object = {};

          object.uuid = this.uuid;
          object.type = this.type;

          if (this.name !== '') object.name = this.name;
          if (this.castShadow === true) object.castShadow = true;
          if (this.receiveShadow === true) object.receiveShadow = true;
          if (this.visible === false) object.visible = false;
          if (this.frustumCulled === false) object.frustumCulled = false;
          if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
          if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;

          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();

          if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

          // object specific properties

          if (this.isInstancedMesh) {

              object.type = 'InstancedMesh';
              object.count = this.count;
              object.instanceMatrix = this.instanceMatrix.toJSON();

          }

          //

          function serialize(library, element) {

              if (library[element.uuid] === undefined) {

                  library[element.uuid] = element.toJSON(meta);

              }

              return element.uuid;

          }

          if (this.isMesh || this.isLine || this.isPoints) {

              object.geometry = serialize(meta.geometries, this.geometry);

              const parameters = this.geometry.parameters;

              if (parameters !== undefined && parameters.shapes !== undefined) {

                  const shapes = parameters.shapes;

                  if (Array.isArray(shapes)) {

                      for (let i = 0, l = shapes.length; i < l; i++) {

                          const shape = shapes[i];

                          serialize(meta.shapes, shape);

                      }

                  } else {

                      serialize(meta.shapes, shapes);

                  }

              }

          }

          if (this.material !== undefined) {

              if (Array.isArray(this.material)) {

                  const uuids = [];

                  for (let i = 0, l = this.material.length; i < l; i++) {

                      uuids.push(serialize(meta.materials, this.material[i]));

                  }

                  object.material = uuids;

              } else {

                  object.material = serialize(meta.materials, this.material);

              }

          }

          //

          if (this.children.length > 0) {

              object.children = [];

              for (let i = 0; i < this.children.length; i++) {

                  object.children.push(this.children[i].toJSON(meta).object);

              }

          }

          if (isRootObject) {

              const geometries = extractFromCache(meta.geometries);
              const materials = extractFromCache(meta.materials);
              const textures = extractFromCache(meta.textures);
              const images = extractFromCache(meta.images);
              const shapes = extractFromCache(meta.shapes);

              if (geometries.length > 0) output.geometries = geometries;
              if (materials.length > 0) output.materials = materials;
              if (textures.length > 0) output.textures = textures;
              if (images.length > 0) output.images = images;
              if (shapes.length > 0) output.shapes = shapes;

          }

          output.object = object;

          return output;

          // extract data from the cache hash
          // remove metadata on each item
          // and return as array
          function extractFromCache(cache) {

              const values = [];
              for (const key in cache) {

                  const data = cache[key];
                  delete data.metadata;
                  values.push(data);

              }

              return values;

          }

      },

      clone: function(recursive) {

          return new this.constructor().copy(this, recursive);

      },

      copy: function(source, recursive) {

          if (recursive === undefined) recursive = true;

          this.name = source.name;

          this.up.copy(source.up);

          this.position.copy(source.position);
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);

          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);

          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

          this.layers.mask = source.layers.mask;
          this.visible = source.visible;

          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;

          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;

          this.userData = JSON.parse(JSON.stringify(source.userData));

          if (recursive === true) {

              for (let i = 0; i < source.children.length; i++) {

                  const child = source.children[i];
                  this.add(child.clone());

              }

          }

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Scene() {

      Object3D.call(this);

      this.type = 'Scene';

      this.background = null;
      this.environment = null;
      this.fog = null;

      this.overrideMaterial = null;

      this.autoUpdate = true; // checked by the renderer

      if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })); // eslint-disable-line no-undef

      }

  }

  Scene.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Scene,

      isScene: true,

      copy: function(source, recursive) {

          Object3D.prototype.copy.call(this, source, recursive);

          if (source.background !== null) this.background = source.background.clone();
          if (source.environment !== null) this.environment = source.environment.clone();
          if (source.fog !== null) this.fog = source.fog.clone();

          if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();

          this.autoUpdate = source.autoUpdate;
          this.matrixAutoUpdate = source.matrixAutoUpdate;

          return this;

      },

      toJSON: function(meta) {

          const data = Object3D.prototype.toJSON.call(this, meta);

          if (this.background !== null) data.object.background = this.background.toJSON(meta);
          if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
          if (this.fog !== null) data.object.fog = this.fog.toJSON();

          return data;

      },

      dispose: function() {

          this.dispatchEvent({ type: 'dispose' });

      }

  });

  const _points = [
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3()
  ];

  const _vector$1 = new Vector3();

  const _box = new Box3();

  // triangle centered vertices

  const _v0 = new Vector3();
  const _v1$2 = new Vector3();
  const _v2 = new Vector3();

  // triangle edge vectors

  const _f0 = new Vector3();
  const _f1 = new Vector3();
  const _f2 = new Vector3();

  const _center = new Vector3();
  const _extents = new Vector3();
  const _triangleNormal = new Vector3();
  const _testAxis = new Vector3();

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3(min, max) {

      this.min = (min !== undefined) ? min : new Vector3(+Infinity, +Infinity, +Infinity);
      this.max = (max !== undefined) ? max : new Vector3(-Infinity, -Infinity, -Infinity);

  }


  Object.assign(Box3.prototype, {

      isBox3: true,

      set: function(min, max) {

          this.min.copy(min);
          this.max.copy(max);

          return this;

      },

      setFromArray: function(array) {

          let minX = +Infinity;
          let minY = +Infinity;
          let minZ = +Infinity;

          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;

          for (let i = 0, l = array.length; i < l; i += 3) {

              const x = array[i];
              const y = array[i + 1];
              const z = array[i + 2];

              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (z < minZ) minZ = z;

              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
              if (z > maxZ) maxZ = z;

          }

          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);

          return this;

      },

      setFromBufferAttribute: function(attribute) {

          let minX = +Infinity;
          let minY = +Infinity;
          let minZ = +Infinity;

          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;

          for (let i = 0, l = attribute.count; i < l; i++) {

              const x = attribute.getX(i);
              const y = attribute.getY(i);
              const z = attribute.getZ(i);

              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (z < minZ) minZ = z;

              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
              if (z > maxZ) maxZ = z;

          }

          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);

          return this;

      },

      setFromPoints: function(points) {

          this.makeEmpty();

          for (let i = 0, il = points.length; i < il; i++) {

              this.expandByPoint(points[i]);

          }

          return this;

      },

      setFromCenterAndSize: function(center, size) {

          const halfSize = _vector$1.copy(size).multiplyScalar(0.5);

          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);

          return this;

      },

      setFromObject: function(object) {

          this.makeEmpty();

          return this.expandByObject(object);

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(box) {

          this.min.copy(box.min);
          this.max.copy(box.max);

          return this;

      },

      makeEmpty: function() {

          this.min.x = this.min.y = this.min.z = +Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;

          return this;

      },

      isEmpty: function() {

          // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

          return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);

      },

      getCenter: function(target) {

          if (target === undefined) {

              console.warn('THREE.Box3: .getCenter() target is now required');
              target = new Vector3();

          }

          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);

      },

      getSize: function(target) {

          if (target === undefined) {

              console.warn('THREE.Box3: .getSize() target is now required');
              target = new Vector3();

          }

          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);

      },

      expandByPoint: function(point) {

          this.min.min(point);
          this.max.max(point);

          return this;

      },

      expandByVector: function(vector) {

          this.min.sub(vector);
          this.max.add(vector);

          return this;

      },

      expandByScalar: function(scalar) {

          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);

          return this;

      },

      expandByObject: function(object) {

          // Computes the world-axis-aligned bounding box of an object (including its children),
          // accounting for both the object's, and children's, world transforms

          object.updateWorldMatrix(false, false);

          const geometry = object.geometry;

          if (geometry !== undefined) {

              if (geometry.boundingBox === null) {

                  geometry.computeBoundingBox();

              }

              _box.copy(geometry.boundingBox);
              _box.applyMatrix4(object.matrixWorld);

              this.union(_box);

          }

          const children = object.children;

          for (let i = 0, l = children.length; i < l; i++) {

              this.expandByObject(children[i]);

          }

          return this;

      },

      containsPoint: function(point) {

          return point.x < this.min.x || point.x > this.max.x ||
              point.y < this.min.y || point.y > this.max.y ||
              point.z < this.min.z || point.z > this.max.z ? false : true;

      },

      containsBox: function(box) {

          return this.min.x <= box.min.x && box.max.x <= this.max.x &&
              this.min.y <= box.min.y && box.max.y <= this.max.y &&
              this.min.z <= box.min.z && box.max.z <= this.max.z;

      },

      getParameter: function(point, target) {

          // This can potentially have a divide by zero if the box
          // has a size dimension of 0.

          if (target === undefined) {

              console.warn('THREE.Box3: .getParameter() target is now required');
              target = new Vector3();

          }

          return target.set(
              (point.x - this.min.x) / (this.max.x - this.min.x),
              (point.y - this.min.y) / (this.max.y - this.min.y),
              (point.z - this.min.z) / (this.max.z - this.min.z)
          );

      },

      intersectsBox: function(box) {

          // using 6 splitting planes to rule out intersections.
          return box.max.x < this.min.x || box.min.x > this.max.x ||
              box.max.y < this.min.y || box.min.y > this.max.y ||
              box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

      },

      intersectsSphere: function(sphere) {

          // Find the point on the AABB closest to the sphere center.
          this.clampPoint(sphere.center, _vector$1);

          // If that point is inside the sphere, the AABB and sphere intersect.
          return _vector$1.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);

      },

      intersectsPlane: function(plane) {

          // We compute the minimum and maximum dot product values. If those values
          // are on the same side (back or front) of the plane, then there is no intersection.

          let min, max;

          if (plane.normal.x > 0) {

              min = plane.normal.x * this.min.x;
              max = plane.normal.x * this.max.x;

          } else {

              min = plane.normal.x * this.max.x;
              max = plane.normal.x * this.min.x;

          }

          if (plane.normal.y > 0) {

              min += plane.normal.y * this.min.y;
              max += plane.normal.y * this.max.y;

          } else {

              min += plane.normal.y * this.max.y;
              max += plane.normal.y * this.min.y;

          }

          if (plane.normal.z > 0) {

              min += plane.normal.z * this.min.z;
              max += plane.normal.z * this.max.z;

          } else {

              min += plane.normal.z * this.max.z;
              max += plane.normal.z * this.min.z;

          }

          return (min <= -plane.constant && max >= -plane.constant);

      },

      intersectsTriangle: function(triangle) {

          if (this.isEmpty()) {

              return false;

          }

          // compute box center and extents
          this.getCenter(_center);
          _extents.subVectors(this.max, _center);

          // translate triangle to aabb origin
          _v0.subVectors(triangle.a, _center);
          _v1$2.subVectors(triangle.b, _center);
          _v2.subVectors(triangle.c, _center);

          // compute edge vectors for triangle
          _f0.subVectors(_v1$2, _v0);
          _f1.subVectors(_v2, _v1$2);
          _f2.subVectors(_v0, _v2);

          // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
          // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
          // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
          let axes = [
              0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y,
              _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0
          ];
          if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {

              return false;

          }

          // test 3 face normals from the aabb
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {

              return false;

          }

          // finally testing the face normal of the triangle
          // use already existing triangle edge vectors here
          _triangleNormal.crossVectors(_f0, _f1);
          axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];

          return satForAxes(axes, _v0, _v1$2, _v2, _extents);

      },

      clampPoint: function(point, target) {

          if (target === undefined) {

              console.warn('THREE.Box3: .clampPoint() target is now required');
              target = new Vector3();

          }

          return target.copy(point).clamp(this.min, this.max);

      },

      distanceToPoint: function(point) {

          const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);

          return clampedPoint.sub(point).length();

      },

      getBoundingSphere: function(target) {

          if (target === undefined) {

              console.error('THREE.Box3: .getBoundingSphere() target is now required');
              //target = new Sphere(); // removed to avoid cyclic dependency

          }

          this.getCenter(target.center);

          target.radius = this.getSize(_vector$1).length() * 0.5;

          return target;

      },

      intersect: function(box) {

          this.min.max(box.min);
          this.max.min(box.max);

          // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
          if (this.isEmpty()) this.makeEmpty();

          return this;

      },

      union: function(box) {

          this.min.min(box.min);
          this.max.max(box.max);

          return this;

      },

      applyMatrix4: function(matrix) {

          // transform of empty box is an empty box.
          if (this.isEmpty()) return this;

          // NOTE: I am using a binary pattern to specify all 2^3 combinations below
          _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
          _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
          _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
          _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
          _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
          _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
          _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
          _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

          this.setFromPoints(_points);

          return this;

      },

      translate: function(offset) {

          this.min.add(offset);
          this.max.add(offset);

          return this;

      },

      equals: function(box) {

          return box.min.equals(this.min) && box.max.equals(this.max);

      }

  });

  function satForAxes(axes, v0, v1, v2, extents) {

      for (let i = 0, j = axes.length - 3; i <= j; i += 3) {

          _testAxis.fromArray(axes, i);
          // project the aabb onto the seperating axis
          const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
          // project all 3 vertices of the triangle onto the seperating axis
          const p0 = v0.dot(_testAxis);
          const p1 = v1.dot(_testAxis);
          const p2 = v2.dot(_testAxis);
          // actual test, basically see if either of the most extreme of the triangle points intersects r
          if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {

              // points of the projected triangle are outside the projected half-length of the aabb
              // the axis is seperating and we can exit
              return false;

          }

      }

      return true;

  }

  const _box$1 = new Box3();

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Sphere(center, radius) {

      this.center = (center !== undefined) ? center : new Vector3();
      this.radius = (radius !== undefined) ? radius : -1;

  }

  Object.assign(Sphere.prototype, {

      set: function(center, radius) {

          this.center.copy(center);
          this.radius = radius;

          return this;

      },

      setFromPoints: function(points, optionalCenter) {

          const center = this.center;

          if (optionalCenter !== undefined) {

              center.copy(optionalCenter);

          } else {

              _box$1.setFromPoints(points).getCenter(center);

          }

          let maxRadiusSq = 0;

          for (let i = 0, il = points.length; i < il; i++) {

              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));

          }

          this.radius = Math.sqrt(maxRadiusSq);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(sphere) {

          this.center.copy(sphere.center);
          this.radius = sphere.radius;

          return this;

      },

      isEmpty: function() {

          return (this.radius < 0);

      },

      makeEmpty: function() {

          this.center.set(0, 0, 0);
          this.radius = -1;

          return this;

      },

      containsPoint: function(point) {

          return (point.distanceToSquared(this.center) <= (this.radius * this.radius));

      },

      distanceToPoint: function(point) {

          return (point.distanceTo(this.center) - this.radius);

      },

      intersectsSphere: function(sphere) {

          const radiusSum = this.radius + sphere.radius;

          return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);

      },

      intersectsBox: function(box) {

          return box.intersectsSphere(this);

      },

      intersectsPlane: function(plane) {

          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;

      },

      clampPoint: function(point, target) {

          const deltaLengthSq = this.center.distanceToSquared(point);

          if (target === undefined) {

              console.warn('THREE.Sphere: .clampPoint() target is now required');
              target = new Vector3();

          }

          target.copy(point);

          if (deltaLengthSq > (this.radius * this.radius)) {

              target.sub(this.center).normalize();
              target.multiplyScalar(this.radius).add(this.center);

          }

          return target;

      },

      getBoundingBox: function(target) {

          if (target === undefined) {

              console.warn('THREE.Sphere: .getBoundingBox() target is now required');
              target = new Box3();

          }

          if (this.isEmpty()) {

              // Empty sphere produces empty bounding box
              target.makeEmpty();
              return target;

          }

          target.set(this.center, this.center);
          target.expandByScalar(this.radius);

          return target;

      },

      applyMatrix4: function(matrix) {

          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();

          return this;

      },

      translate: function(offset) {

          this.center.add(offset);

          return this;

      },

      equals: function(sphere) {

          return sphere.center.equals(this.center) && (sphere.radius === this.radius);

      }

  });

  const _vector$2 = new Vector3();
  const _segCenter = new Vector3();
  const _segDir = new Vector3();
  const _diff = new Vector3();

  const _edge1 = new Vector3();
  const _edge2 = new Vector3();
  const _normal = new Vector3();

  /**
   * @author bhouston / http://clara.io
   */

  function Ray(origin, direction) {

      this.origin = (origin !== undefined) ? origin : new Vector3();
      this.direction = (direction !== undefined) ? direction : new Vector3(0, 0, -1);

  }

  Object.assign(Ray.prototype, {

      set: function(origin, direction) {

          this.origin.copy(origin);
          this.direction.copy(direction);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(ray) {

          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);

          return this;

      },

      at: function(t, target) {

          if (target === undefined) {

              console.warn('THREE.Ray: .at() target is now required');
              target = new Vector3();

          }

          return target.copy(this.direction).multiplyScalar(t).add(this.origin);

      },

      lookAt: function(v) {

          this.direction.copy(v).sub(this.origin).normalize();

          return this;

      },

      recast: function(t) {

          this.origin.copy(this.at(t, _vector$2));

          return this;

      },

      closestPointToPoint: function(point, target) {

          if (target === undefined) {

              console.warn('THREE.Ray: .closestPointToPoint() target is now required');
              target = new Vector3();

          }

          target.subVectors(point, this.origin);

          const directionDistance = target.dot(this.direction);

          if (directionDistance < 0) {

              return target.copy(this.origin);

          }

          return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

      },

      distanceToPoint: function(point) {

          return Math.sqrt(this.distanceSqToPoint(point));

      },

      distanceSqToPoint: function(point) {

          const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);

          // point behind the ray

          if (directionDistance < 0) {

              return this.origin.distanceToSquared(point);

          }

          _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

          return _vector$2.distanceToSquared(point);

      },

      distanceSqToSegment: function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {

          // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
          // It returns the min distance between the ray and the segment
          // defined by v0 and v1
          // It can also set two optional targets :
          // - The closest point on the ray
          // - The closest point on the segment

          _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir.copy(v1).sub(v0).normalize();
          _diff.copy(this.origin).sub(_segCenter);

          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir);
          const b0 = _diff.dot(this.direction);
          const b1 = -_diff.dot(_segDir);
          const c = _diff.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;

          if (det > 0) {

              // The ray and segment are not parallel.

              s0 = a01 * b1 - b0;
              s1 = a01 * b0 - b1;
              extDet = segExtent * det;

              if (s0 >= 0) {

                  if (s1 >= -extDet) {

                      if (s1 <= extDet) {

                          // region 0
                          // Minimum at interior points of ray and segment.

                          const invDet = 1 / det;
                          s0 *= invDet;
                          s1 *= invDet;
                          sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;

                      } else {

                          // region 1

                          s1 = segExtent;
                          s0 = Math.max(0, -(a01 * s1 + b0));
                          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                      }

                  } else {

                      // region 5

                      s1 = -segExtent;
                      s0 = Math.max(0, -(a01 * s1 + b0));
                      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                  }

              } else {

                  if (s1 <= -extDet) {

                      // region 4

                      s0 = Math.max(0, -(-a01 * segExtent + b0));
                      s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                  } else if (s1 <= extDet) {

                      // region 3

                      s0 = 0;
                      s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                      sqrDist = s1 * (s1 + 2 * b1) + c;

                  } else {

                      // region 2

                      s0 = Math.max(0, -(a01 * segExtent + b0));
                      s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                  }

              }

          } else {

              // Ray and segment are parallel.

              s1 = (a01 > 0) ? -segExtent : segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

          }

          if (optionalPointOnRay) {

              optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);

          }

          if (optionalPointOnSegment) {

              optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);

          }

          return sqrDist;

      },

      intersectSphere: function(sphere, target) {

          _vector$2.subVectors(sphere.center, this.origin);
          const tca = _vector$2.dot(this.direction);
          const d2 = _vector$2.dot(_vector$2) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;

          if (d2 > radius2) return null;

          const thc = Math.sqrt(radius2 - d2);

          // t0 = first intersect point - entrance on front of sphere
          const t0 = tca - thc;

          // t1 = second intersect point - exit point on back of sphere
          const t1 = tca + thc;

          // test to see if both t0 and t1 are behind the ray - if so, return null
          if (t0 < 0 && t1 < 0) return null;

          // test to see if t0 is behind the ray:
          // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
          // in order to always return an intersect point that is in front of the ray.
          if (t0 < 0) return this.at(t1, target);

          // else t0 is in front of the ray, so return the first collision point scaled by t0
          return this.at(t0, target);

      },

      intersectsSphere: function(sphere) {

          return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);

      },

      distanceToPlane: function(plane) {

          const denominator = plane.normal.dot(this.direction);

          if (denominator === 0) {

              // line is coplanar, return origin
              if (plane.distanceToPoint(this.origin) === 0) {

                  return 0;

              }

              // Null is preferable to undefined since undefined means.... it is undefined

              return null;

          }

          const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

          // Return if the ray never intersects the plane

          return t >= 0 ? t : null;

      },

      intersectPlane: function(plane, target) {

          const t = this.distanceToPlane(plane);

          if (t === null) {

              return null;

          }

          return this.at(t, target);

      },

      intersectsPlane: function(plane) {

          // check if the ray lies on the plane first

          const distToPoint = plane.distanceToPoint(this.origin);

          if (distToPoint === 0) {

              return true;

          }

          const denominator = plane.normal.dot(this.direction);

          if (denominator * distToPoint < 0) {

              return true;

          }

          // ray origin is behind the plane (and is pointing behind it)

          return false;

      },

      intersectBox: function(box, target) {

          let tmin, tmax, tymin, tymax, tzmin, tzmax;

          const invdirx = 1 / this.direction.x,
              invdiry = 1 / this.direction.y,
              invdirz = 1 / this.direction.z;

          const origin = this.origin;

          if (invdirx >= 0) {

              tmin = (box.min.x - origin.x) * invdirx;
              tmax = (box.max.x - origin.x) * invdirx;

          } else {

              tmin = (box.max.x - origin.x) * invdirx;
              tmax = (box.min.x - origin.x) * invdirx;

          }

          if (invdiry >= 0) {

              tymin = (box.min.y - origin.y) * invdiry;
              tymax = (box.max.y - origin.y) * invdiry;

          } else {

              tymin = (box.max.y - origin.y) * invdiry;
              tymax = (box.min.y - origin.y) * invdiry;

          }

          if ((tmin > tymax) || (tymin > tmax)) return null;

          // These lines also handle the case where tmin or tmax is NaN
          // (result of 0 * Infinity). x !== x returns true if x is NaN

          if (tymin > tmin || tmin !== tmin) tmin = tymin;

          if (tymax < tmax || tmax !== tmax) tmax = tymax;

          if (invdirz >= 0) {

              tzmin = (box.min.z - origin.z) * invdirz;
              tzmax = (box.max.z - origin.z) * invdirz;

          } else {

              tzmin = (box.max.z - origin.z) * invdirz;
              tzmax = (box.min.z - origin.z) * invdirz;

          }

          if ((tmin > tzmax) || (tzmin > tmax)) return null;

          if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

          if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

          //return point closest to the ray (positive side)

          if (tmax < 0) return null;

          return this.at(tmin >= 0 ? tmin : tmax, target);

      },

      intersectsBox: function(box) {

          return this.intersectBox(box, _vector$2) !== null;

      },

      intersectTriangle: function(a, b, c, backfaceCulling, target) {

          // Compute the offset origin, edges, and normal.

          // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

          _edge1.subVectors(b, a);
          _edge2.subVectors(c, a);
          _normal.crossVectors(_edge1, _edge2);

          // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
          // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
          //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
          //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
          //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
          let DdN = this.direction.dot(_normal);
          let sign;

          if (DdN > 0) {

              if (backfaceCulling) return null;
              sign = 1;

          } else if (DdN < 0) {

              sign = -1;
              DdN = -DdN;

          } else {

              return null;

          }

          _diff.subVectors(this.origin, a);
          const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

          // b1 < 0, no intersection
          if (DdQxE2 < 0) {

              return null;

          }

          const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

          // b2 < 0, no intersection
          if (DdE1xQ < 0) {

              return null;

          }

          // b1+b2 > 1, no intersection
          if (DdQxE2 + DdE1xQ > DdN) {

              return null;

          }

          // Line intersects triangle, check if ray does.
          const QdN = -sign * _diff.dot(_normal);

          // t < 0, no intersection
          if (QdN < 0) {

              return null;

          }

          // Ray intersects triangle.
          return this.at(QdN / DdN, target);

      },

      applyMatrix4: function(matrix4) {

          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);

          return this;

      },

      equals: function(ray) {

          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);

      }

  });

  /**
   * @author bhouston / http://clara.io
   */

  const _vector1 = new Vector3();
  const _vector2 = new Vector3();
  const _normalMatrix = new Matrix3();

  function Plane(normal, constant) {

      // normal is assumed to be normalized

      this.normal = (normal !== undefined) ? normal : new Vector3(1, 0, 0);
      this.constant = (constant !== undefined) ? constant : 0;

  }

  Object.assign(Plane.prototype, {

      isPlane: true,

      set: function(normal, constant) {

          this.normal.copy(normal);
          this.constant = constant;

          return this;

      },

      setComponents: function(x, y, z, w) {

          this.normal.set(x, y, z);
          this.constant = w;

          return this;

      },

      setFromNormalAndCoplanarPoint: function(normal, point) {

          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);

          return this;

      },

      setFromCoplanarPoints: function(a, b, c) {

          const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

          // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

          this.setFromNormalAndCoplanarPoint(normal, a);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(plane) {

          this.normal.copy(plane.normal);
          this.constant = plane.constant;

          return this;

      },

      normalize: function() {

          // Note: will lead to a divide by zero if the plane is invalid.

          const inverseNormalLength = 1.0 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;

          return this;

      },

      negate: function() {

          this.constant *= -1;
          this.normal.negate();

          return this;

      },

      distanceToPoint: function(point) {

          return this.normal.dot(point) + this.constant;

      },

      distanceToSphere: function(sphere) {

          return this.distanceToPoint(sphere.center) - sphere.radius;

      },

      projectPoint: function(point, target) {

          if (target === undefined) {

              console.warn('THREE.Plane: .projectPoint() target is now required');
              target = new Vector3();

          }

          return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);

      },

      intersectLine: function(line, target) {

          if (target === undefined) {

              console.warn('THREE.Plane: .intersectLine() target is now required');
              target = new Vector3();

          }

          const direction = line.delta(_vector1);

          const denominator = this.normal.dot(direction);

          if (denominator === 0) {

              // line is coplanar, return origin
              if (this.distanceToPoint(line.start) === 0) {

                  return target.copy(line.start);

              }

              // Unsure if this is the correct method to handle this case.
              return undefined;

          }

          const t = -(line.start.dot(this.normal) + this.constant) / denominator;

          if (t < 0 || t > 1) {

              return undefined;

          }

          return target.copy(direction).multiplyScalar(t).add(line.start);

      },

      intersectsLine: function(line) {

          // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);

          return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);

      },

      intersectsBox: function(box) {

          return box.intersectsPlane(this);

      },

      intersectsSphere: function(sphere) {

          return sphere.intersectsPlane(this);

      },

      coplanarPoint: function(target) {

          if (target === undefined) {

              console.warn('THREE.Plane: .coplanarPoint() target is now required');
              target = new Vector3();

          }

          return target.copy(this.normal).multiplyScalar(-this.constant);

      },

      applyMatrix4: function(matrix, optionalNormalMatrix) {

          const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

          const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);

          const normal = this.normal.applyMatrix3(normalMatrix).normalize();

          this.constant = -referencePoint.dot(normal);

          return this;

      },

      translate: function(offset) {

          this.constant -= offset.dot(this.normal);

          return this;

      },

      equals: function(plane) {

          return plane.normal.equals(this.normal) && (plane.constant === this.constant);

      }

  });

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  const _v0$1 = new Vector3();
  const _v1$3 = new Vector3();
  const _v2$1 = new Vector3();
  const _v3 = new Vector3();

  const _vab = new Vector3();
  const _vac = new Vector3();
  const _vbc = new Vector3();
  const _vap = new Vector3();
  const _vbp = new Vector3();
  const _vcp = new Vector3();

  function Triangle(a, b, c) {

      this.a = (a !== undefined) ? a : new Vector3();
      this.b = (b !== undefined) ? b : new Vector3();
      this.c = (c !== undefined) ? c : new Vector3();

  }

  Object.assign(Triangle, {

      getNormal: function(a, b, c, target) {

          if (target === undefined) {

              console.warn('THREE.Triangle: .getNormal() target is now required');
              target = new Vector3();

          }

          target.subVectors(c, b);
          _v0$1.subVectors(a, b);
          target.cross(_v0$1);

          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {

              return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));

          }

          return target.set(0, 0, 0);

      },

      // static/instance method to calculate barycentric coordinates
      // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
      getBarycoord: function(point, a, b, c, target) {

          _v0$1.subVectors(c, a);
          _v1$3.subVectors(b, a);
          _v2$1.subVectors(point, a);

          const dot00 = _v0$1.dot(_v0$1);
          const dot01 = _v0$1.dot(_v1$3);
          const dot02 = _v0$1.dot(_v2$1);
          const dot11 = _v1$3.dot(_v1$3);
          const dot12 = _v1$3.dot(_v2$1);

          const denom = (dot00 * dot11 - dot01 * dot01);

          if (target === undefined) {

              console.warn('THREE.Triangle: .getBarycoord() target is now required');
              target = new Vector3();

          }

          // collinear or singular triangle
          if (denom === 0) {

              // arbitrary location outside of triangle?
              // not sure if this is the best idea, maybe should be returning undefined
              return target.set(-2, -1, -1);

          }

          const invDenom = 1 / denom;
          const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

          // barycentric coordinates must always sum to 1
          return target.set(1 - u - v, v, u);

      },

      containsPoint: function(point, a, b, c) {

          Triangle.getBarycoord(point, a, b, c, _v3);

          return (_v3.x >= 0) && (_v3.y >= 0) && ((_v3.x + _v3.y) <= 1);

      },

      getUV: function(point, p1, p2, p3, uv1, uv2, uv3, target) {

          this.getBarycoord(point, p1, p2, p3, _v3);

          target.set(0, 0);
          target.addScaledVector(uv1, _v3.x);
          target.addScaledVector(uv2, _v3.y);
          target.addScaledVector(uv3, _v3.z);

          return target;

      },

      isFrontFacing: function(a, b, c, direction) {

          _v0$1.subVectors(c, b);
          _v1$3.subVectors(a, b);

          // strictly front facing
          return (_v0$1.cross(_v1$3).dot(direction) < 0) ? true : false;

      }

  });

  Object.assign(Triangle.prototype, {

      set: function(a, b, c) {

          this.a.copy(a);
          this.b.copy(b);
          this.c.copy(c);

          return this;

      },

      setFromPointsAndIndices: function(points, i0, i1, i2) {

          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i2]);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(triangle) {

          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);

          return this;

      },

      getArea: function() {

          _v0$1.subVectors(this.c, this.b);
          _v1$3.subVectors(this.a, this.b);

          return _v0$1.cross(_v1$3).length() * 0.5;

      },

      getMidpoint: function(target) {

          if (target === undefined) {

              console.warn('THREE.Triangle: .getMidpoint() target is now required');
              target = new Vector3();

          }

          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);

      },

      getNormal: function(target) {

          return Triangle.getNormal(this.a, this.b, this.c, target);

      },

      getPlane: function(target) {

          if (target === undefined) {

              console.warn('THREE.Triangle: .getPlane() target is now required');
              target = new Plane();

          }

          return target.setFromCoplanarPoints(this.a, this.b, this.c);

      },

      getBarycoord: function(point, target) {

          return Triangle.getBarycoord(point, this.a, this.b, this.c, target);

      },

      getUV: function(point, uv1, uv2, uv3, target) {

          return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);

      },

      containsPoint: function(point) {

          return Triangle.containsPoint(point, this.a, this.b, this.c);

      },

      isFrontFacing: function(direction) {

          return Triangle.isFrontFacing(this.a, this.b, this.c, direction);

      },

      intersectsBox: function(box) {

          return box.intersectsTriangle(this);

      },

      closestPointToPoint: function(p, target) {

          if (target === undefined) {

              console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
              target = new Vector3();

          }

          const a = this.a,
              b = this.b,
              c = this.c;
          let v, w;

          // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
          // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
          // under the accompanying license; see chapter 5.1.5 for detailed explanation.
          // basically, we're distinguishing which of the voronoi regions of the triangle
          // the point lies in with the minimum amount of redundant computation.

          _vab.subVectors(b, a);
          _vac.subVectors(c, a);
          _vap.subVectors(p, a);
          const d1 = _vab.dot(_vap);
          const d2 = _vac.dot(_vap);
          if (d1 <= 0 && d2 <= 0) {

              // vertex region of A; barycentric coords (1, 0, 0)
              return target.copy(a);

          }

          _vbp.subVectors(p, b);
          const d3 = _vab.dot(_vbp);
          const d4 = _vac.dot(_vbp);
          if (d3 >= 0 && d4 <= d3) {

              // vertex region of B; barycentric coords (0, 1, 0)
              return target.copy(b);

          }

          const vc = d1 * d4 - d3 * d2;
          if (vc <= 0 && d1 >= 0 && d3 <= 0) {

              v = d1 / (d1 - d3);
              // edge region of AB; barycentric coords (1-v, v, 0)
              return target.copy(a).addScaledVector(_vab, v);

          }

          _vcp.subVectors(p, c);
          const d5 = _vab.dot(_vcp);
          const d6 = _vac.dot(_vcp);
          if (d6 >= 0 && d5 <= d6) {

              // vertex region of C; barycentric coords (0, 0, 1)
              return target.copy(c);

          }

          const vb = d5 * d2 - d1 * d6;
          if (vb <= 0 && d2 >= 0 && d6 <= 0) {

              w = d2 / (d2 - d6);
              // edge region of AC; barycentric coords (1-w, 0, w)
              return target.copy(a).addScaledVector(_vac, w);

          }

          const va = d3 * d6 - d5 * d4;
          if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {

              _vbc.subVectors(c, b);
              w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
              // edge region of BC; barycentric coords (0, 1-w, w)
              return target.copy(b).addScaledVector(_vbc, w); // edge region of BC

          }

          // face region
          const denom = 1 / (va + vb + vc);
          // u = va * denom
          v = vb * denom;
          w = vc * denom;

          return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);

      },

      equals: function(triangle) {

          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const _colorKeywords = {
      'aliceblue': 0xF0F8FF,
      'antiquewhite': 0xFAEBD7,
      'aqua': 0x00FFFF,
      'aquamarine': 0x7FFFD4,
      'azure': 0xF0FFFF,
      'beige': 0xF5F5DC,
      'bisque': 0xFFE4C4,
      'black': 0x000000,
      'blanchedalmond': 0xFFEBCD,
      'blue': 0x0000FF,
      'blueviolet': 0x8A2BE2,
      'brown': 0xA52A2A,
      'burlywood': 0xDEB887,
      'cadetblue': 0x5F9EA0,
      'chartreuse': 0x7FFF00,
      'chocolate': 0xD2691E,
      'coral': 0xFF7F50,
      'cornflowerblue': 0x6495ED,
      'cornsilk': 0xFFF8DC,
      'crimson': 0xDC143C,
      'cyan': 0x00FFFF,
      'darkblue': 0x00008B,
      'darkcyan': 0x008B8B,
      'darkgoldenrod': 0xB8860B,
      'darkgray': 0xA9A9A9,
      'darkgreen': 0x006400,
      'darkgrey': 0xA9A9A9,
      'darkkhaki': 0xBDB76B,
      'darkmagenta': 0x8B008B,
      'darkolivegreen': 0x556B2F,
      'darkorange': 0xFF8C00,
      'darkorchid': 0x9932CC,
      'darkred': 0x8B0000,
      'darksalmon': 0xE9967A,
      'darkseagreen': 0x8FBC8F,
      'darkslateblue': 0x483D8B,
      'darkslategray': 0x2F4F4F,
      'darkslategrey': 0x2F4F4F,
      'darkturquoise': 0x00CED1,
      'darkviolet': 0x9400D3,
      'deeppink': 0xFF1493,
      'deepskyblue': 0x00BFFF,
      'dimgray': 0x696969,
      'dimgrey': 0x696969,
      'dodgerblue': 0x1E90FF,
      'firebrick': 0xB22222,
      'floralwhite': 0xFFFAF0,
      'forestgreen': 0x228B22,
      'fuchsia': 0xFF00FF,
      'gainsboro': 0xDCDCDC,
      'ghostwhite': 0xF8F8FF,
      'gold': 0xFFD700,
      'goldenrod': 0xDAA520,
      'gray': 0x808080,
      'green': 0x008000,
      'greenyellow': 0xADFF2F,
      'grey': 0x808080,
      'honeydew': 0xF0FFF0,
      'hotpink': 0xFF69B4,
      'indianred': 0xCD5C5C,
      'indigo': 0x4B0082,
      'ivory': 0xFFFFF0,
      'khaki': 0xF0E68C,
      'lavender': 0xE6E6FA,
      'lavenderblush': 0xFFF0F5,
      'lawngreen': 0x7CFC00,
      'lemonchiffon': 0xFFFACD,
      'lightblue': 0xADD8E6,
      'lightcoral': 0xF08080,
      'lightcyan': 0xE0FFFF,
      'lightgoldenrodyellow': 0xFAFAD2,
      'lightgray': 0xD3D3D3,
      'lightgreen': 0x90EE90,
      'lightgrey': 0xD3D3D3,
      'lightpink': 0xFFB6C1,
      'lightsalmon': 0xFFA07A,
      'lightseagreen': 0x20B2AA,
      'lightskyblue': 0x87CEFA,
      'lightslategray': 0x778899,
      'lightslategrey': 0x778899,
      'lightsteelblue': 0xB0C4DE,
      'lightyellow': 0xFFFFE0,
      'lime': 0x00FF00,
      'limegreen': 0x32CD32,
      'linen': 0xFAF0E6,
      'magenta': 0xFF00FF,
      'maroon': 0x800000,
      'mediumaquamarine': 0x66CDAA,
      'mediumblue': 0x0000CD,
      'mediumorchid': 0xBA55D3,
      'mediumpurple': 0x9370DB,
      'mediumseagreen': 0x3CB371,
      'mediumslateblue': 0x7B68EE,
      'mediumspringgreen': 0x00FA9A,
      'mediumturquoise': 0x48D1CC,
      'mediumvioletred': 0xC71585,
      'midnightblue': 0x191970,
      'mintcream': 0xF5FFFA,
      'mistyrose': 0xFFE4E1,
      'moccasin': 0xFFE4B5,
      'navajowhite': 0xFFDEAD,
      'navy': 0x000080,
      'oldlace': 0xFDF5E6,
      'olive': 0x808000,
      'olivedrab': 0x6B8E23,
      'orange': 0xFFA500,
      'orangered': 0xFF4500,
      'orchid': 0xDA70D6,
      'palegoldenrod': 0xEEE8AA,
      'palegreen': 0x98FB98,
      'paleturquoise': 0xAFEEEE,
      'palevioletred': 0xDB7093,
      'papayawhip': 0xFFEFD5,
      'peachpuff': 0xFFDAB9,
      'peru': 0xCD853F,
      'pink': 0xFFC0CB,
      'plum': 0xDDA0DD,
      'powderblue': 0xB0E0E6,
      'purple': 0x800080,
      'rebeccapurple': 0x663399,
      'red': 0xFF0000,
      'rosybrown': 0xBC8F8F,
      'royalblue': 0x4169E1,
      'saddlebrown': 0x8B4513,
      'salmon': 0xFA8072,
      'sandybrown': 0xF4A460,
      'seagreen': 0x2E8B57,
      'seashell': 0xFFF5EE,
      'sienna': 0xA0522D,
      'silver': 0xC0C0C0,
      'skyblue': 0x87CEEB,
      'slateblue': 0x6A5ACD,
      'slategray': 0x708090,
      'slategrey': 0x708090,
      'snow': 0xFFFAFA,
      'springgreen': 0x00FF7F,
      'steelblue': 0x4682B4,
      'tan': 0xD2B48C,
      'teal': 0x008080,
      'thistle': 0xD8BFD8,
      'tomato': 0xFF6347,
      'turquoise': 0x40E0D0,
      'violet': 0xEE82EE,
      'wheat': 0xF5DEB3,
      'white': 0xFFFFFF,
      'whitesmoke': 0xF5F5F5,
      'yellow': 0xFFFF00,
      'yellowgreen': 0x9ACD32
  };

  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };

  function Color(r, g, b) {

      if (g === undefined && b === undefined) {

          // r is THREE.Color, hex or string
          return this.set(r);

      }

      return this.setRGB(r, g, b);

  }

  function hue2rgb(p, q, t) {

      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
      return p;

  }

  function SRGBToLinear(c) {

      return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);

  }

  function LinearToSRGB(c) {

      return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;

  }

  Object.assign(Color.prototype, {

      isColor: true,

      r: 1,
      g: 1,
      b: 1,

      set: function(value) {

          if (value && value.isColor) {

              this.copy(value);

          } else if (typeof value === 'number') {

              this.setHex(value);

          } else if (typeof value === 'string') {

              this.setStyle(value);

          }

          return this;

      },

      setScalar: function(scalar) {

          this.r = scalar;
          this.g = scalar;
          this.b = scalar;

          return this;

      },

      setHex: function(hex) {

          hex = Math.floor(hex);

          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;

          return this;

      },

      setRGB: function(r, g, b) {

          this.r = r;
          this.g = g;
          this.b = b;

          return this;

      },

      setHSL: function(h, s, l) {

          // h,s,l ranges are in 0.0 - 1.0
          h = MathUtils.euclideanModulo(h, 1);
          s = MathUtils.clamp(s, 0, 1);
          l = MathUtils.clamp(l, 0, 1);

          if (s === 0) {

              this.r = this.g = this.b = l;

          } else {

              const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
              const q = (2 * l) - p;

              this.r = hue2rgb(q, p, h + 1 / 3);
              this.g = hue2rgb(q, p, h);
              this.b = hue2rgb(q, p, h - 1 / 3);

          }

          return this;

      },

      setStyle: function(style) {

          function handleAlpha(string) {

              if (string === undefined) return;

              if (parseFloat(string) < 1) {

                  console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');

              }

          }


          let m;

          if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {

              // rgb / hsl

              let color;
              const name = m[1];
              const components = m[2];

              switch (name) {

                  case 'rgb':
                  case 'rgba':

                      if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                          // rgb(255,0,0) rgba(255,0,0,0.5)
                          this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                          this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                          this.b = Math.min(255, parseInt(color[3], 10)) / 255;

                          handleAlpha(color[5]);

                          return this;

                      }

                      if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                          // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                          this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                          this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                          this.b = Math.min(100, parseInt(color[3], 10)) / 100;

                          handleAlpha(color[5]);

                          return this;

                      }

                      break;

                  case 'hsl':
                  case 'hsla':

                      if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                          // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                          const h = parseFloat(color[1]) / 360;
                          const s = parseInt(color[2], 10) / 100;
                          const l = parseInt(color[3], 10) / 100;

                          handleAlpha(color[5]);

                          return this.setHSL(h, s, l);

                      }

                      break;

              }

          } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {

              // hex color

              const hex = m[1];
              const size = hex.length;

              if (size === 3) {

                  // #ff0
                  this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                  this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                  this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

                  return this;

              } else if (size === 6) {

                  // #ff0000
                  this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                  this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                  this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

                  return this;

              }

          }

          if (style && style.length > 0) {

              return this.setColorName(style);

          }

          return this;

      },

      setColorName: function(style) {

          // color keywords
          const hex = _colorKeywords[style];

          if (hex !== undefined) {

              // red
              this.setHex(hex);

          } else {

              // unknown color
              console.warn('THREE.Color: Unknown color ' + style);

          }

          return this;

      },

      clone: function() {

          return new this.constructor(this.r, this.g, this.b);

      },

      copy: function(color) {

          this.r = color.r;
          this.g = color.g;
          this.b = color.b;

          return this;

      },

      copyGammaToLinear: function(color, gammaFactor) {

          if (gammaFactor === undefined) gammaFactor = 2.0;

          this.r = Math.pow(color.r, gammaFactor);
          this.g = Math.pow(color.g, gammaFactor);
          this.b = Math.pow(color.b, gammaFactor);

          return this;

      },

      copyLinearToGamma: function(color, gammaFactor) {

          if (gammaFactor === undefined) gammaFactor = 2.0;

          const safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;

          this.r = Math.pow(color.r, safeInverse);
          this.g = Math.pow(color.g, safeInverse);
          this.b = Math.pow(color.b, safeInverse);

          return this;

      },

      convertGammaToLinear: function(gammaFactor) {

          this.copyGammaToLinear(this, gammaFactor);

          return this;

      },

      convertLinearToGamma: function(gammaFactor) {

          this.copyLinearToGamma(this, gammaFactor);

          return this;

      },

      copySRGBToLinear: function(color) {

          this.r = SRGBToLinear(color.r);
          this.g = SRGBToLinear(color.g);
          this.b = SRGBToLinear(color.b);

          return this;

      },

      copyLinearToSRGB: function(color) {

          this.r = LinearToSRGB(color.r);
          this.g = LinearToSRGB(color.g);
          this.b = LinearToSRGB(color.b);

          return this;

      },

      convertSRGBToLinear: function() {

          this.copySRGBToLinear(this);

          return this;

      },

      convertLinearToSRGB: function() {

          this.copyLinearToSRGB(this);

          return this;

      },

      getHex: function() {

          return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;

      },

      getHexString: function() {

          return ('000000' + this.getHex().toString(16)).slice(-6);

      },

      getHSL: function(target) {

          // h,s,l ranges are in 0.0 - 1.0

          if (target === undefined) {

              console.warn('THREE.Color: .getHSL() target is now required');
              target = { h: 0, s: 0, l: 0 };

          }

          const r = this.r,
              g = this.g,
              b = this.b;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);

          let hue, saturation;
          const lightness = (min + max) / 2.0;

          if (min === max) {

              hue = 0;
              saturation = 0;

          } else {

              const delta = max - min;

              saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

              switch (max) {

                  case r:
                      hue = (g - b) / delta + (g < b ? 6 : 0);
                      break;
                  case g:
                      hue = (b - r) / delta + 2;
                      break;
                  case b:
                      hue = (r - g) / delta + 4;
                      break;

              }

              hue /= 6;

          }

          target.h = hue;
          target.s = saturation;
          target.l = lightness;

          return target;

      },

      getStyle: function() {

          return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';

      },

      offsetHSL: function(h, s, l) {

          this.getHSL(_hslA);

          _hslA.h += h;
          _hslA.s += s;
          _hslA.l += l;

          this.setHSL(_hslA.h, _hslA.s, _hslA.l);

          return this;

      },

      add: function(color) {

          this.r += color.r;
          this.g += color.g;
          this.b += color.b;

          return this;

      },

      addColors: function(color1, color2) {

          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;

          return this;

      },

      addScalar: function(s) {

          this.r += s;
          this.g += s;
          this.b += s;

          return this;

      },

      sub: function(color) {

          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);

          return this;

      },

      multiply: function(color) {

          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;

          return this;

      },

      multiplyScalar: function(s) {

          this.r *= s;
          this.g *= s;
          this.b *= s;

          return this;

      },

      lerp: function(color, alpha) {

          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;

          return this;

      },

      lerpHSL: function(color, alpha) {

          this.getHSL(_hslA);
          color.getHSL(_hslB);

          const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
          const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
          const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);

          this.setHSL(h, s, l);

          return this;

      },

      equals: function(c) {

          return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;

          return array;

      },

      fromBufferAttribute: function(attribute, index) {

          this.r = attribute.getX(index);
          this.g = attribute.getY(index);
          this.b = attribute.getZ(index);

          if (attribute.normalized === true) {

              // assuming Uint8Array

              this.r /= 255;
              this.g /= 255;
              this.b /= 255;

          }

          return this;

      },

      toJSON: function() {

          return this.getHex();

      }

  });

  Color.NAMES = _colorKeywords;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Face3(a, b, c, normal, color, materialIndex) {

      this.a = a;
      this.b = b;
      this.c = c;

      this.normal = (normal && normal.isVector3) ? normal : new Vector3();
      this.vertexNormals = Array.isArray(normal) ? normal : [];

      this.color = (color && color.isColor) ? color : new Color();
      this.vertexColors = Array.isArray(color) ? color : [];

      this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

  }

  Object.assign(Face3.prototype, {

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(source) {

          this.a = source.a;
          this.b = source.b;
          this.c = source.c;

          this.normal.copy(source.normal);
          this.color.copy(source.color);

          this.materialIndex = source.materialIndex;

          for (let i = 0, il = source.vertexNormals.length; i < il; i++) {

              this.vertexNormals[i] = source.vertexNormals[i].clone();

          }

          for (let i = 0, il = source.vertexColors.length; i < il; i++) {

              this.vertexColors[i] = source.vertexColors[i].clone();

          }

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  let materialId = 0;

  function Material() {

      Object.defineProperty(this, 'id', { value: materialId++ });

      this.uuid = MathUtils.generateUUID();

      this.name = '';
      this.type = 'Material';

      this.fog = true;

      this.blending = NormalBlending;
      this.side = FrontSide;
      this.flatShading = false;
      this.vertexColors = false;

      this.opacity = 1;
      this.transparent = false;

      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;

      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;

      this.stencilWriteMask = 0xff;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 0xff;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;

      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;

      this.shadowSide = null;

      this.colorWrite = true;

      this.precision = null; // override the renderer's default precision for this material

      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;

      this.dithering = false;

      this.alphaTest = 0;
      this.premultipliedAlpha = false;

      this.visible = true;

      this.toneMapped = true;

      this.userData = {};

      this.version = 0;

  }

  Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

      constructor: Material,

      isMaterial: true,

      onBeforeCompile: function( /* shaderobject, renderer */ ) {},

      customProgramCacheKey: function() {

          return this.onBeforeCompile.toString();

      },

      setValues: function(values) {

          if (values === undefined) return;

          for (const key in values) {

              const newValue = values[key];

              if (newValue === undefined) {

                  console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                  continue;

              }

              // for backward compatability if shading is set in the constructor
              if (key === 'shading') {

                  console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                  this.flatShading = (newValue === FlatShading) ? true : false;
                  continue;

              }

              const currentValue = this[key];

              if (currentValue === undefined) {

                  console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                  continue;

              }

              if (currentValue && currentValue.isColor) {

                  currentValue.set(newValue);

              } else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {

                  currentValue.copy(newValue);

              } else {

                  this[key] = newValue;

              }

          }

      },

      toJSON: function(meta) {

          const isRoot = (meta === undefined || typeof meta === 'string');

          if (isRoot) {

              meta = {
                  textures: {},
                  images: {}
              };

          }

          const data = {
              metadata: {
                  version: 4.5,
                  type: 'Material',
                  generator: 'Material.toJSON'
              }
          };

          // standard Material serialization
          data.uuid = this.uuid;
          data.type = this.type;

          if (this.name !== '') data.name = this.name;

          if (this.color && this.color.isColor) data.color = this.color.getHex();

          if (this.roughness !== undefined) data.roughness = this.roughness;
          if (this.metalness !== undefined) data.metalness = this.metalness;

          if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
          if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;

          if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
          if (this.shininess !== undefined) data.shininess = this.shininess;
          if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

          if (this.clearcoatMap && this.clearcoatMap.isTexture) {

              data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;

          }

          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {

              data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;

          }

          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {

              data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
              data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

          }

          if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

          if (this.aoMap && this.aoMap.isTexture) {

              data.aoMap = this.aoMap.toJSON(meta).uuid;
              data.aoMapIntensity = this.aoMapIntensity;

          }

          if (this.bumpMap && this.bumpMap.isTexture) {

              data.bumpMap = this.bumpMap.toJSON(meta).uuid;
              data.bumpScale = this.bumpScale;

          }

          if (this.normalMap && this.normalMap.isTexture) {

              data.normalMap = this.normalMap.toJSON(meta).uuid;
              data.normalMapType = this.normalMapType;
              data.normalScale = this.normalScale.toArray();

          }

          if (this.displacementMap && this.displacementMap.isTexture) {

              data.displacementMap = this.displacementMap.toJSON(meta).uuid;
              data.displacementScale = this.displacementScale;
              data.displacementBias = this.displacementBias;

          }

          if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

          if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

          if (this.envMap && this.envMap.isTexture) {

              data.envMap = this.envMap.toJSON(meta).uuid;
              data.reflectivity = this.reflectivity; // Scale behind envMap
              data.refractionRatio = this.refractionRatio;

              if (this.combine !== undefined) data.combine = this.combine;
              if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;

          }

          if (this.gradientMap && this.gradientMap.isTexture) {

              data.gradientMap = this.gradientMap.toJSON(meta).uuid;

          }

          if (this.size !== undefined) data.size = this.size;
          if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;

          if (this.blending !== NormalBlending) data.blending = this.blending;
          if (this.flatShading === true) data.flatShading = this.flatShading;
          if (this.side !== FrontSide) data.side = this.side;
          if (this.vertexColors) data.vertexColors = true;

          if (this.opacity < 1) data.opacity = this.opacity;
          if (this.transparent === true) data.transparent = this.transparent;

          data.depthFunc = this.depthFunc;
          data.depthTest = this.depthTest;
          data.depthWrite = this.depthWrite;

          data.stencilWrite = this.stencilWrite;
          data.stencilWriteMask = this.stencilWriteMask;
          data.stencilFunc = this.stencilFunc;
          data.stencilRef = this.stencilRef;
          data.stencilFuncMask = this.stencilFuncMask;
          data.stencilFail = this.stencilFail;
          data.stencilZFail = this.stencilZFail;
          data.stencilZPass = this.stencilZPass;

          // rotation (SpriteMaterial)
          if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;

          if (this.polygonOffset === true) data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;

          if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
          if (this.dashSize !== undefined) data.dashSize = this.dashSize;
          if (this.gapSize !== undefined) data.gapSize = this.gapSize;
          if (this.scale !== undefined) data.scale = this.scale;

          if (this.dithering === true) data.dithering = true;

          if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
          if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;

          if (this.wireframe === true) data.wireframe = this.wireframe;
          if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;

          if (this.morphTargets === true) data.morphTargets = true;
          if (this.morphNormals === true) data.morphNormals = true;
          if (this.skinning === true) data.skinning = true;

          if (this.visible === false) data.visible = false;

          if (this.toneMapped === false) data.toneMapped = false;

          if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

          // TODO: Copied from Object3D.toJSON

          function extractFromCache(cache) {

              const values = [];

              for (const key in cache) {

                  const data = cache[key];
                  delete data.metadata;
                  values.push(data);

              }

              return values;

          }

          if (isRoot) {

              const textures = extractFromCache(meta.textures);
              const images = extractFromCache(meta.images);

              if (textures.length > 0) data.textures = textures;
              if (images.length > 0) data.images = images;

          }

          return data;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(source) {

          this.name = source.name;

          this.fog = source.fog;

          this.blending = source.blending;
          this.side = source.side;
          this.flatShading = source.flatShading;
          this.vertexColors = source.vertexColors;

          this.opacity = source.opacity;
          this.transparent = source.transparent;

          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;

          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;

          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;

          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;

          if (srcPlanes !== null) {

              const n = srcPlanes.length;
              dstPlanes = new Array(n);

              for (let i = 0; i !== n; ++i) {

                  dstPlanes[i] = srcPlanes[i].clone();

              }

          }

          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;

          this.shadowSide = source.shadowSide;

          this.colorWrite = source.colorWrite;

          this.precision = source.precision;

          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;

          this.dithering = source.dithering;

          this.alphaTest = source.alphaTest;
          this.premultipliedAlpha = source.premultipliedAlpha;

          this.visible = source.visible;

          this.toneMapped = source.toneMapped;

          this.userData = JSON.parse(JSON.stringify(source.userData));

          return this;

      },

      dispose: function() {

          this.dispatchEvent({ type: 'dispose' });

      }

  });

  Object.defineProperty(Material.prototype, 'needsUpdate', {

      set: function(value) {

          if (value === true) this.version++;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>
   * }
   */

  function MeshBasicMaterial(parameters) {

      Material.call(this);

      this.type = 'MeshBasicMaterial';

      this.color = new Color(0xffffff); // emissive

      this.map = null;

      this.lightMap = null;
      this.lightMapIntensity = 1.0;

      this.aoMap = null;
      this.aoMapIntensity = 1.0;

      this.specularMap = null;

      this.alphaMap = null;

      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;

      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';

      this.skinning = false;
      this.morphTargets = false;

      this.setValues(parameters);

  }

  MeshBasicMaterial.prototype = Object.create(Material.prototype);
  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

  MeshBasicMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);

      this.map = source.map;

      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;

      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;

      this.specularMap = source.specularMap;

      this.alphaMap = source.alphaMap;

      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;

      return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const _vector$3 = new Vector3();
  const _vector2$1 = new Vector2();

  function BufferAttribute(array, itemSize, normalized) {

      if (Array.isArray(array)) {

          throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

      }

      this.name = '';

      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== undefined ? array.length / itemSize : 0;
      this.normalized = normalized === true;

      this.usage = StaticDrawUsage;
      this.updateRange = { offset: 0, count: -1 };

      this.version = 0;

  }

  Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {

      set: function(value) {

          if (value === true) this.version++;

      }

  });

  Object.assign(BufferAttribute.prototype, {

      isBufferAttribute: true,

      onUploadCallback: function() {},

      setUsage: function(value) {

          this.usage = value;

          return this;

      },

      copy: function(source) {

          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;

          this.usage = source.usage;

          return this;

      },

      copyAt: function(index1, attribute, index2) {

          index1 *= this.itemSize;
          index2 *= attribute.itemSize;

          for (let i = 0, l = this.itemSize; i < l; i++) {

              this.array[index1 + i] = attribute.array[index2 + i];

          }

          return this;

      },

      copyArray: function(array) {

          this.array.set(array);

          return this;

      },

      copyColorsArray: function(colors) {

          const array = this.array;
          let offset = 0;

          for (let i = 0, l = colors.length; i < l; i++) {

              let color = colors[i];

              if (color === undefined) {

                  console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                  color = new Color();

              }

              array[offset++] = color.r;
              array[offset++] = color.g;
              array[offset++] = color.b;

          }

          return this;

      },

      copyVector2sArray: function(vectors) {

          const array = this.array;
          let offset = 0;

          for (let i = 0, l = vectors.length; i < l; i++) {

              let vector = vectors[i];

              if (vector === undefined) {

                  console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                  vector = new Vector2();

              }

              array[offset++] = vector.x;
              array[offset++] = vector.y;

          }

          return this;

      },

      copyVector3sArray: function(vectors) {

          const array = this.array;
          let offset = 0;

          for (let i = 0, l = vectors.length; i < l; i++) {

              let vector = vectors[i];

              if (vector === undefined) {

                  console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                  vector = new Vector3();

              }

              array[offset++] = vector.x;
              array[offset++] = vector.y;
              array[offset++] = vector.z;

          }

          return this;

      },

      copyVector4sArray: function(vectors) {

          const array = this.array;
          let offset = 0;

          for (let i = 0, l = vectors.length; i < l; i++) {

              let vector = vectors[i];

              if (vector === undefined) {

                  console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                  vector = new Vector4();

              }

              array[offset++] = vector.x;
              array[offset++] = vector.y;
              array[offset++] = vector.z;
              array[offset++] = vector.w;

          }

          return this;

      },

      applyMatrix3: function(m) {

          if (this.itemSize === 2) {

              for (let i = 0, l = this.count; i < l; i++) {

                  _vector2$1.fromBufferAttribute(this, i);
                  _vector2$1.applyMatrix3(m);

                  this.setXY(i, _vector2$1.x, _vector2$1.y, );

              }

          } else if (this.itemSize === 3) {

              for (let i = 0, l = this.count; i < l; i++) {

                  _vector$3.fromBufferAttribute(this, i);
                  _vector$3.applyMatrix3(m);

                  this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);

              }

          }

          return this;

      },

      applyMatrix4: function(m) {

          for (let i = 0, l = this.count; i < l; i++) {

              _vector$3.x = this.getX(i);
              _vector$3.y = this.getY(i);
              _vector$3.z = this.getZ(i);

              _vector$3.applyMatrix4(m);

              this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);

          }

          return this;

      },

      applyNormalMatrix: function(m) {

          for (let i = 0, l = this.count; i < l; i++) {

              _vector$3.x = this.getX(i);
              _vector$3.y = this.getY(i);
              _vector$3.z = this.getZ(i);

              _vector$3.applyNormalMatrix(m);

              this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);

          }

          return this;

      },

      transformDirection: function(m) {

          for (let i = 0, l = this.count; i < l; i++) {

              _vector$3.x = this.getX(i);
              _vector$3.y = this.getY(i);
              _vector$3.z = this.getZ(i);

              _vector$3.transformDirection(m);

              this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);

          }

          return this;

      },

      set: function(value, offset) {

          if (offset === undefined) offset = 0;

          this.array.set(value, offset);

          return this;

      },

      getX: function(index) {

          return this.array[index * this.itemSize];

      },

      setX: function(index, x) {

          this.array[index * this.itemSize] = x;

          return this;

      },

      getY: function(index) {

          return this.array[index * this.itemSize + 1];

      },

      setY: function(index, y) {

          this.array[index * this.itemSize + 1] = y;

          return this;

      },

      getZ: function(index) {

          return this.array[index * this.itemSize + 2];

      },

      setZ: function(index, z) {

          this.array[index * this.itemSize + 2] = z;

          return this;

      },

      getW: function(index) {

          return this.array[index * this.itemSize + 3];

      },

      setW: function(index, w) {

          this.array[index * this.itemSize + 3] = w;

          return this;

      },

      setXY: function(index, x, y) {

          index *= this.itemSize;

          this.array[index + 0] = x;
          this.array[index + 1] = y;

          return this;

      },

      setXYZ: function(index, x, y, z) {

          index *= this.itemSize;

          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;

          return this;

      },

      setXYZW: function(index, x, y, z, w) {

          index *= this.itemSize;

          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          this.array[index + 3] = w;

          return this;

      },

      onUpload: function(callback) {

          this.onUploadCallback = callback;

          return this;

      },

      clone: function() {

          return new this.constructor(this.array, this.itemSize).copy(this);

      },

      toJSON: function() {

          return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized
          };

      }

  });

  //

  function Int8BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);

  }

  Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


  function Uint8BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);

  }

  Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);

  }

  Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


  function Int16BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);

  }

  Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


  function Uint16BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);

  }

  Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


  function Int32BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);

  }

  Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


  function Uint32BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);

  }

  Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


  function Float32BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);

  }

  Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


  function Float64BufferAttribute(array, itemSize, normalized) {

      BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);

  }

  Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectGeometry() {

      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.uvs2 = [];

      this.groups = [];

      this.morphTargets = {};

      this.skinWeights = [];
      this.skinIndices = [];

      // this.lineDistances = [];

      this.boundingBox = null;
      this.boundingSphere = null;

      // update flags

      this.verticesNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.groupsNeedUpdate = false;

  }

  Object.assign(DirectGeometry.prototype, {

      computeGroups: function(geometry) {

          const groups = [];

          let group, i;
          let materialIndex = undefined;

          const faces = geometry.faces;

          for (i = 0; i < faces.length; i++) {

              const face = faces[i];

              // materials

              if (face.materialIndex !== materialIndex) {

                  materialIndex = face.materialIndex;

                  if (group !== undefined) {

                      group.count = (i * 3) - group.start;
                      groups.push(group);

                  }

                  group = {
                      start: i * 3,
                      materialIndex: materialIndex
                  };

              }

          }

          if (group !== undefined) {

              group.count = (i * 3) - group.start;
              groups.push(group);

          }

          this.groups = groups;

      },

      fromGeometry: function(geometry) {

          const faces = geometry.faces;
          const vertices = geometry.vertices;
          const faceVertexUvs = geometry.faceVertexUvs;

          const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
          const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;

          // morphs

          const morphTargets = geometry.morphTargets;
          const morphTargetsLength = morphTargets.length;

          let morphTargetsPosition;

          if (morphTargetsLength > 0) {

              morphTargetsPosition = [];

              for (let i = 0; i < morphTargetsLength; i++) {

                  morphTargetsPosition[i] = {
                      name: morphTargets[i].name,
                      data: []
                  };

              }

              this.morphTargets.position = morphTargetsPosition;

          }

          const morphNormals = geometry.morphNormals;
          const morphNormalsLength = morphNormals.length;

          let morphTargetsNormal;

          if (morphNormalsLength > 0) {

              morphTargetsNormal = [];

              for (let i = 0; i < morphNormalsLength; i++) {

                  morphTargetsNormal[i] = {
                      name: morphNormals[i].name,
                      data: []
                  };

              }

              this.morphTargets.normal = morphTargetsNormal;

          }

          // skins

          const skinIndices = geometry.skinIndices;
          const skinWeights = geometry.skinWeights;

          const hasSkinIndices = skinIndices.length === vertices.length;
          const hasSkinWeights = skinWeights.length === vertices.length;

          //

          if (vertices.length > 0 && faces.length === 0) {

              console.error('THREE.DirectGeometry: Faceless geometries are not supported.');

          }

          for (let i = 0; i < faces.length; i++) {

              const face = faces[i];

              this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);

              const vertexNormals = face.vertexNormals;

              if (vertexNormals.length === 3) {

                  this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);

              } else {

                  const normal = face.normal;

                  this.normals.push(normal, normal, normal);

              }

              const vertexColors = face.vertexColors;

              if (vertexColors.length === 3) {

                  this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);

              } else {

                  const color = face.color;

                  this.colors.push(color, color, color);

              }

              if (hasFaceVertexUv === true) {

                  const vertexUvs = faceVertexUvs[0][i];

                  if (vertexUvs !== undefined) {

                      this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);

                  } else {

                      console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);

                      this.uvs.push(new Vector2(), new Vector2(), new Vector2());

                  }

              }

              if (hasFaceVertexUv2 === true) {

                  const vertexUvs = faceVertexUvs[1][i];

                  if (vertexUvs !== undefined) {

                      this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);

                  } else {

                      console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);

                      this.uvs2.push(new Vector2(), new Vector2(), new Vector2());

                  }

              }

              // morphs

              for (let j = 0; j < morphTargetsLength; j++) {

                  const morphTarget = morphTargets[j].vertices;

                  morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);

              }

              for (let j = 0; j < morphNormalsLength; j++) {

                  const morphNormal = morphNormals[j].vertexNormals[i];

                  morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);

              }

              // skins

              if (hasSkinIndices) {

                  this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);

              }

              if (hasSkinWeights) {

                  this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);

              }

          }

          this.computeGroups(geometry);

          this.verticesNeedUpdate = geometry.verticesNeedUpdate;
          this.normalsNeedUpdate = geometry.normalsNeedUpdate;
          this.colorsNeedUpdate = geometry.colorsNeedUpdate;
          this.uvsNeedUpdate = geometry.uvsNeedUpdate;
          this.groupsNeedUpdate = geometry.groupsNeedUpdate;

          if (geometry.boundingSphere !== null) {

              this.boundingSphere = geometry.boundingSphere.clone();

          }

          if (geometry.boundingBox !== null) {

              this.boundingBox = geometry.boundingBox.clone();

          }

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function arrayMax(array) {

      if (array.length === 0) return -Infinity;

      let max = array[0];

      for (let i = 1, l = array.length; i < l; ++i) {

          if (array[i] > max) max = array[i];

      }

      return max;

  }

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  let _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

  const _m1$2 = new Matrix4();
  const _obj = new Object3D();
  const _offset = new Vector3();
  const _box$2 = new Box3();
  const _boxMorphTargets = new Box3();
  const _vector$4 = new Vector3();

  function BufferGeometry() {

      Object.defineProperty(this, 'id', { value: _bufferGeometryId += 2 });

      this.uuid = MathUtils.generateUUID();

      this.name = '';
      this.type = 'BufferGeometry';

      this.index = null;
      this.attributes = {};

      this.morphAttributes = {};
      this.morphTargetsRelative = false;

      this.groups = [];

      this.boundingBox = null;
      this.boundingSphere = null;

      this.drawRange = { start: 0, count: Infinity };

      this.userData = {};

  }

  BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

      constructor: BufferGeometry,

      isBufferGeometry: true,

      getIndex: function() {

          return this.index;

      },

      setIndex: function(index) {

          if (Array.isArray(index)) {

              this.index = new(arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);

          } else {

              this.index = index;

          }

      },

      getAttribute: function(name) {

          return this.attributes[name];

      },

      setAttribute: function(name, attribute) {

          this.attributes[name] = attribute;

          return this;

      },

      deleteAttribute: function(name) {

          delete this.attributes[name];

          return this;

      },

      addGroup: function(start, count, materialIndex) {

          this.groups.push({

              start: start,
              count: count,
              materialIndex: materialIndex !== undefined ? materialIndex : 0

          });

      },

      clearGroups: function() {

          this.groups = [];

      },

      setDrawRange: function(start, count) {

          this.drawRange.start = start;
          this.drawRange.count = count;

      },

      applyMatrix4: function(matrix) {

          const position = this.attributes.position;

          if (position !== undefined) {

              position.applyMatrix4(matrix);

              position.needsUpdate = true;

          }

          const normal = this.attributes.normal;

          if (normal !== undefined) {

              const normalMatrix = new Matrix3().getNormalMatrix(matrix);

              normal.applyNormalMatrix(normalMatrix);

              normal.needsUpdate = true;

          }

          const tangent = this.attributes.tangent;

          if (tangent !== undefined) {

              tangent.transformDirection(matrix);

              tangent.needsUpdate = true;

          }

          if (this.boundingBox !== null) {

              this.computeBoundingBox();

          }

          if (this.boundingSphere !== null) {

              this.computeBoundingSphere();

          }

          return this;

      },

      rotateX: function(angle) {

          // rotate geometry around world x-axis

          _m1$2.makeRotationX(angle);

          this.applyMatrix4(_m1$2);

          return this;

      },

      rotateY: function(angle) {

          // rotate geometry around world y-axis

          _m1$2.makeRotationY(angle);

          this.applyMatrix4(_m1$2);

          return this;

      },

      rotateZ: function(angle) {

          // rotate geometry around world z-axis

          _m1$2.makeRotationZ(angle);

          this.applyMatrix4(_m1$2);

          return this;

      },

      translate: function(x, y, z) {

          // translate geometry

          _m1$2.makeTranslation(x, y, z);

          this.applyMatrix4(_m1$2);

          return this;

      },

      scale: function(x, y, z) {

          // scale geometry

          _m1$2.makeScale(x, y, z);

          this.applyMatrix4(_m1$2);

          return this;

      },

      lookAt: function(vector) {

          _obj.lookAt(vector);

          _obj.updateMatrix();

          this.applyMatrix4(_obj.matrix);

          return this;

      },

      center: function() {

          this.computeBoundingBox();

          this.boundingBox.getCenter(_offset).negate();

          this.translate(_offset.x, _offset.y, _offset.z);

          return this;

      },

      setFromObject: function(object) {

          // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

          const geometry = object.geometry;

          if (object.isPoints || object.isLine) {

              const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
              const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);

              this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
              this.setAttribute('color', colors.copyColorsArray(geometry.colors));

              if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {

                  const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);

                  this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));

              }

              if (geometry.boundingSphere !== null) {

                  this.boundingSphere = geometry.boundingSphere.clone();

              }

              if (geometry.boundingBox !== null) {

                  this.boundingBox = geometry.boundingBox.clone();

              }

          } else if (object.isMesh) {

              if (geometry && geometry.isGeometry) {

                  this.fromGeometry(geometry);

              }

          }

          return this;

      },

      setFromPoints: function(points) {

          const position = [];

          for (let i = 0, l = points.length; i < l; i++) {

              const point = points[i];
              position.push(point.x, point.y, point.z || 0);

          }

          this.setAttribute('position', new Float32BufferAttribute(position, 3));

          return this;

      },

      updateFromObject: function(object) {

          let geometry = object.geometry;

          if (object.isMesh) {

              let direct = geometry.__directGeometry;

              if (geometry.elementsNeedUpdate === true) {

                  direct = undefined;
                  geometry.elementsNeedUpdate = false;

              }

              if (direct === undefined) {

                  return this.fromGeometry(geometry);

              }

              direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
              direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
              direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
              direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
              direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

              geometry.verticesNeedUpdate = false;
              geometry.normalsNeedUpdate = false;
              geometry.colorsNeedUpdate = false;
              geometry.uvsNeedUpdate = false;
              geometry.groupsNeedUpdate = false;

              geometry = direct;

          }

          if (geometry.verticesNeedUpdate === true) {

              const attribute = this.attributes.position;

              if (attribute !== undefined) {

                  attribute.copyVector3sArray(geometry.vertices);
                  attribute.needsUpdate = true;

              }

              geometry.verticesNeedUpdate = false;

          }

          if (geometry.normalsNeedUpdate === true) {

              const attribute = this.attributes.normal;

              if (attribute !== undefined) {

                  attribute.copyVector3sArray(geometry.normals);
                  attribute.needsUpdate = true;

              }

              geometry.normalsNeedUpdate = false;

          }

          if (geometry.colorsNeedUpdate === true) {

              const attribute = this.attributes.color;

              if (attribute !== undefined) {

                  attribute.copyColorsArray(geometry.colors);
                  attribute.needsUpdate = true;

              }

              geometry.colorsNeedUpdate = false;

          }

          if (geometry.uvsNeedUpdate) {

              const attribute = this.attributes.uv;

              if (attribute !== undefined) {

                  attribute.copyVector2sArray(geometry.uvs);
                  attribute.needsUpdate = true;

              }

              geometry.uvsNeedUpdate = false;

          }

          if (geometry.lineDistancesNeedUpdate) {

              const attribute = this.attributes.lineDistance;

              if (attribute !== undefined) {

                  attribute.copyArray(geometry.lineDistances);
                  attribute.needsUpdate = true;

              }

              geometry.lineDistancesNeedUpdate = false;

          }

          if (geometry.groupsNeedUpdate) {

              geometry.computeGroups(object.geometry);
              this.groups = geometry.groups;

              geometry.groupsNeedUpdate = false;

          }

          return this;

      },

      fromGeometry: function(geometry) {

          geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);

          return this.fromDirectGeometry(geometry.__directGeometry);

      },

      fromDirectGeometry: function(geometry) {

          const positions = new Float32Array(geometry.vertices.length * 3);
          this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

          if (geometry.normals.length > 0) {

              const normals = new Float32Array(geometry.normals.length * 3);
              this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));

          }

          if (geometry.colors.length > 0) {

              const colors = new Float32Array(geometry.colors.length * 3);
              this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));

          }

          if (geometry.uvs.length > 0) {

              const uvs = new Float32Array(geometry.uvs.length * 2);
              this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));

          }

          if (geometry.uvs2.length > 0) {

              const uvs2 = new Float32Array(geometry.uvs2.length * 2);
              this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));

          }

          // groups

          this.groups = geometry.groups;

          // morphs

          for (const name in geometry.morphTargets) {

              const array = [];
              const morphTargets = geometry.morphTargets[name];

              for (let i = 0, l = morphTargets.length; i < l; i++) {

                  const morphTarget = morphTargets[i];

                  const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
                  attribute.name = morphTarget.name;

                  array.push(attribute.copyVector3sArray(morphTarget.data));

              }

              this.morphAttributes[name] = array;

          }

          // skinning

          if (geometry.skinIndices.length > 0) {

              const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
              this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));

          }

          if (geometry.skinWeights.length > 0) {

              const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
              this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));

          }

          //

          if (geometry.boundingSphere !== null) {

              this.boundingSphere = geometry.boundingSphere.clone();

          }

          if (geometry.boundingBox !== null) {

              this.boundingBox = geometry.boundingBox.clone();

          }

          return this;

      },

      computeBoundingBox: function() {

          if (this.boundingBox === null) {

              this.boundingBox = new Box3();

          }

          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;

          if (position !== undefined) {

              this.boundingBox.setFromBufferAttribute(position);

              // process morph attributes if present

              if (morphAttributesPosition) {

                  for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

                      const morphAttribute = morphAttributesPosition[i];
                      _box$2.setFromBufferAttribute(morphAttribute);

                      if (this.morphTargetsRelative) {

                          _vector$4.addVectors(this.boundingBox.min, _box$2.min);
                          this.boundingBox.expandByPoint(_vector$4);

                          _vector$4.addVectors(this.boundingBox.max, _box$2.max);
                          this.boundingBox.expandByPoint(_vector$4);

                      } else {

                          this.boundingBox.expandByPoint(_box$2.min);
                          this.boundingBox.expandByPoint(_box$2.max);

                      }

                  }

              }

          } else {

              this.boundingBox.makeEmpty();

          }

          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

              console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);

          }

      },

      computeBoundingSphere: function() {

          if (this.boundingSphere === null) {

              this.boundingSphere = new Sphere();

          }

          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;

          if (position) {

              // first, find the center of the bounding sphere

              const center = this.boundingSphere.center;

              _box$2.setFromBufferAttribute(position);

              // process morph attributes if present

              if (morphAttributesPosition) {

                  for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

                      const morphAttribute = morphAttributesPosition[i];
                      _boxMorphTargets.setFromBufferAttribute(morphAttribute);

                      if (this.morphTargetsRelative) {

                          _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
                          _box$2.expandByPoint(_vector$4);

                          _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
                          _box$2.expandByPoint(_vector$4);

                      } else {

                          _box$2.expandByPoint(_boxMorphTargets.min);
                          _box$2.expandByPoint(_boxMorphTargets.max);

                      }

                  }

              }

              _box$2.getCenter(center);

              // second, try to find a boundingSphere with a radius smaller than the
              // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

              let maxRadiusSq = 0;

              for (let i = 0, il = position.count; i < il; i++) {

                  _vector$4.fromBufferAttribute(position, i);

                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));

              }

              // process morph attributes if present

              if (morphAttributesPosition) {

                  for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

                      const morphAttribute = morphAttributesPosition[i];
                      const morphTargetsRelative = this.morphTargetsRelative;

                      for (let j = 0, jl = morphAttribute.count; j < jl; j++) {

                          _vector$4.fromBufferAttribute(morphAttribute, j);

                          if (morphTargetsRelative) {

                              _offset.fromBufferAttribute(position, j);
                              _vector$4.add(_offset);

                          }

                          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));

                      }

                  }

              }

              this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

              if (isNaN(this.boundingSphere.radius)) {

                  console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);

              }

          }

      },

      computeFaceNormals: function() {

          // backwards compatibility

      },

      computeVertexNormals: function() {

          const index = this.index;
          const positionAttribute = this.getAttribute('position');

          if (positionAttribute !== undefined) {

              let normalAttribute = this.getAttribute('normal');

              if (normalAttribute === undefined) {

                  normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                  this.setAttribute('normal', normalAttribute);

              } else {

                  // reset existing normals to zero

                  for (let i = 0, il = normalAttribute.count; i < il; i++) {

                      normalAttribute.setXYZ(i, 0, 0, 0);

                  }

              }

              const pA = new Vector3(),
                  pB = new Vector3(),
                  pC = new Vector3();
              const nA = new Vector3(),
                  nB = new Vector3(),
                  nC = new Vector3();
              const cb = new Vector3(),
                  ab = new Vector3();

              // indexed elements

              if (index) {

                  for (let i = 0, il = index.count; i < il; i += 3) {

                      const vA = index.getX(i + 0);
                      const vB = index.getX(i + 1);
                      const vC = index.getX(i + 2);

                      pA.fromBufferAttribute(positionAttribute, vA);
                      pB.fromBufferAttribute(positionAttribute, vB);
                      pC.fromBufferAttribute(positionAttribute, vC);

                      cb.subVectors(pC, pB);
                      ab.subVectors(pA, pB);
                      cb.cross(ab);

                      nA.fromBufferAttribute(normalAttribute, vA);
                      nB.fromBufferAttribute(normalAttribute, vB);
                      nC.fromBufferAttribute(normalAttribute, vC);

                      nA.add(cb);
                      nB.add(cb);
                      nC.add(cb);

                      normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                      normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                      normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);

                  }

              } else {

                  // non-indexed elements (unconnected triangle soup)

                  for (let i = 0, il = positionAttribute.count; i < il; i += 3) {

                      pA.fromBufferAttribute(positionAttribute, i + 0);
                      pB.fromBufferAttribute(positionAttribute, i + 1);
                      pC.fromBufferAttribute(positionAttribute, i + 2);

                      cb.subVectors(pC, pB);
                      ab.subVectors(pA, pB);
                      cb.cross(ab);

                      normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
                      normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
                      normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);

                  }

              }

              this.normalizeNormals();

              normalAttribute.needsUpdate = true;

          }

      },

      merge: function(geometry, offset) {

          if (!(geometry && geometry.isBufferGeometry)) {

              console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
              return;

          }

          if (offset === undefined) {

              offset = 0;

              console.warn(
                  'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' +
                  'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
              );

          }

          const attributes = this.attributes;

          for (const key in attributes) {

              if (geometry.attributes[key] === undefined) continue;

              const attribute1 = attributes[key];
              const attributeArray1 = attribute1.array;

              const attribute2 = geometry.attributes[key];
              const attributeArray2 = attribute2.array;

              const attributeOffset = attribute2.itemSize * offset;
              const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

              for (let i = 0, j = attributeOffset; i < length; i++, j++) {

                  attributeArray1[j] = attributeArray2[i];

              }

          }

          return this;

      },

      normalizeNormals: function() {

          const normals = this.attributes.normal;

          for (let i = 0, il = normals.count; i < il; i++) {

              _vector$4.fromBufferAttribute(normals, i);

              _vector$4.normalize();

              normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);

          }

      },

      toNonIndexed: function() {

          function convertBufferAttribute(attribute, indices) {

              const array = attribute.array;
              const itemSize = attribute.itemSize;
              const normalized = attribute.normalized;

              const array2 = new array.constructor(indices.length * itemSize);

              let index = 0,
                  index2 = 0;

              for (let i = 0, l = indices.length; i < l; i++) {

                  index = indices[i] * itemSize;

                  for (let j = 0; j < itemSize; j++) {

                      array2[index2++] = array[index++];

                  }

              }

              return new BufferAttribute(array2, itemSize, normalized);

          }

          //

          if (this.index === null) {

              console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
              return this;

          }

          const geometry2 = new BufferGeometry();

          const indices = this.index.array;
          const attributes = this.attributes;

          // attributes

          for (const name in attributes) {

              const attribute = attributes[name];

              const newAttribute = convertBufferAttribute(attribute, indices);

              geometry2.setAttribute(name, newAttribute);

          }

          // morph attributes

          const morphAttributes = this.morphAttributes;

          for (const name in morphAttributes) {

              const morphArray = [];
              const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

              for (let i = 0, il = morphAttribute.length; i < il; i++) {

                  const attribute = morphAttribute[i];

                  const newAttribute = convertBufferAttribute(attribute, indices);

                  morphArray.push(newAttribute);

              }

              geometry2.morphAttributes[name] = morphArray;

          }

          geometry2.morphTargetsRelative = this.morphTargetsRelative;

          // groups

          const groups = this.groups;

          for (let i = 0, l = groups.length; i < l; i++) {

              const group = groups[i];
              geometry2.addGroup(group.start, group.count, group.materialIndex);

          }

          return geometry2;

      },

      toJSON: function() {

          const data = {
              metadata: {
                  version: 4.5,
                  type: 'BufferGeometry',
                  generator: 'BufferGeometry.toJSON'
              }
          };

          // standard BufferGeometry serialization

          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== '') data.name = this.name;
          if (Object.keys(this.userData).length > 0) data.userData = this.userData;

          if (this.parameters !== undefined) {

              const parameters = this.parameters;

              for (const key in parameters) {

                  if (parameters[key] !== undefined) data[key] = parameters[key];

              }

              return data;

          }

          data.data = { attributes: {} };

          const index = this.index;

          if (index !== null) {

              data.data.index = {
                  type: index.array.constructor.name,
                  array: Array.prototype.slice.call(index.array)
              };

          }

          const attributes = this.attributes;

          for (const key in attributes) {

              const attribute = attributes[key];

              const attributeData = attribute.toJSON(data.data);

              if (attribute.name !== '') attributeData.name = attribute.name;

              data.data.attributes[key] = attributeData;

          }

          const morphAttributes = {};
          let hasMorphAttributes = false;

          for (const key in this.morphAttributes) {

              const attributeArray = this.morphAttributes[key];

              const array = [];

              for (let i = 0, il = attributeArray.length; i < il; i++) {

                  const attribute = attributeArray[i];

                  const attributeData = attribute.toJSON(data.data);

                  if (attribute.name !== '') attributeData.name = attribute.name;

                  array.push(attributeData);

              }

              if (array.length > 0) {

                  morphAttributes[key] = array;

                  hasMorphAttributes = true;

              }

          }

          if (hasMorphAttributes) {

              data.data.morphAttributes = morphAttributes;
              data.data.morphTargetsRelative = this.morphTargetsRelative;

          }

          const groups = this.groups;

          if (groups.length > 0) {

              data.data.groups = JSON.parse(JSON.stringify(groups));

          }

          const boundingSphere = this.boundingSphere;

          if (boundingSphere !== null) {

              data.data.boundingSphere = {
                  center: boundingSphere.center.toArray(),
                  radius: boundingSphere.radius
              };

          }

          return data;

      },

      clone: function() {

          /*
           // Handle primitives

           const parameters = this.parameters;

           if ( parameters !== undefined ) {

           const values = [];

           for ( const key in parameters ) {

           values.push( parameters[ key ] );

           }

           const geometry = Object.create( this.constructor.prototype );
           this.constructor.apply( geometry, values );
           return geometry;

           }

           return new this.constructor().copy( this );
           */

          return new BufferGeometry().copy(this);

      },

      copy: function(source) {

          // reset

          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;

          // used for storing cloned, shared data

          const data = {};

          // name

          this.name = source.name;

          // index

          const index = source.index;

          if (index !== null) {

              this.setIndex(index.clone(data));

          }

          // attributes

          const attributes = source.attributes;

          for (const name in attributes) {

              const attribute = attributes[name];
              this.setAttribute(name, attribute.clone(data));

          }

          // morph attributes

          const morphAttributes = source.morphAttributes;

          for (const name in morphAttributes) {

              const array = [];
              const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

              for (let i = 0, l = morphAttribute.length; i < l; i++) {

                  array.push(morphAttribute[i].clone(data));

              }

              this.morphAttributes[name] = array;

          }

          this.morphTargetsRelative = source.morphTargetsRelative;

          // groups

          const groups = source.groups;

          for (let i = 0, l = groups.length; i < l; i++) {

              const group = groups[i];
              this.addGroup(group.start, group.count, group.materialIndex);

          }

          // bounding box

          const boundingBox = source.boundingBox;

          if (boundingBox !== null) {

              this.boundingBox = boundingBox.clone();

          }

          // bounding sphere

          const boundingSphere = source.boundingSphere;

          if (boundingSphere !== null) {

              this.boundingSphere = boundingSphere.clone();

          }

          // draw range

          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;

          // user data

          this.userData = source.userData;

          return this;

      },

      dispose: function() {

          this.dispatchEvent({ type: 'dispose' });

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author jonobr1 / http://jonobr1.com/
   */

  const _inverseMatrix = new Matrix4();
  const _ray = new Ray();
  const _sphere = new Sphere();

  const _vA = new Vector3();
  const _vB = new Vector3();
  const _vC = new Vector3();

  const _tempA = new Vector3();
  const _tempB = new Vector3();
  const _tempC = new Vector3();

  const _morphA = new Vector3();
  const _morphB = new Vector3();
  const _morphC = new Vector3();

  const _uvA = new Vector2();
  const _uvB = new Vector2();
  const _uvC = new Vector2();

  const _intersectionPoint = new Vector3();
  const _intersectionPointWorld = new Vector3();

  function Mesh(geometry, material) {

      Object3D.call(this);

      this.type = 'Mesh';

      this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
      this.material = material !== undefined ? material : new MeshBasicMaterial();

      this.updateMorphTargets();

  }

  Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Mesh,

      isMesh: true,

      copy: function(source) {

          Object3D.prototype.copy.call(this, source);

          if (source.morphTargetInfluences !== undefined) {

              this.morphTargetInfluences = source.morphTargetInfluences.slice();

          }

          if (source.morphTargetDictionary !== undefined) {

              this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);

          }

          this.material = source.material;
          this.geometry = source.geometry;

          return this;

      },

      updateMorphTargets: function() {

          const geometry = this.geometry;

          if (geometry.isBufferGeometry) {

              const morphAttributes = geometry.morphAttributes;
              const keys = Object.keys(morphAttributes);

              if (keys.length > 0) {

                  const morphAttribute = morphAttributes[keys[0]];

                  if (morphAttribute !== undefined) {

                      this.morphTargetInfluences = [];
                      this.morphTargetDictionary = {};

                      for (let m = 0, ml = morphAttribute.length; m < ml; m++) {

                          const name = morphAttribute[m].name || String(m);

                          this.morphTargetInfluences.push(0);
                          this.morphTargetDictionary[name] = m;

                      }

                  }

              }

          } else {

              const morphTargets = geometry.morphTargets;

              if (morphTargets !== undefined && morphTargets.length > 0) {

                  console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');

              }

          }

      },

      raycast: function(raycaster, intersects) {

          const geometry = this.geometry;
          const material = this.material;
          const matrixWorld = this.matrixWorld;

          if (material === undefined) return;

          // Checking boundingSphere distance to ray

          if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

          _sphere.copy(geometry.boundingSphere);
          _sphere.applyMatrix4(matrixWorld);

          if (raycaster.ray.intersectsSphere(_sphere) === false) return;

          //

          _inverseMatrix.getInverse(matrixWorld);
          _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

          // Check boundingBox before continuing

          if (geometry.boundingBox !== null) {

              if (_ray.intersectsBox(geometry.boundingBox) === false) return;

          }

          let intersection;

          if (geometry.isBufferGeometry) {

              const index = geometry.index;
              const position = geometry.attributes.position;
              const morphPosition = geometry.morphAttributes.position;
              const morphTargetsRelative = geometry.morphTargetsRelative;
              const uv = geometry.attributes.uv;
              const uv2 = geometry.attributes.uv2;
              const groups = geometry.groups;
              const drawRange = geometry.drawRange;

              if (index !== null) {

                  // indexed buffer geometry

                  if (Array.isArray(material)) {

                      for (let i = 0, il = groups.length; i < il; i++) {

                          const group = groups[i];
                          const groupMaterial = material[group.materialIndex];

                          const start = Math.max(group.start, drawRange.start);
                          const end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));

                          for (let j = start, jl = end; j < jl; j += 3) {

                              const a = index.getX(j);
                              const b = index.getX(j + 1);
                              const c = index.getX(j + 2);

                              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                              if (intersection) {

                                  intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                                  intersection.face.materialIndex = group.materialIndex;
                                  intersects.push(intersection);

                              }

                          }

                      }

                  } else {

                      const start = Math.max(0, drawRange.start);
                      const end = Math.min(index.count, (drawRange.start + drawRange.count));

                      for (let i = start, il = end; i < il; i += 3) {

                          const a = index.getX(i);
                          const b = index.getX(i + 1);
                          const c = index.getX(i + 2);

                          intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                          if (intersection) {

                              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
                              intersects.push(intersection);

                          }

                      }

                  }

              } else if (position !== undefined) {

                  // non-indexed buffer geometry

                  if (Array.isArray(material)) {

                      for (let i = 0, il = groups.length; i < il; i++) {

                          const group = groups[i];
                          const groupMaterial = material[group.materialIndex];

                          const start = Math.max(group.start, drawRange.start);
                          const end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));

                          for (let j = start, jl = end; j < jl; j += 3) {

                              const a = j;
                              const b = j + 1;
                              const c = j + 2;

                              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                              if (intersection) {

                                  intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                                  intersection.face.materialIndex = group.materialIndex;
                                  intersects.push(intersection);

                              }

                          }

                      }

                  } else {

                      const start = Math.max(0, drawRange.start);
                      const end = Math.min(position.count, (drawRange.start + drawRange.count));

                      for (let i = start, il = end; i < il; i += 3) {

                          const a = i;
                          const b = i + 1;
                          const c = i + 2;

                          intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                          if (intersection) {

                              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
                              intersects.push(intersection);

                          }

                      }

                  }

              }

          } else if (geometry.isGeometry) {

              const isMultiMaterial = Array.isArray(material);

              const vertices = geometry.vertices;
              const faces = geometry.faces;
              let uvs;

              const faceVertexUvs = geometry.faceVertexUvs[0];
              if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

              for (let f = 0, fl = faces.length; f < fl; f++) {

                  const face = faces[f];
                  const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;

                  if (faceMaterial === undefined) continue;

                  const fvA = vertices[face.a];
                  const fvB = vertices[face.b];
                  const fvC = vertices[face.c];

                  intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);

                  if (intersection) {

                      if (uvs && uvs[f]) {

                          const uvs_f = uvs[f];
                          _uvA.copy(uvs_f[0]);
                          _uvB.copy(uvs_f[1]);
                          _uvC.copy(uvs_f[2]);

                          intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());

                      }

                      intersection.face = face;
                      intersection.faceIndex = f;
                      intersects.push(intersection);

                  }

              }

          }

      }

  });

  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {

      let intersect;

      if (material.side === BackSide) {

          intersect = ray.intersectTriangle(pC, pB, pA, true, point);

      } else {

          intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);

      }

      if (intersect === null) return null;

      _intersectionPointWorld.copy(point);
      _intersectionPointWorld.applyMatrix4(object.matrixWorld);

      const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);

      if (distance < raycaster.near || distance > raycaster.far) return null;

      return {
          distance: distance,
          point: _intersectionPointWorld.clone(),
          object: object
      };

  }

  function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {

      _vA.fromBufferAttribute(position, a);
      _vB.fromBufferAttribute(position, b);
      _vC.fromBufferAttribute(position, c);

      const morphInfluences = object.morphTargetInfluences;

      if (material.morphTargets && morphPosition && morphInfluences) {

          _morphA.set(0, 0, 0);
          _morphB.set(0, 0, 0);
          _morphC.set(0, 0, 0);

          for (let i = 0, il = morphPosition.length; i < il; i++) {

              const influence = morphInfluences[i];
              const morphAttribute = morphPosition[i];

              if (influence === 0) continue;

              _tempA.fromBufferAttribute(morphAttribute, a);
              _tempB.fromBufferAttribute(morphAttribute, b);
              _tempC.fromBufferAttribute(morphAttribute, c);

              if (morphTargetsRelative) {

                  _morphA.addScaledVector(_tempA, influence);
                  _morphB.addScaledVector(_tempB, influence);
                  _morphC.addScaledVector(_tempC, influence);

              } else {

                  _morphA.addScaledVector(_tempA.sub(_vA), influence);
                  _morphB.addScaledVector(_tempB.sub(_vB), influence);
                  _morphC.addScaledVector(_tempC.sub(_vC), influence);

              }

          }

          _vA.add(_morphA);
          _vB.add(_morphB);
          _vC.add(_morphC);

      }

      if (object.isSkinnedMesh) {

          object.boneTransform(a, _vA);
          object.boneTransform(b, _vB);
          object.boneTransform(c, _vC);

      }

      const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

      if (intersection) {

          if (uv) {

              _uvA.fromBufferAttribute(uv, a);
              _uvB.fromBufferAttribute(uv, b);
              _uvC.fromBufferAttribute(uv, c);

              intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());

          }

          if (uv2) {

              _uvA.fromBufferAttribute(uv2, a);
              _uvB.fromBufferAttribute(uv2, b);
              _uvC.fromBufferAttribute(uv2, c);

              intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());

          }

          const face = new Face3(a, b, c);
          Triangle.getNormal(_vA, _vB, _vC, face.normal);

          intersection.face = face;

      }

      return intersection;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author bhouston / http://clara.io
   */

  let _geometryId = 0; // Geometry uses even numbers as Id
  const _m1$3 = new Matrix4();
  const _obj$1 = new Object3D();
  const _offset$1 = new Vector3();

  function Geometry() {

      Object.defineProperty(this, 'id', { value: _geometryId += 2 });

      this.uuid = MathUtils.generateUUID();

      this.name = '';
      this.type = 'Geometry';

      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [
          []
      ];

      this.morphTargets = [];
      this.morphNormals = [];

      this.skinWeights = [];
      this.skinIndices = [];

      this.lineDistances = [];

      this.boundingBox = null;
      this.boundingSphere = null;

      // update flags

      this.elementsNeedUpdate = false;
      this.verticesNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.lineDistancesNeedUpdate = false;
      this.groupsNeedUpdate = false;

  }

  Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

      constructor: Geometry,

      isGeometry: true,

      applyMatrix4: function(matrix) {

          const normalMatrix = new Matrix3().getNormalMatrix(matrix);

          for (let i = 0, il = this.vertices.length; i < il; i++) {

              const vertex = this.vertices[i];
              vertex.applyMatrix4(matrix);

          }

          for (let i = 0, il = this.faces.length; i < il; i++) {

              const face = this.faces[i];
              face.normal.applyMatrix3(normalMatrix).normalize();

              for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {

                  face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();

              }

          }

          if (this.boundingBox !== null) {

              this.computeBoundingBox();

          }

          if (this.boundingSphere !== null) {

              this.computeBoundingSphere();

          }

          this.verticesNeedUpdate = true;
          this.normalsNeedUpdate = true;

          return this;

      },

      rotateX: function(angle) {

          // rotate geometry around world x-axis

          _m1$3.makeRotationX(angle);

          this.applyMatrix4(_m1$3);

          return this;

      },

      rotateY: function(angle) {

          // rotate geometry around world y-axis

          _m1$3.makeRotationY(angle);

          this.applyMatrix4(_m1$3);

          return this;

      },

      rotateZ: function(angle) {

          // rotate geometry around world z-axis

          _m1$3.makeRotationZ(angle);

          this.applyMatrix4(_m1$3);

          return this;

      },

      translate: function(x, y, z) {

          // translate geometry

          _m1$3.makeTranslation(x, y, z);

          this.applyMatrix4(_m1$3);

          return this;

      },

      scale: function(x, y, z) {

          // scale geometry

          _m1$3.makeScale(x, y, z);

          this.applyMatrix4(_m1$3);

          return this;

      },

      lookAt: function(vector) {

          _obj$1.lookAt(vector);

          _obj$1.updateMatrix();

          this.applyMatrix4(_obj$1.matrix);

          return this;

      },

      fromBufferGeometry: function(geometry) {

          const scope = this;

          const index = geometry.index !== null ? geometry.index : undefined;
          const attributes = geometry.attributes;

          if (attributes.position === undefined) {

              console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
              return this;

          }

          const position = attributes.position;
          const normal = attributes.normal;
          const color = attributes.color;
          const uv = attributes.uv;
          const uv2 = attributes.uv2;

          if (uv2 !== undefined) this.faceVertexUvs[1] = [];

          for (let i = 0; i < position.count; i++) {

              scope.vertices.push(new Vector3().fromBufferAttribute(position, i));

              if (color !== undefined) {

                  scope.colors.push(new Color().fromBufferAttribute(color, i));

              }

          }

          function addFace(a, b, c, materialIndex) {

              const vertexColors = (color === undefined) ? [] : [
                  scope.colors[a].clone(),
                  scope.colors[b].clone(),
                  scope.colors[c].clone()
              ];

              const vertexNormals = (normal === undefined) ? [] : [
                  new Vector3().fromBufferAttribute(normal, a),
                  new Vector3().fromBufferAttribute(normal, b),
                  new Vector3().fromBufferAttribute(normal, c)
              ];

              const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);

              scope.faces.push(face);

              if (uv !== undefined) {

                  scope.faceVertexUvs[0].push([
                      new Vector2().fromBufferAttribute(uv, a),
                      new Vector2().fromBufferAttribute(uv, b),
                      new Vector2().fromBufferAttribute(uv, c)
                  ]);

              }

              if (uv2 !== undefined) {

                  scope.faceVertexUvs[1].push([
                      new Vector2().fromBufferAttribute(uv2, a),
                      new Vector2().fromBufferAttribute(uv2, b),
                      new Vector2().fromBufferAttribute(uv2, c)
                  ]);

              }

          }

          const groups = geometry.groups;

          if (groups.length > 0) {

              for (let i = 0; i < groups.length; i++) {

                  const group = groups[i];

                  const start = group.start;
                  const count = group.count;

                  for (let j = start, jl = start + count; j < jl; j += 3) {

                      if (index !== undefined) {

                          addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);

                      } else {

                          addFace(j, j + 1, j + 2, group.materialIndex);

                      }

                  }

              }

          } else {

              if (index !== undefined) {

                  for (let i = 0; i < index.count; i += 3) {

                      addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));

                  }

              } else {

                  for (let i = 0; i < position.count; i += 3) {

                      addFace(i, i + 1, i + 2);

                  }

              }

          }

          this.computeFaceNormals();

          if (geometry.boundingBox !== null) {

              this.boundingBox = geometry.boundingBox.clone();

          }

          if (geometry.boundingSphere !== null) {

              this.boundingSphere = geometry.boundingSphere.clone();

          }

          return this;

      },

      center: function() {

          this.computeBoundingBox();

          this.boundingBox.getCenter(_offset$1).negate();

          this.translate(_offset$1.x, _offset$1.y, _offset$1.z);

          return this;

      },

      normalize: function() {

          this.computeBoundingSphere();

          const center = this.boundingSphere.center;
          const radius = this.boundingSphere.radius;

          const s = radius === 0 ? 1 : 1.0 / radius;

          const matrix = new Matrix4();
          matrix.set(
              s, 0, 0, -s * center.x,
              0, s, 0, -s * center.y,
              0, 0, s, -s * center.z,
              0, 0, 0, 1
          );

          this.applyMatrix4(matrix);

          return this;

      },

      computeFaceNormals: function() {

          const cb = new Vector3(),
              ab = new Vector3();

          for (let f = 0, fl = this.faces.length; f < fl; f++) {

              const face = this.faces[f];

              const vA = this.vertices[face.a];
              const vB = this.vertices[face.b];
              const vC = this.vertices[face.c];

              cb.subVectors(vC, vB);
              ab.subVectors(vA, vB);
              cb.cross(ab);

              cb.normalize();

              face.normal.copy(cb);

          }

      },

      computeVertexNormals: function(areaWeighted) {

          if (areaWeighted === undefined) areaWeighted = true;

          const vertices = new Array(this.vertices.length);

          for (let v = 0, vl = this.vertices.length; v < vl; v++) {

              vertices[v] = new Vector3();

          }

          if (areaWeighted) {

              // vertex normals weighted by triangle areas
              // http://www.iquilezles.org/www/articles/normals/normals.htm

              const cb = new Vector3(),
                  ab = new Vector3();

              for (let f = 0, fl = this.faces.length; f < fl; f++) {

                  const face = this.faces[f];

                  const vA = this.vertices[face.a];
                  const vB = this.vertices[face.b];
                  const vC = this.vertices[face.c];

                  cb.subVectors(vC, vB);
                  ab.subVectors(vA, vB);
                  cb.cross(ab);

                  vertices[face.a].add(cb);
                  vertices[face.b].add(cb);
                  vertices[face.c].add(cb);

              }

          } else {

              this.computeFaceNormals();

              for (let f = 0, fl = this.faces.length; f < fl; f++) {

                  const face = this.faces[f];

                  vertices[face.a].add(face.normal);
                  vertices[face.b].add(face.normal);
                  vertices[face.c].add(face.normal);

              }

          }

          for (let v = 0, vl = this.vertices.length; v < vl; v++) {

              vertices[v].normalize();

          }

          for (let f = 0, fl = this.faces.length; f < fl; f++) {

              const face = this.faces[f];

              const vertexNormals = face.vertexNormals;

              if (vertexNormals.length === 3) {

                  vertexNormals[0].copy(vertices[face.a]);
                  vertexNormals[1].copy(vertices[face.b]);
                  vertexNormals[2].copy(vertices[face.c]);

              } else {

                  vertexNormals[0] = vertices[face.a].clone();
                  vertexNormals[1] = vertices[face.b].clone();
                  vertexNormals[2] = vertices[face.c].clone();

              }

          }

          if (this.faces.length > 0) {

              this.normalsNeedUpdate = true;

          }

      },

      computeFlatVertexNormals: function() {

          this.computeFaceNormals();

          for (let f = 0, fl = this.faces.length; f < fl; f++) {

              const face = this.faces[f];

              const vertexNormals = face.vertexNormals;

              if (vertexNormals.length === 3) {

                  vertexNormals[0].copy(face.normal);
                  vertexNormals[1].copy(face.normal);
                  vertexNormals[2].copy(face.normal);

              } else {

                  vertexNormals[0] = face.normal.clone();
                  vertexNormals[1] = face.normal.clone();
                  vertexNormals[2] = face.normal.clone();

              }

          }

          if (this.faces.length > 0) {

              this.normalsNeedUpdate = true;

          }

      },

      computeMorphNormals: function() {

          // save original normals
          // - create temp variables on first access
          //   otherwise just copy (for faster repeated calls)

          for (let f = 0, fl = this.faces.length; f < fl; f++) {

              const face = this.faces[f];

              if (!face.__originalFaceNormal) {

                  face.__originalFaceNormal = face.normal.clone();

              } else {

                  face.__originalFaceNormal.copy(face.normal);

              }

              if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

              for (let i = 0, il = face.vertexNormals.length; i < il; i++) {

                  if (!face.__originalVertexNormals[i]) {

                      face.__originalVertexNormals[i] = face.vertexNormals[i].clone();

                  } else {

                      face.__originalVertexNormals[i].copy(face.vertexNormals[i]);

                  }

              }

          }

          // use temp geometry to compute face and vertex normals for each morph

          const tmpGeo = new Geometry();
          tmpGeo.faces = this.faces;

          for (let i = 0, il = this.morphTargets.length; i < il; i++) {

              // create on first access

              if (!this.morphNormals[i]) {

                  this.morphNormals[i] = {};
                  this.morphNormals[i].faceNormals = [];
                  this.morphNormals[i].vertexNormals = [];

                  const dstNormalsFace = this.morphNormals[i].faceNormals;
                  const dstNormalsVertex = this.morphNormals[i].vertexNormals;

                  for (let f = 0, fl = this.faces.length; f < fl; f++) {

                      const faceNormal = new Vector3();
                      const vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

                      dstNormalsFace.push(faceNormal);
                      dstNormalsVertex.push(vertexNormals);

                  }

              }

              const morphNormals = this.morphNormals[i];

              // set vertices to morph target

              tmpGeo.vertices = this.morphTargets[i].vertices;

              // compute morph normals

              tmpGeo.computeFaceNormals();
              tmpGeo.computeVertexNormals();

              // store morph normals

              for (let f = 0, fl = this.faces.length; f < fl; f++) {

                  const face = this.faces[f];

                  const faceNormal = morphNormals.faceNormals[f];
                  const vertexNormals = morphNormals.vertexNormals[f];

                  faceNormal.copy(face.normal);

                  vertexNormals.a.copy(face.vertexNormals[0]);
                  vertexNormals.b.copy(face.vertexNormals[1]);
                  vertexNormals.c.copy(face.vertexNormals[2]);

              }

          }

          // restore original normals

          for (let f = 0, fl = this.faces.length; f < fl; f++) {

              const face = this.faces[f];

              face.normal = face.__originalFaceNormal;
              face.vertexNormals = face.__originalVertexNormals;

          }

      },

      computeBoundingBox: function() {

          if (this.boundingBox === null) {

              this.boundingBox = new Box3();

          }

          this.boundingBox.setFromPoints(this.vertices);

      },

      computeBoundingSphere: function() {

          if (this.boundingSphere === null) {

              this.boundingSphere = new Sphere();

          }

          this.boundingSphere.setFromPoints(this.vertices);

      },

      merge: function(geometry, matrix, materialIndexOffset) {

          if (!(geometry && geometry.isGeometry)) {

              console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
              return;

          }

          let normalMatrix,
              vertexOffset = this.vertices.length,
              vertices1 = this.vertices,
              vertices2 = geometry.vertices,
              faces1 = this.faces,
              faces2 = geometry.faces,
              colors1 = this.colors,
              colors2 = geometry.colors;

          if (materialIndexOffset === undefined) materialIndexOffset = 0;

          if (matrix !== undefined) {

              normalMatrix = new Matrix3().getNormalMatrix(matrix);

          }

          // vertices

          for (let i = 0, il = vertices2.length; i < il; i++) {

              const vertex = vertices2[i];

              const vertexCopy = vertex.clone();

              if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);

              vertices1.push(vertexCopy);

          }

          // colors

          for (let i = 0, il = colors2.length; i < il; i++) {

              colors1.push(colors2[i].clone());

          }

          // faces

          for (let i = 0, il = faces2.length; i < il; i++) {

              let face = faces2[i],
                  faceCopy, normal, color,
                  faceVertexNormals = face.vertexNormals,
                  faceVertexColors = face.vertexColors;

              faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
              faceCopy.normal.copy(face.normal);

              if (normalMatrix !== undefined) {

                  faceCopy.normal.applyMatrix3(normalMatrix).normalize();

              }

              for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {

                  normal = faceVertexNormals[j].clone();

                  if (normalMatrix !== undefined) {

                      normal.applyMatrix3(normalMatrix).normalize();

                  }

                  faceCopy.vertexNormals.push(normal);

              }

              faceCopy.color.copy(face.color);

              for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {

                  color = faceVertexColors[j];
                  faceCopy.vertexColors.push(color.clone());

              }

              faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

              faces1.push(faceCopy);

          }

          // uvs

          for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {

              const faceVertexUvs2 = geometry.faceVertexUvs[i];

              if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];

              for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {

                  const uvs2 = faceVertexUvs2[j],
                      uvsCopy = [];

                  for (let k = 0, kl = uvs2.length; k < kl; k++) {

                      uvsCopy.push(uvs2[k].clone());

                  }

                  this.faceVertexUvs[i].push(uvsCopy);

              }

          }

      },

      mergeMesh: function(mesh) {

          if (!(mesh && mesh.isMesh)) {

              console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
              return;

          }

          if (mesh.matrixAutoUpdate) mesh.updateMatrix();

          this.merge(mesh.geometry, mesh.matrix);

      },

      /*
       * Checks for duplicate vertices with hashmap.
       * Duplicated vertices are removed
       * and faces' vertices are updated.
       */

      mergeVertices: function() {

          const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
          const unique = [],
              changes = [];

          const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
          const precision = Math.pow(10, precisionPoints);

          for (let i = 0, il = this.vertices.length; i < il; i++) {

              const v = this.vertices[i];
              const key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

              if (verticesMap[key] === undefined) {

                  verticesMap[key] = i;
                  unique.push(this.vertices[i]);
                  changes[i] = unique.length - 1;

              } else {

                  //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                  changes[i] = changes[verticesMap[key]];

              }

          }


          // if faces are completely degenerate after merging vertices, we
          // have to remove them from the geometry.
          const faceIndicesToRemove = [];

          for (let i = 0, il = this.faces.length; i < il; i++) {

              const face = this.faces[i];

              face.a = changes[face.a];
              face.b = changes[face.b];
              face.c = changes[face.c];

              const indices = [face.a, face.b, face.c];

              // if any duplicate vertices are found in a Face3
              // we have to remove the face as nothing can be saved
              for (let n = 0; n < 3; n++) {

                  if (indices[n] === indices[(n + 1) % 3]) {

                      faceIndicesToRemove.push(i);
                      break;

                  }

              }

          }

          for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {

              const idx = faceIndicesToRemove[i];

              this.faces.splice(idx, 1);

              for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {

                  this.faceVertexUvs[j].splice(idx, 1);

              }

          }

          // Use unique set of vertices

          const diff = this.vertices.length - unique.length;
          this.vertices = unique;
          return diff;

      },

      setFromPoints: function(points) {

          this.vertices = [];

          for (let i = 0, l = points.length; i < l; i++) {

              const point = points[i];
              this.vertices.push(new Vector3(point.x, point.y, point.z || 0));

          }

          return this;

      },

      sortFacesByMaterialIndex: function() {

          const faces = this.faces;
          const length = faces.length;

          // tag faces

          for (let i = 0; i < length; i++) {

              faces[i]._id = i;

          }

          // sort faces

          function materialIndexSort(a, b) {

              return a.materialIndex - b.materialIndex;

          }

          faces.sort(materialIndexSort);

          // sort uvs

          const uvs1 = this.faceVertexUvs[0];
          const uvs2 = this.faceVertexUvs[1];

          let newUvs1, newUvs2;

          if (uvs1 && uvs1.length === length) newUvs1 = [];
          if (uvs2 && uvs2.length === length) newUvs2 = [];

          for (let i = 0; i < length; i++) {

              const id = faces[i]._id;

              if (newUvs1) newUvs1.push(uvs1[id]);
              if (newUvs2) newUvs2.push(uvs2[id]);

          }

          if (newUvs1) this.faceVertexUvs[0] = newUvs1;
          if (newUvs2) this.faceVertexUvs[1] = newUvs2;

      },

      toJSON: function() {

          const data = {
              metadata: {
                  version: 4.5,
                  type: 'Geometry',
                  generator: 'Geometry.toJSON'
              }
          };

          // standard Geometry serialization

          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== '') data.name = this.name;

          if (this.parameters !== undefined) {

              const parameters = this.parameters;

              for (const key in parameters) {

                  if (parameters[key] !== undefined) data[key] = parameters[key];

              }

              return data;

          }

          const vertices = [];

          for (let i = 0; i < this.vertices.length; i++) {

              const vertex = this.vertices[i];
              vertices.push(vertex.x, vertex.y, vertex.z);

          }

          const faces = [];
          const normals = [];
          const normalsHash = {};
          const colors = [];
          const colorsHash = {};
          const uvs = [];
          const uvsHash = {};

          for (let i = 0; i < this.faces.length; i++) {

              const face = this.faces[i];

              const hasMaterial = true;
              const hasFaceUv = false; // deprecated
              const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
              const hasFaceNormal = face.normal.length() > 0;
              const hasFaceVertexNormal = face.vertexNormals.length > 0;
              const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
              const hasFaceVertexColor = face.vertexColors.length > 0;

              let faceType = 0;

              faceType = setBit(faceType, 0, 0); // isQuad
              faceType = setBit(faceType, 1, hasMaterial);
              faceType = setBit(faceType, 2, hasFaceUv);
              faceType = setBit(faceType, 3, hasFaceVertexUv);
              faceType = setBit(faceType, 4, hasFaceNormal);
              faceType = setBit(faceType, 5, hasFaceVertexNormal);
              faceType = setBit(faceType, 6, hasFaceColor);
              faceType = setBit(faceType, 7, hasFaceVertexColor);

              faces.push(faceType);
              faces.push(face.a, face.b, face.c);
              faces.push(face.materialIndex);

              if (hasFaceVertexUv) {

                  const faceVertexUvs = this.faceVertexUvs[0][i];

                  faces.push(
                      getUvIndex(faceVertexUvs[0]),
                      getUvIndex(faceVertexUvs[1]),
                      getUvIndex(faceVertexUvs[2])
                  );

              }

              if (hasFaceNormal) {

                  faces.push(getNormalIndex(face.normal));

              }

              if (hasFaceVertexNormal) {

                  const vertexNormals = face.vertexNormals;

                  faces.push(
                      getNormalIndex(vertexNormals[0]),
                      getNormalIndex(vertexNormals[1]),
                      getNormalIndex(vertexNormals[2])
                  );

              }

              if (hasFaceColor) {

                  faces.push(getColorIndex(face.color));

              }

              if (hasFaceVertexColor) {

                  const vertexColors = face.vertexColors;

                  faces.push(
                      getColorIndex(vertexColors[0]),
                      getColorIndex(vertexColors[1]),
                      getColorIndex(vertexColors[2])
                  );

              }

          }

          function setBit(value, position, enabled) {

              return enabled ? value | (1 << position) : value & (~(1 << position));

          }

          function getNormalIndex(normal) {

              const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

              if (normalsHash[hash] !== undefined) {

                  return normalsHash[hash];

              }

              normalsHash[hash] = normals.length / 3;
              normals.push(normal.x, normal.y, normal.z);

              return normalsHash[hash];

          }

          function getColorIndex(color) {

              const hash = color.r.toString() + color.g.toString() + color.b.toString();

              if (colorsHash[hash] !== undefined) {

                  return colorsHash[hash];

              }

              colorsHash[hash] = colors.length;
              colors.push(color.getHex());

              return colorsHash[hash];

          }

          function getUvIndex(uv) {

              const hash = uv.x.toString() + uv.y.toString();

              if (uvsHash[hash] !== undefined) {

                  return uvsHash[hash];

              }

              uvsHash[hash] = uvs.length / 2;
              uvs.push(uv.x, uv.y);

              return uvsHash[hash];

          }

          data.data = {};

          data.data.vertices = vertices;
          data.data.normals = normals;
          if (colors.length > 0) data.data.colors = colors;
          if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility
          data.data.faces = faces;

          return data;

      },

      clone: function() {

          /*
           // Handle primitives

           const parameters = this.parameters;

           if ( parameters !== undefined ) {

           const values = [];

           for ( const key in parameters ) {

           values.push( parameters[ key ] );

           }

           const geometry = Object.create( this.constructor.prototype );
           this.constructor.apply( geometry, values );
           return geometry;

           }

           return new this.constructor().copy( this );
           */

          return new Geometry().copy(this);

      },

      copy: function(source) {

          // reset

          this.vertices = [];
          this.colors = [];
          this.faces = [];
          this.faceVertexUvs = [
              []
          ];
          this.morphTargets = [];
          this.morphNormals = [];
          this.skinWeights = [];
          this.skinIndices = [];
          this.lineDistances = [];
          this.boundingBox = null;
          this.boundingSphere = null;

          // name

          this.name = source.name;

          // vertices

          const vertices = source.vertices;

          for (let i = 0, il = vertices.length; i < il; i++) {

              this.vertices.push(vertices[i].clone());

          }

          // colors

          const colors = source.colors;

          for (let i = 0, il = colors.length; i < il; i++) {

              this.colors.push(colors[i].clone());

          }

          // faces

          const faces = source.faces;

          for (let i = 0, il = faces.length; i < il; i++) {

              this.faces.push(faces[i].clone());

          }

          // face vertex uvs

          for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {

              const faceVertexUvs = source.faceVertexUvs[i];

              if (this.faceVertexUvs[i] === undefined) {

                  this.faceVertexUvs[i] = [];

              }

              for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {

                  const uvs = faceVertexUvs[j],
                      uvsCopy = [];

                  for (let k = 0, kl = uvs.length; k < kl; k++) {

                      const uv = uvs[k];

                      uvsCopy.push(uv.clone());

                  }

                  this.faceVertexUvs[i].push(uvsCopy);

              }

          }

          // morph targets

          const morphTargets = source.morphTargets;

          for (let i = 0, il = morphTargets.length; i < il; i++) {

              const morphTarget = {};
              morphTarget.name = morphTargets[i].name;

              // vertices

              if (morphTargets[i].vertices !== undefined) {

                  morphTarget.vertices = [];

                  for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {

                      morphTarget.vertices.push(morphTargets[i].vertices[j].clone());

                  }

              }

              // normals

              if (morphTargets[i].normals !== undefined) {

                  morphTarget.normals = [];

                  for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {

                      morphTarget.normals.push(morphTargets[i].normals[j].clone());

                  }

              }

              this.morphTargets.push(morphTarget);

          }

          // morph normals

          const morphNormals = source.morphNormals;

          for (let i = 0, il = morphNormals.length; i < il; i++) {

              const morphNormal = {};

              // vertex normals

              if (morphNormals[i].vertexNormals !== undefined) {

                  morphNormal.vertexNormals = [];

                  for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {

                      const srcVertexNormal = morphNormals[i].vertexNormals[j];
                      const destVertexNormal = {};

                      destVertexNormal.a = srcVertexNormal.a.clone();
                      destVertexNormal.b = srcVertexNormal.b.clone();
                      destVertexNormal.c = srcVertexNormal.c.clone();

                      morphNormal.vertexNormals.push(destVertexNormal);

                  }

              }

              // face normals

              if (morphNormals[i].faceNormals !== undefined) {

                  morphNormal.faceNormals = [];

                  for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {

                      morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());

                  }

              }

              this.morphNormals.push(morphNormal);

          }

          // skin weights

          const skinWeights = source.skinWeights;

          for (let i = 0, il = skinWeights.length; i < il; i++) {

              this.skinWeights.push(skinWeights[i].clone());

          }

          // skin indices

          const skinIndices = source.skinIndices;

          for (let i = 0, il = skinIndices.length; i < il; i++) {

              this.skinIndices.push(skinIndices[i].clone());

          }

          // line distances

          const lineDistances = source.lineDistances;

          for (let i = 0, il = lineDistances.length; i < il; i++) {

              this.lineDistances.push(lineDistances[i]);

          }

          // bounding box

          const boundingBox = source.boundingBox;

          if (boundingBox !== null) {

              this.boundingBox = boundingBox.clone();

          }

          // bounding sphere

          const boundingSphere = source.boundingSphere;

          if (boundingSphere !== null) {

              this.boundingSphere = boundingSphere.clone();

          }

          // update flags

          this.elementsNeedUpdate = source.elementsNeedUpdate;
          this.verticesNeedUpdate = source.verticesNeedUpdate;
          this.uvsNeedUpdate = source.uvsNeedUpdate;
          this.normalsNeedUpdate = source.normalsNeedUpdate;
          this.colorsNeedUpdate = source.colorsNeedUpdate;
          this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
          this.groupsNeedUpdate = source.groupsNeedUpdate;

          return this;

      },

      dispose: function() {

          this.dispatchEvent({ type: 'dispose' });

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // BoxGeometry

  class BoxGeometry extends Geometry {

      constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {

          super();

          this.type = 'BoxGeometry';

          this.parameters = {
              width: width,
              height: height,
              depth: depth,
              widthSegments: widthSegments,
              heightSegments: heightSegments,
              depthSegments: depthSegments
          };

          this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
          this.mergeVertices();

      }

  }

  // BoxBufferGeometry

  class BoxBufferGeometry extends BufferGeometry {

      constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {

          super();

          this.type = 'BoxBufferGeometry';

          this.parameters = {
              width: width,
              height: height,
              depth: depth,
              widthSegments: widthSegments,
              heightSegments: heightSegments,
              depthSegments: depthSegments
          };

          const scope = this;

          width = width || 1;
          height = height || 1;
          depth = depth || 1;

          // segments

          widthSegments = Math.floor(widthSegments) || 1;
          heightSegments = Math.floor(heightSegments) || 1;
          depthSegments = Math.floor(depthSegments) || 1;

          // buffers

          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];

          // helper variables

          let numberOfVertices = 0;
          let groupStart = 0;

          // build each side of the box geometry

          buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
          buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
          buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
          buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
          buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
          buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

          // build geometry

          this.setIndex(indices);
          this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
          this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
          this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

          function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {

              const segmentWidth = width / gridX;
              const segmentHeight = height / gridY;

              const widthHalf = width / 2;
              const heightHalf = height / 2;
              const depthHalf = depth / 2;

              const gridX1 = gridX + 1;
              const gridY1 = gridY + 1;

              let vertexCounter = 0;
              let groupCount = 0;

              const vector = new Vector3();

              // generate vertices, normals and uvs

              for (let iy = 0; iy < gridY1; iy++) {

                  const y = iy * segmentHeight - heightHalf;

                  for (let ix = 0; ix < gridX1; ix++) {

                      const x = ix * segmentWidth - widthHalf;

                      // set values to correct vector component

                      vector[u] = x * udir;
                      vector[v] = y * vdir;
                      vector[w] = depthHalf;

                      // now apply vector to vertex buffer

                      vertices.push(vector.x, vector.y, vector.z);

                      // set values to correct vector component

                      vector[u] = 0;
                      vector[v] = 0;
                      vector[w] = depth > 0 ? 1 : -1;

                      // now apply vector to normal buffer

                      normals.push(vector.x, vector.y, vector.z);

                      // uvs

                      uvs.push(ix / gridX);
                      uvs.push(1 - (iy / gridY));

                      // counters

                      vertexCounter += 1;

                  }

              }

              // indices

              // 1. you need three indices to draw a single face
              // 2. a single segment consists of two faces
              // 3. so we need to generate six (2*3) indices per segment

              for (let iy = 0; iy < gridY; iy++) {

                  for (let ix = 0; ix < gridX; ix++) {

                      const a = numberOfVertices + ix + gridX1 * iy;
                      const b = numberOfVertices + ix + gridX1 * (iy + 1);
                      const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                      const d = numberOfVertices + (ix + 1) + gridX1 * iy;

                      // faces

                      indices.push(a, b, d);
                      indices.push(b, c, d);

                      // increase counter

                      groupCount += 6;

                  }

              }

              // add a group to the geometry. this will ensure multi material support

              scope.addGroup(groupStart, groupCount, materialIndex);

              // calculate new start value for groups

              groupStart += groupCount;

              // update total number of vertices

              numberOfVertices += vertexCounter;

          }

      }

  }

  /**
   * Uniform Utilities
   */

  function cloneUniforms(src) {

      const dst = {};

      for (const u in src) {

          dst[u] = {};

          for (const p in src[u]) {

              const property = src[u][p];

              if (property && (property.isColor ||
                      property.isMatrix3 || property.isMatrix4 ||
                      property.isVector2 || property.isVector3 || property.isVector4 ||
                      property.isTexture)) {

                  dst[u][p] = property.clone();

              } else if (Array.isArray(property)) {

                  dst[u][p] = property.slice();

              } else {

                  dst[u][p] = property;

              }

          }

      }

      return dst;

  }

  function mergeUniforms(uniforms) {

      const merged = {};

      for (let u = 0; u < uniforms.length; u++) {

          const tmp = cloneUniforms(uniforms[u]);

          for (const p in tmp) {

              merged[p] = tmp[p];

          }

      }

      return merged;

  }

  // Legacy

  const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

  var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

  var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function ShaderMaterial(parameters) {

      Material.call(this);

      this.type = 'ShaderMaterial';

      this.defines = {};
      this.uniforms = {};

      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;

      this.linewidth = 1;

      this.wireframe = false;
      this.wireframeLinewidth = 1;

      this.fog = false; // set to use scene fog
      this.lights = false; // set to use scene lights
      this.clipping = false; // set to use user-defined clipping planes

      this.skinning = false; // set to use skinning attribute streams
      this.morphTargets = false; // set to use morph targets
      this.morphNormals = false; // set to use morph normals

      this.extensions = {
          derivatives: false, // set to use derivatives
          fragDepth: false, // set to use fragment depth values
          drawBuffers: false, // set to use draw buffers
          shaderTextureLOD: false // set to use shader texture LOD
      };

      // When rendered geometry doesn't include these attributes but the material does,
      // use these default values in WebGL. This avoids errors when buffer data is missing.
      this.defaultAttributeValues = {
          'color': [1, 1, 1],
          'uv': [0, 0],
          'uv2': [0, 0]
      };

      this.index0AttributeName = undefined;
      this.uniformsNeedUpdate = false;

      if (parameters !== undefined) {

          if (parameters.attributes !== undefined) {

              console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');

          }

          this.setValues(parameters);

      }

  }

  ShaderMaterial.prototype = Object.create(Material.prototype);
  ShaderMaterial.prototype.constructor = ShaderMaterial;

  ShaderMaterial.prototype.isShaderMaterial = true;

  ShaderMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;

      this.uniforms = cloneUniforms(source.uniforms);

      this.defines = Object.assign({}, source.defines);

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;

      this.lights = source.lights;
      this.clipping = source.clipping;

      this.skinning = source.skinning;

      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;

      this.extensions = Object.assign({}, source.extensions);

      return this;

  };

  ShaderMaterial.prototype.toJSON = function(meta) {

      const data = Material.prototype.toJSON.call(this, meta);

      data.uniforms = {};

      for (const name in this.uniforms) {

          const uniform = this.uniforms[name];
          const value = uniform.value;

          if (value && value.isTexture) {

              data.uniforms[name] = {
                  type: 't',
                  value: value.toJSON(meta).uuid
              };

          } else if (value && value.isColor) {

              data.uniforms[name] = {
                  type: 'c',
                  value: value.getHex()
              };

          } else if (value && value.isVector2) {

              data.uniforms[name] = {
                  type: 'v2',
                  value: value.toArray()
              };

          } else if (value && value.isVector3) {

              data.uniforms[name] = {
                  type: 'v3',
                  value: value.toArray()
              };

          } else if (value && value.isVector4) {

              data.uniforms[name] = {
                  type: 'v4',
                  value: value.toArray()
              };

          } else if (value && value.isMatrix3) {

              data.uniforms[name] = {
                  type: 'm3',
                  value: value.toArray()
              };

          } else if (value && value.isMatrix4) {

              data.uniforms[name] = {
                  type: 'm4',
                  value: value.toArray()
              };

          } else {

              data.uniforms[name] = {
                  value: value
              };

              // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

          }

      }

      if (Object.keys(this.defines).length > 0) data.defines = this.defines;

      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;

      const extensions = {};

      for (const key in this.extensions) {

          if (this.extensions[key] === true) extensions[key] = true;

      }

      if (Object.keys(extensions).length > 0) data.extensions = extensions;

      return data;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Camera() {

      Object3D.call(this);

      this.type = 'Camera';

      this.matrixWorldInverse = new Matrix4();

      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();

  }

  Camera.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Camera,

      isCamera: true,

      copy: function(source, recursive) {

          Object3D.prototype.copy.call(this, source, recursive);

          this.matrixWorldInverse.copy(source.matrixWorldInverse);

          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);

          return this;

      },

      getWorldDirection: function(target) {

          if (target === undefined) {

              console.warn('THREE.Camera: .getWorldDirection() target is now required');
              target = new Vector3();

          }

          this.updateMatrixWorld(true);

          const e = this.matrixWorld.elements;

          return target.set(-e[8], -e[9], -e[10]).normalize();

      },

      updateMatrixWorld: function(force) {

          Object3D.prototype.updateMatrixWorld.call(this, force);

          this.matrixWorldInverse.getInverse(this.matrixWorld);

      },

      updateWorldMatrix: function(updateParents, updateChildren) {

          Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);

          this.matrixWorldInverse.getInverse(this.matrixWorld);

      },

      clone: function() {

          return new this.constructor().copy(this);

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author greggman / http://games.greggman.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author tschw
   */

  function PerspectiveCamera(fov, aspect, near, far) {

      Camera.call(this);

      this.type = 'PerspectiveCamera';

      this.fov = fov !== undefined ? fov : 50;
      this.zoom = 1;

      this.near = near !== undefined ? near : 0.1;
      this.far = far !== undefined ? far : 2000;
      this.focus = 10;

      this.aspect = aspect !== undefined ? aspect : 1;
      this.view = null;

      this.filmGauge = 35; // width of the film (default in millimeters)
      this.filmOffset = 0; // horizontal film offset (same unit as gauge)

      this.updateProjectionMatrix();

  }

  PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {

      constructor: PerspectiveCamera,

      isPerspectiveCamera: true,

      copy: function(source, recursive) {

          Camera.prototype.copy.call(this, source, recursive);

          this.fov = source.fov;
          this.zoom = source.zoom;

          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;

          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);

          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;

          return this;

      },

      /**
       * Sets the FOV by focal length in respect to the current .filmGauge.
       *
       * The default film gauge is 35, so that the focal length can be specified for
       * a 35mm (full frame) camera.
       *
       * Values for focal length and film gauge must have the same unit.
       */
      setFocalLength: function(focalLength) {

          // see http://www.bobatkins.com/photography/technical/field_of_view.html
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

          this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();

      },

      /**
       * Calculates the focal length from the current .fov and .filmGauge.
       */
      getFocalLength: function() {

          const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);

          return 0.5 * this.getFilmHeight() / vExtentSlope;

      },

      getEffectiveFOV: function() {

          return MathUtils.RAD2DEG * 2 * Math.atan(
              Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);

      },

      getFilmWidth: function() {

          // film not completely covered in portrait format (aspect < 1)
          return this.filmGauge * Math.min(this.aspect, 1);

      },

      getFilmHeight: function() {

          // film not completely covered in landscape format (aspect > 1)
          return this.filmGauge / Math.max(this.aspect, 1);

      },

      /**
       * Sets an offset in a larger frustum. This is useful for multi-window or
       * multi-monitor/multi-machine setups.
       *
       * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
       * the monitors are in grid like this
       *
       *   +---+---+---+
       *   | A | B | C |
       *   +---+---+---+
       *   | D | E | F |
       *   +---+---+---+
       *
       * then for each monitor you would call it like this
       *
       *   const w = 1920;
       *   const h = 1080;
       *   const fullWidth = w * 3;
       *   const fullHeight = h * 2;
       *
       *   --A--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
       *   --B--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
       *   --C--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
       *   --D--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
       *   --E--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
       *   --F--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
       *
       *   Note there is no reason monitors have to be the same size or in a grid.
       */
      setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {

          this.aspect = fullWidth / fullHeight;

          if (this.view === null) {

              this.view = {
                  enabled: true,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1
              };

          }

          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;

          this.updateProjectionMatrix();

      },

      clearViewOffset: function() {

          if (this.view !== null) {

              this.view.enabled = false;

          }

          this.updateProjectionMatrix();

      },

      updateProjectionMatrix: function() {

          let near = this.near,
              top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom,
              height = 2 * top,
              width = this.aspect * height,
              left = -0.5 * width,
              view = this.view;

          if (this.view !== null && this.view.enabled) {

              const fullWidth = view.fullWidth,
                  fullHeight = view.fullHeight;

              left += view.offsetX * width / fullWidth;
              top -= view.offsetY * height / fullHeight;
              width *= view.width / fullWidth;
              height *= view.height / fullHeight;

          }

          const skew = this.filmOffset;
          if (skew !== 0) left += near * skew / this.getFilmWidth();

          this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);

          this.projectionMatrixInverse.getInverse(this.projectionMatrix);

      },

      toJSON: function(meta) {

          const data = Object3D.prototype.toJSON.call(this, meta);

          data.object.fov = this.fov;
          data.object.zoom = this.zoom;

          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;

          data.object.aspect = this.aspect;

          if (this.view !== null) data.object.view = Object.assign({}, this.view);

          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;

          return data;

      }

  });

  /**
   * Camera for rendering cube maps
   *	- renders scene into axis-aligned cube
   *
   * @author alteredq / http://alteredqualia.com/
   */

  const fov = 90,
      aspect = 1;

  function CubeCamera(near, far, renderTarget) {

      Object3D.call(this);

      this.type = 'CubeCamera';

      if (renderTarget.isWebGLCubeRenderTarget !== true) {

          console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
          return;

      }

      this.renderTarget = renderTarget;

      const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = this.layers;
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new Vector3(1, 0, 0));
      this.add(cameraPX);

      const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = this.layers;
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new Vector3(-1, 0, 0));
      this.add(cameraNX);

      const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = this.layers;
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new Vector3(0, 1, 0));
      this.add(cameraPY);

      const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = this.layers;
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new Vector3(0, -1, 0));
      this.add(cameraNY);

      const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = this.layers;
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new Vector3(0, 0, 1));
      this.add(cameraPZ);

      const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = this.layers;
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new Vector3(0, 0, -1));
      this.add(cameraNZ);

      this.update = function(renderer, scene) {

          if (this.parent === null) this.updateMatrixWorld();

          const currentXrEnabled = renderer.xr.enabled;
          const currentRenderTarget = renderer.getRenderTarget();

          renderer.xr.enabled = false;

          const generateMipmaps = renderTarget.texture.generateMipmaps;

          renderTarget.texture.generateMipmaps = false;

          renderer.setRenderTarget(renderTarget, 0);
          renderer.render(scene, cameraPX);

          renderer.setRenderTarget(renderTarget, 1);
          renderer.render(scene, cameraNX);

          renderer.setRenderTarget(renderTarget, 2);
          renderer.render(scene, cameraPY);

          renderer.setRenderTarget(renderTarget, 3);
          renderer.render(scene, cameraNY);

          renderer.setRenderTarget(renderTarget, 4);
          renderer.render(scene, cameraPZ);

          renderTarget.texture.generateMipmaps = generateMipmaps;

          renderer.setRenderTarget(renderTarget, 5);
          renderer.render(scene, cameraNZ);

          renderer.setRenderTarget(currentRenderTarget);

          renderer.xr.enabled = currentXrEnabled;

      };

      this.clear = function(renderer, color, depth, stencil) {

          const currentRenderTarget = renderer.getRenderTarget();

          for (let i = 0; i < 6; i++) {

              renderer.setRenderTarget(renderTarget, i);

              renderer.clear(color, depth, stencil);

          }

          renderer.setRenderTarget(currentRenderTarget);

      };

  }

  CubeCamera.prototype = Object.create(Object3D.prototype);
  CubeCamera.prototype.constructor = CubeCamera;

  /**
   * @author alteredq / http://alteredqualia.com
   * @author WestLangley / http://github.com/WestLangley
   */

  function WebGLCubeRenderTarget(size, options, dummy) {

      if (Number.isInteger(options)) {

          console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');

          options = dummy;

      }

      WebGLRenderTarget.call(this, size, size, options);

  }

  WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
  WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;

  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

  WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(renderer, texture) {

      this.texture.type = texture.type;
      this.texture.format = texture.format;
      this.texture.encoding = texture.encoding;

      const scene = new Scene();

      const shader = {

          uniforms: {
              tEquirect: { value: null },
          },

          vertexShader: [

              "varying vec3 vWorldDirection;",

              "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",

              "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",

              "}",

              "void main() {",

              "	vWorldDirection = transformDirection( position, modelMatrix );",

              "	#include <begin_vertex>",
              "	#include <project_vertex>",

              "}"

          ].join('\n'),

          fragmentShader: [

              "uniform sampler2D tEquirect;",

              "varying vec3 vWorldDirection;",

              "#include <common>",

              "void main() {",

              "	vec3 direction = normalize( vWorldDirection );",

              "	vec2 sampleUV = equirectUv( direction );",

              "	gl_FragColor = texture2D( tEquirect, sampleUV );",

              "}"

          ].join('\n'),
      };

      const material = new ShaderMaterial({

          name: 'CubemapFromEquirect',

          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: BackSide,
          blending: NoBlending

      });

      material.uniforms.tEquirect.value = texture;

      const mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);

      scene.add(mesh);

      const camera = new CubeCamera(1, 10, this);
      camera.update(renderer, scene);

      mesh.geometry.dispose();
      mesh.material.dispose();

      return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

      Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

      this.image = { data: data || null, width: width || 1, height: height || 1 };

      this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
      this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;

      this.needsUpdate = true;

  }

  DataTexture.prototype = Object.create(Texture.prototype);
  DataTexture.prototype.constructor = DataTexture;

  DataTexture.prototype.isDataTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / http://clara.io
   */

  const _sphere$1 = new Sphere();
  const _vector$5 = new Vector3();

  function Frustum(p0, p1, p2, p3, p4, p5) {

      this.planes = [

          (p0 !== undefined) ? p0 : new Plane(),
          (p1 !== undefined) ? p1 : new Plane(),
          (p2 !== undefined) ? p2 : new Plane(),
          (p3 !== undefined) ? p3 : new Plane(),
          (p4 !== undefined) ? p4 : new Plane(),
          (p5 !== undefined) ? p5 : new Plane()

      ];

  }

  Object.assign(Frustum.prototype, {

      set: function(p0, p1, p2, p3, p4, p5) {

          const planes = this.planes;

          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p2);
          planes[3].copy(p3);
          planes[4].copy(p4);
          planes[5].copy(p5);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(frustum) {

          const planes = this.planes;

          for (let i = 0; i < 6; i++) {

              planes[i].copy(frustum.planes[i]);

          }

          return this;

      },

      setFromProjectionMatrix: function(m) {

          const planes = this.planes;
          const me = m.elements;
          const me0 = me[0],
              me1 = me[1],
              me2 = me[2],
              me3 = me[3];
          const me4 = me[4],
              me5 = me[5],
              me6 = me[6],
              me7 = me[7];
          const me8 = me[8],
              me9 = me[9],
              me10 = me[10],
              me11 = me[11];
          const me12 = me[12],
              me13 = me[13],
              me14 = me[14],
              me15 = me[15];

          planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();

          return this;

      },

      intersectsObject: function(object) {

          const geometry = object.geometry;

          if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

          _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

          return this.intersectsSphere(_sphere$1);

      },

      intersectsSprite: function(sprite) {

          _sphere$1.center.set(0, 0, 0);
          _sphere$1.radius = 0.7071067811865476;
          _sphere$1.applyMatrix4(sprite.matrixWorld);

          return this.intersectsSphere(_sphere$1);

      },

      intersectsSphere: function(sphere) {

          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;

          for (let i = 0; i < 6; i++) {

              const distance = planes[i].distanceToPoint(center);

              if (distance < negRadius) {

                  return false;

              }

          }

          return true;

      },

      intersectsBox: function(box) {

          const planes = this.planes;

          for (let i = 0; i < 6; i++) {

              const plane = planes[i];

              // corner at max distance

              _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
              _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
              _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

              if (plane.distanceToPoint(_vector$5) < 0) {

                  return false;

              }

          }

          return true;

      },

      containsPoint: function(point) {

          const planes = this.planes;

          for (let i = 0; i < 6; i++) {

              if (planes[i].distanceToPoint(point) < 0) {

                  return false;

              }

          }

          return true;

      }

  });

  /**
   * Uniforms library for shared webgl shaders
   */

  const UniformsLib = {

      common: {

          diffuse: { value: new Color(0xeeeeee) },
          opacity: { value: 1.0 },

          map: { value: null },
          uvTransform: { value: new Matrix3() },
          uv2Transform: { value: new Matrix3() },

          alphaMap: { value: null },

      },

      specularmap: {

          specularMap: { value: null },

      },

      envmap: {

          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1.0 },
          refractionRatio: { value: 0.98 },
          maxMipLevel: { value: 0 }

      },

      aomap: {

          aoMap: { value: null },
          aoMapIntensity: { value: 1 }

      },

      lightmap: {

          lightMap: { value: null },
          lightMapIntensity: { value: 1 }

      },

      emissivemap: {

          emissiveMap: { value: null }

      },

      bumpmap: {

          bumpMap: { value: null },
          bumpScale: { value: 1 }

      },

      normalmap: {

          normalMap: { value: null },
          normalScale: { value: new Vector2(1, 1) }

      },

      displacementmap: {

          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 }

      },

      roughnessmap: {

          roughnessMap: { value: null }

      },

      metalnessmap: {

          metalnessMap: { value: null }

      },

      gradientmap: {

          gradientMap: { value: null }

      },

      fog: {

          fogDensity: { value: 0.00025 },
          fogNear: { value: 1 },
          fogFar: { value: 2000 },
          fogColor: { value: new Color(0xffffff) }

      },

      lights: {

          ambientLightColor: { value: [] },

          lightProbe: { value: [] },

          directionalLights: {
              value: [],
              properties: {
                  direction: {},
                  color: {}
              }
          },

          directionalLightShadows: {
              value: [],
              properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
              }
          },

          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },

          spotLights: {
              value: [],
              properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {}
              }
          },

          spotLightShadows: {
              value: [],
              properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
              }
          },

          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },

          pointLights: {
              value: [],
              properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {}
              }
          },

          pointLightShadows: {
              value: [],
              properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {}
              }
          },

          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },

          hemisphereLights: {
              value: [],
              properties: {
                  direction: {},
                  skyColor: {},
                  groundColor: {}
              }
          },

          // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
          rectAreaLights: {
              value: [],
              properties: {
                  color: {},
                  position: {},
                  width: {},
                  height: {}
              }
          }

      },

      points: {

          diffuse: { value: new Color(0xeeeeee) },
          opacity: { value: 1.0 },
          size: { value: 1.0 },
          scale: { value: 1.0 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new Matrix3() }

      },

      sprite: {

          diffuse: { value: new Color(0xeeeeee) },
          opacity: { value: 1.0 },
          center: { value: new Vector2(0.5, 0.5) },
          rotation: { value: 0.0 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new Matrix3() }

      }

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLAnimation() {

      let context = null;
      let isAnimating = false;
      let animationLoop = null;
      let requestId = null;

      function onAnimationFrame(time, frame) {

          animationLoop(time, frame);

          requestId = context.requestAnimationFrame(onAnimationFrame);

      }

      return {

          start: function() {

              if (isAnimating === true) return;
              if (animationLoop === null) return;

              requestId = context.requestAnimationFrame(onAnimationFrame);

              isAnimating = true;

          },

          stop: function() {

              context.cancelAnimationFrame(requestId);

              isAnimating = false;

          },

          setAnimationLoop: function(callback) {

              animationLoop = callback;

          },

          setContext: function(value) {

              context = value;

          }

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLAttributes(gl, capabilities) {

      const isWebGL2 = capabilities.isWebGL2;

      const buffers = new WeakMap();

      function createBuffer(attribute, bufferType) {

          const array = attribute.array;
          const usage = attribute.usage;

          const buffer = gl.createBuffer();

          gl.bindBuffer(bufferType, buffer);
          gl.bufferData(bufferType, array, usage);

          attribute.onUploadCallback();

          let type = 5126;

          if (array instanceof Float32Array) {

              type = 5126;

          } else if (array instanceof Float64Array) {

              console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');

          } else if (array instanceof Uint16Array) {

              type = 5123;

          } else if (array instanceof Int16Array) {

              type = 5122;

          } else if (array instanceof Uint32Array) {

              type = 5125;

          } else if (array instanceof Int32Array) {

              type = 5124;

          } else if (array instanceof Int8Array) {

              type = 5120;

          } else if (array instanceof Uint8Array) {

              type = 5121;

          }

          return {
              buffer: buffer,
              type: type,
              bytesPerElement: array.BYTES_PER_ELEMENT,
              version: attribute.version
          };

      }

      function updateBuffer(buffer, attribute, bufferType) {

          const array = attribute.array;
          const updateRange = attribute.updateRange;

          gl.bindBuffer(bufferType, buffer);

          if (updateRange.count === -1) {

              // Not using update ranges

              gl.bufferSubData(bufferType, 0, array);

          } else {

              if (isWebGL2) {

                  gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
                      array, updateRange.offset, updateRange.count);

              } else {

                  gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
                      array.subarray(updateRange.offset, updateRange.offset + updateRange.count));

              }

              updateRange.count = -1; // reset range

          }

      }

      //

      function get(attribute) {

          if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

          return buffers.get(attribute);

      }

      function remove(attribute) {

          if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

          const data = buffers.get(attribute);

          if (data) {

              gl.deleteBuffer(data.buffer);

              buffers.delete(attribute);

          }

      }

      function update(attribute, bufferType) {

          if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

          const data = buffers.get(attribute);

          if (data === undefined) {

              buffers.set(attribute, createBuffer(attribute, bufferType));

          } else if (data.version < attribute.version) {

              updateBuffer(data.buffer, attribute, bufferType);

              data.version = attribute.version;

          }

      }

      return {

          get: get,
          remove: remove,
          update: update

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PlaneGeometry

  function PlaneGeometry(width, height, widthSegments, heightSegments) {

      Geometry.call(this);

      this.type = 'PlaneGeometry';

      this.parameters = {
          width: width,
          height: height,
          widthSegments: widthSegments,
          heightSegments: heightSegments
      };

      this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
      this.mergeVertices();

  }

  PlaneGeometry.prototype = Object.create(Geometry.prototype);
  PlaneGeometry.prototype.constructor = PlaneGeometry;

  // PlaneBufferGeometry

  function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {

      BufferGeometry.call(this);

      this.type = 'PlaneBufferGeometry';

      this.parameters = {
          width: width,
          height: height,
          widthSegments: widthSegments,
          heightSegments: heightSegments
      };

      width = width || 1;
      height = height || 1;

      const width_half = width / 2;
      const height_half = height / 2;

      const gridX = Math.floor(widthSegments) || 1;
      const gridY = Math.floor(heightSegments) || 1;

      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;

      const segment_width = width / gridX;
      const segment_height = height / gridY;

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // generate vertices, normals and uvs

      for (let iy = 0; iy < gridY1; iy++) {

          const y = iy * segment_height - height_half;

          for (let ix = 0; ix < gridX1; ix++) {

              const x = ix * segment_width - width_half;

              vertices.push(x, -y, 0);

              normals.push(0, 0, 1);

              uvs.push(ix / gridX);
              uvs.push(1 - (iy / gridY));

          }

      }

      // indices

      for (let iy = 0; iy < gridY; iy++) {

          for (let ix = 0; ix < gridX; ix++) {

              const a = ix + gridX1 * iy;
              const b = ix + gridX1 * (iy + 1);
              const c = (ix + 1) + gridX1 * (iy + 1);
              const d = (ix + 1) + gridX1 * iy;

              // faces

              indices.push(a, b, d);
              indices.push(b, c, d);

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

  }

  PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

  var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

  var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  var begin_vertex = "vec3 transformed = vec3( position );";

  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

  var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

  var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

  var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

  var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

  var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";

  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

  var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

  var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

  var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

  var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

  var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

  var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

  var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

  var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

  var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";

  var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";

  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

  var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

  var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

  var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

  var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

  var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

  var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

  var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

  var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

  var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

  var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

  var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

  var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  const ShaderChunk = {
      alphamap_fragment: alphamap_fragment,
      alphamap_pars_fragment: alphamap_pars_fragment,
      alphatest_fragment: alphatest_fragment,
      aomap_fragment: aomap_fragment,
      aomap_pars_fragment: aomap_pars_fragment,
      begin_vertex: begin_vertex,
      beginnormal_vertex: beginnormal_vertex,
      bsdfs: bsdfs,
      bumpmap_pars_fragment: bumpmap_pars_fragment,
      clipping_planes_fragment: clipping_planes_fragment,
      clipping_planes_pars_fragment: clipping_planes_pars_fragment,
      clipping_planes_pars_vertex: clipping_planes_pars_vertex,
      clipping_planes_vertex: clipping_planes_vertex,
      color_fragment: color_fragment,
      color_pars_fragment: color_pars_fragment,
      color_pars_vertex: color_pars_vertex,
      color_vertex: color_vertex,
      common: common,
      cube_uv_reflection_fragment: cube_uv_reflection_fragment,
      defaultnormal_vertex: defaultnormal_vertex,
      displacementmap_pars_vertex: displacementmap_pars_vertex,
      displacementmap_vertex: displacementmap_vertex,
      emissivemap_fragment: emissivemap_fragment,
      emissivemap_pars_fragment: emissivemap_pars_fragment,
      encodings_fragment: encodings_fragment,
      encodings_pars_fragment: encodings_pars_fragment,
      envmap_fragment: envmap_fragment,
      envmap_common_pars_fragment: envmap_common_pars_fragment,
      envmap_pars_fragment: envmap_pars_fragment,
      envmap_pars_vertex: envmap_pars_vertex,
      envmap_physical_pars_fragment: envmap_physical_pars_fragment,
      envmap_vertex: envmap_vertex,
      fog_vertex: fog_vertex,
      fog_pars_vertex: fog_pars_vertex,
      fog_fragment: fog_fragment,
      fog_pars_fragment: fog_pars_fragment,
      gradientmap_pars_fragment: gradientmap_pars_fragment,
      lightmap_fragment: lightmap_fragment,
      lightmap_pars_fragment: lightmap_pars_fragment,
      lights_lambert_vertex: lights_lambert_vertex,
      lights_pars_begin: lights_pars_begin,
      lights_toon_fragment: lights_toon_fragment,
      lights_toon_pars_fragment: lights_toon_pars_fragment,
      lights_phong_fragment: lights_phong_fragment,
      lights_phong_pars_fragment: lights_phong_pars_fragment,
      lights_physical_fragment: lights_physical_fragment,
      lights_physical_pars_fragment: lights_physical_pars_fragment,
      lights_fragment_begin: lights_fragment_begin,
      lights_fragment_maps: lights_fragment_maps,
      lights_fragment_end: lights_fragment_end,
      logdepthbuf_fragment: logdepthbuf_fragment,
      logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
      logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
      logdepthbuf_vertex: logdepthbuf_vertex,
      map_fragment: map_fragment,
      map_pars_fragment: map_pars_fragment,
      map_particle_fragment: map_particle_fragment,
      map_particle_pars_fragment: map_particle_pars_fragment,
      metalnessmap_fragment: metalnessmap_fragment,
      metalnessmap_pars_fragment: metalnessmap_pars_fragment,
      morphnormal_vertex: morphnormal_vertex,
      morphtarget_pars_vertex: morphtarget_pars_vertex,
      morphtarget_vertex: morphtarget_vertex,
      normal_fragment_begin: normal_fragment_begin,
      normal_fragment_maps: normal_fragment_maps,
      normalmap_pars_fragment: normalmap_pars_fragment,
      clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
      clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
      clearcoat_pars_fragment: clearcoat_pars_fragment,
      packing: packing,
      premultiplied_alpha_fragment: premultiplied_alpha_fragment,
      project_vertex: project_vertex,
      dithering_fragment: dithering_fragment,
      dithering_pars_fragment: dithering_pars_fragment,
      roughnessmap_fragment: roughnessmap_fragment,
      roughnessmap_pars_fragment: roughnessmap_pars_fragment,
      shadowmap_pars_fragment: shadowmap_pars_fragment,
      shadowmap_pars_vertex: shadowmap_pars_vertex,
      shadowmap_vertex: shadowmap_vertex,
      shadowmask_pars_fragment: shadowmask_pars_fragment,
      skinbase_vertex: skinbase_vertex,
      skinning_pars_vertex: skinning_pars_vertex,
      skinning_vertex: skinning_vertex,
      skinnormal_vertex: skinnormal_vertex,
      specularmap_fragment: specularmap_fragment,
      specularmap_pars_fragment: specularmap_pars_fragment,
      tonemapping_fragment: tonemapping_fragment,
      tonemapping_pars_fragment: tonemapping_pars_fragment,
      uv_pars_fragment: uv_pars_fragment,
      uv_pars_vertex: uv_pars_vertex,
      uv_vertex: uv_vertex,
      uv2_pars_fragment: uv2_pars_fragment,
      uv2_pars_vertex: uv2_pars_vertex,
      uv2_vertex: uv2_vertex,
      worldpos_vertex: worldpos_vertex,

      background_frag: background_frag,
      background_vert: background_vert,
      cube_frag: cube_frag,
      cube_vert: cube_vert,
      depth_frag: depth_frag,
      depth_vert: depth_vert,
      distanceRGBA_frag: distanceRGBA_frag,
      distanceRGBA_vert: distanceRGBA_vert,
      equirect_frag: equirect_frag,
      equirect_vert: equirect_vert,
      linedashed_frag: linedashed_frag,
      linedashed_vert: linedashed_vert,
      meshbasic_frag: meshbasic_frag,
      meshbasic_vert: meshbasic_vert,
      meshlambert_frag: meshlambert_frag,
      meshlambert_vert: meshlambert_vert,
      meshmatcap_frag: meshmatcap_frag,
      meshmatcap_vert: meshmatcap_vert,
      meshtoon_frag: meshtoon_frag,
      meshtoon_vert: meshtoon_vert,
      meshphong_frag: meshphong_frag,
      meshphong_vert: meshphong_vert,
      meshphysical_frag: meshphysical_frag,
      meshphysical_vert: meshphysical_vert,
      normal_frag: normal_frag,
      normal_vert: normal_vert,
      points_frag: points_frag,
      points_vert: points_vert,
      shadow_frag: shadow_frag,
      shadow_vert: shadow_vert,
      sprite_frag: sprite_frag,
      sprite_vert: sprite_vert
  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   */

  const ShaderLib = {

      basic: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.specularmap,
              UniformsLib.envmap,
              UniformsLib.aomap,
              UniformsLib.lightmap,
              UniformsLib.fog
          ]),

          vertexShader: ShaderChunk.meshbasic_vert,
          fragmentShader: ShaderChunk.meshbasic_frag

      },

      lambert: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.specularmap,
              UniformsLib.envmap,
              UniformsLib.aomap,
              UniformsLib.lightmap,
              UniformsLib.emissivemap,
              UniformsLib.fog,
              UniformsLib.lights,
              {
                  emissive: { value: new Color(0x000000) }
              }
          ]),

          vertexShader: ShaderChunk.meshlambert_vert,
          fragmentShader: ShaderChunk.meshlambert_frag

      },

      phong: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.specularmap,
              UniformsLib.envmap,
              UniformsLib.aomap,
              UniformsLib.lightmap,
              UniformsLib.emissivemap,
              UniformsLib.bumpmap,
              UniformsLib.normalmap,
              UniformsLib.displacementmap,
              UniformsLib.fog,
              UniformsLib.lights,
              {
                  emissive: { value: new Color(0x000000) },
                  specular: { value: new Color(0x111111) },
                  shininess: { value: 30 }
              }
          ]),

          vertexShader: ShaderChunk.meshphong_vert,
          fragmentShader: ShaderChunk.meshphong_frag

      },

      standard: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.envmap,
              UniformsLib.aomap,
              UniformsLib.lightmap,
              UniformsLib.emissivemap,
              UniformsLib.bumpmap,
              UniformsLib.normalmap,
              UniformsLib.displacementmap,
              UniformsLib.roughnessmap,
              UniformsLib.metalnessmap,
              UniformsLib.fog,
              UniformsLib.lights,
              {
                  emissive: { value: new Color(0x000000) },
                  roughness: { value: 1.0 },
                  metalness: { value: 0.0 },
                  envMapIntensity: { value: 1 } // temporary
              }
          ]),

          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag

      },

      toon: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.aomap,
              UniformsLib.lightmap,
              UniformsLib.emissivemap,
              UniformsLib.bumpmap,
              UniformsLib.normalmap,
              UniformsLib.displacementmap,
              UniformsLib.gradientmap,
              UniformsLib.fog,
              UniformsLib.lights,
              {
                  emissive: { value: new Color(0x000000) }
              }
          ]),

          vertexShader: ShaderChunk.meshtoon_vert,
          fragmentShader: ShaderChunk.meshtoon_frag

      },

      matcap: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.bumpmap,
              UniformsLib.normalmap,
              UniformsLib.displacementmap,
              UniformsLib.fog,
              {
                  matcap: { value: null }
              }
          ]),

          vertexShader: ShaderChunk.meshmatcap_vert,
          fragmentShader: ShaderChunk.meshmatcap_frag

      },

      points: {

          uniforms: mergeUniforms([
              UniformsLib.points,
              UniformsLib.fog
          ]),

          vertexShader: ShaderChunk.points_vert,
          fragmentShader: ShaderChunk.points_frag

      },

      dashed: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.fog,
              {
                  scale: { value: 1 },
                  dashSize: { value: 1 },
                  totalSize: { value: 2 }
              }
          ]),

          vertexShader: ShaderChunk.linedashed_vert,
          fragmentShader: ShaderChunk.linedashed_frag

      },

      depth: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.displacementmap
          ]),

          vertexShader: ShaderChunk.depth_vert,
          fragmentShader: ShaderChunk.depth_frag

      },

      normal: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.bumpmap,
              UniformsLib.normalmap,
              UniformsLib.displacementmap,
              {
                  opacity: { value: 1.0 }
              }
          ]),

          vertexShader: ShaderChunk.normal_vert,
          fragmentShader: ShaderChunk.normal_frag

      },

      sprite: {

          uniforms: mergeUniforms([
              UniformsLib.sprite,
              UniformsLib.fog
          ]),

          vertexShader: ShaderChunk.sprite_vert,
          fragmentShader: ShaderChunk.sprite_frag

      },

      background: {

          uniforms: {
              uvTransform: { value: new Matrix3() },
              t2D: { value: null },
          },

          vertexShader: ShaderChunk.background_vert,
          fragmentShader: ShaderChunk.background_frag

      },
      /* -------------------------------------------------------------------------
      //	Cube map shader
       ------------------------------------------------------------------------- */

      cube: {

          uniforms: mergeUniforms([
              UniformsLib.envmap,
              {
                  opacity: { value: 1.0 }
              }
          ]),

          vertexShader: ShaderChunk.cube_vert,
          fragmentShader: ShaderChunk.cube_frag

      },

      equirect: {

          uniforms: {
              tEquirect: { value: null },
          },

          vertexShader: ShaderChunk.equirect_vert,
          fragmentShader: ShaderChunk.equirect_frag

      },

      distanceRGBA: {

          uniforms: mergeUniforms([
              UniformsLib.common,
              UniformsLib.displacementmap,
              {
                  referencePosition: { value: new Vector3() },
                  nearDistance: { value: 1 },
                  farDistance: { value: 1000 }
              }
          ]),

          vertexShader: ShaderChunk.distanceRGBA_vert,
          fragmentShader: ShaderChunk.distanceRGBA_frag

      },

      shadow: {

          uniforms: mergeUniforms([
              UniformsLib.lights,
              UniformsLib.fog,
              {
                  color: { value: new Color(0x00000) },
                  opacity: { value: 1.0 }
              },
          ]),

          vertexShader: ShaderChunk.shadow_vert,
          fragmentShader: ShaderChunk.shadow_frag

      }

  };

  ShaderLib.physical = {

      uniforms: mergeUniforms([
          ShaderLib.standard.uniforms,
          {
              clearcoat: { value: 0 },
              clearcoatMap: { value: null },
              clearcoatRoughness: { value: 0 },
              clearcoatRoughnessMap: { value: null },
              clearcoatNormalScale: { value: new Vector2(1, 1) },
              clearcoatNormalMap: { value: null },
              sheen: { value: new Color(0x000000) },
              transparency: { value: 0 },
          }
      ]),

      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLBackground(renderer, state, objects, premultipliedAlpha) {

      const clearColor = new Color(0x000000);
      let clearAlpha = 0;

      let planeMesh;
      let boxMesh;

      let currentBackground = null;
      let currentBackgroundVersion = 0;
      let currentTonemapping = null;

      function render(renderList, scene, camera, forceClear) {

          let background = scene.isScene === true ? scene.background : null;

          // Ignore background in AR
          // TODO: Reconsider this.

          const xr = renderer.xr;
          const session = xr.getSession && xr.getSession();

          if (session && session.environmentBlendMode === 'additive') {

              background = null;

          }

          if (background === null) {

              setClear(clearColor, clearAlpha);

          } else if (background && background.isColor) {

              setClear(background, 1);
              forceClear = true;

          }

          if (renderer.autoClear || forceClear) {

              renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);

          }

          if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {

              if (boxMesh === undefined) {

                  boxMesh = new Mesh(
                      new BoxBufferGeometry(1, 1, 1),
                      new ShaderMaterial({
                          name: 'BackgroundCubeMaterial',
                          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                          vertexShader: ShaderLib.cube.vertexShader,
                          fragmentShader: ShaderLib.cube.fragmentShader,
                          side: BackSide,
                          depthTest: false,
                          depthWrite: false,
                          fog: false
                      })
                  );

                  boxMesh.geometry.deleteAttribute('normal');
                  boxMesh.geometry.deleteAttribute('uv');

                  boxMesh.onBeforeRender = function(renderer, scene, camera) {

                      this.matrixWorld.copyPosition(camera.matrixWorld);

                  };

                  // enable code injection for non-built-in material
                  Object.defineProperty(boxMesh.material, 'envMap', {

                      get: function() {

                          return this.uniforms.envMap.value;

                      }

                  });

                  objects.update(boxMesh);

              }

              const texture = background.isWebGLCubeRenderTarget ? background.texture : background;

              boxMesh.material.uniforms.envMap.value = texture;
              boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;

              if (currentBackground !== background ||
                  currentBackgroundVersion !== texture.version ||
                  currentTonemapping !== renderer.toneMapping) {

                  boxMesh.material.needsUpdate = true;

                  currentBackground = background;
                  currentBackgroundVersion = texture.version;
                  currentTonemapping = renderer.toneMapping;

              }

              // push to the pre-sorted opaque render list
              renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);

          } else if (background && background.isTexture) {

              if (planeMesh === undefined) {

                  planeMesh = new Mesh(
                      new PlaneBufferGeometry(2, 2),
                      new ShaderMaterial({
                          name: 'BackgroundMaterial',
                          uniforms: cloneUniforms(ShaderLib.background.uniforms),
                          vertexShader: ShaderLib.background.vertexShader,
                          fragmentShader: ShaderLib.background.fragmentShader,
                          side: FrontSide,
                          depthTest: false,
                          depthWrite: false,
                          fog: false
                      })
                  );

                  planeMesh.geometry.deleteAttribute('normal');

                  // enable code injection for non-built-in material
                  Object.defineProperty(planeMesh.material, 'map', {

                      get: function() {

                          return this.uniforms.t2D.value;

                      }

                  });

                  objects.update(planeMesh);

              }

              planeMesh.material.uniforms.t2D.value = background;

              if (background.matrixAutoUpdate === true) {

                  background.updateMatrix();

              }

              planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

              if (currentBackground !== background ||
                  currentBackgroundVersion !== background.version ||
                  currentTonemapping !== renderer.toneMapping) {

                  planeMesh.material.needsUpdate = true;

                  currentBackground = background;
                  currentBackgroundVersion = background.version;
                  currentTonemapping = renderer.toneMapping;

              }


              // push to the pre-sorted opaque render list
              renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);

          }

      }

      function setClear(color, alpha) {

          state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);

      }

      return {

          getClearColor: function() {

              return clearColor;

          },
          setClearColor: function(color, alpha) {

              clearColor.set(color);
              clearAlpha = alpha !== undefined ? alpha : 1;
              setClear(clearColor, clearAlpha);

          },
          getClearAlpha: function() {

              return clearAlpha;

          },
          setClearAlpha: function(alpha) {

              clearAlpha = alpha;
              setClear(clearColor, clearAlpha);

          },
          render: render

      };

  }

  /**
   * @author Mugen87 / https://github.com/Mugen87
   * @author Takahiro / https://github.com/takahirox
   */

  function WebGLBindingStates(gl, extensions, attributes, capabilities) {

      const maxVertexAttributes = gl.getParameter(34921);

      const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
      const vaoAvailable = capabilities.isWebGL2 || extension !== null;

      const bindingStates = {};

      const defaultState = createBindingState(null);
      let currentState = defaultState;

      function setup(object, material, program, geometry, index) {

          let updateBuffers = false;

          if (vaoAvailable) {

              const state = getBindingState(geometry, program, material);

              if (currentState !== state) {

                  currentState = state;
                  bindVertexArrayObject(currentState.object);

              }

              updateBuffers = needsUpdate(geometry);

              if (updateBuffers) saveCache(geometry);

          } else {

              const wireframe = (material.wireframe === true);

              if (currentState.geometry !== geometry.id ||
                  currentState.program !== program.id ||
                  currentState.wireframe !== wireframe) {

                  currentState.geometry = geometry.id;
                  currentState.program = program.id;
                  currentState.wireframe = wireframe;

                  updateBuffers = true;

              }

          }

          if (object.isInstancedMesh === true) {

              updateBuffers = true;

          }

          if (index !== null) {

              attributes.update(index, 34963);

          }

          if (updateBuffers) {

              setupVertexAttributes(object, material, program, geometry);

              if (index !== null) {

                  gl.bindBuffer(34963, attributes.get(index).buffer);

              }

          }

      }

      function createVertexArrayObject() {

          if (capabilities.isWebGL2) return gl.createVertexArray();

          return extension.createVertexArrayOES();

      }

      function bindVertexArrayObject(vao) {

          if (capabilities.isWebGL2) return gl.bindVertexArray(vao);

          return extension.bindVertexArrayOES(vao);

      }

      function deleteVertexArrayObject(vao) {

          if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);

          return extension.deleteVertexArrayOES(vao);

      }

      function getBindingState(geometry, program, material) {

          const wireframe = (material.wireframe === true);

          let programMap = bindingStates[geometry.id];

          if (programMap === undefined) {

              programMap = {};
              bindingStates[geometry.id] = programMap;

          }

          let stateMap = programMap[program.id];

          if (stateMap === undefined) {

              stateMap = {};
              programMap[program.id] = stateMap;

          }

          let state = stateMap[wireframe];

          if (state === undefined) {

              state = createBindingState(createVertexArrayObject());
              stateMap[wireframe] = state;

          }

          return state;

      }

      function createBindingState(vao) {

          const newAttributes = [];
          const enabledAttributes = [];
          const attributeDivisors = [];

          for (let i = 0; i < maxVertexAttributes; i++) {

              newAttributes[i] = 0;
              enabledAttributes[i] = 0;
              attributeDivisors[i] = 0;

          }

          return {

              // for backward compatibility on non-VAO support browser
              geometry: null,
              program: null,
              wireframe: false,

              newAttributes: newAttributes,
              enabledAttributes: enabledAttributes,
              attributeDivisors: attributeDivisors,
              object: vao,
              attributes: {}

          };

      }

      function needsUpdate(geometry) {

          const cachedAttributes = currentState.attributes;
          const geometryAttributes = geometry.attributes;

          if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) return true;

          for (const key in geometryAttributes) {

              const cachedAttribute = cachedAttributes[key];
              const geometryAttribute = geometryAttributes[key];

              if (cachedAttribute.attribute !== geometryAttribute) return true;

              if (cachedAttribute.data !== geometryAttribute.data) return true;

          }

          return false;

      }

      function saveCache(geometry) {

          const cache = {};
          const attributes = geometry.attributes;

          for (const key in attributes) {

              const attribute = attributes[key];

              const data = {};
              data.attribute = attribute;

              if (attribute.data) {

                  data.data = attribute.data;

              }

              cache[key] = data;

          }

          currentState.attributes = cache;

      }

      function initAttributes() {

          const newAttributes = currentState.newAttributes;

          for (let i = 0, il = newAttributes.length; i < il; i++) {

              newAttributes[i] = 0;

          }

      }

      function enableAttribute(attribute) {

          enableAttributeAndDivisor(attribute, 0);

      }

      function enableAttributeAndDivisor(attribute, meshPerAttribute) {

          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          const attributeDivisors = currentState.attributeDivisors;

          newAttributes[attribute] = 1;

          if (enabledAttributes[attribute] === 0) {

              gl.enableVertexAttribArray(attribute);
              enabledAttributes[attribute] = 1;

          }

          if (attributeDivisors[attribute] !== meshPerAttribute) {

              const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');

              extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
              attributeDivisors[attribute] = meshPerAttribute;

          }

      }

      function disableUnusedAttributes() {

          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;

          for (let i = 0, il = enabledAttributes.length; i < il; i++) {

              if (enabledAttributes[i] !== newAttributes[i]) {

                  gl.disableVertexAttribArray(i);
                  enabledAttributes[i] = 0;

              }

          }

      }

      function vertexAttribPointer(index, size, type, normalized, stride, offset) {

          if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {

              gl.vertexAttribIPointer(index, size, type, normalized, stride, offset);

          } else {

              gl.vertexAttribPointer(index, size, type, normalized, stride, offset);

          }

      }

      function setupVertexAttributes(object, material, program, geometry) {

          if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {

              if (extensions.get('ANGLE_instanced_arrays') === null) return;

          }

          initAttributes();

          const geometryAttributes = geometry.attributes;

          const programAttributes = program.getAttributes();

          const materialDefaultAttributeValues = material.defaultAttributeValues;

          for (const name in programAttributes) {

              const programAttribute = programAttributes[name];

              if (programAttribute >= 0) {

                  const geometryAttribute = geometryAttributes[name];

                  if (geometryAttribute !== undefined) {

                      const normalized = geometryAttribute.normalized;
                      const size = geometryAttribute.itemSize;

                      const attribute = attributes.get(geometryAttribute);

                      // TODO Attribute may not be available on context restore

                      if (attribute === undefined) continue;

                      const buffer = attribute.buffer;
                      const type = attribute.type;
                      const bytesPerElement = attribute.bytesPerElement;

                      if (geometryAttribute.isInterleavedBufferAttribute) {

                          const data = geometryAttribute.data;
                          const stride = data.stride;
                          const offset = geometryAttribute.offset;

                          if (data && data.isInstancedInterleavedBuffer) {

                              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

                              if (geometry._maxInstanceCount === undefined) {

                                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;

                              }

                          } else {

                              enableAttribute(programAttribute);

                          }

                          gl.bindBuffer(34962, buffer);
                          vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);

                      } else {

                          if (geometryAttribute.isInstancedBufferAttribute) {

                              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

                              if (geometry._maxInstanceCount === undefined) {

                                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                              }

                          } else {

                              enableAttribute(programAttribute);

                          }

                          gl.bindBuffer(34962, buffer);
                          vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);

                      }

                  } else if (name === 'instanceMatrix') {

                      const attribute = attributes.get(object.instanceMatrix);

                      // TODO Attribute may not be available on context restore

                      if (attribute === undefined) continue;

                      const buffer = attribute.buffer;
                      const type = attribute.type;

                      enableAttributeAndDivisor(programAttribute + 0, 1);
                      enableAttributeAndDivisor(programAttribute + 1, 1);
                      enableAttributeAndDivisor(programAttribute + 2, 1);
                      enableAttributeAndDivisor(programAttribute + 3, 1);

                      gl.bindBuffer(34962, buffer);

                      gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
                      gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
                      gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
                      gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);

                  } else if (materialDefaultAttributeValues !== undefined) {

                      const value = materialDefaultAttributeValues[name];

                      if (value !== undefined) {

                          switch (value.length) {

                              case 2:
                                  gl.vertexAttrib2fv(programAttribute, value);
                                  break;

                              case 3:
                                  gl.vertexAttrib3fv(programAttribute, value);
                                  break;

                              case 4:
                                  gl.vertexAttrib4fv(programAttribute, value);
                                  break;

                              default:
                                  gl.vertexAttrib1fv(programAttribute, value);

                          }

                      }

                  }

              }

          }

          disableUnusedAttributes();

      }

      function dispose() {

          reset();

          for (const geometryId in bindingStates) {

              const programMap = bindingStates[geometryId];

              for (const programId in programMap) {

                  const stateMap = programMap[programId];

                  for (const wireframe in stateMap) {

                      deleteVertexArrayObject(stateMap[wireframe].object);

                      delete stateMap[wireframe];

                  }

                  delete programMap[programId];

              }

              delete bindingStates[geometryId];

          }

      }

      function releaseStatesOfGeometry(geometry) {

          if (bindingStates[geometry.id] === undefined) return;

          const programMap = bindingStates[geometry.id];

          for (const programId in programMap) {

              const stateMap = programMap[programId];

              for (const wireframe in stateMap) {

                  deleteVertexArrayObject(stateMap[wireframe].object);

                  delete stateMap[wireframe];

              }

              delete programMap[programId];

          }

          delete bindingStates[geometry.id];

      }

      function releaseStatesOfProgram(program) {

          for (const geometryId in bindingStates) {

              const programMap = bindingStates[geometryId];

              if (programMap[program.id] === undefined) continue;

              const stateMap = programMap[program.id];

              for (const wireframe in stateMap) {

                  deleteVertexArrayObject(stateMap[wireframe].object);

                  delete stateMap[wireframe];

              }

              delete programMap[program.id];

          }

      }

      function reset() {

          resetDefaultState();

          if (currentState === defaultState) return;

          currentState = defaultState;
          bindVertexArrayObject(currentState.object);

      }

      // for backward-compatilibity

      function resetDefaultState() {

          defaultState.geometry = null;
          defaultState.program = null;
          defaultState.wireframe = false;

      }

      return {

          setup: setup,
          reset: reset,
          resetDefaultState: resetDefaultState,
          dispose: dispose,
          releaseStatesOfGeometry: releaseStatesOfGeometry,
          releaseStatesOfProgram: releaseStatesOfProgram,

          initAttributes: initAttributes,
          enableAttribute: enableAttribute,
          disableUnusedAttributes: disableUnusedAttributes

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLBufferRenderer(gl, extensions, info, capabilities) {

      const isWebGL2 = capabilities.isWebGL2;

      let mode;

      function setMode(value) {

          mode = value;

      }

      function render(start, count) {

          gl.drawArrays(mode, start, count);

          info.update(count, mode);

      }

      function renderInstances(geometry, start, count, primcount) {

          if (primcount === 0) return;

          let extension, methodName;

          if (isWebGL2) {

              extension = gl;
              methodName = 'drawArraysInstanced';

          } else {

              extension = extensions.get('ANGLE_instanced_arrays');
              methodName = 'drawArraysInstancedANGLE';

              if (extension === null) {

                  console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                  return;

              }

          }

          extension[methodName](mode, start, count, primcount);

          info.update(count, mode, primcount);

      }

      //

      this.setMode = setMode;
      this.render = render;
      this.renderInstances = renderInstances;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLCapabilities(gl, extensions, parameters) {

      let maxAnisotropy;

      function getMaxAnisotropy() {

          if (maxAnisotropy !== undefined) return maxAnisotropy;

          const extension = extensions.get('EXT_texture_filter_anisotropic');

          if (extension !== null) {

              maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);

          } else {

              maxAnisotropy = 0;

          }

          return maxAnisotropy;

      }

      function getMaxPrecision(precision) {

          if (precision === 'highp') {

              if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                  gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {

                  return 'highp';

              }

              precision = 'mediump';

          }

          if (precision === 'mediump') {

              if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
                  gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {

                  return 'mediump';

              }

          }

          return 'lowp';

      }

      /* eslint-disable no-undef */
      const isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) ||
          (typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext);
      /* eslint-enable no-undef */

      let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
      const maxPrecision = getMaxPrecision(precision);

      if (maxPrecision !== precision) {

          console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
          precision = maxPrecision;

      }

      const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

      const maxTextures = gl.getParameter(34930);
      const maxVertexTextures = gl.getParameter(35660);
      const maxTextureSize = gl.getParameter(3379);
      const maxCubemapSize = gl.getParameter(34076);

      const maxAttributes = gl.getParameter(34921);
      const maxVertexUniforms = gl.getParameter(36347);
      const maxVaryings = gl.getParameter(36348);
      const maxFragmentUniforms = gl.getParameter(36349);

      const vertexTextures = maxVertexTextures > 0;
      const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
      const floatVertexTextures = vertexTextures && floatFragmentTextures;

      const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;

      return {

          isWebGL2: isWebGL2,

          getMaxAnisotropy: getMaxAnisotropy,
          getMaxPrecision: getMaxPrecision,

          precision: precision,
          logarithmicDepthBuffer: logarithmicDepthBuffer,

          maxTextures: maxTextures,
          maxVertexTextures: maxVertexTextures,
          maxTextureSize: maxTextureSize,
          maxCubemapSize: maxCubemapSize,

          maxAttributes: maxAttributes,
          maxVertexUniforms: maxVertexUniforms,
          maxVaryings: maxVaryings,
          maxFragmentUniforms: maxFragmentUniforms,

          vertexTextures: vertexTextures,
          floatFragmentTextures: floatFragmentTextures,
          floatVertexTextures: floatVertexTextures,

          maxSamples: maxSamples

      };

  }

  /**
   * @author tschw
   */

  function WebGLClipping() {

      const scope = this;

      let globalState = null,
          numGlobalPlanes = 0,
          localClippingEnabled = false,
          renderingShadows = false;

      const plane = new Plane(),
          viewNormalMatrix = new Matrix3(),

          uniform = { value: null, needsUpdate: false };

      this.uniform = uniform;
      this.numPlanes = 0;
      this.numIntersection = 0;

      this.init = function(planes, enableLocalClipping, camera) {

          const enabled =
              planes.length !== 0 ||
              enableLocalClipping ||
              // enable state of previous frame - the clipping code has to
              // run another frame in order to reset the state:
              numGlobalPlanes !== 0 ||
              localClippingEnabled;

          localClippingEnabled = enableLocalClipping;

          globalState = projectPlanes(planes, camera, 0);
          numGlobalPlanes = planes.length;

          return enabled;

      };

      this.beginShadows = function() {

          renderingShadows = true;
          projectPlanes(null);

      };

      this.endShadows = function() {

          renderingShadows = false;
          resetGlobalState();

      };

      this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {

          if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {

              // there's no local clipping

              if (renderingShadows) {

                  // there's no global clipping

                  projectPlanes(null);

              } else {

                  resetGlobalState();

              }

          } else {

              const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                  lGlobal = nGlobal * 4;

              let dstArray = cache.clippingState || null;

              uniform.value = dstArray; // ensure unique state

              dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

              for (let i = 0; i !== lGlobal; ++i) {

                  dstArray[i] = globalState[i];

              }

              cache.clippingState = dstArray;
              this.numIntersection = clipIntersection ? this.numPlanes : 0;
              this.numPlanes += nGlobal;

          }


      };

      function resetGlobalState() {

          if (uniform.value !== globalState) {

              uniform.value = globalState;
              uniform.needsUpdate = numGlobalPlanes > 0;

          }

          scope.numPlanes = numGlobalPlanes;
          scope.numIntersection = 0;

      }

      function projectPlanes(planes, camera, dstOffset, skipTransform) {

          let nPlanes = planes !== null ? planes.length : 0,
              dstArray = null;

          if (nPlanes !== 0) {

              dstArray = uniform.value;

              if (skipTransform !== true || dstArray === null) {

                  const flatSize = dstOffset + nPlanes * 4,
                      viewMatrix = camera.matrixWorldInverse;

                  viewNormalMatrix.getNormalMatrix(viewMatrix);

                  if (dstArray === null || dstArray.length < flatSize) {

                      dstArray = new Float32Array(flatSize);

                  }

                  for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {

                      plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);

                      plane.normal.toArray(dstArray, i4);
                      dstArray[i4 + 3] = plane.constant;

                  }

              }

              uniform.value = dstArray;
              uniform.needsUpdate = true;

          }

          scope.numPlanes = nPlanes;
          scope.numIntersection = 0;

          return dstArray;

      }

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLExtensions(gl) {

      const extensions = {};

      return {

          get: function(name) {

              if (extensions[name] !== undefined) {

                  return extensions[name];

              }

              let extension;

              switch (name) {

                  case 'WEBGL_depth_texture':
                      extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                      break;

                  case 'EXT_texture_filter_anisotropic':
                      extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                      break;

                  case 'WEBGL_compressed_texture_s3tc':
                      extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                      break;

                  case 'WEBGL_compressed_texture_pvrtc':
                      extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                      break;

                  default:
                      extension = gl.getExtension(name);

              }

              if (extension === null) {

                  console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');

              }

              extensions[name] = extension;

              return extension;

          }

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLGeometries(gl, attributes, info, bindingStates) {

      const geometries = new WeakMap();
      const wireframeAttributes = new WeakMap();

      function onGeometryDispose(event) {

          const geometry = event.target;
          const buffergeometry = geometries.get(geometry);

          if (buffergeometry.index !== null) {

              attributes.remove(buffergeometry.index);

          }

          for (const name in buffergeometry.attributes) {

              attributes.remove(buffergeometry.attributes[name]);

          }

          geometry.removeEventListener('dispose', onGeometryDispose);

          geometries.delete(geometry);

          const attribute = wireframeAttributes.get(buffergeometry);

          if (attribute) {

              attributes.remove(attribute);
              wireframeAttributes.delete(buffergeometry);

          }

          bindingStates.releaseStatesOfGeometry(geometry);

          if (geometry.isInstancedBufferGeometry === true) {

              delete geometry._maxInstanceCount;

          }

          //

          info.memory.geometries--;

      }

      function get(object, geometry) {

          let buffergeometry = geometries.get(geometry);

          if (buffergeometry) return buffergeometry;

          geometry.addEventListener('dispose', onGeometryDispose);

          if (geometry.isBufferGeometry) {

              buffergeometry = geometry;

          } else if (geometry.isGeometry) {

              if (geometry._bufferGeometry === undefined) {

                  geometry._bufferGeometry = new BufferGeometry().setFromObject(object);

              }

              buffergeometry = geometry._bufferGeometry;

          }

          geometries.set(geometry, buffergeometry);

          info.memory.geometries++;

          return buffergeometry;

      }

      function update(geometry) {

          const geometryAttributes = geometry.attributes;

          // Updating index buffer in VAO now. See WebGLBindingStates.

          for (const name in geometryAttributes) {

              attributes.update(geometryAttributes[name], 34962);

          }

          // morph targets

          const morphAttributes = geometry.morphAttributes;

          for (const name in morphAttributes) {

              const array = morphAttributes[name];

              for (let i = 0, l = array.length; i < l; i++) {

                  attributes.update(array[i], 34962);

              }

          }

      }

      function updateWireframeAttribute(geometry) {

          const indices = [];

          const geometryIndex = geometry.index;
          const geometryPosition = geometry.attributes.position;
          let version = 0;

          if (geometryIndex !== null) {

              const array = geometryIndex.array;
              version = geometryIndex.version;

              for (let i = 0, l = array.length; i < l; i += 3) {

                  const a = array[i + 0];
                  const b = array[i + 1];
                  const c = array[i + 2];

                  indices.push(a, b, b, c, c, a);

              }

          } else {

              const array = geometryPosition.array;
              version = geometryPosition.version;

              for (let i = 0, l = (array.length / 3) - 1; i < l; i += 3) {

                  const a = i + 0;
                  const b = i + 1;
                  const c = i + 2;

                  indices.push(a, b, b, c, c, a);

              }

          }

          const attribute = new(arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
          attribute.version = version;

          // Updating index buffer in VAO now. See WebGLBindingStates

          //

          const previousAttribute = wireframeAttributes.get(geometry);

          if (previousAttribute) attributes.remove(previousAttribute);

          //

          wireframeAttributes.set(geometry, attribute);

      }

      function getWireframeAttribute(geometry) {

          const currentAttribute = wireframeAttributes.get(geometry);

          if (currentAttribute) {

              const geometryIndex = geometry.index;

              if (geometryIndex !== null) {

                  // if the attribute is obsolete, create a new one

                  if (currentAttribute.version < geometryIndex.version) {

                      updateWireframeAttribute(geometry);

                  }

              }

          } else {

              updateWireframeAttribute(geometry);

          }

          return wireframeAttributes.get(geometry);

      }

      return {

          get: get,
          update: update,

          getWireframeAttribute: getWireframeAttribute

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {

      const isWebGL2 = capabilities.isWebGL2;

      let mode;

      function setMode(value) {

          mode = value;

      }

      let type, bytesPerElement;

      function setIndex(value) {

          type = value.type;
          bytesPerElement = value.bytesPerElement;

      }

      function render(start, count) {

          gl.drawElements(mode, count, type, start * bytesPerElement);

          info.update(count, mode);

      }

      function renderInstances(geometry, start, count, primcount) {

          if (primcount === 0) return;

          let extension, methodName;

          if (isWebGL2) {

              extension = gl;
              methodName = 'drawElementsInstanced';

          } else {

              extension = extensions.get('ANGLE_instanced_arrays');
              methodName = 'drawElementsInstancedANGLE';

              if (extension === null) {

                  console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                  return;

              }

          }

          extension[methodName](mode, count, type, start * bytesPerElement, primcount);

          info.update(count, mode, primcount);

      }

      //

      this.setMode = setMode;
      this.setIndex = setIndex;
      this.render = render;
      this.renderInstances = renderInstances;

  }

  /**
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WebGLInfo(gl) {

      const memory = {
          geometries: 0,
          textures: 0
      };

      const render = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
      };

      function update(count, mode, instanceCount) {

          instanceCount = instanceCount || 1;

          render.calls++;

          switch (mode) {

              case 4:
                  render.triangles += instanceCount * (count / 3);
                  break;

              case 1:
                  render.lines += instanceCount * (count / 2);
                  break;

              case 3:
                  render.lines += instanceCount * (count - 1);
                  break;

              case 2:
                  render.lines += instanceCount * count;
                  break;

              case 0:
                  render.points += instanceCount * count;
                  break;

              default:
                  console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                  break;

          }

      }

      function reset() {

          render.frame++;
          render.calls = 0;
          render.triangles = 0;
          render.points = 0;
          render.lines = 0;

      }

      return {
          memory: memory,
          render: render,
          programs: null,
          autoReset: true,
          reset: reset,
          update: update
      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function numericalSort(a, b) {

      return a[0] - b[0];

  }

  function absNumericalSort(a, b) {

      return Math.abs(b[1]) - Math.abs(a[1]);

  }

  function WebGLMorphtargets(gl) {

      const influencesList = {};
      const morphInfluences = new Float32Array(8);

      const workInfluences = [];

      for (let i = 0; i < 8; i++) {

          workInfluences[i] = [i, 0];

      }

      function update(object, geometry, material, program) {

          const objectInfluences = object.morphTargetInfluences;

          // When object doesn't have morph target influences defined, we treat it as a 0-length array
          // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

          const length = objectInfluences === undefined ? 0 : objectInfluences.length;

          let influences = influencesList[geometry.id];

          if (influences === undefined) {

              // initialise list

              influences = [];

              for (let i = 0; i < length; i++) {

                  influences[i] = [i, 0];

              }

              influencesList[geometry.id] = influences;

          }

          // Collect influences

          for (let i = 0; i < length; i++) {

              const influence = influences[i];

              influence[0] = i;
              influence[1] = objectInfluences[i];

          }

          influences.sort(absNumericalSort);

          for (let i = 0; i < 8; i++) {

              if (i < length && influences[i][1]) {

                  workInfluences[i][0] = influences[i][0];
                  workInfluences[i][1] = influences[i][1];

              } else {

                  workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
                  workInfluences[i][1] = 0;

              }

          }

          workInfluences.sort(numericalSort);

          const morphTargets = material.morphTargets && geometry.morphAttributes.position;
          const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

          let morphInfluencesSum = 0;

          for (let i = 0; i < 8; i++) {

              const influence = workInfluences[i];
              const index = influence[0];
              const value = influence[1];

              if (index !== Number.MAX_SAFE_INTEGER && value) {

                  if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {

                      geometry.setAttribute('morphTarget' + i, morphTargets[index]);

                  }

                  if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {

                      geometry.setAttribute('morphNormal' + i, morphNormals[index]);

                  }

                  morphInfluences[i] = value;
                  morphInfluencesSum += value;

              } else {

                  if (morphTargets && geometry.getAttribute('morphTarget' + i) !== undefined) {

                      geometry.deleteAttribute('morphTarget' + i);

                  }

                  if (morphNormals && geometry.getAttribute('morphNormal' + i) !== undefined) {

                      geometry.deleteAttribute('morphNormal' + i);

                  }

                  morphInfluences[i] = 0;

              }

          }

          // GLSL shader uses formula baseinfluence * base + sum(target * influence)
          // This allows us to switch between absolute morphs and relative morphs without changing shader code
          // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
          const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

          program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
          program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);

      }

      return {

          update: update

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLObjects(gl, geometries, attributes, info) {

      let updateMap = new WeakMap();

      function update(object) {

          const frame = info.render.frame;

          const geometry = object.geometry;
          const buffergeometry = geometries.get(object, geometry);

          // Update once per frame

          if (updateMap.get(buffergeometry) !== frame) {

              if (geometry.isGeometry) {

                  buffergeometry.updateFromObject(object);

              }

              geometries.update(buffergeometry);

              updateMap.set(buffergeometry, frame);

          }

          if (object.isInstancedMesh) {

              attributes.update(object.instanceMatrix, 34962);

          }

          return buffergeometry;

      }

      function dispose() {

          updateMap = new WeakMap();

      }

      return {

          update: update,
          dispose: dispose

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

      images = images !== undefined ? images : [];
      mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
      format = format !== undefined ? format : RGBFormat;

      Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

      this.flipY = false;

  }

  CubeTexture.prototype = Object.create(Texture.prototype);
  CubeTexture.prototype.constructor = CubeTexture;

  CubeTexture.prototype.isCubeTexture = true;

  Object.defineProperty(CubeTexture.prototype, 'images', {

      get: function() {

          return this.image;

      },

      set: function(value) {

          this.image = value;

      }

  });

  /**
   * @author Takahiro https://github.com/takahirox
   */

  function DataTexture2DArray(data, width, height, depth) {

      Texture.call(this, null);

      this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;

      this.wrapR = ClampToEdgeWrapping;

      this.generateMipmaps = false;
      this.flipY = false;

      this.needsUpdate = true;

  }

  DataTexture2DArray.prototype = Object.create(Texture.prototype);
  DataTexture2DArray.prototype.constructor = DataTexture2DArray;
  DataTexture2DArray.prototype.isDataTexture2DArray = true;

  /**
   * @author Artur Trzesiok
   */

  function DataTexture3D(data, width, height, depth) {

      // We're going to add .setXXX() methods for setting properties later.
      // Users can still set in DataTexture3D directly.
      //
      //	const texture = new THREE.DataTexture3D( data, width, height, depth );
      // 	texture.anisotropy = 16;
      //
      // See #14839

      Texture.call(this, null);

      this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;

      this.wrapR = ClampToEdgeWrapping;

      this.generateMipmaps = false;
      this.flipY = false;

      this.needsUpdate = true;


  }

  DataTexture3D.prototype = Object.create(Texture.prototype);
  DataTexture3D.prototype.constructor = DataTexture3D;
  DataTexture3D.prototype.isDataTexture3D = true;

  /**
   * @author tschw
   * @author Mugen87 / https://github.com/Mugen87
   * @author mrdoob / http://mrdoob.com/
   *
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [textures] )
   *
   * 		uploads a uniform value(s)
   *  	the 'textures' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (textures factorizations):
   *
   * .upload( gl, seq, values, textures )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (textures factorizations):
   *
   * .setValue( gl, name, value, textures )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */

  const emptyTexture = new Texture();
  const emptyTexture2dArray = new DataTexture2DArray();
  const emptyTexture3d = new DataTexture3D();
  const emptyCubeTexture = new CubeTexture();

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  const arrayCacheF32 = [];
  const arrayCacheI32 = [];

  // Float32Array caches used for uploading Matrix uniforms

  const mat4array = new Float32Array(16);
  const mat3array = new Float32Array(9);
  const mat2array = new Float32Array(4);

  // Flattening for arrays of vectors and matrices

  function flatten(array, nBlocks, blockSize) {

      const firstElem = array[0];

      if (firstElem <= 0 || firstElem > 0) return array;
      // unoptimized: ! isNaN( firstElem )
      // see http://jacksondunstan.com/articles/983

      let n = nBlocks * blockSize,
          r = arrayCacheF32[n];

      if (r === undefined) {

          r = new Float32Array(n);
          arrayCacheF32[n] = r;

      }

      if (nBlocks !== 0) {

          firstElem.toArray(r, 0);

          for (let i = 1, offset = 0; i !== nBlocks; ++i) {

              offset += blockSize;
              array[i].toArray(r, offset);

          }

      }

      return r;

  }

  function arraysEqual(a, b) {

      if (a.length !== b.length) return false;

      for (let i = 0, l = a.length; i < l; i++) {

          if (a[i] !== b[i]) return false;

      }

      return true;

  }

  function copyArray(a, b) {

      for (let i = 0, l = b.length; i < l; i++) {

          a[i] = b[i];

      }

  }

  // Texture unit allocation

  function allocTexUnits(textures, n) {

      let r = arrayCacheI32[n];

      if (r === undefined) {

          r = new Int32Array(n);
          arrayCacheI32[n] = r;

      }

      for (let i = 0; i !== n; ++i) {

          r[i] = textures.allocateTextureUnit();

      }

      return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValueV1f(gl, v) {

      const cache = this.cache;

      if (cache[0] === v) return;

      gl.uniform1f(this.addr, v);

      cache[0] = v;

  }

  // Single float vector (from flat array or THREE.VectorN)

  function setValueV2f(gl, v) {

      const cache = this.cache;

      if (v.x !== undefined) {

          if (cache[0] !== v.x || cache[1] !== v.y) {

              gl.uniform2f(this.addr, v.x, v.y);

              cache[0] = v.x;
              cache[1] = v.y;

          }

      } else {

          if (arraysEqual(cache, v)) return;

          gl.uniform2fv(this.addr, v);

          copyArray(cache, v);

      }

  }

  function setValueV3f(gl, v) {

      const cache = this.cache;

      if (v.x !== undefined) {

          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {

              gl.uniform3f(this.addr, v.x, v.y, v.z);

              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;

          }

      } else if (v.r !== undefined) {

          if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {

              gl.uniform3f(this.addr, v.r, v.g, v.b);

              cache[0] = v.r;
              cache[1] = v.g;
              cache[2] = v.b;

          }

      } else {

          if (arraysEqual(cache, v)) return;

          gl.uniform3fv(this.addr, v);

          copyArray(cache, v);

      }

  }

  function setValueV4f(gl, v) {

      const cache = this.cache;

      if (v.x !== undefined) {

          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {

              gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);

              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;
              cache[3] = v.w;

          }

      } else {

          if (arraysEqual(cache, v)) return;

          gl.uniform4fv(this.addr, v);

          copyArray(cache, v);

      }

  }

  // Single matrix (from flat array or MatrixN)

  function setValueM2(gl, v) {

      const cache = this.cache;
      const elements = v.elements;

      if (elements === undefined) {

          if (arraysEqual(cache, v)) return;

          gl.uniformMatrix2fv(this.addr, false, v);

          copyArray(cache, v);

      } else {

          if (arraysEqual(cache, elements)) return;

          mat2array.set(elements);

          gl.uniformMatrix2fv(this.addr, false, mat2array);

          copyArray(cache, elements);

      }

  }

  function setValueM3(gl, v) {

      const cache = this.cache;
      const elements = v.elements;

      if (elements === undefined) {

          if (arraysEqual(cache, v)) return;

          gl.uniformMatrix3fv(this.addr, false, v);

          copyArray(cache, v);

      } else {

          if (arraysEqual(cache, elements)) return;

          mat3array.set(elements);

          gl.uniformMatrix3fv(this.addr, false, mat3array);

          copyArray(cache, elements);

      }

  }

  function setValueM4(gl, v) {

      const cache = this.cache;
      const elements = v.elements;

      if (elements === undefined) {

          if (arraysEqual(cache, v)) return;

          gl.uniformMatrix4fv(this.addr, false, v);

          copyArray(cache, v);

      } else {

          if (arraysEqual(cache, elements)) return;

          mat4array.set(elements);

          gl.uniformMatrix4fv(this.addr, false, mat4array);

          copyArray(cache, elements);

      }

  }

  // Single texture (2D / Cube)

  function setValueT1(gl, v, textures) {

      const cache = this.cache;
      const unit = textures.allocateTextureUnit();

      if (cache[0] !== unit) {

          gl.uniform1i(this.addr, unit);
          cache[0] = unit;

      }

      textures.safeSetTexture2D(v || emptyTexture, unit);

  }

  function setValueT2DArray1(gl, v, textures) {

      const cache = this.cache;
      const unit = textures.allocateTextureUnit();

      if (cache[0] !== unit) {

          gl.uniform1i(this.addr, unit);
          cache[0] = unit;

      }

      textures.setTexture2DArray(v || emptyTexture2dArray, unit);

  }

  function setValueT3D1(gl, v, textures) {

      const cache = this.cache;
      const unit = textures.allocateTextureUnit();

      if (cache[0] !== unit) {

          gl.uniform1i(this.addr, unit);
          cache[0] = unit;

      }

      textures.setTexture3D(v || emptyTexture3d, unit);

  }

  function setValueT6(gl, v, textures) {

      const cache = this.cache;
      const unit = textures.allocateTextureUnit();

      if (cache[0] !== unit) {

          gl.uniform1i(this.addr, unit);
          cache[0] = unit;

      }

      textures.safeSetTextureCube(v || emptyCubeTexture, unit);

  }

  // Integer / Boolean vectors or arrays thereof (always flat arrays)

  function setValueV1i(gl, v) {

      const cache = this.cache;

      if (cache[0] === v) return;

      gl.uniform1i(this.addr, v);

      cache[0] = v;

  }

  function setValueV2i(gl, v) {

      const cache = this.cache;

      if (arraysEqual(cache, v)) return;

      gl.uniform2iv(this.addr, v);

      copyArray(cache, v);

  }

  function setValueV3i(gl, v) {

      const cache = this.cache;

      if (arraysEqual(cache, v)) return;

      gl.uniform3iv(this.addr, v);

      copyArray(cache, v);

  }

  function setValueV4i(gl, v) {

      const cache = this.cache;

      if (arraysEqual(cache, v)) return;

      gl.uniform4iv(this.addr, v);

      copyArray(cache, v);

  }

  // uint

  function setValueV1ui(gl, v) {

      const cache = this.cache;

      if (cache[0] === v) return;

      gl.uniform1ui(this.addr, v);

      cache[0] = v;

  }

  // Helper to pick the right setter for the singular case

  function getSingularSetter(type) {

      switch (type) {

          case 0x1406:
              return setValueV1f; // FLOAT
          case 0x8b50:
              return setValueV2f; // _VEC2
          case 0x8b51:
              return setValueV3f; // _VEC3
          case 0x8b52:
              return setValueV4f; // _VEC4

          case 0x8b5a:
              return setValueM2; // _MAT2
          case 0x8b5b:
              return setValueM3; // _MAT3
          case 0x8b5c:
              return setValueM4; // _MAT4

          case 0x1404:
          case 0x8b56:
              return setValueV1i; // INT, BOOL
          case 0x8b53:
          case 0x8b57:
              return setValueV2i; // _VEC2
          case 0x8b54:
          case 0x8b58:
              return setValueV3i; // _VEC3
          case 0x8b55:
          case 0x8b59:
              return setValueV4i; // _VEC4

          case 0x1405:
              return setValueV1ui; // UINT

          case 0x8b5e: // SAMPLER_2D
          case 0x8d66: // SAMPLER_EXTERNAL_OES
          case 0x8dca: // INT_SAMPLER_2D
          case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
          case 0x8b62: // SAMPLER_2D_SHADOW
              return setValueT1;

          case 0x8b5f: // SAMPLER_3D
          case 0x8dcb: // INT_SAMPLER_3D
          case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
              return setValueT3D1;

          case 0x8b60: // SAMPLER_CUBE
          case 0x8dcc: // INT_SAMPLER_CUBE
          case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
          case 0x8dc5: // SAMPLER_CUBE_SHADOW
              return setValueT6;

          case 0x8dc1: // SAMPLER_2D_ARRAY
          case 0x8dcf: // INT_SAMPLER_2D_ARRAY
          case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
          case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
              return setValueT2DArray1;

      }

  }

  // Array of scalars
  function setValueV1fArray(gl, v) {

      gl.uniform1fv(this.addr, v);

  }

  // Integer / Boolean vectors or arrays thereof (always flat arrays)
  function setValueV1iArray(gl, v) {

      gl.uniform1iv(this.addr, v);

  }

  function setValueV2iArray(gl, v) {

      gl.uniform2iv(this.addr, v);

  }

  function setValueV3iArray(gl, v) {

      gl.uniform3iv(this.addr, v);

  }

  function setValueV4iArray(gl, v) {

      gl.uniform4iv(this.addr, v);

  }


  // Array of vectors (flat or from THREE classes)

  function setValueV2fArray(gl, v) {

      const data = flatten(v, this.size, 2);

      gl.uniform2fv(this.addr, data);

  }

  function setValueV3fArray(gl, v) {

      const data = flatten(v, this.size, 3);

      gl.uniform3fv(this.addr, data);

  }

  function setValueV4fArray(gl, v) {

      const data = flatten(v, this.size, 4);

      gl.uniform4fv(this.addr, data);

  }

  // Array of matrices (flat or from THREE clases)

  function setValueM2Array(gl, v) {

      const data = flatten(v, this.size, 4);

      gl.uniformMatrix2fv(this.addr, false, data);

  }

  function setValueM3Array(gl, v) {

      const data = flatten(v, this.size, 9);

      gl.uniformMatrix3fv(this.addr, false, data);

  }

  function setValueM4Array(gl, v) {

      const data = flatten(v, this.size, 16);

      gl.uniformMatrix4fv(this.addr, false, data);

  }

  // Array of textures (2D / Cube)

  function setValueT1Array(gl, v, textures) {

      const n = v.length;

      const units = allocTexUnits(textures, n);

      gl.uniform1iv(this.addr, units);

      for (let i = 0; i !== n; ++i) {

          textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);

      }

  }

  function setValueT6Array(gl, v, textures) {

      const n = v.length;

      const units = allocTexUnits(textures, n);

      gl.uniform1iv(this.addr, units);

      for (let i = 0; i !== n; ++i) {

          textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);

      }

  }

  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter(type) {

      switch (type) {

          case 0x1406:
              return setValueV1fArray; // FLOAT
          case 0x8b50:
              return setValueV2fArray; // _VEC2
          case 0x8b51:
              return setValueV3fArray; // _VEC3
          case 0x8b52:
              return setValueV4fArray; // _VEC4

          case 0x8b5a:
              return setValueM2Array; // _MAT2
          case 0x8b5b:
              return setValueM3Array; // _MAT3
          case 0x8b5c:
              return setValueM4Array; // _MAT4

          case 0x1404:
          case 0x8b56:
              return setValueV1iArray; // INT, BOOL
          case 0x8b53:
          case 0x8b57:
              return setValueV2iArray; // _VEC2
          case 0x8b54:
          case 0x8b58:
              return setValueV3iArray; // _VEC3
          case 0x8b55:
          case 0x8b59:
              return setValueV4iArray; // _VEC4

          case 0x8b5e: // SAMPLER_2D
          case 0x8d66: // SAMPLER_EXTERNAL_OES
          case 0x8dca: // INT_SAMPLER_2D
          case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
          case 0x8b62: // SAMPLER_2D_SHADOW
              return setValueT1Array;

          case 0x8b60: // SAMPLER_CUBE
          case 0x8dcc: // INT_SAMPLER_CUBE
          case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
          case 0x8dc5: // SAMPLER_CUBE_SHADOW
              return setValueT6Array;

      }

  }

  // --- Uniform Classes ---

  function SingleUniform(id, activeInfo, addr) {

      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.setValue = getSingularSetter(activeInfo.type);

      // this.path = activeInfo.name; // DEBUG

  }

  function PureArrayUniform(id, activeInfo, addr) {

      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.size = activeInfo.size;
      this.setValue = getPureArraySetter(activeInfo.type);

      // this.path = activeInfo.name; // DEBUG

  }

  PureArrayUniform.prototype.updateCache = function(data) {

      let cache = this.cache;

      if (data instanceof Float32Array && cache.length !== data.length) {

          this.cache = new Float32Array(data.length);

      }

      copyArray(cache, data);

  };

  function StructuredUniform(id) {

      this.id = id;

      this.seq = [];
      this.map = {};

  }

  StructuredUniform.prototype.setValue = function(gl, value, textures) {

      const seq = this.seq;

      for (let i = 0, n = seq.length; i !== n; ++i) {

          const u = seq[i];
          u.setValue(gl, value[u.id], textures);

      }

  };

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

  // extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform(container, uniformObject) {

      container.seq.push(uniformObject);
      container.map[uniformObject.id] = uniformObject;

  }

  function parseUniform(activeInfo, addr, container) {

      const path = activeInfo.name,
          pathLength = path.length;

      // reset RegExp object, because of the early exit of a previous run
      RePathPart.lastIndex = 0;

      while (true) {

          const match = RePathPart.exec(path),
              matchEnd = RePathPart.lastIndex;

          let id = match[1],
              idIsIndex = match[2] === ']',
              subscript = match[3];

          if (idIsIndex) id = id | 0; // convert to integer

          if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {

              // bare name or "pure" bottom-level array "[0]" suffix

              addUniform(container, subscript === undefined ?
                  new SingleUniform(id, activeInfo, addr) :
                  new PureArrayUniform(id, activeInfo, addr));

              break;

          } else {

              // step into inner node / create it in case it doesn't exist

              const map = container.map;
              let next = map[id];

              if (next === undefined) {

                  next = new StructuredUniform(id);
                  addUniform(container, next);

              }

              container = next;

          }

      }

  }

  // Root Container

  function WebGLUniforms(gl, program) {

      this.seq = [];
      this.map = {};

      const n = gl.getProgramParameter(program, 35718);

      for (let i = 0; i < n; ++i) {

          const info = gl.getActiveUniform(program, i),
              addr = gl.getUniformLocation(program, info.name);

          parseUniform(info, addr, this);

      }

  }

  WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {

      const u = this.map[name];

      if (u !== undefined) u.setValue(gl, value, textures);

  };

  WebGLUniforms.prototype.setOptional = function(gl, object, name) {

      const v = object[name];

      if (v !== undefined) this.setValue(gl, name, v);

  };


  // Static interface

  WebGLUniforms.upload = function(gl, seq, values, textures) {

      for (let i = 0, n = seq.length; i !== n; ++i) {

          const u = seq[i],
              v = values[u.id];

          if (v.needsUpdate !== false) {

              // note: always updating when .needsUpdate is undefined
              u.setValue(gl, v.value, textures);

          }

      }

  };

  WebGLUniforms.seqWithValue = function(seq, values) {

      const r = [];

      for (let i = 0, n = seq.length; i !== n; ++i) {

          const u = seq[i];
          if (u.id in values) r.push(u);

      }

      return r;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLShader(gl, type, string) {

      const shader = gl.createShader(type);

      gl.shaderSource(shader, string);
      gl.compileShader(shader);

      return shader;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  let programIdCount = 0;

  function addLineNumbers(string) {

      const lines = string.split('\n');

      for (let i = 0; i < lines.length; i++) {

          lines[i] = (i + 1) + ': ' + lines[i];

      }

      return lines.join('\n');

  }

  function getEncodingComponents(encoding) {

      switch (encoding) {

          case LinearEncoding:
              return ['Linear', '( value )'];
          case sRGBEncoding:
              return ['sRGB', '( value )'];
          case RGBEEncoding:
              return ['RGBE', '( value )'];
          case RGBM7Encoding:
              return ['RGBM', '( value, 7.0 )'];
          case RGBM16Encoding:
              return ['RGBM', '( value, 16.0 )'];
          case RGBDEncoding:
              return ['RGBD', '( value, 256.0 )'];
          case GammaEncoding:
              return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
          case LogLuvEncoding:
              return ['LogLuv', '( value )'];
          default:
              console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
              return ['Linear', '( value )'];

      }

  }

  function getShaderErrors(gl, shader, type) {

      const status = gl.getShaderParameter(shader, 35713);
      const log = gl.getShaderInfoLog(shader).trim();

      if (status && log === '') return '';

      // --enable-privileged-webgl-extension
      // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

      const source = gl.getShaderSource(shader);

      return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);

  }

  function getTexelDecodingFunction(functionName, encoding) {

      const components = getEncodingComponents(encoding);
      return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';

  }

  function getTexelEncodingFunction(functionName, encoding) {

      const components = getEncodingComponents(encoding);
      return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';

  }

  function getToneMappingFunction(functionName, toneMapping) {

      let toneMappingName;

      switch (toneMapping) {

          case LinearToneMapping:
              toneMappingName = 'Linear';
              break;

          case ReinhardToneMapping:
              toneMappingName = 'Reinhard';
              break;

          case CineonToneMapping:
              toneMappingName = 'OptimizedCineon';
              break;

          case ACESFilmicToneMapping:
              toneMappingName = 'ACESFilmic';
              break;

          case CustomToneMapping:
              toneMappingName = 'Custom';
              break;

          default:
              console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
              toneMappingName = 'Linear';

      }

      return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

  }

  function generateExtensions(parameters) {

      const chunks = [
          (parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical') ? '#extension GL_OES_standard_derivatives : enable' : '',
          (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
          (parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers) ? '#extension GL_EXT_draw_buffers : require' : '',
          (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
      ];

      return chunks.filter(filterEmptyLine).join('\n');

  }

  function generateDefines(defines) {

      const chunks = [];

      for (const name in defines) {

          const value = defines[name];

          if (value === false) continue;

          chunks.push('#define ' + name + ' ' + value);

      }

      return chunks.join('\n');

  }

  function fetchAttributeLocations(gl, program) {

      const attributes = {};

      const n = gl.getProgramParameter(program, 35721);

      for (let i = 0; i < n; i++) {

          const info = gl.getActiveAttrib(program, i);
          const name = info.name;

          // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

          attributes[name] = gl.getAttribLocation(program, name);

      }

      return attributes;

  }

  function filterEmptyLine(string) {

      return string !== '';

  }

  function replaceLightNums(string, parameters) {

      return string
          .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);

  }

  function replaceClippingPlaneNums(string, parameters) {

      return string
          .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
          .replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));

  }

  // Resolve Includes

  const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function resolveIncludes(string) {

      return string.replace(includePattern, includeReplacer);

  }

  function includeReplacer(match, include) {

      const string = ShaderChunk[include];

      if (string === undefined) {

          throw new Error('Can not resolve #include <' + include + '>');

      }

      return resolveIncludes(string);

  }

  // Unroll Loops

  const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  const unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

  function unrollLoops(string) {

      return string
          .replace(unrollLoopPattern, loopReplacer)
          .replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);

  }

  function deprecatedLoopReplacer(match, start, end, snippet) {

      console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
      return loopReplacer(match, start, end, snippet);

  }

  function loopReplacer(match, start, end, snippet) {

      let string = '';

      for (let i = parseInt(start); i < parseInt(end); i++) {

          string += snippet
              .replace(/\[ i \]/g, '[ ' + i + ' ]')
              .replace(/UNROLLED_LOOP_INDEX/g, i);

      }

      return string;

  }

  //

  function generatePrecision(parameters) {

      let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

      if (parameters.precision === "highp") {

          precisionstring += "\n#define HIGH_PRECISION";

      } else if (parameters.precision === "mediump") {

          precisionstring += "\n#define MEDIUM_PRECISION";

      } else if (parameters.precision === "lowp") {

          precisionstring += "\n#define LOW_PRECISION";

      }

      return precisionstring;

  }

  function generateShadowMapTypeDefine(parameters) {

      let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

      if (parameters.shadowMapType === PCFShadowMap) {

          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

      } else if (parameters.shadowMapType === PCFSoftShadowMap) {

          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

      } else if (parameters.shadowMapType === VSMShadowMap) {

          shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

      }

      return shadowMapTypeDefine;

  }

  function generateEnvMapTypeDefine(parameters) {

      let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

      if (parameters.envMap) {

          switch (parameters.envMapMode) {

              case CubeReflectionMapping:
              case CubeRefractionMapping:
                  envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                  break;

              case CubeUVReflectionMapping:
              case CubeUVRefractionMapping:
                  envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                  break;

              case EquirectangularReflectionMapping:
              case EquirectangularRefractionMapping:
                  envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                  break;

          }

      }

      return envMapTypeDefine;

  }

  function generateEnvMapModeDefine(parameters) {

      let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

      if (parameters.envMap) {

          switch (parameters.envMapMode) {

              case CubeRefractionMapping:
              case EquirectangularRefractionMapping:
                  envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                  break;

          }

      }

      return envMapModeDefine;

  }

  function generateEnvMapBlendingDefine(parameters) {

      let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

      if (parameters.envMap) {

          switch (parameters.combine) {

              case MultiplyOperation:
                  envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                  break;

              case MixOperation:
                  envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                  break;

              case AddOperation:
                  envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                  break;

          }

      }

      return envMapBlendingDefine;

  }

  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {

      const gl = renderer.getContext();

      const defines = parameters.defines;

      let vertexShader = parameters.vertexShader;
      let fragmentShader = parameters.fragmentShader;

      const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
      const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
      const envMapModeDefine = generateEnvMapModeDefine(parameters);
      const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);


      const gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;

      const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);

      const customDefines = generateDefines(defines);

      const program = gl.createProgram();

      let prefixVertex, prefixFragment;

      if (parameters.isRawShaderMaterial) {

          prefixVertex = [

              customDefines

          ].filter(filterEmptyLine).join('\n');

          if (prefixVertex.length > 0) {

              prefixVertex += '\n';

          }

          prefixFragment = [

              customExtensions,
              customDefines

          ].filter(filterEmptyLine).join('\n');

          if (prefixFragment.length > 0) {

              prefixFragment += '\n';

          }

      } else {

          prefixVertex = [

              generatePrecision(parameters),

              '#define SHADER_NAME ' + parameters.shaderName,

              customDefines,

              parameters.instancing ? '#define USE_INSTANCING' : '',
              parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

              '#define GAMMA_FACTOR ' + gammaFactorDefine,

              '#define MAX_BONES ' + parameters.maxBones,
              (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
              (parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',

              parameters.map ? '#define USE_MAP' : '',
              parameters.envMap ? '#define USE_ENVMAP' : '',
              parameters.envMap ? '#define ' + envMapModeDefine : '',
              parameters.lightMap ? '#define USE_LIGHTMAP' : '',
              parameters.aoMap ? '#define USE_AOMAP' : '',
              parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              parameters.bumpMap ? '#define USE_BUMPMAP' : '',
              parameters.normalMap ? '#define USE_NORMALMAP' : '',
              (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
              (parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',

              parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
              parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
              parameters.specularMap ? '#define USE_SPECULARMAP' : '',
              parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
              parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

              parameters.vertexTangents ? '#define USE_TANGENT' : '',
              parameters.vertexColors ? '#define USE_COLOR' : '',
              parameters.vertexUvs ? '#define USE_UV' : '',
              parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

              parameters.flatShading ? '#define FLAT_SHADED' : '',

              parameters.skinning ? '#define USE_SKINNING' : '',
              parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

              parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
              parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
              parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
              parameters.flipSided ? '#define FLIP_SIDED' : '',

              parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

              parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

              parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              (parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',

              'uniform mat4 modelMatrix;',
              'uniform mat4 modelViewMatrix;',
              'uniform mat4 projectionMatrix;',
              'uniform mat4 viewMatrix;',
              'uniform mat3 normalMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',

              '#ifdef USE_INSTANCING',

              ' attribute mat4 instanceMatrix;',

              '#endif',

              'attribute vec3 position;',
              'attribute vec3 normal;',
              'attribute vec2 uv;',

              '#ifdef USE_TANGENT',

              '	attribute vec4 tangent;',

              '#endif',

              '#ifdef USE_COLOR',

              '	attribute vec3 color;',

              '#endif',

              '#ifdef USE_MORPHTARGETS',

              '	attribute vec3 morphTarget0;',
              '	attribute vec3 morphTarget1;',
              '	attribute vec3 morphTarget2;',
              '	attribute vec3 morphTarget3;',

              '	#ifdef USE_MORPHNORMALS',

              '		attribute vec3 morphNormal0;',
              '		attribute vec3 morphNormal1;',
              '		attribute vec3 morphNormal2;',
              '		attribute vec3 morphNormal3;',

              '	#else',

              '		attribute vec3 morphTarget4;',
              '		attribute vec3 morphTarget5;',
              '		attribute vec3 morphTarget6;',
              '		attribute vec3 morphTarget7;',

              '	#endif',

              '#endif',

              '#ifdef USE_SKINNING',

              '	attribute vec4 skinIndex;',
              '	attribute vec4 skinWeight;',

              '#endif',

              '\n'

          ].filter(filterEmptyLine).join('\n');

          prefixFragment = [

              customExtensions,

              generatePrecision(parameters),

              '#define SHADER_NAME ' + parameters.shaderName,

              customDefines,

              parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer

              '#define GAMMA_FACTOR ' + gammaFactorDefine,

              (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
              (parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',

              parameters.map ? '#define USE_MAP' : '',
              parameters.matcap ? '#define USE_MATCAP' : '',
              parameters.envMap ? '#define USE_ENVMAP' : '',
              parameters.envMap ? '#define ' + envMapTypeDefine : '',
              parameters.envMap ? '#define ' + envMapModeDefine : '',
              parameters.envMap ? '#define ' + envMapBlendingDefine : '',
              parameters.lightMap ? '#define USE_LIGHTMAP' : '',
              parameters.aoMap ? '#define USE_AOMAP' : '',
              parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              parameters.bumpMap ? '#define USE_BUMPMAP' : '',
              parameters.normalMap ? '#define USE_NORMALMAP' : '',
              (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
              (parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
              parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
              parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              parameters.specularMap ? '#define USE_SPECULARMAP' : '',
              parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
              parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

              parameters.sheen ? '#define USE_SHEEN' : '',

              parameters.vertexTangents ? '#define USE_TANGENT' : '',
              parameters.vertexColors ? '#define USE_COLOR' : '',
              parameters.vertexUvs ? '#define USE_UV' : '',
              parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

              parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

              parameters.flatShading ? '#define FLAT_SHADED' : '',

              parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
              parameters.flipSided ? '#define FLIP_SIDED' : '',

              parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

              parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

              parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

              parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              (parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',

              ((parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod) ? '#define TEXTURE_LOD_EXT' : '',

              'uniform mat4 viewMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',

              (parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '',
              (parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
              (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',

              parameters.dithering ? '#define DITHERING' : '',

              ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
              parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
              parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
              parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
              parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
              parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
              getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),

              parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

              '\n'

          ].filter(filterEmptyLine).join('\n');

      }

      vertexShader = resolveIncludes(vertexShader);
      vertexShader = replaceLightNums(vertexShader, parameters);
      vertexShader = replaceClippingPlaneNums(vertexShader, parameters);

      fragmentShader = resolveIncludes(fragmentShader);
      fragmentShader = replaceLightNums(fragmentShader, parameters);
      fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);

      vertexShader = unrollLoops(vertexShader);
      fragmentShader = unrollLoops(fragmentShader);

      if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {

          let isGLSL3ShaderMaterial = false;

          const versionRegex = /^\s*#version\s+300\s+es\s*\n/;

          if (parameters.isShaderMaterial &&
              vertexShader.match(versionRegex) !== null &&
              fragmentShader.match(versionRegex) !== null) {

              isGLSL3ShaderMaterial = true;

              vertexShader = vertexShader.replace(versionRegex, '');
              fragmentShader = fragmentShader.replace(versionRegex, '');

          }

          // GLSL 3.0 conversion

          prefixVertex = [
              '#version 300 es\n',
              '#define attribute in',
              '#define varying out',
              '#define texture2D texture'
          ].join('\n') + '\n' + prefixVertex;

          prefixFragment = [
              '#version 300 es\n',
              '#define varying in',
              isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
              isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
              '#define gl_FragDepthEXT gl_FragDepth',
              '#define texture2D texture',
              '#define textureCube texture',
              '#define texture2DProj textureProj',
              '#define texture2DLodEXT textureLod',
              '#define texture2DProjLodEXT textureProjLod',
              '#define textureCubeLodEXT textureLod',
              '#define texture2DGradEXT textureGrad',
              '#define texture2DProjGradEXT textureProjGrad',
              '#define textureCubeGradEXT textureGrad'
          ].join('\n') + '\n' + prefixFragment;

      }

      const vertexGlsl = prefixVertex + vertexShader;
      const fragmentGlsl = prefixFragment + fragmentShader;

      // console.log( '*VERTEX*', vertexGlsl );
      // console.log( '*FRAGMENT*', fragmentGlsl );

      const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
      const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);

      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);

      // Force a particular attribute to index 0.

      if (parameters.index0AttributeName !== undefined) {

          gl.bindAttribLocation(program, 0, parameters.index0AttributeName);

      } else if (parameters.morphTargets === true) {

          // programs with morphTargets displace position out of attribute 0
          gl.bindAttribLocation(program, 0, 'position');

      }

      gl.linkProgram(program);

      // check for link errors
      if (renderer.debug.checkShaderErrors) {

          const programLog = gl.getProgramInfoLog(program).trim();
          const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
          const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();

          let runnable = true;
          let haveDiagnostics = true;

          if (gl.getProgramParameter(program, 35714) === false) {

              runnable = false;

              const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
              const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');

              console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);

          } else if (programLog !== '') {

              console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);

          } else if (vertexLog === '' || fragmentLog === '') {

              haveDiagnostics = false;

          }

          if (haveDiagnostics) {

              this.diagnostics = {

                  runnable: runnable,

                  programLog: programLog,

                  vertexShader: {

                      log: vertexLog,
                      prefix: prefixVertex

                  },

                  fragmentShader: {

                      log: fragmentLog,
                      prefix: prefixFragment

                  }

              };

          }

      }

      // Clean up

      // Crashes in iOS9 and iOS10. #18402
      // gl.detachShader( program, glVertexShader );
      // gl.detachShader( program, glFragmentShader );

      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);

      // set up caching for uniform locations

      let cachedUniforms;

      this.getUniforms = function() {

          if (cachedUniforms === undefined) {

              cachedUniforms = new WebGLUniforms(gl, program);

          }

          return cachedUniforms;

      };

      // set up caching for attribute locations

      let cachedAttributes;

      this.getAttributes = function() {

          if (cachedAttributes === undefined) {

              cachedAttributes = fetchAttributeLocations(gl, program);

          }

          return cachedAttributes;

      };

      // free resource

      this.destroy = function() {

          bindingStates.releaseStatesOfProgram(this);

          gl.deleteProgram(program);
          this.program = undefined;

      };

      //

      this.name = parameters.shaderName;
      this.id = programIdCount++;
      this.cacheKey = cacheKey;
      this.usedTimes = 1;
      this.program = program;
      this.vertexShader = glVertexShader;
      this.fragmentShader = glFragmentShader;

      return this;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLPrograms(renderer, extensions, capabilities, bindingStates) {

      const programs = [];

      const isWebGL2 = capabilities.isWebGL2;
      const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
      const floatVertexTextures = capabilities.floatVertexTextures;
      const maxVertexUniforms = capabilities.maxVertexUniforms;
      const vertexTextures = capabilities.vertexTextures;

      let precision = capabilities.precision;

      const shaderIDs = {
          MeshDepthMaterial: 'depth',
          MeshDistanceMaterial: 'distanceRGBA',
          MeshNormalMaterial: 'normal',
          MeshBasicMaterial: 'basic',
          MeshLambertMaterial: 'lambert',
          MeshPhongMaterial: 'phong',
          MeshToonMaterial: 'toon',
          MeshStandardMaterial: 'physical',
          MeshPhysicalMaterial: 'physical',
          MeshMatcapMaterial: 'matcap',
          LineBasicMaterial: 'basic',
          LineDashedMaterial: 'dashed',
          PointsMaterial: 'points',
          ShadowMaterial: 'shadow',
          SpriteMaterial: 'sprite'
      };

      const parameterNames = [
          "precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing",
          "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",
          "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap",
          "roughnessMap", "metalnessMap", "gradientMap",
          "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",
          "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
          "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
          "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
          "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
          "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
          "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
          "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",
          "sheen"
      ];

      function getShaderObject(material, shaderID) {

          let shaderobject;

          if (shaderID) {

              const shader = ShaderLib[shaderID];

              shaderobject = {
                  name: material.name || material.type,
                  uniforms: UniformsUtils.clone(shader.uniforms),
                  vertexShader: shader.vertexShader,
                  fragmentShader: shader.fragmentShader
              };

          } else {

              shaderobject = {
                  name: material.name || material.type,
                  uniforms: material.uniforms,
                  vertexShader: material.vertexShader,
                  fragmentShader: material.fragmentShader
              };

          }

          return shaderobject;

      }

      function allocateBones(object) {

          const skeleton = object.skeleton;
          const bones = skeleton.bones;

          if (floatVertexTextures) {

              return 1024;

          } else {

              // default for when object is not specified
              // ( for example when prebuilding shader to be used with multiple objects )
              //
              //  - leave some extra space for other uniforms
              //  - limit here is ANGLE's 254 max uniform vectors
              //    (up to 54 should be safe)

              const nVertexUniforms = maxVertexUniforms;
              const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);

              const maxBones = Math.min(nVertexMatrices, bones.length);

              if (maxBones < bones.length) {

                  console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                  return 0;

              }

              return maxBones;

          }

      }

      function getTextureEncodingFromMap(map) {

          let encoding;

          if (!map) {

              encoding = LinearEncoding;

          } else if (map.isTexture) {

              encoding = map.encoding;

          } else if (map.isWebGLRenderTarget) {

              console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
              encoding = map.texture.encoding;

          }

          return encoding;

      }

      function getParameters(material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {

          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;

          const envMap = material.envMap || environment;

          const shaderID = shaderIDs[material.type];

          // heuristics to create shader parameters according to lights in the scene
          // (not to blow over maxLights budget)

          const maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;

          if (material.precision !== null) {

              precision = capabilities.getMaxPrecision(material.precision);

              if (precision !== material.precision) {

                  console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');

              }

          }

          const shaderobject = getShaderObject(material, shaderID);
          material.onBeforeCompile(shaderobject, renderer);

          const currentRenderTarget = renderer.getRenderTarget();

          const parameters = {

              isWebGL2: isWebGL2,

              shaderID: shaderID,
              shaderName: shaderobject.name,

              uniforms: shaderobject.uniforms,
              vertexShader: shaderobject.vertexShader,
              fragmentShader: shaderobject.fragmentShader,
              defines: material.defines,

              isRawShaderMaterial: material.isRawShaderMaterial,
              isShaderMaterial: material.isShaderMaterial,

              precision: precision,

              instancing: object.isInstancedMesh === true,

              supportsVertexTextures: vertexTextures,
              outputEncoding: (currentRenderTarget !== null) ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
              map: !!material.map,
              mapEncoding: getTextureEncodingFromMap(material.map),
              matcap: !!material.matcap,
              matcapEncoding: getTextureEncodingFromMap(material.matcap),
              envMap: !!envMap,
              envMapMode: envMap && envMap.mapping,
              envMapEncoding: getTextureEncodingFromMap(envMap),
              envMapCubeUV: (!!envMap) && ((envMap.mapping === CubeUVReflectionMapping) || (envMap.mapping === CubeUVRefractionMapping)),
              lightMap: !!material.lightMap,
              lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
              aoMap: !!material.aoMap,
              emissiveMap: !!material.emissiveMap,
              emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
              bumpMap: !!material.bumpMap,
              normalMap: !!material.normalMap,
              objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
              tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
              clearcoatMap: !!material.clearcoatMap,
              clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
              clearcoatNormalMap: !!material.clearcoatNormalMap,
              displacementMap: !!material.displacementMap,
              roughnessMap: !!material.roughnessMap,
              metalnessMap: !!material.metalnessMap,
              specularMap: !!material.specularMap,
              alphaMap: !!material.alphaMap,

              gradientMap: !!material.gradientMap,

              sheen: !!material.sheen,

              combine: material.combine,

              vertexTangents: (material.normalMap && material.vertexTangents),
              vertexColors: material.vertexColors,
              vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap,
              uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap) && !!material.displacementMap,

              fog: !!fog,
              useFog: material.fog,
              fogExp2: (fog && fog.isFogExp2),

              flatShading: material.flatShading,

              sizeAttenuation: material.sizeAttenuation,
              logarithmicDepthBuffer: logarithmicDepthBuffer,

              skinning: material.skinning && maxBones > 0,
              maxBones: maxBones,
              useVertexTexture: floatVertexTextures,

              morphTargets: material.morphTargets,
              morphNormals: material.morphNormals,
              maxMorphTargets: renderer.maxMorphTargets,
              maxMorphNormals: renderer.maxMorphNormals,

              numDirLights: lights.directional.length,
              numPointLights: lights.point.length,
              numSpotLights: lights.spot.length,
              numRectAreaLights: lights.rectArea.length,
              numHemiLights: lights.hemi.length,

              numDirLightShadows: lights.directionalShadowMap.length,
              numPointLightShadows: lights.pointShadowMap.length,
              numSpotLightShadows: lights.spotShadowMap.length,

              numClippingPlanes: nClipPlanes,
              numClipIntersection: nClipIntersection,

              dithering: material.dithering,

              shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
              shadowMapType: renderer.shadowMap.type,

              toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
              physicallyCorrectLights: renderer.physicallyCorrectLights,

              premultipliedAlpha: material.premultipliedAlpha,

              alphaTest: material.alphaTest,
              doubleSided: material.side === DoubleSide,
              flipSided: material.side === BackSide,

              depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false,

              index0AttributeName: material.index0AttributeName,

              extensionDerivatives: material.extensions && material.extensions.derivatives,
              extensionFragDepth: material.extensions && material.extensions.fragDepth,
              extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
              extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

              rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
              rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
              rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,

              customProgramCacheKey: material.customProgramCacheKey()

          };

          return parameters;

      }

      function getProgramCacheKey(parameters) {

          const array = [];

          if (parameters.shaderID) {

              array.push(parameters.shaderID);

          } else {

              array.push(parameters.fragmentShader);
              array.push(parameters.vertexShader);

          }

          if (parameters.defines !== undefined) {

              for (const name in parameters.defines) {

                  array.push(name);
                  array.push(parameters.defines[name]);

              }

          }

          if (parameters.isRawShaderMaterial === undefined) {

              for (let i = 0; i < parameterNames.length; i++) {

                  array.push(parameters[parameterNames[i]]);

              }

              array.push(renderer.outputEncoding);
              array.push(renderer.gammaFactor);

          }

          array.push(parameters.customProgramCacheKey);

          return array.join();

      }

      function acquireProgram(parameters, cacheKey) {

          let program;

          // Check if code has been already compiled
          for (let p = 0, pl = programs.length; p < pl; p++) {

              const preexistingProgram = programs[p];

              if (preexistingProgram.cacheKey === cacheKey) {

                  program = preexistingProgram;
                  ++program.usedTimes;

                  break;

              }

          }

          if (program === undefined) {

              program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
              programs.push(program);

          }

          return program;

      }

      function releaseProgram(program) {

          if (--program.usedTimes === 0) {

              // Remove from unordered set
              const i = programs.indexOf(program);
              programs[i] = programs[programs.length - 1];
              programs.pop();

              // Free WebGL resources
              program.destroy();

          }

      }

      return {
          getParameters: getParameters,
          getProgramCacheKey: getProgramCacheKey,
          acquireProgram: acquireProgram,
          releaseProgram: releaseProgram,
          // Exposed for resource monitoring & error feedback via renderer.info:
          programs: programs
      };

  }

  /**
   * @author fordacious / fordacious.github.io
   */

  function WebGLProperties() {

      let properties = new WeakMap();

      function get(object) {

          let map = properties.get(object);

          if (map === undefined) {

              map = {};
              properties.set(object, map);

          }

          return map;

      }

      function remove(object) {

          properties.delete(object);

      }

      function update(object, key, value) {

          properties.get(object)[key] = value;

      }

      function dispose() {

          properties = new WeakMap();

      }

      return {
          get: get,
          remove: remove,
          update: update,
          dispose: dispose
      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function painterSortStable(a, b) {

      if (a.groupOrder !== b.groupOrder) {

          return a.groupOrder - b.groupOrder;

      } else if (a.renderOrder !== b.renderOrder) {

          return a.renderOrder - b.renderOrder;

      } else if (a.program !== b.program) {

          return a.program.id - b.program.id;

      } else if (a.material.id !== b.material.id) {

          return a.material.id - b.material.id;

      } else if (a.z !== b.z) {

          return a.z - b.z;

      } else {

          return a.id - b.id;

      }

  }

  function reversePainterSortStable(a, b) {

      if (a.groupOrder !== b.groupOrder) {

          return a.groupOrder - b.groupOrder;

      } else if (a.renderOrder !== b.renderOrder) {

          return a.renderOrder - b.renderOrder;

      } else if (a.z !== b.z) {

          return b.z - a.z;

      } else {

          return a.id - b.id;

      }

  }


  function WebGLRenderList() {

      const renderItems = [];
      let renderItemsIndex = 0;

      const opaque = [];
      const transparent = [];

      const defaultProgram = { id: -1 };

      function init() {

          renderItemsIndex = 0;

          opaque.length = 0;
          transparent.length = 0;

      }

      function getNextRenderItem(object, geometry, material, groupOrder, z, group) {

          let renderItem = renderItems[renderItemsIndex];

          if (renderItem === undefined) {

              renderItem = {
                  id: object.id,
                  object: object,
                  geometry: geometry,
                  material: material,
                  program: material.program || defaultProgram,
                  groupOrder: groupOrder,
                  renderOrder: object.renderOrder,
                  z: z,
                  group: group
              };

              renderItems[renderItemsIndex] = renderItem;

          } else {

              renderItem.id = object.id;
              renderItem.object = object;
              renderItem.geometry = geometry;
              renderItem.material = material;
              renderItem.program = material.program || defaultProgram;
              renderItem.groupOrder = groupOrder;
              renderItem.renderOrder = object.renderOrder;
              renderItem.z = z;
              renderItem.group = group;

          }

          renderItemsIndex++;

          return renderItem;

      }

      function push(object, geometry, material, groupOrder, z, group) {

          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

          (material.transparent === true ? transparent : opaque).push(renderItem);

      }

      function unshift(object, geometry, material, groupOrder, z, group) {

          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

          (material.transparent === true ? transparent : opaque).unshift(renderItem);

      }

      function sort(customOpaqueSort, customTransparentSort) {

          if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
          if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);

      }

      function finish() {

          // Clear references from inactive renderItems in the list

          for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {

              const renderItem = renderItems[i];

              if (renderItem.id === null) break;

              renderItem.id = null;
              renderItem.object = null;
              renderItem.geometry = null;
              renderItem.material = null;
              renderItem.program = null;
              renderItem.group = null;

          }

      }

      return {
          opaque: opaque,
          transparent: transparent,

          init: init,
          push: push,
          unshift: unshift,
          finish: finish,

          sort: sort
      };

  }

  function WebGLRenderLists() {

      let lists = new WeakMap();

      function onSceneDispose(event) {

          const scene = event.target;

          scene.removeEventListener('dispose', onSceneDispose);

          lists.delete(scene);

      }

      function get(scene, camera) {

          const cameras = lists.get(scene);
          let list;

          if (cameras === undefined) {

              list = new WebGLRenderList();
              lists.set(scene, new WeakMap());
              lists.get(scene).set(camera, list);

              scene.addEventListener('dispose', onSceneDispose);

          } else {

              list = cameras.get(camera);
              if (list === undefined) {

                  list = new WebGLRenderList();
                  cameras.set(camera, list);

              }

          }

          return list;

      }

      function dispose() {

          lists = new WeakMap();

      }

      return {
          get: get,
          dispose: dispose
      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function UniformsCache() {

      const lights = {};

      return {

          get: function(light) {

              if (lights[light.id] !== undefined) {

                  return lights[light.id];

              }

              let uniforms;

              switch (light.type) {

                  case 'DirectionalLight':
                      uniforms = {
                          direction: new Vector3(),
                          color: new Color()
                      };
                      break;

                  case 'SpotLight':
                      uniforms = {
                          position: new Vector3(),
                          direction: new Vector3(),
                          color: new Color(),
                          distance: 0,
                          coneCos: 0,
                          penumbraCos: 0,
                          decay: 0
                      };
                      break;

                  case 'PointLight':
                      uniforms = {
                          position: new Vector3(),
                          color: new Color(),
                          distance: 0,
                          decay: 0
                      };
                      break;

                  case 'HemisphereLight':
                      uniforms = {
                          direction: new Vector3(),
                          skyColor: new Color(),
                          groundColor: new Color()
                      };
                      break;

                  case 'RectAreaLight':
                      uniforms = {
                          color: new Color(),
                          position: new Vector3(),
                          halfWidth: new Vector3(),
                          halfHeight: new Vector3()
                      };
                      break;

              }

              lights[light.id] = uniforms;

              return uniforms;

          }

      };

  }

  function ShadowUniformsCache() {

      const lights = {};

      return {

          get: function(light) {

              if (lights[light.id] !== undefined) {

                  return lights[light.id];

              }

              let uniforms;

              switch (light.type) {

                  case 'DirectionalLight':
                      uniforms = {
                          shadowBias: 0,
                          shadowNormalBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new Vector2()
                      };
                      break;

                  case 'SpotLight':
                      uniforms = {
                          shadowBias: 0,
                          shadowNormalBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new Vector2()
                      };
                      break;

                  case 'PointLight':
                      uniforms = {
                          shadowBias: 0,
                          shadowNormalBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new Vector2(),
                          shadowCameraNear: 1,
                          shadowCameraFar: 1000
                      };
                      break;

                      // TODO (abelnation): set RectAreaLight shadow uniforms

              }

              lights[light.id] = uniforms;

              return uniforms;

          }

      };

  }



  let nextVersion = 0;

  function shadowCastingLightsFirst(lightA, lightB) {

      return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);

  }

  function WebGLLights() {

      const cache = new UniformsCache();

      const shadowCache = ShadowUniformsCache();

      const state = {

          version: 0,

          hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,

              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1
          },

          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: []

      };

      for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

      const vector3 = new Vector3();
      const matrix4 = new Matrix4();
      const matrix42 = new Matrix4();

      function setup(lights, shadows, camera) {

          let r = 0,
              g = 0,
              b = 0;

          for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;

          let numDirectionalShadows = 0;
          let numPointShadows = 0;
          let numSpotShadows = 0;

          const viewMatrix = camera.matrixWorldInverse;

          lights.sort(shadowCastingLightsFirst);

          for (let i = 0, l = lights.length; i < l; i++) {

              const light = lights[i];

              const color = light.color;
              const intensity = light.intensity;
              const distance = light.distance;

              const shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;

              if (light.isAmbientLight) {

                  r += color.r * intensity;
                  g += color.g * intensity;
                  b += color.b * intensity;

              } else if (light.isLightProbe) {

                  for (let j = 0; j < 9; j++) {

                      state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);

                  }

              } else if (light.isDirectionalLight) {

                  const uniforms = cache.get(light);

                  uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                  uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                  vector3.setFromMatrixPosition(light.target.matrixWorld);
                  uniforms.direction.sub(vector3);
                  uniforms.direction.transformDirection(viewMatrix);

                  if (light.castShadow) {

                      const shadow = light.shadow;

                      const shadowUniforms = shadowCache.get(light);

                      shadowUniforms.shadowBias = shadow.bias;
                      shadowUniforms.shadowNormalBias = shadow.normalBias;
                      shadowUniforms.shadowRadius = shadow.radius;
                      shadowUniforms.shadowMapSize = shadow.mapSize;

                      state.directionalShadow[directionalLength] = shadowUniforms;
                      state.directionalShadowMap[directionalLength] = shadowMap;
                      state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;

                      numDirectionalShadows++;

                  }

                  state.directional[directionalLength] = uniforms;

                  directionalLength++;

              } else if (light.isSpotLight) {

                  const uniforms = cache.get(light);

                  uniforms.position.setFromMatrixPosition(light.matrixWorld);
                  uniforms.position.applyMatrix4(viewMatrix);

                  uniforms.color.copy(color).multiplyScalar(intensity);
                  uniforms.distance = distance;

                  uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                  vector3.setFromMatrixPosition(light.target.matrixWorld);
                  uniforms.direction.sub(vector3);
                  uniforms.direction.transformDirection(viewMatrix);

                  uniforms.coneCos = Math.cos(light.angle);
                  uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                  uniforms.decay = light.decay;

                  if (light.castShadow) {

                      const shadow = light.shadow;

                      const shadowUniforms = shadowCache.get(light);

                      shadowUniforms.shadowBias = shadow.bias;
                      shadowUniforms.shadowNormalBias = shadow.normalBias;
                      shadowUniforms.shadowRadius = shadow.radius;
                      shadowUniforms.shadowMapSize = shadow.mapSize;

                      state.spotShadow[spotLength] = shadowUniforms;
                      state.spotShadowMap[spotLength] = shadowMap;
                      state.spotShadowMatrix[spotLength] = light.shadow.matrix;

                      numSpotShadows++;

                  }

                  state.spot[spotLength] = uniforms;

                  spotLength++;

              } else if (light.isRectAreaLight) {

                  const uniforms = cache.get(light);

                  // (a) intensity is the total visible light emitted
                  //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

                  // (b) intensity is the brightness of the light
                  uniforms.color.copy(color).multiplyScalar(intensity);

                  uniforms.position.setFromMatrixPosition(light.matrixWorld);
                  uniforms.position.applyMatrix4(viewMatrix);

                  // extract local rotation of light to derive width/height half vectors
                  matrix42.identity();
                  matrix4.copy(light.matrixWorld);
                  matrix4.premultiply(viewMatrix);
                  matrix42.extractRotation(matrix4);

                  uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                  uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

                  uniforms.halfWidth.applyMatrix4(matrix42);
                  uniforms.halfHeight.applyMatrix4(matrix42);

                  // TODO (abelnation): RectAreaLight distance?
                  // uniforms.distance = distance;

                  state.rectArea[rectAreaLength] = uniforms;

                  rectAreaLength++;

              } else if (light.isPointLight) {

                  const uniforms = cache.get(light);

                  uniforms.position.setFromMatrixPosition(light.matrixWorld);
                  uniforms.position.applyMatrix4(viewMatrix);

                  uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                  uniforms.distance = light.distance;
                  uniforms.decay = light.decay;

                  if (light.castShadow) {

                      const shadow = light.shadow;

                      const shadowUniforms = shadowCache.get(light);

                      shadowUniforms.shadowBias = shadow.bias;
                      shadowUniforms.shadowNormalBias = shadow.normalBias;
                      shadowUniforms.shadowRadius = shadow.radius;
                      shadowUniforms.shadowMapSize = shadow.mapSize;
                      shadowUniforms.shadowCameraNear = shadow.camera.near;
                      shadowUniforms.shadowCameraFar = shadow.camera.far;

                      state.pointShadow[pointLength] = shadowUniforms;
                      state.pointShadowMap[pointLength] = shadowMap;
                      state.pointShadowMatrix[pointLength] = light.shadow.matrix;

                      numPointShadows++;

                  }

                  state.point[pointLength] = uniforms;

                  pointLength++;

              } else if (light.isHemisphereLight) {

                  const uniforms = cache.get(light);

                  uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                  uniforms.direction.transformDirection(viewMatrix);
                  uniforms.direction.normalize();

                  uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                  uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

                  state.hemi[hemiLength] = uniforms;

                  hemiLength++;

              }

          }

          state.ambient[0] = r;
          state.ambient[1] = g;
          state.ambient[2] = b;

          const hash = state.hash;

          if (hash.directionalLength !== directionalLength ||
              hash.pointLength !== pointLength ||
              hash.spotLength !== spotLength ||
              hash.rectAreaLength !== rectAreaLength ||
              hash.hemiLength !== hemiLength ||
              hash.numDirectionalShadows !== numDirectionalShadows ||
              hash.numPointShadows !== numPointShadows ||
              hash.numSpotShadows !== numSpotShadows) {

              state.directional.length = directionalLength;
              state.spot.length = spotLength;
              state.rectArea.length = rectAreaLength;
              state.point.length = pointLength;
              state.hemi.length = hemiLength;

              state.directionalShadow.length = numDirectionalShadows;
              state.directionalShadowMap.length = numDirectionalShadows;
              state.pointShadow.length = numPointShadows;
              state.pointShadowMap.length = numPointShadows;
              state.spotShadow.length = numSpotShadows;
              state.spotShadowMap.length = numSpotShadows;
              state.directionalShadowMatrix.length = numDirectionalShadows;
              state.pointShadowMatrix.length = numPointShadows;
              state.spotShadowMatrix.length = numSpotShadows;

              hash.directionalLength = directionalLength;
              hash.pointLength = pointLength;
              hash.spotLength = spotLength;
              hash.rectAreaLength = rectAreaLength;
              hash.hemiLength = hemiLength;

              hash.numDirectionalShadows = numDirectionalShadows;
              hash.numPointShadows = numPointShadows;
              hash.numSpotShadows = numSpotShadows;

              state.version = nextVersion++;

          }

      }

      return {
          setup: setup,
          state: state
      };

  }

  /**
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WebGLRenderState() {

      const lights = new WebGLLights();

      const lightsArray = [];
      const shadowsArray = [];

      function init() {

          lightsArray.length = 0;
          shadowsArray.length = 0;

      }

      function pushLight(light) {

          lightsArray.push(light);

      }

      function pushShadow(shadowLight) {

          shadowsArray.push(shadowLight);

      }

      function setupLights(camera) {

          lights.setup(lightsArray, shadowsArray, camera);

      }

      const state = {
          lightsArray: lightsArray,
          shadowsArray: shadowsArray,

          lights: lights
      };

      return {
          init: init,
          state: state,
          setupLights: setupLights,

          pushLight: pushLight,
          pushShadow: pushShadow
      };

  }

  function WebGLRenderStates() {

      let renderStates = new WeakMap();

      function onSceneDispose(event) {

          const scene = event.target;

          scene.removeEventListener('dispose', onSceneDispose);

          renderStates.delete(scene);

      }

      function get(scene, camera) {

          let renderState;

          if (renderStates.has(scene) === false) {

              renderState = new WebGLRenderState();
              renderStates.set(scene, new WeakMap());
              renderStates.get(scene).set(camera, renderState);

              scene.addEventListener('dispose', onSceneDispose);

          } else {

              if (renderStates.get(scene).has(camera) === false) {

                  renderState = new WebGLRenderState();
                  renderStates.get(scene).set(camera, renderState);

              } else {

                  renderState = renderStates.get(scene).get(camera);

              }

          }

          return renderState;

      }

      function dispose() {

          renderStates = new WeakMap();

      }

      return {
          get: get,
          dispose: dispose
      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / https://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */

  function MeshDepthMaterial(parameters) {

      Material.call(this);

      this.type = 'MeshDepthMaterial';

      this.depthPacking = BasicDepthPacking;

      this.skinning = false;
      this.morphTargets = false;

      this.map = null;

      this.alphaMap = null;

      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;

      this.wireframe = false;
      this.wireframeLinewidth = 1;

      this.fog = false;

      this.setValues(parameters);

  }

  MeshDepthMaterial.prototype = Object.create(Material.prototype);
  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

  MeshDepthMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.depthPacking = source.depthPacking;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;

      this.map = source.map;

      this.alphaMap = source.alphaMap;

      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;

      return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */

  function MeshDistanceMaterial(parameters) {

      Material.call(this);

      this.type = 'MeshDistanceMaterial';

      this.referencePosition = new Vector3();
      this.nearDistance = 1;
      this.farDistance = 1000;

      this.skinning = false;
      this.morphTargets = false;

      this.map = null;

      this.alphaMap = null;

      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;

      this.fog = false;

      this.setValues(parameters);

  }

  MeshDistanceMaterial.prototype = Object.create(Material.prototype);
  MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

  MeshDistanceMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;

      this.map = source.map;

      this.alphaMap = source.alphaMap;

      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;

      return this;

  };

  var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

  var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLShadowMap(_renderer, _objects, maxTextureSize) {

      let _frustum = new Frustum();

      const _shadowMapSize = new Vector2(),
          _viewportSize = new Vector2(),

          _viewport = new Vector4(),

          _depthMaterials = [],
          _distanceMaterials = [],

          _materialCache = {};

      const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

      const shadowMaterialVertical = new ShaderMaterial({

          defines: {
              SAMPLE_RATE: 2.0 / 8.0,
              HALF_SAMPLE_RATE: 1.0 / 8.0
          },

          uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Vector2() },
              radius: { value: 4.0 }
          },

          vertexShader: vsm_vert,

          fragmentShader: vsm_frag

      });

      const shadowMaterialHorizonal = shadowMaterialVertical.clone();
      shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;

      const fullScreenTri = new BufferGeometry();
      fullScreenTri.setAttribute(
          "position",
          new BufferAttribute(
              new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
              3
          )
      );

      const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);

      const scope = this;

      this.enabled = false;

      this.autoUpdate = true;
      this.needsUpdate = false;

      this.type = PCFShadowMap;

      this.render = function(lights, scene, camera) {

          if (scope.enabled === false) return;
          if (scope.autoUpdate === false && scope.needsUpdate === false) return;

          if (lights.length === 0) return;

          const currentRenderTarget = _renderer.getRenderTarget();
          const activeCubeFace = _renderer.getActiveCubeFace();
          const activeMipmapLevel = _renderer.getActiveMipmapLevel();

          const _state = _renderer.state;

          // Set GL state for depth map.
          _state.setBlending(NoBlending);
          _state.buffers.color.setClear(1, 1, 1, 1);
          _state.buffers.depth.setTest(true);
          _state.setScissorTest(false);

          // render depth map

          for (let i = 0, il = lights.length; i < il; i++) {

              const light = lights[i];
              const shadow = light.shadow;

              if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

              if (shadow === undefined) {

                  console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                  continue;

              }

              _shadowMapSize.copy(shadow.mapSize);

              const shadowFrameExtents = shadow.getFrameExtents();

              _shadowMapSize.multiply(shadowFrameExtents);

              _viewportSize.copy(shadow.mapSize);

              if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {

                  if (_shadowMapSize.x > maxTextureSize) {

                      _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                      _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                      shadow.mapSize.x = _viewportSize.x;

                  }

                  if (_shadowMapSize.y > maxTextureSize) {

                      _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                      _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                      shadow.mapSize.y = _viewportSize.y;

                  }

              }

              if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {

                  const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

                  shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                  shadow.map.texture.name = light.name + ".shadowMap";

                  shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);

                  shadow.camera.updateProjectionMatrix();

              }

              if (shadow.map === null) {

                  const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

                  shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                  shadow.map.texture.name = light.name + ".shadowMap";

                  shadow.camera.updateProjectionMatrix();

              }

              _renderer.setRenderTarget(shadow.map);
              _renderer.clear();

              const viewportCount = shadow.getViewportCount();

              for (let vp = 0; vp < viewportCount; vp++) {

                  const viewport = shadow.getViewport(vp);

                  _viewport.set(
                      _viewportSize.x * viewport.x,
                      _viewportSize.y * viewport.y,
                      _viewportSize.x * viewport.z,
                      _viewportSize.y * viewport.w
                  );

                  _state.viewport(_viewport);

                  shadow.updateMatrices(light, vp);

                  _frustum = shadow.getFrustum();

                  renderObject(scene, camera, shadow.camera, light, this.type);

              }

              // do blur pass for VSM

              if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {

                  VSMPass(shadow, camera);

              }

              shadow.needsUpdate = false;

          }

          scope.needsUpdate = false;

          _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);

      };

      function VSMPass(shadow, camera) {

          const geometry = _objects.update(fullScreenMesh);

          // vertical pass

          shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
          shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialVertical.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.mapPass);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

          // horizonal pass

          shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
          shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.map);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);

      }

      function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {

          const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

          let material = _depthMaterials[index];

          if (material === undefined) {

              material = new MeshDepthMaterial({

                  depthPacking: RGBADepthPacking,

                  morphTargets: useMorphing,
                  skinning: useSkinning

              });

              _depthMaterials[index] = material;

          }

          return material;

      }

      function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {

          const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

          let material = _distanceMaterials[index];

          if (material === undefined) {

              material = new MeshDistanceMaterial({

                  morphTargets: useMorphing,
                  skinning: useSkinning

              });

              _distanceMaterials[index] = material;

          }

          return material;

      }

      function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {

          let result = null;

          let getMaterialVariant = getDepthMaterialVariant;
          let customMaterial = object.customDepthMaterial;

          if (light.isPointLight === true) {

              getMaterialVariant = getDistanceMaterialVariant;
              customMaterial = object.customDistanceMaterial;

          }

          if (customMaterial === undefined) {

              let useMorphing = false;

              if (material.morphTargets === true) {

                  useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

              }

              let useSkinning = false;

              if (object.isSkinnedMesh === true) {

                  if (material.skinning === true) {

                      useSkinning = true;

                  } else {

                      console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);

                  }

              }

              const useInstancing = object.isInstancedMesh === true;

              result = getMaterialVariant(useMorphing, useSkinning, useInstancing);

          } else {

              result = customMaterial;

          }

          if (_renderer.localClippingEnabled &&
              material.clipShadows === true &&
              material.clippingPlanes.length !== 0) {

              // in this case we need a unique material instance reflecting the
              // appropriate state

              const keyA = result.uuid,
                  keyB = material.uuid;

              let materialsForVariant = _materialCache[keyA];

              if (materialsForVariant === undefined) {

                  materialsForVariant = {};
                  _materialCache[keyA] = materialsForVariant;

              }

              let cachedMaterial = materialsForVariant[keyB];

              if (cachedMaterial === undefined) {

                  cachedMaterial = result.clone();
                  materialsForVariant[keyB] = cachedMaterial;

              }

              result = cachedMaterial;

          }

          result.visible = material.visible;
          result.wireframe = material.wireframe;

          if (type === VSMShadowMap) {

              result.side = (material.shadowSide !== null) ? material.shadowSide : material.side;

          } else {

              result.side = (material.shadowSide !== null) ? material.shadowSide : shadowSide[material.side];

          }

          result.clipShadows = material.clipShadows;
          result.clippingPlanes = material.clippingPlanes;
          result.clipIntersection = material.clipIntersection;

          result.wireframeLinewidth = material.wireframeLinewidth;
          result.linewidth = material.linewidth;

          if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {

              result.referencePosition.setFromMatrixPosition(light.matrixWorld);
              result.nearDistance = shadowCameraNear;
              result.farDistance = shadowCameraFar;

          }

          return result;

      }

      function renderObject(object, camera, shadowCamera, light, type) {

          if (object.visible === false) return;

          const visible = object.layers.test(camera.layers);

          if (visible && (object.isMesh || object.isLine || object.isPoints)) {

              if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap)) && (!object.frustumCulled || _frustum.intersectsObject(object))) {

                  object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

                  const geometry = _objects.update(object);
                  const material = object.material;

                  if (Array.isArray(material)) {

                      const groups = geometry.groups;

                      for (let k = 0, kl = groups.length; k < kl; k++) {

                          const group = groups[k];
                          const groupMaterial = material[group.materialIndex];

                          if (groupMaterial && groupMaterial.visible) {

                              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

                              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);

                          }

                      }

                  } else if (material.visible) {

                      const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

                      _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);

                  }

              }

          }

          const children = object.children;

          for (let i = 0, l = children.length; i < l; i++) {

              renderObject(children[i], camera, shadowCamera, light, type);

          }

      }

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLState(gl, extensions, capabilities) {

      const isWebGL2 = capabilities.isWebGL2;

      function ColorBuffer() {

          let locked = false;

          const color = new Vector4();
          let currentColorMask = null;
          const currentColorClear = new Vector4(0, 0, 0, 0);

          return {

              setMask: function(colorMask) {

                  if (currentColorMask !== colorMask && !locked) {

                      gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                      currentColorMask = colorMask;

                  }

              },

              setLocked: function(lock) {

                  locked = lock;

              },

              setClear: function(r, g, b, a, premultipliedAlpha) {

                  if (premultipliedAlpha === true) {

                      r *= a;
                      g *= a;
                      b *= a;

                  }

                  color.set(r, g, b, a);

                  if (currentColorClear.equals(color) === false) {

                      gl.clearColor(r, g, b, a);
                      currentColorClear.copy(color);

                  }

              },

              reset: function() {

                  locked = false;

                  currentColorMask = null;
                  currentColorClear.set(-1, 0, 0, 0); // set to invalid state

              }

          };

      }

      function DepthBuffer() {

          let locked = false;

          let currentDepthMask = null;
          let currentDepthFunc = null;
          let currentDepthClear = null;

          return {

              setTest: function(depthTest) {

                  if (depthTest) {

                      enable(2929);

                  } else {

                      disable(2929);

                  }

              },

              setMask: function(depthMask) {

                  if (currentDepthMask !== depthMask && !locked) {

                      gl.depthMask(depthMask);
                      currentDepthMask = depthMask;

                  }

              },

              setFunc: function(depthFunc) {

                  if (currentDepthFunc !== depthFunc) {

                      if (depthFunc) {

                          switch (depthFunc) {

                              case NeverDepth:

                                  gl.depthFunc(512);
                                  break;

                              case AlwaysDepth:

                                  gl.depthFunc(519);
                                  break;

                              case LessDepth:

                                  gl.depthFunc(513);
                                  break;

                              case LessEqualDepth:

                                  gl.depthFunc(515);
                                  break;

                              case EqualDepth:

                                  gl.depthFunc(514);
                                  break;

                              case GreaterEqualDepth:

                                  gl.depthFunc(518);
                                  break;

                              case GreaterDepth:

                                  gl.depthFunc(516);
                                  break;

                              case NotEqualDepth:

                                  gl.depthFunc(517);
                                  break;

                              default:

                                  gl.depthFunc(515);

                          }

                      } else {

                          gl.depthFunc(515);

                      }

                      currentDepthFunc = depthFunc;

                  }

              },

              setLocked: function(lock) {

                  locked = lock;

              },

              setClear: function(depth) {

                  if (currentDepthClear !== depth) {

                      gl.clearDepth(depth);
                      currentDepthClear = depth;

                  }

              },

              reset: function() {

                  locked = false;

                  currentDepthMask = null;
                  currentDepthFunc = null;
                  currentDepthClear = null;

              }

          };

      }

      function StencilBuffer() {

          let locked = false;

          let currentStencilMask = null;
          let currentStencilFunc = null;
          let currentStencilRef = null;
          let currentStencilFuncMask = null;
          let currentStencilFail = null;
          let currentStencilZFail = null;
          let currentStencilZPass = null;
          let currentStencilClear = null;

          return {

              setTest: function(stencilTest) {

                  if (!locked) {

                      if (stencilTest) {

                          enable(2960);

                      } else {

                          disable(2960);

                      }

                  }

              },

              setMask: function(stencilMask) {

                  if (currentStencilMask !== stencilMask && !locked) {

                      gl.stencilMask(stencilMask);
                      currentStencilMask = stencilMask;

                  }

              },

              setFunc: function(stencilFunc, stencilRef, stencilMask) {

                  if (currentStencilFunc !== stencilFunc ||
                      currentStencilRef !== stencilRef ||
                      currentStencilFuncMask !== stencilMask) {

                      gl.stencilFunc(stencilFunc, stencilRef, stencilMask);

                      currentStencilFunc = stencilFunc;
                      currentStencilRef = stencilRef;
                      currentStencilFuncMask = stencilMask;

                  }

              },

              setOp: function(stencilFail, stencilZFail, stencilZPass) {

                  if (currentStencilFail !== stencilFail ||
                      currentStencilZFail !== stencilZFail ||
                      currentStencilZPass !== stencilZPass) {

                      gl.stencilOp(stencilFail, stencilZFail, stencilZPass);

                      currentStencilFail = stencilFail;
                      currentStencilZFail = stencilZFail;
                      currentStencilZPass = stencilZPass;

                  }

              },

              setLocked: function(lock) {

                  locked = lock;

              },

              setClear: function(stencil) {

                  if (currentStencilClear !== stencil) {

                      gl.clearStencil(stencil);
                      currentStencilClear = stencil;

                  }

              },

              reset: function() {

                  locked = false;

                  currentStencilMask = null;
                  currentStencilFunc = null;
                  currentStencilRef = null;
                  currentStencilFuncMask = null;
                  currentStencilFail = null;
                  currentStencilZFail = null;
                  currentStencilZPass = null;
                  currentStencilClear = null;

              }

          };

      }

      //

      const colorBuffer = new ColorBuffer();
      const depthBuffer = new DepthBuffer();
      const stencilBuffer = new StencilBuffer();

      let enabledCapabilities = {};

      let currentProgram = null;

      let currentBlendingEnabled = null;
      let currentBlending = null;
      let currentBlendEquation = null;
      let currentBlendSrc = null;
      let currentBlendDst = null;
      let currentBlendEquationAlpha = null;
      let currentBlendSrcAlpha = null;
      let currentBlendDstAlpha = null;
      let currentPremultipledAlpha = false;

      let currentFlipSided = null;
      let currentCullFace = null;

      let currentLineWidth = null;

      let currentPolygonOffsetFactor = null;
      let currentPolygonOffsetUnits = null;

      const maxTextures = gl.getParameter(35661);

      let lineWidthAvailable = false;
      let version = 0;
      const glVersion = gl.getParameter(7938);

      if (glVersion.indexOf('WebGL') !== -1) {

          version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
          lineWidthAvailable = (version >= 1.0);

      } else if (glVersion.indexOf('OpenGL ES') !== -1) {

          version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
          lineWidthAvailable = (version >= 2.0);

      }

      let currentTextureSlot = null;
      let currentBoundTextures = {};

      const currentScissor = new Vector4();
      const currentViewport = new Vector4();

      function createTexture(type, target, count) {

          const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
          const texture = gl.createTexture();

          gl.bindTexture(type, texture);
          gl.texParameteri(type, 10241, 9728);
          gl.texParameteri(type, 10240, 9728);

          for (let i = 0; i < count; i++) {

              gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);

          }

          return texture;

      }

      const emptyTextures = {};
      emptyTextures[3553] = createTexture(3553, 3553, 1);
      emptyTextures[34067] = createTexture(34067, 34069, 6);

      // init

      colorBuffer.setClear(0, 0, 0, 1);
      depthBuffer.setClear(1);
      stencilBuffer.setClear(0);

      enable(2929);
      depthBuffer.setFunc(LessEqualDepth);

      setFlipSided(false);
      setCullFace(CullFaceBack);
      enable(2884);

      setBlending(NoBlending);

      //

      function enable(id) {

          if (enabledCapabilities[id] !== true) {

              gl.enable(id);
              enabledCapabilities[id] = true;

          }

      }

      function disable(id) {

          if (enabledCapabilities[id] !== false) {

              gl.disable(id);
              enabledCapabilities[id] = false;

          }

      }

      function useProgram(program) {

          if (currentProgram !== program) {

              gl.useProgram(program);

              currentProgram = program;

              return true;

          }

          return false;

      }

      const equationToGL = {
          [AddEquation]: 32774,
          [SubtractEquation]: 32778,
          [ReverseSubtractEquation]: 32779
      };

      if (isWebGL2) {

          equationToGL[MinEquation] = 32775;
          equationToGL[MaxEquation] = 32776;

      } else {

          const extension = extensions.get('EXT_blend_minmax');

          if (extension !== null) {

              equationToGL[MinEquation] = extension.MIN_EXT;
              equationToGL[MaxEquation] = extension.MAX_EXT;

          }

      }

      const factorToGL = {
          [ZeroFactor]: 0,
          [OneFactor]: 1,
          [SrcColorFactor]: 768,
          [SrcAlphaFactor]: 770,
          [SrcAlphaSaturateFactor]: 776,
          [DstColorFactor]: 774,
          [DstAlphaFactor]: 772,
          [OneMinusSrcColorFactor]: 769,
          [OneMinusSrcAlphaFactor]: 771,
          [OneMinusDstColorFactor]: 775,
          [OneMinusDstAlphaFactor]: 773
      };

      function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {

          if (blending === NoBlending) {

              if (currentBlendingEnabled) {

                  disable(3042);
                  currentBlendingEnabled = false;

              }

              return;

          }

          if (!currentBlendingEnabled) {

              enable(3042);
              currentBlendingEnabled = true;

          }

          if (blending !== CustomBlending) {

              if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {

                  if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {

                      gl.blendEquation(32774);

                      currentBlendEquation = AddEquation;
                      currentBlendEquationAlpha = AddEquation;

                  }

                  if (premultipliedAlpha) {

                      switch (blending) {

                          case NormalBlending:
                              gl.blendFuncSeparate(1, 771, 1, 771);
                              break;

                          case AdditiveBlending:
                              gl.blendFunc(1, 1);
                              break;

                          case SubtractiveBlending:
                              gl.blendFuncSeparate(0, 0, 769, 771);
                              break;

                          case MultiplyBlending:
                              gl.blendFuncSeparate(0, 768, 0, 770);
                              break;

                          default:
                              console.error('THREE.WebGLState: Invalid blending: ', blending);
                              break;

                      }

                  } else {

                      switch (blending) {

                          case NormalBlending:
                              gl.blendFuncSeparate(770, 771, 1, 771);
                              break;

                          case AdditiveBlending:
                              gl.blendFunc(770, 1);
                              break;

                          case SubtractiveBlending:
                              gl.blendFunc(0, 769);
                              break;

                          case MultiplyBlending:
                              gl.blendFunc(0, 768);
                              break;

                          default:
                              console.error('THREE.WebGLState: Invalid blending: ', blending);
                              break;

                      }

                  }

                  currentBlendSrc = null;
                  currentBlendDst = null;
                  currentBlendSrcAlpha = null;
                  currentBlendDstAlpha = null;

                  currentBlending = blending;
                  currentPremultipledAlpha = premultipliedAlpha;

              }

              return;

          }

          // custom blending

          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;

          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {

              gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);

              currentBlendEquation = blendEquation;
              currentBlendEquationAlpha = blendEquationAlpha;

          }

          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {

              gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);

              currentBlendSrc = blendSrc;
              currentBlendDst = blendDst;
              currentBlendSrcAlpha = blendSrcAlpha;
              currentBlendDstAlpha = blendDstAlpha;

          }

          currentBlending = blending;
          currentPremultipledAlpha = null;

      }

      function setMaterial(material, frontFaceCW) {

          material.side === DoubleSide ?
              disable(2884) :
              enable(2884);

          let flipSided = (material.side === BackSide);
          if (frontFaceCW) flipSided = !flipSided;

          setFlipSided(flipSided);

          (material.blending === NormalBlending && material.transparent === false) ?
          setBlending(NoBlending): setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);

          depthBuffer.setFunc(material.depthFunc);
          depthBuffer.setTest(material.depthTest);
          depthBuffer.setMask(material.depthWrite);
          colorBuffer.setMask(material.colorWrite);

          const stencilWrite = material.stencilWrite;
          stencilBuffer.setTest(stencilWrite);
          if (stencilWrite) {

              stencilBuffer.setMask(material.stencilWriteMask);
              stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
              stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);

          }

          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);

      }

      //

      function setFlipSided(flipSided) {

          if (currentFlipSided !== flipSided) {

              if (flipSided) {

                  gl.frontFace(2304);

              } else {

                  gl.frontFace(2305);

              }

              currentFlipSided = flipSided;

          }

      }

      function setCullFace(cullFace) {

          if (cullFace !== CullFaceNone) {

              enable(2884);

              if (cullFace !== currentCullFace) {

                  if (cullFace === CullFaceBack) {

                      gl.cullFace(1029);

                  } else if (cullFace === CullFaceFront) {

                      gl.cullFace(1028);

                  } else {

                      gl.cullFace(1032);

                  }

              }

          } else {

              disable(2884);

          }

          currentCullFace = cullFace;

      }

      function setLineWidth(width) {

          if (width !== currentLineWidth) {

              if (lineWidthAvailable) gl.lineWidth(width);

              currentLineWidth = width;

          }

      }

      function setPolygonOffset(polygonOffset, factor, units) {

          if (polygonOffset) {

              enable(32823);

              if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {

                  gl.polygonOffset(factor, units);

                  currentPolygonOffsetFactor = factor;
                  currentPolygonOffsetUnits = units;

              }

          } else {

              disable(32823);

          }

      }

      function setScissorTest(scissorTest) {

          if (scissorTest) {

              enable(3089);

          } else {

              disable(3089);

          }

      }

      // texture

      function activeTexture(webglSlot) {

          if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

          if (currentTextureSlot !== webglSlot) {

              gl.activeTexture(webglSlot);
              currentTextureSlot = webglSlot;

          }

      }

      function bindTexture(webglType, webglTexture) {

          if (currentTextureSlot === null) {

              activeTexture();

          }

          let boundTexture = currentBoundTextures[currentTextureSlot];

          if (boundTexture === undefined) {

              boundTexture = { type: undefined, texture: undefined };
              currentBoundTextures[currentTextureSlot] = boundTexture;

          }

          if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {

              gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);

              boundTexture.type = webglType;
              boundTexture.texture = webglTexture;

          }

      }

      function unbindTexture() {

          const boundTexture = currentBoundTextures[currentTextureSlot];

          if (boundTexture !== undefined && boundTexture.type !== undefined) {

              gl.bindTexture(boundTexture.type, null);

              boundTexture.type = undefined;
              boundTexture.texture = undefined;

          }

      }

      function compressedTexImage2D() {

          try {

              gl.compressedTexImage2D.apply(gl, arguments);

          } catch (error) {

              console.error('THREE.WebGLState:', error);

          }

      }

      function texImage2D() {

          try {

              gl.texImage2D.apply(gl, arguments);

          } catch (error) {

              console.error('THREE.WebGLState:', error);

          }

      }

      function texImage3D() {

          try {

              gl.texImage3D.apply(gl, arguments);

          } catch (error) {

              console.error('THREE.WebGLState:', error);

          }

      }

      //

      function scissor(scissor) {

          if (currentScissor.equals(scissor) === false) {

              gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
              currentScissor.copy(scissor);

          }

      }

      function viewport(viewport) {

          if (currentViewport.equals(viewport) === false) {

              gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
              currentViewport.copy(viewport);

          }

      }

      //

      function reset() {

          enabledCapabilities = {};

          currentTextureSlot = null;
          currentBoundTextures = {};

          currentProgram = null;

          currentBlending = null;

          currentFlipSided = null;
          currentCullFace = null;

          colorBuffer.reset();
          depthBuffer.reset();
          stencilBuffer.reset();

      }

      return {

          buffers: {
              color: colorBuffer,
              depth: depthBuffer,
              stencil: stencilBuffer
          },

          enable: enable,
          disable: disable,

          useProgram: useProgram,

          setBlending: setBlending,
          setMaterial: setMaterial,

          setFlipSided: setFlipSided,
          setCullFace: setCullFace,

          setLineWidth: setLineWidth,
          setPolygonOffset: setPolygonOffset,

          setScissorTest: setScissorTest,

          activeTexture: activeTexture,
          bindTexture: bindTexture,
          unbindTexture: unbindTexture,
          compressedTexImage2D: compressedTexImage2D,
          texImage2D: texImage2D,
          texImage3D: texImage3D,

          scissor: scissor,
          viewport: viewport,

          reset: reset

      };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {

      const isWebGL2 = capabilities.isWebGL2;
      const maxTextures = capabilities.maxTextures;
      const maxCubemapSize = capabilities.maxCubemapSize;
      const maxTextureSize = capabilities.maxTextureSize;
      const maxSamples = capabilities.maxSamples;

      const _videoTextures = new WeakMap();
      let _canvas;

      // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
      // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
      // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

      let useOffscreenCanvas = false;

      try {

          useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' &&
              (new OffscreenCanvas(1, 1).getContext("2d")) !== null;

      } catch (err) {

          // Ignore any errors

      }

      function createCanvas(width, height) {

          // Use OffscreenCanvas when available. Specially needed in web workers

          return useOffscreenCanvas ?
              new OffscreenCanvas(width, height) :
              document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');

      }

      function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {

          let scale = 1;

          // handle case if texture exceeds max size

          if (image.width > maxSize || image.height > maxSize) {

              scale = maxSize / Math.max(image.width, image.height);

          }

          // only perform resize if necessary

          if (scale < 1 || needsPowerOfTwo === true) {

              // only perform resize for certain image types

              if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
                  (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
                  (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {

                  const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

                  const width = floor(scale * image.width);
                  const height = floor(scale * image.height);

                  if (_canvas === undefined) _canvas = createCanvas(width, height);

                  // cube textures can't reuse the same canvas

                  const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;

                  canvas.width = width;
                  canvas.height = height;

                  const context = canvas.getContext('2d');
                  context.drawImage(image, 0, 0, width, height);

                  console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');

                  return canvas;

              } else {

                  if ('data' in image) {

                      console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');

                  }

                  return image;

              }

          }

          return image;

      }

      function isPowerOfTwo(image) {

          return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);

      }

      function textureNeedsPowerOfTwo(texture) {

          if (isWebGL2) return false;

          return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) ||
              (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);

      }

      function textureNeedsGenerateMipmaps(texture, supportsMips) {

          return texture.generateMipmaps && supportsMips &&
              texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

      }

      function generateMipmap(target, texture, width, height) {

          _gl.generateMipmap(target);

          const textureProperties = properties.get(texture);

          // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
          textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;

      }

      function getInternalFormat(internalFormatName, glFormat, glType) {

          if (isWebGL2 === false) return glFormat;

          if (internalFormatName !== null) {

              if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];

              console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');

          }

          let internalFormat = glFormat;

          if (glFormat === 6403) {

              if (glType === 5126) internalFormat = 33326;
              if (glType === 5131) internalFormat = 33325;
              if (glType === 5121) internalFormat = 33321;

          }

          if (glFormat === 6407) {

              if (glType === 5126) internalFormat = 34837;
              if (glType === 5131) internalFormat = 34843;
              if (glType === 5121) internalFormat = 32849;

          }

          if (glFormat === 6408) {

              if (glType === 5126) internalFormat = 34836;
              if (glType === 5131) internalFormat = 34842;
              if (glType === 5121) internalFormat = 32856;

          }

          if (internalFormat === 33325 || internalFormat === 33326 ||
              internalFormat === 34842 || internalFormat === 34836) {

              extensions.get('EXT_color_buffer_float');

          }

          return internalFormat;

      }

      // Fallback filters for non-power-of-2 textures

      function filterFallback(f) {

          if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {

              return 9728;

          }

          return 9729;

      }

      //

      function onTextureDispose(event) {

          const texture = event.target;

          texture.removeEventListener('dispose', onTextureDispose);

          deallocateTexture(texture);

          if (texture.isVideoTexture) {

              _videoTextures.delete(texture);

          }

          info.memory.textures--;

      }

      function onRenderTargetDispose(event) {

          const renderTarget = event.target;

          renderTarget.removeEventListener('dispose', onRenderTargetDispose);

          deallocateRenderTarget(renderTarget);

          info.memory.textures--;

      }

      //

      function deallocateTexture(texture) {

          const textureProperties = properties.get(texture);

          if (textureProperties.__webglInit === undefined) return;

          _gl.deleteTexture(textureProperties.__webglTexture);

          properties.remove(texture);

      }

      function deallocateRenderTarget(renderTarget) {

          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(renderTarget.texture);

          if (!renderTarget) return;

          if (textureProperties.__webglTexture !== undefined) {

              _gl.deleteTexture(textureProperties.__webglTexture);

          }

          if (renderTarget.depthTexture) {

              renderTarget.depthTexture.dispose();

          }

          if (renderTarget.isWebGLCubeRenderTarget) {

              for (let i = 0; i < 6; i++) {

                  _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                  if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);

              }

          } else {

              _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
              if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
              if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
              if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
              if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);

          }

          properties.remove(renderTarget.texture);
          properties.remove(renderTarget);

      }

      //

      let textureUnits = 0;

      function resetTextureUnits() {

          textureUnits = 0;

      }

      function allocateTextureUnit() {

          const textureUnit = textureUnits;

          if (textureUnit >= maxTextures) {

              console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);

          }

          textureUnits += 1;

          return textureUnit;

      }

      //

      function setTexture2D(texture, slot) {

          const textureProperties = properties.get(texture);

          if (texture.isVideoTexture) updateVideoTexture(texture);

          if (texture.version > 0 && textureProperties.__version !== texture.version) {

              const image = texture.image;

              if (image === undefined) {

                  console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');

              } else if (image.complete === false) {

                  console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');

              } else {

                  uploadTexture(textureProperties, texture, slot);
                  return;

              }

          }

          state.activeTexture(33984 + slot);
          state.bindTexture(3553, textureProperties.__webglTexture);

      }

      function setTexture2DArray(texture, slot) {

          const textureProperties = properties.get(texture);

          if (texture.version > 0 && textureProperties.__version !== texture.version) {

              uploadTexture(textureProperties, texture, slot);
              return;

          }

          state.activeTexture(33984 + slot);
          state.bindTexture(35866, textureProperties.__webglTexture);

      }

      function setTexture3D(texture, slot) {

          const textureProperties = properties.get(texture);

          if (texture.version > 0 && textureProperties.__version !== texture.version) {

              uploadTexture(textureProperties, texture, slot);
              return;

          }

          state.activeTexture(33984 + slot);
          state.bindTexture(32879, textureProperties.__webglTexture);

      }

      function setTextureCube(texture, slot) {

          if (texture.image.length !== 6) return;

          const textureProperties = properties.get(texture);

          if (texture.version > 0 && textureProperties.__version !== texture.version) {

              initTexture(textureProperties, texture);

              state.activeTexture(33984 + slot);
              state.bindTexture(34067, textureProperties.__webglTexture);

              _gl.pixelStorei(37440, texture.flipY);

              const isCompressed = (texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture));
              const isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);

              const cubeImage = [];

              for (let i = 0; i < 6; i++) {

                  if (!isCompressed && !isDataTexture) {

                      cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);

                  } else {

                      cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];

                  }

              }

              const image = cubeImage[0],
                  supportsMips = isPowerOfTwo(image) || isWebGL2,
                  glFormat = utils.convert(texture.format),
                  glType = utils.convert(texture.type),
                  glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

              setTextureParameters(34067, texture, supportsMips);

              let mipmaps;

              if (isCompressed) {

                  for (let i = 0; i < 6; i++) {

                      mipmaps = cubeImage[i].mipmaps;

                      for (let j = 0; j < mipmaps.length; j++) {

                          const mipmap = mipmaps[j];

                          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

                              if (glFormat !== null) {

                                  state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);

                              } else {

                                  console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');

                              }

                          } else {

                              state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

                          }

                      }

                  }

                  textureProperties.__maxMipLevel = mipmaps.length - 1;

              } else {

                  mipmaps = texture.mipmaps;

                  for (let i = 0; i < 6; i++) {

                      if (isDataTexture) {

                          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

                          for (let j = 0; j < mipmaps.length; j++) {

                              const mipmap = mipmaps[j];
                              const mipmapImage = mipmap.image[i].image;

                              state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);

                          }

                      } else {

                          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

                          for (let j = 0; j < mipmaps.length; j++) {

                              const mipmap = mipmaps[j];

                              state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);

                          }

                      }

                  }

                  textureProperties.__maxMipLevel = mipmaps.length;

              }

              if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

                  // We assume images for cube map have the same size.
                  generateMipmap(34067, texture, image.width, image.height);

              }

              textureProperties.__version = texture.version;

              if (texture.onUpdate) texture.onUpdate(texture);

          } else {

              state.activeTexture(33984 + slot);
              state.bindTexture(34067, textureProperties.__webglTexture);

          }

      }

      function setTextureCubeDynamic(texture, slot) {

          state.activeTexture(33984 + slot);
          state.bindTexture(34067, properties.get(texture).__webglTexture);

      }

      const wrappingToGL = {
          [RepeatWrapping]: 10497,
          [ClampToEdgeWrapping]: 33071,
          [MirroredRepeatWrapping]: 33648
      };

      const filterToGL = {
          [NearestFilter]: 9728,
          [NearestMipmapNearestFilter]: 9984,
          [NearestMipmapLinearFilter]: 9986,

          [LinearFilter]: 9729,
          [LinearMipmapNearestFilter]: 9985,
          [LinearMipmapLinearFilter]: 9987
      };

      function setTextureParameters(textureType, texture, supportsMips) {

          if (supportsMips) {

              _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
              _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);

              if (textureType === 32879 || textureType === 35866) {

                  _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);

              }

              _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
              _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);

          } else {

              _gl.texParameteri(textureType, 10242, 33071);
              _gl.texParameteri(textureType, 10243, 33071);

              if (textureType === 32879 || textureType === 35866) {

                  _gl.texParameteri(textureType, 32882, 33071);

              }

              if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {

                  console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');

              }

              _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
              _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

              if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {

                  console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');

              }

          }

          const extension = extensions.get('EXT_texture_filter_anisotropic');

          if (extension) {

              if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
              if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

              if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {

                  _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                  properties.get(texture).__currentAnisotropy = texture.anisotropy;

              }

          }

      }

      function initTexture(textureProperties, texture) {

          if (textureProperties.__webglInit === undefined) {

              textureProperties.__webglInit = true;

              texture.addEventListener('dispose', onTextureDispose);

              textureProperties.__webglTexture = _gl.createTexture();

              info.memory.textures++;

          }

      }

      function uploadTexture(textureProperties, texture, slot) {

          let textureType = 3553;

          if (texture.isDataTexture2DArray) textureType = 35866;
          if (texture.isDataTexture3D) textureType = 32879;

          initTexture(textureProperties, texture);

          state.activeTexture(33984 + slot);
          state.bindTexture(textureType, textureProperties.__webglTexture);

          _gl.pixelStorei(37440, texture.flipY);
          _gl.pixelStorei(37441, texture.premultiplyAlpha);
          _gl.pixelStorei(3317, texture.unpackAlignment);

          const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
          const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);

          const supportsMips = isPowerOfTwo(image) || isWebGL2,
              glFormat = utils.convert(texture.format);

          let glType = utils.convert(texture.type),
              glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

          setTextureParameters(textureType, texture, supportsMips);

          let mipmap;
          const mipmaps = texture.mipmaps;

          if (texture.isDepthTexture) {

              // populate depth texture with dummy data

              glInternalFormat = 6402;

              if (isWebGL2) {

                  if (texture.type === FloatType) {

                      glInternalFormat = 36012;

                  } else if (texture.type === UnsignedIntType) {

                      glInternalFormat = 33190;

                  } else if (texture.type === UnsignedInt248Type) {

                      glInternalFormat = 35056;

                  } else {

                      glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

                  }

              } else {

                  if (texture.type === FloatType) {

                      console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');

                  }

              }

              // validation checks for WebGL 1

              if (texture.format === DepthFormat && glInternalFormat === 6402) {

                  // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                  // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                  if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {

                      console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');

                      texture.type = UnsignedShortType;
                      glType = utils.convert(texture.type);

                  }

              }

              if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {

                  // Depth stencil textures need the DEPTH_STENCIL internal format
                  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                  glInternalFormat = 34041;

                  // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                  // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                  if (texture.type !== UnsignedInt248Type) {

                      console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');

                      texture.type = UnsignedInt248Type;
                      glType = utils.convert(texture.type);

                  }

              }

              //

              state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);

          } else if (texture.isDataTexture) {

              // use manually created mipmaps if available
              // if there are no manual mipmaps
              // set 0 level mipmap and then use GL to generate other mipmap levels

              if (mipmaps.length > 0 && supportsMips) {

                  for (let i = 0, il = mipmaps.length; i < il; i++) {

                      mipmap = mipmaps[i];
                      state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

                  }

                  texture.generateMipmaps = false;
                  textureProperties.__maxMipLevel = mipmaps.length - 1;

              } else {

                  state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                  textureProperties.__maxMipLevel = 0;

              }

          } else if (texture.isCompressedTexture) {

              for (let i = 0, il = mipmaps.length; i < il; i++) {

                  mipmap = mipmaps[i];

                  if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

                      if (glFormat !== null) {

                          state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);

                      } else {

                          console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');

                      }

                  } else {

                      state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

                  }

              }

              textureProperties.__maxMipLevel = mipmaps.length - 1;

          } else if (texture.isDataTexture2DArray) {

              state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
              textureProperties.__maxMipLevel = 0;

          } else if (texture.isDataTexture3D) {

              state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
              textureProperties.__maxMipLevel = 0;

          } else {

              // regular Texture (image, video, canvas)

              // use manually created mipmaps if available
              // if there are no manual mipmaps
              // set 0 level mipmap and then use GL to generate other mipmap levels

              if (mipmaps.length > 0 && supportsMips) {

                  for (let i = 0, il = mipmaps.length; i < il; i++) {

                      mipmap = mipmaps[i];
                      state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);

                  }

                  texture.generateMipmaps = false;
                  textureProperties.__maxMipLevel = mipmaps.length - 1;

              } else {

                  state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
                  textureProperties.__maxMipLevel = 0;

              }

          }

          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

              generateMipmap(textureType, texture, image.width, image.height);

          }

          textureProperties.__version = texture.version;

          if (texture.onUpdate) texture.onUpdate(texture);

      }

      // Render targets

      // Setup storage for target texture and bind it to correct framebuffer
      function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {

          const glFormat = utils.convert(renderTarget.texture.format);
          const glType = utils.convert(renderTarget.texture.type);
          const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
          state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
          _gl.bindFramebuffer(36160, framebuffer);
          _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
          _gl.bindFramebuffer(36160, null);

      }

      // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
      function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {

          _gl.bindRenderbuffer(36161, renderbuffer);

          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {

              let glInternalFormat = 33189;

              if (isMultisample) {

                  const depthTexture = renderTarget.depthTexture;

                  if (depthTexture && depthTexture.isDepthTexture) {

                      if (depthTexture.type === FloatType) {

                          glInternalFormat = 36012;

                      } else if (depthTexture.type === UnsignedIntType) {

                          glInternalFormat = 33190;

                      }

                  }

                  const samples = getRenderTargetSamples(renderTarget);

                  _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

              } else {

                  _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);

              }

              _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);

          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {

              if (isMultisample) {

                  const samples = getRenderTargetSamples(renderTarget);

                  _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);

              } else {

                  _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);

              }


              _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);

          } else {

              const glFormat = utils.convert(renderTarget.texture.format);
              const glType = utils.convert(renderTarget.texture.type);
              const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);

              if (isMultisample) {

                  const samples = getRenderTargetSamples(renderTarget);

                  _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

              } else {

                  _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);

              }

          }

          _gl.bindRenderbuffer(36161, null);

      }

      // Setup resources for a Depth Texture for a FBO (needs an extension)
      function setupDepthTexture(framebuffer, renderTarget) {

          const isCube = (renderTarget && renderTarget.isWebGLCubeRenderTarget);
          if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

          _gl.bindFramebuffer(36160, framebuffer);

          if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {

              throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

          }

          // upload an empty depth texture with framebuffer size
          if (!properties.get(renderTarget.depthTexture).__webglTexture ||
              renderTarget.depthTexture.image.width !== renderTarget.width ||
              renderTarget.depthTexture.image.height !== renderTarget.height) {

              renderTarget.depthTexture.image.width = renderTarget.width;
              renderTarget.depthTexture.image.height = renderTarget.height;
              renderTarget.depthTexture.needsUpdate = true;

          }

          setTexture2D(renderTarget.depthTexture, 0);

          const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

          if (renderTarget.depthTexture.format === DepthFormat) {

              _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);

          } else if (renderTarget.depthTexture.format === DepthStencilFormat) {

              _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);

          } else {

              throw new Error('Unknown depthTexture format');

          }

      }

      // Setup GL resources for a non-texture depth buffer
      function setupDepthRenderbuffer(renderTarget) {

          const renderTargetProperties = properties.get(renderTarget);

          const isCube = (renderTarget.isWebGLCubeRenderTarget === true);

          if (renderTarget.depthTexture) {

              if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');

              setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);

          } else {

              if (isCube) {

                  renderTargetProperties.__webglDepthbuffer = [];

                  for (let i = 0; i < 6; i++) {

                      _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
                      renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                      setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);

                  }

              } else {

                  _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
                  renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                  setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);

              }

          }

          _gl.bindFramebuffer(36160, null);

      }

      // Set up GL resources for the render target
      function setupRenderTarget(renderTarget) {

          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(renderTarget.texture);

          renderTarget.addEventListener('dispose', onRenderTargetDispose);

          textureProperties.__webglTexture = _gl.createTexture();

          info.memory.textures++;

          const isCube = (renderTarget.isWebGLCubeRenderTarget === true);
          const isMultisample = (renderTarget.isWebGLMultisampleRenderTarget === true);
          const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

          // Handles WebGL2 RGBFormat fallback - #18858

          if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {

              renderTarget.texture.format = RGBAFormat;

              console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');

          }

          // Setup framebuffer

          if (isCube) {

              renderTargetProperties.__webglFramebuffer = [];

              for (let i = 0; i < 6; i++) {

                  renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();

              }

          } else {

              renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

              if (isMultisample) {

                  if (isWebGL2) {

                      renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                      renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

                      _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

                      const glFormat = utils.convert(renderTarget.texture.format);
                      const glType = utils.convert(renderTarget.texture.type);
                      const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                      const samples = getRenderTargetSamples(renderTarget);
                      _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

                      _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                      _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                      _gl.bindRenderbuffer(36161, null);

                      if (renderTarget.depthBuffer) {

                          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);

                      }

                      _gl.bindFramebuffer(36160, null);


                  } else {

                      console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');

                  }

              }

          }

          // Setup color buffer

          if (isCube) {

              state.bindTexture(34067, textureProperties.__webglTexture);
              setTextureParameters(34067, renderTarget.texture, supportsMips);

              for (let i = 0; i < 6; i++) {

                  setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);

              }

              if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {

                  generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);

              }

              state.bindTexture(34067, null);

          } else {

              state.bindTexture(3553, textureProperties.__webglTexture);
              setTextureParameters(3553, renderTarget.texture, supportsMips);
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

              if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {

                  generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);

              }

              state.bindTexture(3553, null);

          }

          // Setup depth and stencil buffers

          if (renderTarget.depthBuffer) {

              setupDepthRenderbuffer(renderTarget);

          }

      }

      function updateRenderTargetMipmap(renderTarget) {

          const texture = renderTarget.texture;
          const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

              const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
              const webglTexture = properties.get(texture).__webglTexture;

              state.bindTexture(target, webglTexture);
              generateMipmap(target, texture, renderTarget.width, renderTarget.height);
              state.bindTexture(target, null);

          }

      }

      function updateMultisampleRenderTarget(renderTarget) {

          if (renderTarget.isWebGLMultisampleRenderTarget) {

              if (isWebGL2) {

                  const renderTargetProperties = properties.get(renderTarget);

                  _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                  _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

                  const width = renderTarget.width;
                  const height = renderTarget.height;
                  let mask = 16384;

                  if (renderTarget.depthBuffer) mask |= 256;
                  if (renderTarget.stencilBuffer) mask |= 1024;

                  _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);

                  _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905

              } else {

                  console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');

              }

          }

      }

      function getRenderTargetSamples(renderTarget) {

          return (isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget) ?
              Math.min(maxSamples, renderTarget.samples) : 0;

      }

      function updateVideoTexture(texture) {

          const frame = info.render.frame;

          // Check the last frame we updated the VideoTexture

          if (_videoTextures.get(texture) !== frame) {

              _videoTextures.set(texture, frame);
              texture.update();

          }

      }

      // backwards compatibility

      let warnedTexture2D = false;
      let warnedTextureCube = false;

      function safeSetTexture2D(texture, slot) {

          if (texture && texture.isWebGLRenderTarget) {

              if (warnedTexture2D === false) {

                  console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
                  warnedTexture2D = true;

              }

              texture = texture.texture;

          }

          setTexture2D(texture, slot);

      }

      function safeSetTextureCube(texture, slot) {

          if (texture && texture.isWebGLCubeRenderTarget) {

              if (warnedTextureCube === false) {

                  console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                  warnedTextureCube = true;

              }

              texture = texture.texture;

          }

          // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
          // TODO: unify these code paths
          if ((texture && texture.isCubeTexture) ||
              (Array.isArray(texture.image) && texture.image.length === 6)) {

              // CompressedTexture can have Array in image :/

              // this function alone should take care of cube textures
              setTextureCube(texture, slot);

          } else {

              // assumed: texture property of THREE.WebGLCubeRenderTarget
              setTextureCubeDynamic(texture, slot);

          }

      }

      //

      this.allocateTextureUnit = allocateTextureUnit;
      this.resetTextureUnits = resetTextureUnits;

      this.setTexture2D = setTexture2D;
      this.setTexture2DArray = setTexture2DArray;
      this.setTexture3D = setTexture3D;
      this.setTextureCube = setTextureCube;
      this.setTextureCubeDynamic = setTextureCubeDynamic;
      this.setupRenderTarget = setupRenderTarget;
      this.updateRenderTargetMipmap = updateRenderTargetMipmap;
      this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

      this.safeSetTexture2D = safeSetTexture2D;
      this.safeSetTextureCube = safeSetTextureCube;

  }

  /**
   * @author thespite / http://www.twitter.com/thespite
   */

  function WebGLUtils(gl, extensions, capabilities) {

      const isWebGL2 = capabilities.isWebGL2;

      function convert(p) {

          let extension;

          if (p === UnsignedByteType) return 5121;
          if (p === UnsignedShort4444Type) return 32819;
          if (p === UnsignedShort5551Type) return 32820;
          if (p === UnsignedShort565Type) return 33635;

          if (p === ByteType) return 5120;
          if (p === ShortType) return 5122;
          if (p === UnsignedShortType) return 5123;
          if (p === IntType) return 5124;
          if (p === UnsignedIntType) return 5125;
          if (p === FloatType) return 5126;

          if (p === HalfFloatType) {

              if (isWebGL2) return 5131;

              extension = extensions.get('OES_texture_half_float');

              if (extension !== null) {

                  return extension.HALF_FLOAT_OES;

              } else {

                  return null;

              }

          }

          if (p === AlphaFormat) return 6406;
          if (p === RGBFormat) return 6407;
          if (p === RGBAFormat) return 6408;
          if (p === LuminanceFormat) return 6409;
          if (p === LuminanceAlphaFormat) return 6410;
          if (p === DepthFormat) return 6402;
          if (p === DepthStencilFormat) return 34041;
          if (p === RedFormat) return 6403;

          // WebGL2 formats.

          if (p === RedIntegerFormat) return 36244;
          if (p === RGFormat) return 33319;
          if (p === RGIntegerFormat) return 33320;
          if (p === RGBIntegerFormat) return 36248;
          if (p === RGBAIntegerFormat) return 36249;

          if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
              p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {

              extension = extensions.get('WEBGL_compressed_texture_s3tc');

              if (extension !== null) {

                  if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

              } else {

                  return null;

              }

          }

          if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
              p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {

              extension = extensions.get('WEBGL_compressed_texture_pvrtc');

              if (extension !== null) {

                  if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                  if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                  if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                  if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

              } else {

                  return null;

              }

          }

          if (p === RGB_ETC1_Format) {

              extension = extensions.get('WEBGL_compressed_texture_etc1');

              if (extension !== null) {

                  return extension.COMPRESSED_RGB_ETC1_WEBGL;

              } else {

                  return null;

              }

          }

          if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {

              extension = extensions.get('WEBGL_compressed_texture_etc');

              if (extension !== null) {

                  if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                  if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;

              }

          }

          if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
              p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
              p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
              p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
              p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
              p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
              p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
              p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
              p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
              p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {

              extension = extensions.get('WEBGL_compressed_texture_astc');

              if (extension !== null) {

                  // TODO Complete?

                  return p;

              } else {

                  return null;

              }

          }

          if (p === RGBA_BPTC_Format) {

              extension = extensions.get('EXT_texture_compression_bptc');

              if (extension !== null) {

                  // TODO Complete?

                  return p;

              } else {

                  return null;

              }

          }

          if (p === UnsignedInt248Type) {

              if (isWebGL2) return 34042;

              extension = extensions.get('WEBGL_depth_texture');

              if (extension !== null) {

                  return extension.UNSIGNED_INT_24_8_WEBGL;

              } else {

                  return null;

              }

          }

      }

      return { convert: convert };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ArrayCamera(array) {

      PerspectiveCamera.call(this);

      this.cameras = array || [];

  }

  ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {

      constructor: ArrayCamera,

      isArrayCamera: true

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Group() {

      Object3D.call(this);

      this.type = 'Group';

  }

  Group.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Group,

      isGroup: true

  });

  /**
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WebXRController() {

      this._targetRay = null;
      this._grip = null;

  }

  Object.assign(WebXRController.prototype, {

      constructor: WebXRController,

      getTargetRaySpace: function() {

          if (this._targetRay === null) {

              this._targetRay = new Group();
              this._targetRay.matrixAutoUpdate = false;
              this._targetRay.visible = false;

          }

          return this._targetRay;

      },

      getGripSpace: function() {

          if (this._grip === null) {

              this._grip = new Group();
              this._grip.matrixAutoUpdate = false;
              this._grip.visible = false;

          }

          return this._grip;

      },

      dispatchEvent: function(event) {

          if (this._targetRay !== null) {

              this._targetRay.dispatchEvent(event);

          }

          if (this._grip !== null) {

              this._grip.dispatchEvent(event);

          }

          return this;

      },

      disconnect: function(inputSource) {

          this.dispatchEvent({ type: 'disconnected', data: inputSource });

          if (this._targetRay !== null) {

              this._targetRay.visible = false;

          }

          if (this._grip !== null) {

              this._grip.visible = false;

          }

          return this;

      },

      update: function(inputSource, frame, referenceSpace) {

          let inputPose = null;
          let gripPose = null;

          const targetRay = this._targetRay;
          const grip = this._grip;

          if (inputSource) {

              if (targetRay !== null) {

                  inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

                  if (inputPose !== null) {

                      targetRay.matrix.fromArray(inputPose.transform.matrix);
                      targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

                  }

              }

              if (grip !== null && inputSource.gripSpace) {

                  gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

                  if (gripPose !== null) {

                      grip.matrix.fromArray(gripPose.transform.matrix);
                      grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

                  }

              }

          }

          if (targetRay !== null) {

              targetRay.visible = (inputPose !== null);

          }

          if (grip !== null) {

              grip.visible = (gripPose !== null);

          }

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebXRManager(renderer, gl) {

      const scope = this;

      let session = null;

      let framebufferScaleFactor = 1.0;

      let referenceSpace = null;
      let referenceSpaceType = 'local-floor';

      let pose = null;

      const controllers = [];
      const inputSourcesMap = new Map();

      //

      const cameraL = new PerspectiveCamera();
      cameraL.layers.enable(1);
      cameraL.viewport = new Vector4();

      const cameraR = new PerspectiveCamera();
      cameraR.layers.enable(2);
      cameraR.viewport = new Vector4();

      const cameras = [cameraL, cameraR];

      const cameraVR = new ArrayCamera();
      cameraVR.layers.enable(1);
      cameraVR.layers.enable(2);

      let _currentDepthNear = null;
      let _currentDepthFar = null;

      //

      this.enabled = false;

      this.isPresenting = false;

      this.getController = function(index) {

          let controller = controllers[index];

          if (controller === undefined) {

              controller = new WebXRController();
              controllers[index] = controller;

          }

          return controller.getTargetRaySpace();

      };

      this.getControllerGrip = function(index) {

          let controller = controllers[index];

          if (controller === undefined) {

              controller = new WebXRController();
              controllers[index] = controller;

          }

          return controller.getGripSpace();

      };

      //

      function onSessionEvent(event) {

          const controller = inputSourcesMap.get(event.inputSource);

          if (controller) {

              controller.dispatchEvent({ type: event.type });

          }

      }

      function onSessionEnd() {

          inputSourcesMap.forEach(function(controller, inputSource) {

              controller.disconnect(inputSource);

          });

          inputSourcesMap.clear();

          //

          renderer.setFramebuffer(null);
          renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830
          animation.stop();

          scope.isPresenting = false;

          scope.dispatchEvent({ type: 'sessionend' });

      }

      function onRequestReferenceSpace(value) {

          referenceSpace = value;

          animation.setContext(session);
          animation.start();

          scope.isPresenting = true;

          scope.dispatchEvent({ type: 'sessionstart' });

      }

      this.setFramebufferScaleFactor = function(value) {

          framebufferScaleFactor = value;

          if (scope.isPresenting === true) {

              console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');

          }

      };

      this.setReferenceSpaceType = function(value) {

          referenceSpaceType = value;

          if (scope.isPresenting === true) {

              console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');

          }

      };

      this.getReferenceSpace = function() {

          return referenceSpace;

      };

      this.getSession = function() {

          return session;

      };

      this.setSession = function(value) {

          session = value;

          if (session !== null) {

              session.addEventListener('select', onSessionEvent);
              session.addEventListener('selectstart', onSessionEvent);
              session.addEventListener('selectend', onSessionEvent);
              session.addEventListener('squeeze', onSessionEvent);
              session.addEventListener('squeezestart', onSessionEvent);
              session.addEventListener('squeezeend', onSessionEvent);
              session.addEventListener('end', onSessionEnd);

              const attributes = gl.getContextAttributes();

              if (attributes.xrCompatible !== true) {

                  gl.makeXRCompatible();

              }

              const layerInit = {
                  antialias: attributes.antialias,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor: framebufferScaleFactor
              };

              // eslint-disable-next-line no-undef
              const baseLayer = new XRWebGLLayer(session, gl, layerInit);

              session.updateRenderState({ baseLayer: baseLayer });

              session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);

              //

              session.addEventListener('inputsourceschange', updateInputSources);

          }

      };

      function updateInputSources(event) {

          const inputSources = session.inputSources;

          // Assign inputSources to available controllers

          for (let i = 0; i < controllers.length; i++) {

              inputSourcesMap.set(inputSources[i], controllers[i]);

          }

          // Notify disconnected

          for (let i = 0; i < event.removed.length; i++) {

              const inputSource = event.removed[i];
              const controller = inputSourcesMap.get(inputSource);

              if (controller) {

                  controller.dispatchEvent({ type: 'disconnected', data: inputSource });
                  inputSourcesMap.delete(inputSource);

              }

          }

          // Notify connected

          for (let i = 0; i < event.added.length; i++) {

              const inputSource = event.added[i];
              const controller = inputSourcesMap.get(inputSource);

              if (controller) {

                  controller.dispatchEvent({ type: 'connected', data: inputSource });

              }

          }

      }

      //

      const cameraLPos = new Vector3();
      const cameraRPos = new Vector3();

      /**
       * @author jsantell / https://www.jsantell.com/
       *
       * Assumes 2 cameras that are parallel and share an X-axis, and that
       * the cameras' projection and world matrices have already been set.
       * And that near and far planes are identical for both cameras.
       * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
       */
      function setProjectionFromUnion(camera, cameraL, cameraR) {

          cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
          cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);

          const ipd = cameraLPos.distanceTo(cameraRPos);

          const projL = cameraL.projectionMatrix.elements;
          const projR = cameraR.projectionMatrix.elements;

          // VR systems will have identical far and near planes, and
          // most likely identical top and bottom frustum extents.
          // Use the left camera for these values.
          const near = projL[14] / (projL[10] - 1);
          const far = projL[14] / (projL[10] + 1);
          const topFov = (projL[9] + 1) / projL[5];
          const bottomFov = (projL[9] - 1) / projL[5];

          const leftFov = (projL[8] - 1) / projL[0];
          const rightFov = (projR[8] + 1) / projR[0];
          const left = near * leftFov;
          const right = near * rightFov;

          // Calculate the new camera's position offset from the
          // left camera. xOffset should be roughly half `ipd`.
          const zOffset = ipd / (-leftFov + rightFov);
          const xOffset = zOffset * -leftFov;

          // TODO: Better way to apply this offset?
          cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
          camera.translateX(xOffset);
          camera.translateZ(zOffset);
          camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
          camera.matrixWorldInverse.getInverse(camera.matrixWorld);

          // Find the union of the frustum values of the cameras and scale
          // the values so that the near plane's position does not change in world space,
          // although must now be relative to the new union camera.
          const near2 = near + zOffset;
          const far2 = far + zOffset;
          const left2 = left - xOffset;
          const right2 = right + (ipd - xOffset);
          const top2 = topFov * far / far2 * near2;
          const bottom2 = bottomFov * far / far2 * near2;

          camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);

      }

      function updateCamera(camera, parent) {

          if (parent === null) {

              camera.matrixWorld.copy(camera.matrix);

          } else {

              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);

          }

          camera.matrixWorldInverse.getInverse(camera.matrixWorld);

      }

      this.getCamera = function(camera) {

          cameraVR.near = cameraR.near = cameraL.near = camera.near;
          cameraVR.far = cameraR.far = cameraL.far = camera.far;

          if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {

              // Note that the new renderState won't apply until the next frame. See #18320

              session.updateRenderState({
                  depthNear: cameraVR.near,
                  depthFar: cameraVR.far
              });

              _currentDepthNear = cameraVR.near;
              _currentDepthFar = cameraVR.far;

          }

          const parent = camera.parent;
          const cameras = cameraVR.cameras;

          updateCamera(cameraVR, parent);

          for (let i = 0; i < cameras.length; i++) {

              updateCamera(cameras[i], parent);

          }

          // update camera and its children

          camera.matrixWorld.copy(cameraVR.matrixWorld);

          const children = camera.children;

          for (let i = 0, l = children.length; i < l; i++) {

              children[i].updateMatrixWorld(true);

          }

          // update projection matrix for proper view frustum culling

          if (cameras.length === 2) {

              setProjectionFromUnion(cameraVR, cameraL, cameraR);

          } else {

              // assume single camera setup (AR)

              cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);

          }

          return cameraVR;

      };

      // Animation Loop

      let onAnimationFrameCallback = null;

      function onAnimationFrame(time, frame) {

          pose = frame.getViewerPose(referenceSpace);

          if (pose !== null) {

              const views = pose.views;
              const baseLayer = session.renderState.baseLayer;

              renderer.setFramebuffer(baseLayer.framebuffer);

              let cameraVRNeedsUpdate = false;

              // check if it's necessary to rebuild cameraVR's camera list

              if (views.length !== cameraVR.cameras.length) {

                  cameraVR.cameras.length = 0;
                  cameraVRNeedsUpdate = true;

              }

              for (let i = 0; i < views.length; i++) {

                  const view = views[i];
                  const viewport = baseLayer.getViewport(view);

                  const camera = cameras[i];
                  camera.matrix.fromArray(view.transform.matrix);
                  camera.projectionMatrix.fromArray(view.projectionMatrix);
                  camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

                  if (i === 0) {

                      cameraVR.matrix.copy(camera.matrix);

                  }

                  if (cameraVRNeedsUpdate === true) {

                      cameraVR.cameras.push(camera);

                  }

              }

          }

          //

          const inputSources = session.inputSources;

          for (let i = 0; i < controllers.length; i++) {

              const controller = controllers[i];
              const inputSource = inputSources[i];

              controller.update(inputSource, frame, referenceSpace);

          }

          if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);

      }

      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);

      this.setAnimationLoop = function(callback) {

          onAnimationFrameCallback = callback;

      };

      this.dispose = function() {};

  }

  Object.assign(WebXRManager.prototype, EventDispatcher.prototype);

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLMaterials(properties) {

      function refreshFogUniforms(uniforms, fog) {

          uniforms.fogColor.value.copy(fog.color);

          if (fog.isFog) {

              uniforms.fogNear.value = fog.near;
              uniforms.fogFar.value = fog.far;

          } else if (fog.isFogExp2) {

              uniforms.fogDensity.value = fog.density;

          }

      }

      function refreshMaterialUniforms(uniforms, material, environment, pixelRatio, height) {

          if (material.isMeshBasicMaterial) {

              refreshUniformsCommon(uniforms, material);

          } else if (material.isMeshLambertMaterial) {

              refreshUniformsCommon(uniforms, material);
              refreshUniformsLambert(uniforms, material);

          } else if (material.isMeshToonMaterial) {

              refreshUniformsCommon(uniforms, material);
              refreshUniformsToon(uniforms, material);

          } else if (material.isMeshPhongMaterial) {

              refreshUniformsCommon(uniforms, material);
              refreshUniformsPhong(uniforms, material);

          } else if (material.isMeshStandardMaterial) {

              refreshUniformsCommon(uniforms, material, environment);

              if (material.isMeshPhysicalMaterial) {

                  refreshUniformsPhysical(uniforms, material, environment);

              } else {

                  refreshUniformsStandard(uniforms, material, environment);

              }

          } else if (material.isMeshMatcapMaterial) {

              refreshUniformsCommon(uniforms, material);
              refreshUniformsMatcap(uniforms, material);

          } else if (material.isMeshDepthMaterial) {

              refreshUniformsCommon(uniforms, material);
              refreshUniformsDepth(uniforms, material);

          } else if (material.isMeshDistanceMaterial) {

              refreshUniformsCommon(uniforms, material);
              refreshUniformsDistance(uniforms, material);

          } else if (material.isMeshNormalMaterial) {

              refreshUniformsCommon(uniforms, material);
              refreshUniformsNormal(uniforms, material);

          } else if (material.isLineBasicMaterial) {

              refreshUniformsLine(uniforms, material);

              if (material.isLineDashedMaterial) {

                  refreshUniformsDash(uniforms, material);

              }

          } else if (material.isPointsMaterial) {

              refreshUniformsPoints(uniforms, material, pixelRatio, height);

          } else if (material.isSpriteMaterial) {

              refreshUniformsSprites(uniforms, material);

          } else if (material.isShadowMaterial) {

              uniforms.color.value.copy(material.color);
              uniforms.opacity.value = material.opacity;

          } else if (material.isShaderMaterial) {

              material.uniformsNeedUpdate = false; // #15581

          }

      }

      function refreshUniformsCommon(uniforms, material, environment) {

          uniforms.opacity.value = material.opacity;

          if (material.color) {

              uniforms.diffuse.value.copy(material.color);

          }

          if (material.emissive) {

              uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);

          }

          if (material.map) {

              uniforms.map.value = material.map;

          }

          if (material.alphaMap) {

              uniforms.alphaMap.value = material.alphaMap;

          }

          if (material.specularMap) {

              uniforms.specularMap.value = material.specularMap;

          }

          const envMap = material.envMap || environment;

          if (envMap) {

              uniforms.envMap.value = envMap;

              uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;

              uniforms.reflectivity.value = material.reflectivity;
              uniforms.refractionRatio.value = material.refractionRatio;

              uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;

          }

          if (material.lightMap) {

              uniforms.lightMap.value = material.lightMap;
              uniforms.lightMapIntensity.value = material.lightMapIntensity;

          }

          if (material.aoMap) {

              uniforms.aoMap.value = material.aoMap;
              uniforms.aoMapIntensity.value = material.aoMapIntensity;

          }

          // uv repeat and offset setting priorities
          // 1. color map
          // 2. specular map
          // 3. normal map
          // 4. bump map
          // 5. alpha map
          // 6. emissive map

          let uvScaleMap;

          if (material.map) {

              uvScaleMap = material.map;

          } else if (material.specularMap) {

              uvScaleMap = material.specularMap;

          } else if (material.displacementMap) {

              uvScaleMap = material.displacementMap;

          } else if (material.normalMap) {

              uvScaleMap = material.normalMap;

          } else if (material.bumpMap) {

              uvScaleMap = material.bumpMap;

          } else if (material.roughnessMap) {

              uvScaleMap = material.roughnessMap;

          } else if (material.metalnessMap) {

              uvScaleMap = material.metalnessMap;

          } else if (material.alphaMap) {

              uvScaleMap = material.alphaMap;

          } else if (material.emissiveMap) {

              uvScaleMap = material.emissiveMap;

          }

          if (uvScaleMap !== undefined) {

              // backwards compatibility
              if (uvScaleMap.isWebGLRenderTarget) {

                  uvScaleMap = uvScaleMap.texture;

              }

              if (uvScaleMap.matrixAutoUpdate === true) {

                  uvScaleMap.updateMatrix();

              }

              uniforms.uvTransform.value.copy(uvScaleMap.matrix);

          }

          // uv repeat and offset setting priorities for uv2
          // 1. ao map
          // 2. light map

          let uv2ScaleMap;

          if (material.aoMap) {

              uv2ScaleMap = material.aoMap;

          } else if (material.lightMap) {

              uv2ScaleMap = material.lightMap;

          }

          if (uv2ScaleMap !== undefined) {

              // backwards compatibility
              if (uv2ScaleMap.isWebGLRenderTarget) {

                  uv2ScaleMap = uv2ScaleMap.texture;

              }

              if (uv2ScaleMap.matrixAutoUpdate === true) {

                  uv2ScaleMap.updateMatrix();

              }

              uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);

          }

      }

      function refreshUniformsLine(uniforms, material) {

          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;

      }

      function refreshUniformsDash(uniforms, material) {

          uniforms.dashSize.value = material.dashSize;
          uniforms.totalSize.value = material.dashSize + material.gapSize;
          uniforms.scale.value = material.scale;

      }

      function refreshUniformsPoints(uniforms, material, pixelRatio, height) {

          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.size.value = material.size * pixelRatio;
          uniforms.scale.value = height * 0.5;

          if (material.map) {

              uniforms.map.value = material.map;

          }

          if (material.alphaMap) {

              uniforms.alphaMap.value = material.alphaMap;

          }

          // uv repeat and offset setting priorities
          // 1. color map
          // 2. alpha map

          let uvScaleMap;

          if (material.map) {

              uvScaleMap = material.map;

          } else if (material.alphaMap) {

              uvScaleMap = material.alphaMap;

          }

          if (uvScaleMap !== undefined) {

              if (uvScaleMap.matrixAutoUpdate === true) {

                  uvScaleMap.updateMatrix();

              }

              uniforms.uvTransform.value.copy(uvScaleMap.matrix);

          }

      }

      function refreshUniformsSprites(uniforms, material) {

          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.rotation.value = material.rotation;

          if (material.map) {

              uniforms.map.value = material.map;

          }

          if (material.alphaMap) {

              uniforms.alphaMap.value = material.alphaMap;

          }

          // uv repeat and offset setting priorities
          // 1. color map
          // 2. alpha map

          let uvScaleMap;

          if (material.map) {

              uvScaleMap = material.map;

          } else if (material.alphaMap) {

              uvScaleMap = material.alphaMap;

          }

          if (uvScaleMap !== undefined) {

              if (uvScaleMap.matrixAutoUpdate === true) {

                  uvScaleMap.updateMatrix();

              }

              uniforms.uvTransform.value.copy(uvScaleMap.matrix);

          }

      }

      function refreshUniformsLambert(uniforms, material) {

          if (material.emissiveMap) {

              uniforms.emissiveMap.value = material.emissiveMap;

          }

      }

      function refreshUniformsPhong(uniforms, material) {

          uniforms.specular.value.copy(material.specular);
          uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

          if (material.emissiveMap) {

              uniforms.emissiveMap.value = material.emissiveMap;

          }

          if (material.bumpMap) {

              uniforms.bumpMap.value = material.bumpMap;
              uniforms.bumpScale.value = material.bumpScale;
              if (material.side === BackSide) uniforms.bumpScale.value *= -1;

          }

          if (material.normalMap) {

              uniforms.normalMap.value = material.normalMap;
              uniforms.normalScale.value.copy(material.normalScale);
              if (material.side === BackSide) uniforms.normalScale.value.negate();

          }

          if (material.displacementMap) {

              uniforms.displacementMap.value = material.displacementMap;
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;

          }

      }

      function refreshUniformsToon(uniforms, material) {

          if (material.gradientMap) {

              uniforms.gradientMap.value = material.gradientMap;

          }

          if (material.emissiveMap) {

              uniforms.emissiveMap.value = material.emissiveMap;

          }

          if (material.bumpMap) {

              uniforms.bumpMap.value = material.bumpMap;
              uniforms.bumpScale.value = material.bumpScale;
              if (material.side === BackSide) uniforms.bumpScale.value *= -1;

          }

          if (material.normalMap) {

              uniforms.normalMap.value = material.normalMap;
              uniforms.normalScale.value.copy(material.normalScale);
              if (material.side === BackSide) uniforms.normalScale.value.negate();

          }

          if (material.displacementMap) {

              uniforms.displacementMap.value = material.displacementMap;
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;

          }

      }

      function refreshUniformsStandard(uniforms, material, environment) {

          uniforms.roughness.value = material.roughness;
          uniforms.metalness.value = material.metalness;

          if (material.roughnessMap) {

              uniforms.roughnessMap.value = material.roughnessMap;

          }

          if (material.metalnessMap) {

              uniforms.metalnessMap.value = material.metalnessMap;

          }

          if (material.emissiveMap) {

              uniforms.emissiveMap.value = material.emissiveMap;

          }

          if (material.bumpMap) {

              uniforms.bumpMap.value = material.bumpMap;
              uniforms.bumpScale.value = material.bumpScale;
              if (material.side === BackSide) uniforms.bumpScale.value *= -1;

          }

          if (material.normalMap) {

              uniforms.normalMap.value = material.normalMap;
              uniforms.normalScale.value.copy(material.normalScale);
              if (material.side === BackSide) uniforms.normalScale.value.negate();

          }

          if (material.displacementMap) {

              uniforms.displacementMap.value = material.displacementMap;
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;

          }

          if (material.envMap || environment) {

              //uniforms.envMap.value = material.envMap; // part of uniforms common
              uniforms.envMapIntensity.value = material.envMapIntensity;

          }

      }

      function refreshUniformsPhysical(uniforms, material, environment) {

          refreshUniformsStandard(uniforms, material, environment);

          uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

          uniforms.clearcoat.value = material.clearcoat;
          uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
          if (material.sheen) uniforms.sheen.value.copy(material.sheen);

          if (material.clearcoatMap) {

              uniforms.clearcoatMap.value = material.clearcoatMap;

          }

          if (material.clearcoatRoughnessMap) {

              uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

          }

          if (material.clearcoatNormalMap) {

              uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
              uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

              if (material.side === BackSide) {

                  uniforms.clearcoatNormalScale.value.negate();

              }

          }

          uniforms.transparency.value = material.transparency;

      }

      function refreshUniformsMatcap(uniforms, material) {

          if (material.matcap) {

              uniforms.matcap.value = material.matcap;

          }

          if (material.bumpMap) {

              uniforms.bumpMap.value = material.bumpMap;
              uniforms.bumpScale.value = material.bumpScale;
              if (material.side === BackSide) uniforms.bumpScale.value *= -1;

          }

          if (material.normalMap) {

              uniforms.normalMap.value = material.normalMap;
              uniforms.normalScale.value.copy(material.normalScale);
              if (material.side === BackSide) uniforms.normalScale.value.negate();

          }

          if (material.displacementMap) {

              uniforms.displacementMap.value = material.displacementMap;
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;

          }

      }

      function refreshUniformsDepth(uniforms, material) {

          if (material.displacementMap) {

              uniforms.displacementMap.value = material.displacementMap;
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;

          }

      }

      function refreshUniformsDistance(uniforms, material) {

          if (material.displacementMap) {

              uniforms.displacementMap.value = material.displacementMap;
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;

          }

          uniforms.referencePosition.value.copy(material.referencePosition);
          uniforms.nearDistance.value = material.nearDistance;
          uniforms.farDistance.value = material.farDistance;

      }

      function refreshUniformsNormal(uniforms, material) {

          if (material.bumpMap) {

              uniforms.bumpMap.value = material.bumpMap;
              uniforms.bumpScale.value = material.bumpScale;
              if (material.side === BackSide) uniforms.bumpScale.value *= -1;

          }

          if (material.normalMap) {

              uniforms.normalMap.value = material.normalMap;
              uniforms.normalScale.value.copy(material.normalScale);
              if (material.side === BackSide) uniforms.normalScale.value.negate();

          }

          if (material.displacementMap) {

              uniforms.displacementMap.value = material.displacementMap;
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;

          }

      }

      return {
          refreshFogUniforms: refreshFogUniforms,
          refreshMaterialUniforms: refreshMaterialUniforms
      };

  }

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   * @author tschw
   */

  function WebGLRenderer(parameters) {

      parameters = parameters || {};

      const _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
          _context = parameters.context !== undefined ? parameters.context : null,

          _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
          _depth = parameters.depth !== undefined ? parameters.depth : true,
          _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
          _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
          _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
          _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
          _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
          _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

      let currentRenderList = null;
      let currentRenderState = null;

      // public properties

      this.domElement = _canvas;

      // Debug configuration container
      this.debug = {

          /**
           * Enables error checking and reporting when shader programs are being compiled
           * @type {boolean}
           */
          checkShaderErrors: true
      };

      // clearing

      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;

      // scene graph

      this.sortObjects = true;

      // user-defined clipping

      this.clippingPlanes = [];
      this.localClippingEnabled = false;

      // physically based shading

      this.gammaFactor = 2.0; // for backwards compatibility
      this.outputEncoding = LinearEncoding;

      // physical lights

      this.physicallyCorrectLights = false;

      // tone mapping

      this.toneMapping = NoToneMapping;
      this.toneMappingExposure = 1.0;

      // morphs

      this.maxMorphTargets = 8;
      this.maxMorphNormals = 4;

      // internal properties

      const _this = this;

      let _isContextLost = false;

      // internal state cache

      let _framebuffer = null;

      let _currentActiveCubeFace = 0;
      let _currentActiveMipmapLevel = 0;
      let _currentRenderTarget = null;
      let _currentFramebuffer = null;
      let _currentMaterialId = -1;

      let _currentCamera = null;
      let _currentArrayCamera = null;

      const _currentViewport = new Vector4();
      const _currentScissor = new Vector4();
      let _currentScissorTest = null;

      //

      let _width = _canvas.width;
      let _height = _canvas.height;

      let _pixelRatio = 1;
      let _opaqueSort = null;
      let _transparentSort = null;

      const _viewport = new Vector4(0, 0, _width, _height);
      const _scissor = new Vector4(0, 0, _width, _height);
      let _scissorTest = false;

      // frustum

      const _frustum = new Frustum();

      // clipping

      const _clipping = new WebGLClipping();
      let _clippingEnabled = false;
      let _localClippingEnabled = false;

      // camera matrices cache

      const _projScreenMatrix = new Matrix4();

      const _vector3 = new Vector3();

      const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

      function getTargetPixelRatio() {

          return _currentRenderTarget === null ? _pixelRatio : 1;

      }

      // initialize

      let _gl = _context;

      function getContext(contextNames, contextAttributes) {

          for (let i = 0; i < contextNames.length; i++) {

              const contextName = contextNames[i];
              const context = _canvas.getContext(contextName, contextAttributes);
              if (context !== null) return context;

          }

          return null;

      }

      try {

          const contextAttributes = {
              alpha: _alpha,
              depth: _depth,
              stencil: _stencil,
              antialias: _antialias,
              premultipliedAlpha: _premultipliedAlpha,
              preserveDrawingBuffer: _preserveDrawingBuffer,
              powerPreference: _powerPreference,
              failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
          };

          // event listeners must be registered before WebGL context is created, see #12753

          _canvas.addEventListener('webglcontextlost', onContextLost, false);
          _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

          if (_gl === null) {

              const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

              if (_this.isWebGL1Renderer === true) {

                  contextNames.shift();

              }

              _gl = getContext(contextNames, contextAttributes);

              if (_gl === null) {

                  if (getContext(contextNames)) {

                      throw new Error('Error creating WebGL context with your selected attributes.');

                  } else {

                      throw new Error('Error creating WebGL context.');

                  }

              }

          }

          // Some experimental-webgl implementations do not have getShaderPrecisionFormat

          if (_gl.getShaderPrecisionFormat === undefined) {

              _gl.getShaderPrecisionFormat = function() {

                  return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

              };

          }

      } catch (error) {

          console.error('THREE.WebGLRenderer: ' + error.message);
          throw error;

      }

      let extensions, capabilities, state, info;
      let properties, textures, attributes, geometries, objects;
      let programCache, materials, renderLists, renderStates;

      let background, morphtargets, bufferRenderer, indexedBufferRenderer;

      let utils, bindingStates;

      function initGLContext() {

          extensions = new WebGLExtensions(_gl);

          capabilities = new WebGLCapabilities(_gl, extensions, parameters);

          if (capabilities.isWebGL2 === false) {

              extensions.get('WEBGL_depth_texture');
              extensions.get('OES_texture_float');
              extensions.get('OES_texture_half_float');
              extensions.get('OES_texture_half_float_linear');
              extensions.get('OES_standard_derivatives');
              extensions.get('OES_element_index_uint');
              extensions.get('OES_vertex_array_object');
              extensions.get('ANGLE_instanced_arrays');

          }

          extensions.get('OES_texture_float_linear');

          utils = new WebGLUtils(_gl, extensions, capabilities);

          state = new WebGLState(_gl, extensions, capabilities);
          state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
          state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());

          info = new WebGLInfo(_gl);
          properties = new WebGLProperties();
          textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
          attributes = new WebGLAttributes(_gl, capabilities);
          bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
          geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
          objects = new WebGLObjects(_gl, geometries, attributes, info);
          morphtargets = new WebGLMorphtargets(_gl);
          programCache = new WebGLPrograms(_this, extensions, capabilities, bindingStates);
          materials = new WebGLMaterials(properties);
          renderLists = new WebGLRenderLists();
          renderStates = new WebGLRenderStates();

          background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);

          bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
          indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);

          info.programs = programCache.programs;

          _this.capabilities = capabilities;
          _this.extensions = extensions;
          _this.properties = properties;
          _this.renderLists = renderLists;
          _this.state = state;
          _this.info = info;

      }

      initGLContext();

      // xr

      const xr = new WebXRManager(_this, _gl);

      this.xr = xr;

      // shadow map

      const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);

      this.shadowMap = shadowMap;

      // API

      this.getContext = function() {

          return _gl;

      };

      this.getContextAttributes = function() {

          return _gl.getContextAttributes();

      };

      this.forceContextLoss = function() {

          const extension = extensions.get('WEBGL_lose_context');
          if (extension) extension.loseContext();

      };

      this.forceContextRestore = function() {

          const extension = extensions.get('WEBGL_lose_context');
          if (extension) extension.restoreContext();

      };

      this.getPixelRatio = function() {

          return _pixelRatio;

      };

      this.setPixelRatio = function(value) {

          if (value === undefined) return;

          _pixelRatio = value;

          this.setSize(_width, _height, false);

      };

      this.getSize = function(target) {

          if (target === undefined) {

              console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');

              target = new Vector2();

          }

          return target.set(_width, _height);

      };

      this.setSize = function(width, height, updateStyle) {

          if (xr.isPresenting) {

              console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
              return;

          }

          _width = width;
          _height = height;

          _canvas.width = Math.floor(width * _pixelRatio);
          _canvas.height = Math.floor(height * _pixelRatio);

          if (updateStyle !== false) {

              _canvas.style.width = width + 'px';
              _canvas.style.height = height + 'px';

          }

          this.setViewport(0, 0, width, height);

      };

      this.getDrawingBufferSize = function(target) {

          if (target === undefined) {

              console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');

              target = new Vector2();

          }

          return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();

      };

      this.setDrawingBufferSize = function(width, height, pixelRatio) {

          _width = width;
          _height = height;

          _pixelRatio = pixelRatio;

          _canvas.width = Math.floor(width * pixelRatio);
          _canvas.height = Math.floor(height * pixelRatio);

          this.setViewport(0, 0, width, height);

      };

      this.getCurrentViewport = function(target) {

          if (target === undefined) {

              console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');

              target = new Vector4();

          }

          return target.copy(_currentViewport);

      };

      this.getViewport = function(target) {

          return target.copy(_viewport);

      };

      this.setViewport = function(x, y, width, height) {

          if (x.isVector4) {

              _viewport.set(x.x, x.y, x.z, x.w);

          } else {

              _viewport.set(x, y, width, height);

          }

          state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());

      };

      this.getScissor = function(target) {

          return target.copy(_scissor);

      };

      this.setScissor = function(x, y, width, height) {

          if (x.isVector4) {

              _scissor.set(x.x, x.y, x.z, x.w);

          } else {

              _scissor.set(x, y, width, height);

          }

          state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());

      };

      this.getScissorTest = function() {

          return _scissorTest;

      };

      this.setScissorTest = function(boolean) {

          state.setScissorTest(_scissorTest = boolean);

      };

      this.setOpaqueSort = function(method) {

          _opaqueSort = method;

      };

      this.setTransparentSort = function(method) {

          _transparentSort = method;

      };

      // Clearing

      this.getClearColor = function() {

          return background.getClearColor();

      };

      this.setClearColor = function() {

          background.setClearColor.apply(background, arguments);

      };

      this.getClearAlpha = function() {

          return background.getClearAlpha();

      };

      this.setClearAlpha = function() {

          background.setClearAlpha.apply(background, arguments);

      };

      this.clear = function(color, depth, stencil) {

          let bits = 0;

          if (color === undefined || color) bits |= 16384;
          if (depth === undefined || depth) bits |= 256;
          if (stencil === undefined || stencil) bits |= 1024;

          _gl.clear(bits);

      };

      this.clearColor = function() {

          this.clear(true, false, false);

      };

      this.clearDepth = function() {

          this.clear(false, true, false);

      };

      this.clearStencil = function() {

          this.clear(false, false, true);

      };

      //

      this.dispose = function() {

          _canvas.removeEventListener('webglcontextlost', onContextLost, false);
          _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

          renderLists.dispose();
          renderStates.dispose();
          properties.dispose();
          objects.dispose();
          bindingStates.dispose();

          xr.dispose();

          animation.stop();

      };

      // Events

      function onContextLost(event) {

          event.preventDefault();

          console.log('THREE.WebGLRenderer: Context Lost.');

          _isContextLost = true;

      }

      function onContextRestore( /* event */ ) {

          console.log('THREE.WebGLRenderer: Context Restored.');

          _isContextLost = false;

          initGLContext();

      }

      function onMaterialDispose(event) {

          const material = event.target;

          material.removeEventListener('dispose', onMaterialDispose);

          deallocateMaterial(material);

      }

      // Buffer deallocation

      function deallocateMaterial(material) {

          releaseMaterialProgramReference(material);

          properties.remove(material);

      }


      function releaseMaterialProgramReference(material) {

          const programInfo = properties.get(material).program;

          material.program = undefined;

          if (programInfo !== undefined) {

              programCache.releaseProgram(programInfo);

          }

      }

      // Buffer rendering

      function renderObjectImmediate(object, program) {

          object.render(function(object) {

              _this.renderBufferImmediate(object, program);

          });

      }

      this.renderBufferImmediate = function(object, program) {

          bindingStates.initAttributes();

          const buffers = properties.get(object);

          if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
          if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
          if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
          if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();

          const programAttributes = program.getAttributes();

          if (object.hasPositions) {

              _gl.bindBuffer(34962, buffers.position);
              _gl.bufferData(34962, object.positionArray, 35048);

              bindingStates.enableAttribute(programAttributes.position);
              _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);

          }

          if (object.hasNormals) {

              _gl.bindBuffer(34962, buffers.normal);
              _gl.bufferData(34962, object.normalArray, 35048);

              bindingStates.enableAttribute(programAttributes.normal);
              _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);

          }

          if (object.hasUvs) {

              _gl.bindBuffer(34962, buffers.uv);
              _gl.bufferData(34962, object.uvArray, 35048);

              bindingStates.enableAttribute(programAttributes.uv);
              _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);

          }

          if (object.hasColors) {

              _gl.bindBuffer(34962, buffers.color);
              _gl.bufferData(34962, object.colorArray, 35048);

              bindingStates.enableAttribute(programAttributes.color);
              _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);

          }

          bindingStates.disableUnusedAttributes();

          _gl.drawArrays(4, 0, object.count);

          object.count = 0;

      };

      this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {

          if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

          const frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);

          const program = setProgram(camera, scene, material, object);

          state.setMaterial(material, frontFaceCW);

          //

          let index = geometry.index;
          const position = geometry.attributes.position;

          //

          if (index === null) {

              if (position === undefined || position.count === 0) return;

          } else if (index.count === 0) {

              return;

          }

          //

          let rangeFactor = 1;

          if (material.wireframe === true) {

              index = geometries.getWireframeAttribute(geometry);
              rangeFactor = 2;

          }

          if (material.morphTargets || material.morphNormals) {

              morphtargets.update(object, geometry, material, program);

          }

          bindingStates.setup(object, material, program, geometry, index);

          let attribute;
          let renderer = bufferRenderer;

          if (index !== null) {

              attribute = attributes.get(index);

              renderer = indexedBufferRenderer;
              renderer.setIndex(attribute);

          }

          //

          const dataCount = (index !== null) ? index.count : position.count;

          const rangeStart = geometry.drawRange.start * rangeFactor;
          const rangeCount = geometry.drawRange.count * rangeFactor;

          const groupStart = group !== null ? group.start * rangeFactor : 0;
          const groupCount = group !== null ? group.count * rangeFactor : Infinity;

          const drawStart = Math.max(rangeStart, groupStart);
          const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

          const drawCount = Math.max(0, drawEnd - drawStart + 1);

          if (drawCount === 0) return;

          //

          if (object.isMesh) {

              if (material.wireframe === true) {

                  state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                  renderer.setMode(1);

              } else {

                  renderer.setMode(4);

              }

          } else if (object.isLine) {

              let lineWidth = material.linewidth;

              if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

              state.setLineWidth(lineWidth * getTargetPixelRatio());

              if (object.isLineSegments) {

                  renderer.setMode(1);

              } else if (object.isLineLoop) {

                  renderer.setMode(2);

              } else {

                  renderer.setMode(3);

              }

          } else if (object.isPoints) {

              renderer.setMode(0);

          } else if (object.isSprite) {

              renderer.setMode(4);

          }

          if (object.isInstancedMesh) {

              renderer.renderInstances(geometry, drawStart, drawCount, object.count);

          } else if (geometry.isInstancedBufferGeometry) {

              const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);

              renderer.renderInstances(geometry, drawStart, drawCount, instanceCount);

          } else {

              renderer.render(drawStart, drawCount);

          }

      };

      // Compile

      this.compile = function(scene, camera) {

          currentRenderState = renderStates.get(scene, camera);
          currentRenderState.init();

          scene.traverse(function(object) {

              if (object.isLight) {

                  currentRenderState.pushLight(object);

                  if (object.castShadow) {

                      currentRenderState.pushShadow(object);

                  }

              }

          });

          currentRenderState.setupLights(camera);

          const compiled = new WeakMap();

          scene.traverse(function(object) {

              let material = object.material;

              if (material) {

                  if (Array.isArray(material)) {

                      for (let i = 0; i < material.length; i++) {

                          let material2 = material[i];

                          if (compiled.has(material2) === false) {

                              initMaterial(material2, scene, object);
                              compiled.set(material2);

                          }

                      }

                  } else if (compiled.has(material) === false) {

                      initMaterial(material, scene, object);
                      compiled.set(material);

                  }

              }

          });

      };

      // Animation Loop

      let onAnimationFrameCallback = null;

      function onAnimationFrame(time) {

          if (xr.isPresenting) return;
          if (onAnimationFrameCallback) onAnimationFrameCallback(time);

      }

      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);

      if (typeof window !== 'undefined') animation.setContext(window);

      this.setAnimationLoop = function(callback) {

          onAnimationFrameCallback = callback;
          xr.setAnimationLoop(callback);

          (callback === null) ? animation.stop(): animation.start();

      };

      // Rendering

      this.render = function(scene, camera) {

          let renderTarget, forceClear;

          if (arguments[2] !== undefined) {

              console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
              renderTarget = arguments[2];

          }

          if (arguments[3] !== undefined) {

              console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
              forceClear = arguments[3];

          }

          if (camera !== undefined && camera.isCamera !== true) {

              console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
              return;

          }

          if (_isContextLost === true) return;

          // reset caching for this frame

          bindingStates.resetDefaultState();
          _currentMaterialId = -1;
          _currentCamera = null;

          // update scene graph

          if (scene.autoUpdate === true) scene.updateMatrixWorld();

          // update camera matrices and frustum

          if (camera.parent === null) camera.updateMatrixWorld();

          if (xr.enabled === true && xr.isPresenting === true) {

              camera = xr.getCamera(camera);

          }

          //
          if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);

          currentRenderState = renderStates.get(scene, camera);
          currentRenderState.init();

          _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          _frustum.setFromProjectionMatrix(_projScreenMatrix);

          _localClippingEnabled = this.localClippingEnabled;
          _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

          currentRenderList = renderLists.get(scene, camera);
          currentRenderList.init();

          projectObject(scene, camera, 0, _this.sortObjects);

          currentRenderList.finish();

          if (_this.sortObjects === true) {

              currentRenderList.sort(_opaqueSort, _transparentSort);

          }

          //

          if (_clippingEnabled === true) _clipping.beginShadows();

          const shadowsArray = currentRenderState.state.shadowsArray;

          shadowMap.render(shadowsArray, scene, camera);

          currentRenderState.setupLights(camera);

          if (_clippingEnabled === true) _clipping.endShadows();

          //

          if (this.info.autoReset === true) this.info.reset();

          if (renderTarget !== undefined) {

              this.setRenderTarget(renderTarget);

          }

          //

          background.render(currentRenderList, scene, camera, forceClear);

          // render scene

          const opaqueObjects = currentRenderList.opaque;
          const transparentObjects = currentRenderList.transparent;

          if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
          if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);

          //

          if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);

          //

          if (_currentRenderTarget !== null) {

              // Generate mipmap if we're using any kind of mipmap filtering

              textures.updateRenderTargetMipmap(_currentRenderTarget);

              // resolve multisample renderbuffers to a single-sample texture if necessary

              textures.updateMultisampleRenderTarget(_currentRenderTarget);

          }

          // Ensure depth buffer writing is enabled so it can be cleared on next render

          state.buffers.depth.setTest(true);
          state.buffers.depth.setMask(true);
          state.buffers.color.setMask(true);

          state.setPolygonOffset(false);

          // _gl.finish();

          currentRenderList = null;
          currentRenderState = null;

      };

      function projectObject(object, camera, groupOrder, sortObjects) {

          if (object.visible === false) return;

          const visible = object.layers.test(camera.layers);

          if (visible) {

              if (object.isGroup) {

                  groupOrder = object.renderOrder;

              } else if (object.isLOD) {

                  if (object.autoUpdate === true) object.update(camera);

              } else if (object.isLight) {

                  currentRenderState.pushLight(object);

                  if (object.castShadow) {

                      currentRenderState.pushShadow(object);

                  }

              } else if (object.isSprite) {

                  if (!object.frustumCulled || _frustum.intersectsSprite(object)) {

                      if (sortObjects) {

                          _vector3.setFromMatrixPosition(object.matrixWorld)
                              .applyMatrix4(_projScreenMatrix);

                      }

                      const geometry = objects.update(object);
                      const material = object.material;

                      if (material.visible) {

                          currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);

                      }

                  }

              } else if (object.isImmediateRenderObject) {

                  if (sortObjects) {

                      _vector3.setFromMatrixPosition(object.matrixWorld)
                          .applyMatrix4(_projScreenMatrix);

                  }

                  currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);

              } else if (object.isMesh || object.isLine || object.isPoints) {

                  if (object.isSkinnedMesh) {

                      // update skeleton only once in a frame

                      if (object.skeleton.frame !== info.render.frame) {

                          object.skeleton.update();
                          object.skeleton.frame = info.render.frame;

                      }

                  }

                  if (!object.frustumCulled || _frustum.intersectsObject(object)) {

                      if (sortObjects) {

                          _vector3.setFromMatrixPosition(object.matrixWorld)
                              .applyMatrix4(_projScreenMatrix);

                      }

                      const geometry = objects.update(object);
                      const material = object.material;

                      if (Array.isArray(material)) {

                          const groups = geometry.groups;

                          for (let i = 0, l = groups.length; i < l; i++) {

                              const group = groups[i];
                              const groupMaterial = material[group.materialIndex];

                              if (groupMaterial && groupMaterial.visible) {

                                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);

                              }

                          }

                      } else if (material.visible) {

                          currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);

                      }

                  }

              }

          }

          const children = object.children;

          for (let i = 0, l = children.length; i < l; i++) {

              projectObject(children[i], camera, groupOrder, sortObjects);

          }

      }

      function renderObjects(renderList, scene, camera) {

          const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

          for (let i = 0, l = renderList.length; i < l; i++) {

              const renderItem = renderList[i];

              const object = renderItem.object;
              const geometry = renderItem.geometry;
              const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
              const group = renderItem.group;

              if (camera.isArrayCamera) {

                  _currentArrayCamera = camera;

                  const cameras = camera.cameras;

                  for (let j = 0, jl = cameras.length; j < jl; j++) {

                      const camera2 = cameras[j];

                      if (object.layers.test(camera2.layers)) {

                          state.viewport(_currentViewport.copy(camera2.viewport));

                          currentRenderState.setupLights(camera2);

                          renderObject(object, scene, camera2, geometry, material, group);

                      }

                  }

              } else {

                  _currentArrayCamera = null;

                  renderObject(object, scene, camera, geometry, material, group);

              }

          }

      }

      function renderObject(object, scene, camera, geometry, material, group) {

          object.onBeforeRender(_this, scene, camera, geometry, material, group);
          currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);

          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

          if (object.isImmediateRenderObject) {

              const program = setProgram(camera, scene, material, object);

              state.setMaterial(material);

              bindingStates.reset();

              renderObjectImmediate(object, program);

          } else {

              _this.renderBufferDirect(camera, scene, geometry, material, object, group);

          }

          object.onAfterRender(_this, scene, camera, geometry, material, group);
          currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);

      }

      function initMaterial(material, scene, object) {
          // console.log('MATERIAL ', material, ' OBJECT ', object);
          if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

          const materialProperties = properties.get(material);

          const lights = currentRenderState.state.lights;
          const shadowsArray = currentRenderState.state.shadowsArray;

          const lightsStateVersion = lights.state.version;

          const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
          const programCacheKey = programCache.getProgramCacheKey(parameters);

          let program = materialProperties.program;
          let programChange = true;

          if (program === undefined) {

              // new material
              material.addEventListener('dispose', onMaterialDispose);

          } else if (program.cacheKey !== programCacheKey) {

              // changed glsl or parameters
              releaseMaterialProgramReference(material);

          } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {

              materialProperties.lightsStateVersion = lightsStateVersion;

              programChange = false;

          } else if (parameters.shaderID !== undefined) {

              // same glsl and uniform list
              return;

          } else {

              // only rebuild uniform list
              programChange = false;

          }

          if (programChange) {

              program = programCache.acquireProgram(parameters, programCacheKey);

              materialProperties.program = program;
              materialProperties.uniforms = parameters.uniforms;
              materialProperties.outputEncoding = parameters.outputEncoding;
              material.program = program;

          }

          const programAttributes = program.getAttributes();

          if (material.morphTargets) {

              material.numSupportedMorphTargets = 0;

              for (let i = 0; i < _this.maxMorphTargets; i++) {

                  if (programAttributes['morphTarget' + i] >= 0) {

                      material.numSupportedMorphTargets++;

                  }

              }

          }

          if (material.morphNormals) {

              material.numSupportedMorphNormals = 0;

              for (let i = 0; i < _this.maxMorphNormals; i++) {

                  if (programAttributes['morphNormal' + i] >= 0) {

                      material.numSupportedMorphNormals++;

                  }

              }

          }

          const uniforms = materialProperties.uniforms;

          if (!material.isShaderMaterial &&
              !material.isRawShaderMaterial ||
              material.clipping === true) {

              materialProperties.numClippingPlanes = _clipping.numPlanes;
              materialProperties.numIntersection = _clipping.numIntersection;
              uniforms.clippingPlanes = _clipping.uniform;

          }

          materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
          materialProperties.fog = scene.fog;

          // store the light setup it was created for

          materialProperties.needsLights = materialNeedsLights(material);
          materialProperties.lightsStateVersion = lightsStateVersion;

          if (materialProperties.needsLights) {

              // wire up the material to this renderer's lighting state

              uniforms.ambientLightColor.value = lights.state.ambient;
              uniforms.lightProbe.value = lights.state.probe;
              uniforms.directionalLights.value = lights.state.directional;
              uniforms.directionalLightShadows.value = lights.state.directionalShadow;
              uniforms.spotLights.value = lights.state.spot;
              uniforms.spotLightShadows.value = lights.state.spotShadow;
              uniforms.rectAreaLights.value = lights.state.rectArea;
              uniforms.pointLights.value = lights.state.point;
              uniforms.pointLightShadows.value = lights.state.pointShadow;
              uniforms.hemisphereLights.value = lights.state.hemi;

              uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
              uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
              uniforms.spotShadowMap.value = lights.state.spotShadowMap;
              uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
              uniforms.pointShadowMap.value = lights.state.pointShadowMap;
              uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
              // TODO (abelnation): add area lights shadow info to uniforms

          }

          const progUniforms = materialProperties.program.getUniforms(),
              uniformsList =
              WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);

          materialProperties.uniformsList = uniformsList;

      }

      function setProgram(camera, scene, material, object) {

          if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

          textures.resetTextureUnits();

          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const encoding = (_currentRenderTarget === null) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;

          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;

          if (_clippingEnabled === true) {

              if (_localClippingEnabled === true || camera !== _currentCamera) {

                  const useCache =
                      camera === _currentCamera &&
                      material.id === _currentMaterialId;

                  // we might want to call this function with some ClippingGroup
                  // object instead of the material, once it becomes feasible
                  // (#8465, #8379)
                  _clipping.setState(
                      material.clippingPlanes, material.clipIntersection, material.clipShadows,
                      camera, materialProperties, useCache);

              }

          }

          if (material.version === materialProperties.__version) {

              if (materialProperties.program === undefined) {

                  initMaterial(material, scene, object);

              } else if (material.fog && materialProperties.fog !== fog) {

                  initMaterial(material, scene, object);

              } else if (materialProperties.environment !== environment) {

                  initMaterial(material, scene, object);

              } else if (materialProperties.needsLights && (materialProperties.lightsStateVersion !== lights.state.version)) {

                  initMaterial(material, scene, object);

              } else if (materialProperties.numClippingPlanes !== undefined &&
                  (materialProperties.numClippingPlanes !== _clipping.numPlanes ||
                      materialProperties.numIntersection !== _clipping.numIntersection)) {

                  initMaterial(material, scene, object);

              } else if (materialProperties.outputEncoding !== encoding) {

                  initMaterial(material, scene, object);

              }

          } else {

              initMaterial(material, scene, object);
              materialProperties.__version = material.version;

          }

          let refreshProgram = false;
          let refreshMaterial = false;
          let refreshLights = false;

          const program = materialProperties.program,
              p_uniforms = program.getUniforms(),
              m_uniforms = materialProperties.uniforms;

          if (state.useProgram(program.program)) {

              refreshProgram = true;
              refreshMaterial = true;
              refreshLights = true;

          }

          if (material.id !== _currentMaterialId) {

              _currentMaterialId = material.id;

              refreshMaterial = true;

          }

          if (refreshProgram || _currentCamera !== camera) {

              p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

              if (capabilities.logarithmicDepthBuffer) {

                  p_uniforms.setValue(_gl, 'logDepthBufFC',
                      2.0 / (Math.log(camera.far + 1.0) / Math.LN2));

              }

              if (_currentCamera !== camera) {

                  _currentCamera = camera;

                  // lighting uniforms depend on the camera so enforce an update
                  // now, in case this material supports lights - or later, when
                  // the next material that does gets activated:

                  refreshMaterial = true; // set to true on material change
                  refreshLights = true; // remains set until update done

              }

              // load material specific uniforms
              // (shader material also gets them for the sake of genericity)

              if (material.isShaderMaterial ||
                  material.isMeshPhongMaterial ||
                  material.isMeshToonMaterial ||
                  material.isMeshStandardMaterial ||
                  material.envMap) {

                  const uCamPos = p_uniforms.map.cameraPosition;

                  if (uCamPos !== undefined) {

                      uCamPos.setValue(_gl,
                          _vector3.setFromMatrixPosition(camera.matrixWorld));

                  }

              }

              if (material.isMeshPhongMaterial ||
                  material.isMeshToonMaterial ||
                  material.isMeshLambertMaterial ||
                  material.isMeshBasicMaterial ||
                  material.isMeshStandardMaterial ||
                  material.isShaderMaterial) {

                  p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);

              }

              if (material.isMeshPhongMaterial ||
                  material.isMeshToonMaterial ||
                  material.isMeshLambertMaterial ||
                  material.isMeshBasicMaterial ||
                  material.isMeshStandardMaterial ||
                  material.isShaderMaterial ||
                  material.isShadowMaterial ||
                  material.skinning) {

                  p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);

              }

          }

          // skinning uniforms must be set even if material didn't change
          // auto-setting of texture unit for bone texture must go before other textures
          // otherwise textures used for skinning can take over texture units reserved for other material textures

          if (material.skinning) {

              p_uniforms.setOptional(_gl, object, 'bindMatrix');
              p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

              const skeleton = object.skeleton;

              if (skeleton) {

                  const bones = skeleton.bones;

                  if (capabilities.floatVertexTextures) {

                      if (skeleton.boneTexture === undefined) {

                          // layout (1 matrix = 4 pixels)
                          //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                          //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                          //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                          //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                          //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


                          let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                          size = MathUtils.ceilPowerOfTwo(size);
                          size = Math.max(size, 4);

                          const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                          boneMatrices.set(skeleton.boneMatrices); // copy current values

                          const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);

                          skeleton.boneMatrices = boneMatrices;
                          skeleton.boneTexture = boneTexture;
                          skeleton.boneTextureSize = size;

                      }

                      p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                      p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);

                  } else {

                      p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');

                  }

              }

          }

          if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {

              materialProperties.receiveShadow = object.receiveShadow;
              p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);

          }

          if (refreshMaterial) {

              p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

              if (materialProperties.needsLights) {

                  // the current material requires lighting info

                  // note: all lighting uniforms are always set correctly
                  // they simply reference the renderer's state for their
                  // values
                  //
                  // use the current material's .needsUpdate flags to set
                  // the GL state when required

                  markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);

              }

              // refresh uniforms common to several materials

              if (fog && material.fog) {

                  materials.refreshFogUniforms(m_uniforms, fog);

              }

              materials.refreshMaterialUniforms(m_uniforms, material, environment, _pixelRatio, _height);

              // RectAreaLight Texture
              // TODO (mrdoob): Find a nicer implementation

              if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
              if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

              WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);

          }

          if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {

              WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
              material.uniformsNeedUpdate = false;

          }

          if (material.isSpriteMaterial) {

              p_uniforms.setValue(_gl, 'center', object.center);

          }

          // common matrices

          p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
          p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
          p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

          return program;

      }

      // If uniforms are marked as clean, they don't need to be loaded to the GPU.

      function markUniformsLightsNeedsUpdate(uniforms, value) {

          uniforms.ambientLightColor.needsUpdate = value;
          uniforms.lightProbe.needsUpdate = value;

          uniforms.directionalLights.needsUpdate = value;
          uniforms.directionalLightShadows.needsUpdate = value;
          uniforms.pointLights.needsUpdate = value;
          uniforms.pointLightShadows.needsUpdate = value;
          uniforms.spotLights.needsUpdate = value;
          uniforms.spotLightShadows.needsUpdate = value;
          uniforms.rectAreaLights.needsUpdate = value;
          uniforms.hemisphereLights.needsUpdate = value;

      }

      function materialNeedsLights(material) {

          return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
              material.isMeshStandardMaterial || material.isShadowMaterial ||
              (material.isShaderMaterial && material.lights === true);

      }

      //
      this.setFramebuffer = function(value) {

          if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);

          _framebuffer = value;

      };

      this.getActiveCubeFace = function() {

          return _currentActiveCubeFace;

      };

      this.getActiveMipmapLevel = function() {

          return _currentActiveMipmapLevel;

      };

      this.getRenderTarget = function() {

          return _currentRenderTarget;

      };

      this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {

          _currentRenderTarget = renderTarget;
          _currentActiveCubeFace = activeCubeFace;
          _currentActiveMipmapLevel = activeMipmapLevel;

          if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {

              textures.setupRenderTarget(renderTarget);

          }

          let framebuffer = _framebuffer;
          let isCube = false;

          if (renderTarget) {

              const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

              if (renderTarget.isWebGLCubeRenderTarget) {

                  framebuffer = __webglFramebuffer[activeCubeFace || 0];
                  isCube = true;

              } else if (renderTarget.isWebGLMultisampleRenderTarget) {

                  framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;

              } else {

                  framebuffer = __webglFramebuffer;

              }

              _currentViewport.copy(renderTarget.viewport);
              _currentScissor.copy(renderTarget.scissor);
              _currentScissorTest = renderTarget.scissorTest;

          } else {

              _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
              _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
              _currentScissorTest = _scissorTest;

          }

          if (_currentFramebuffer !== framebuffer) {

              _gl.bindFramebuffer(36160, framebuffer);
              _currentFramebuffer = framebuffer;

          }

          state.viewport(_currentViewport);
          state.scissor(_currentScissor);
          state.setScissorTest(_currentScissorTest);

          if (isCube) {

              const textureProperties = properties.get(renderTarget.texture);
              _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);

          }

      };

      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {

          if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {

              console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
              return;

          }

          let framebuffer = properties.get(renderTarget).__webglFramebuffer;

          if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {

              framebuffer = framebuffer[activeCubeFaceIndex];

          }

          if (framebuffer) {

              let restore = false;

              if (framebuffer !== _currentFramebuffer) {

                  _gl.bindFramebuffer(36160, framebuffer);

                  restore = true;

              }

              try {

                  const texture = renderTarget.texture;
                  const textureFormat = texture.format;
                  const textureType = texture.type;

                  if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {

                      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                      return;

                  }

                  if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
                      !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                      !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {

                      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                      return;

                  }

                  if (_gl.checkFramebufferStatus(36160) === 36053) {

                      // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

                      if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {

                          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);

                      }

                  } else {

                      console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');

                  }

              } finally {

                  if (restore) {

                      _gl.bindFramebuffer(36160, _currentFramebuffer);

                  }

              }

          }

      };

      this.copyFramebufferToTexture = function(position, texture, level) {

          if (level === undefined) level = 0;

          const levelScale = Math.pow(2, -level);
          const width = Math.floor(texture.image.width * levelScale);
          const height = Math.floor(texture.image.height * levelScale);
          const glFormat = utils.convert(texture.format);

          textures.setTexture2D(texture, 0);

          _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);

          state.unbindTexture();

      };

      this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {

          if (level === undefined) level = 0;

          const width = srcTexture.image.width;
          const height = srcTexture.image.height;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);

          textures.setTexture2D(dstTexture, 0);

          // As another texture upload may have changed pixelStorei
          // parameters, make sure they are correct for the dstTexture
          _gl.pixelStorei(37440, dstTexture.flipY);
          _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(3317, dstTexture.unpackAlignment);

          if (srcTexture.isDataTexture) {

              _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);

          } else {

              if (srcTexture.isCompressedTexture) {

                  _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);

              } else {

                  _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);

              }

          }

          // Generate mipmaps only when copying level 0
          if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);

          state.unbindTexture();

      };

      this.initTexture = function(texture) {

          textures.setTexture2D(texture, 0);

          state.unbindTexture();

      };

      if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })); // eslint-disable-line no-undef

      }

  }

  /**
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WebGL1Renderer(parameters) {

      WebGLRenderer.call(this, parameters);

  }

  WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {

      constructor: WebGL1Renderer,

      isWebGL1Renderer: true

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function FogExp2(color, density) {

      this.name = '';

      this.color = new Color(color);
      this.density = (density !== undefined) ? density : 0.00025;

  }

  Object.assign(FogExp2.prototype, {

      isFogExp2: true,

      clone: function() {

          return new FogExp2(this.color, this.density);

      },

      toJSON: function( /* meta */ ) {

          return {
              type: 'FogExp2',
              color: this.color.getHex(),
              density: this.density
          };

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Fog(color, near, far) {

      this.name = '';

      this.color = new Color(color);

      this.near = (near !== undefined) ? near : 1;
      this.far = (far !== undefined) ? far : 1000;

  }

  Object.assign(Fog.prototype, {

      isFog: true,

      clone: function() {

          return new Fog(this.color, this.near, this.far);

      },

      toJSON: function( /* meta */ ) {

          return {
              type: 'Fog',
              color: this.color.getHex(),
              near: this.near,
              far: this.far
          };

      }

  });

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InterleavedBuffer(array, stride) {

      this.array = array;
      this.stride = stride;
      this.count = array !== undefined ? array.length / stride : 0;

      this.usage = StaticDrawUsage;
      this.updateRange = { offset: 0, count: -1 };

      this.version = 0;

      this.uuid = MathUtils.generateUUID();

  }

  Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {

      set: function(value) {

          if (value === true) this.version++;

      }

  });

  Object.assign(InterleavedBuffer.prototype, {

      isInterleavedBuffer: true,

      onUploadCallback: function() {},

      setUsage: function(value) {

          this.usage = value;

          return this;

      },

      copy: function(source) {

          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;

          return this;

      },

      copyAt: function(index1, attribute, index2) {

          index1 *= this.stride;
          index2 *= attribute.stride;

          for (let i = 0, l = this.stride; i < l; i++) {

              this.array[index1 + i] = attribute.array[index2 + i];

          }

          return this;

      },

      set: function(value, offset) {

          if (offset === undefined) offset = 0;

          this.array.set(value, offset);

          return this;

      },

      clone: function(data) {

          if (data.arrayBuffers === undefined) {

              data.arrayBuffers = {};

          }

          if (this.array.buffer._uuid === undefined) {

              this.array.buffer._uuid = MathUtils.generateUUID();

          }

          if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {

              data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;

          }

          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);

          const ib = new InterleavedBuffer(array, this.stride);
          ib.setUsage(this.usage);

          return ib;

      },

      onUpload: function(callback) {

          this.onUploadCallback = callback;

          return this;

      },

      toJSON: function(data) {

          if (data.arrayBuffers === undefined) {

              data.arrayBuffers = {};

          }

          // generate UUID for array buffer if necessary

          if (this.array.buffer._uuid === undefined) {

              this.array.buffer._uuid = MathUtils.generateUUID();

          }

          if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {

              data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));

          }

          //

          return {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride
          };

      }

  });

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  const _vector$6 = new Vector3();

  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {

      this.name = '';

      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;

      this.normalized = normalized === true;

  }

  Object.defineProperties(InterleavedBufferAttribute.prototype, {

      count: {

          get: function() {

              return this.data.count;

          }

      },

      array: {

          get: function() {

              return this.data.array;

          }

      }

  });

  Object.assign(InterleavedBufferAttribute.prototype, {

      isInterleavedBufferAttribute: true,

      applyMatrix4: function(m) {

          for (let i = 0, l = this.data.count; i < l; i++) {

              _vector$6.x = this.getX(i);
              _vector$6.y = this.getY(i);
              _vector$6.z = this.getZ(i);

              _vector$6.applyMatrix4(m);

              this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);

          }

          return this;

      },

      setX: function(index, x) {

          this.data.array[index * this.data.stride + this.offset] = x;

          return this;

      },

      setY: function(index, y) {

          this.data.array[index * this.data.stride + this.offset + 1] = y;

          return this;

      },

      setZ: function(index, z) {

          this.data.array[index * this.data.stride + this.offset + 2] = z;

          return this;

      },

      setW: function(index, w) {

          this.data.array[index * this.data.stride + this.offset + 3] = w;

          return this;

      },

      getX: function(index) {

          return this.data.array[index * this.data.stride + this.offset];

      },

      getY: function(index) {

          return this.data.array[index * this.data.stride + this.offset + 1];

      },

      getZ: function(index) {

          return this.data.array[index * this.data.stride + this.offset + 2];

      },

      getW: function(index) {

          return this.data.array[index * this.data.stride + this.offset + 3];

      },

      setXY: function(index, x, y) {

          index = index * this.data.stride + this.offset;

          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;

          return this;

      },

      setXYZ: function(index, x, y, z) {

          index = index * this.data.stride + this.offset;

          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;

          return this;

      },

      setXYZW: function(index, x, y, z, w) {

          index = index * this.data.stride + this.offset;

          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          this.data.array[index + 3] = w;

          return this;

      },

      clone: function(data) {

          if (data === undefined) {

              console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');

              const array = [];

              for (let i = 0; i < this.count; i++) {

                  const index = i * this.data.stride + this.offset;

                  for (let j = 0; j < this.itemSize; j++) {

                      array.push(this.data.array[index + j]);

                  }

              }

              return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);

          } else {

              if (data.interleavedBuffers === undefined) {

                  data.interleavedBuffers = {};

              }

              if (data.interleavedBuffers[this.data.uuid] === undefined) {

                  data.interleavedBuffers[this.data.uuid] = this.data.clone(data);

              }

              return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);

          }

      },

      toJSON: function(data) {

          if (data === undefined) {

              console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');

              const array = [];

              for (let i = 0; i < this.count; i++) {

                  const index = i * this.data.stride + this.offset;

                  for (let j = 0; j < this.itemSize; j++) {

                      array.push(this.data.array[index + j]);

                  }

              }

              // deinterleave data and save it as an ordinary buffer attribute for now

              return {
                  itemSize: this.itemSize,
                  type: this.array.constructor.name,
                  array: array,
                  normalized: this.normalized
              };

          } else {

              // save as true interlaved attribtue

              if (data.interleavedBuffers === undefined) {

                  data.interleavedBuffers = {};

              }

              if (data.interleavedBuffers[this.data.uuid] === undefined) {

                  data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);

              }

              return {
                  isInterleavedBufferAttribute: true,
                  itemSize: this.itemSize,
                  data: this.data.uuid,
                  offset: this.offset,
                  normalized: this.normalized
              };

          }

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *  rotation: <float>,
   *  sizeAttenuation: <bool>
   * }
   */

  function SpriteMaterial(parameters) {

      Material.call(this);

      this.type = 'SpriteMaterial';

      this.color = new Color(0xffffff);

      this.map = null;

      this.alphaMap = null;

      this.rotation = 0;

      this.sizeAttenuation = true;

      this.transparent = true;

      this.setValues(parameters);

  }

  SpriteMaterial.prototype = Object.create(Material.prototype);
  SpriteMaterial.prototype.constructor = SpriteMaterial;
  SpriteMaterial.prototype.isSpriteMaterial = true;

  SpriteMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);

      this.map = source.map;

      this.alphaMap = source.alphaMap;

      this.rotation = source.rotation;

      this.sizeAttenuation = source.sizeAttenuation;

      return this;

  };

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  let _geometry;

  const _intersectPoint = new Vector3();
  const _worldScale = new Vector3();
  const _mvPosition = new Vector3();

  const _alignedPosition = new Vector2();
  const _rotatedPosition = new Vector2();
  const _viewWorldMatrix = new Matrix4();

  const _vA$1 = new Vector3();
  const _vB$1 = new Vector3();
  const _vC$1 = new Vector3();

  const _uvA$1 = new Vector2();
  const _uvB$1 = new Vector2();
  const _uvC$1 = new Vector2();

  function Sprite(material) {

      Object3D.call(this);

      this.type = 'Sprite';

      if (_geometry === undefined) {

          _geometry = new BufferGeometry();

          const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0,
              0.5, -0.5, 0, 1, 0,
              0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1
          ]);

          const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

          _geometry.setIndex([0, 1, 2, 0, 2, 3]);
          _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
          _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));

      }

      this.geometry = _geometry;
      this.material = (material !== undefined) ? material : new SpriteMaterial();

      this.center = new Vector2(0.5, 0.5);

  }

  Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Sprite,

      isSprite: true,

      raycast: function(raycaster, intersects) {

          if (raycaster.camera === null) {

              console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');

          }

          _worldScale.setFromMatrixScale(this.matrixWorld);

          _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
          this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

          _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

          if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {

              _worldScale.multiplyScalar(-_mvPosition.z);

          }

          const rotation = this.material.rotation;
          let sin, cos;

          if (rotation !== 0) {

              cos = Math.cos(rotation);
              sin = Math.sin(rotation);

          }

          const center = this.center;

          transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

          _uvA$1.set(0, 0);
          _uvB$1.set(1, 0);
          _uvC$1.set(1, 1);

          // check first triangle
          let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

          if (intersect === null) {

              // check second triangle
              transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
              _uvB$1.set(0, 1);

              intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
              if (intersect === null) {

                  return;

              }

          }

          const distance = raycaster.ray.origin.distanceTo(_intersectPoint);

          if (distance < raycaster.near || distance > raycaster.far) return;

          intersects.push({

              distance: distance,
              point: _intersectPoint.clone(),
              uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
              face: null,
              object: this

          });

      },

      copy: function(source) {

          Object3D.prototype.copy.call(this, source);

          if (source.center !== undefined) this.center.copy(source.center);

          this.material = source.material;

          return this;

      }

  });

  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {

      // compute position in camera space
      _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

      // to check if rotation is not zero
      if (sin !== undefined) {

          _rotatedPosition.x = (cos * _alignedPosition.x) - (sin * _alignedPosition.y);
          _rotatedPosition.y = (sin * _alignedPosition.x) + (cos * _alignedPosition.y);

      } else {

          _rotatedPosition.copy(_alignedPosition);

      }


      vertexPosition.copy(mvPosition);
      vertexPosition.x += _rotatedPosition.x;
      vertexPosition.y += _rotatedPosition.y;

      // transform to world space
      vertexPosition.applyMatrix4(_viewWorldMatrix);

  }

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  const _v1$4 = new Vector3();
  const _v2$2 = new Vector3();

  function LOD() {

      Object3D.call(this);

      this._currentLevel = 0;

      this.type = 'LOD';

      Object.defineProperties(this, {
          levels: {
              enumerable: true,
              value: []
          }
      });

      this.autoUpdate = true;

  }

  LOD.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: LOD,

      isLOD: true,

      copy: function(source) {

          Object3D.prototype.copy.call(this, source, false);

          const levels = source.levels;

          for (let i = 0, l = levels.length; i < l; i++) {

              const level = levels[i];

              this.addLevel(level.object.clone(), level.distance);

          }

          this.autoUpdate = source.autoUpdate;

          return this;

      },

      addLevel: function(object, distance) {

          if (distance === undefined) distance = 0;

          distance = Math.abs(distance);

          const levels = this.levels;

          let l;

          for (l = 0; l < levels.length; l++) {

              if (distance < levels[l].distance) {

                  break;

              }

          }

          levels.splice(l, 0, { distance: distance, object: object });

          this.add(object);

          return this;

      },

      getCurrentLevel: function() {

          return this._currentLevel;

      },

      getObjectForDistance: function(distance) {

          const levels = this.levels;

          if (levels.length > 0) {

              let i, l;

              for (i = 1, l = levels.length; i < l; i++) {

                  if (distance < levels[i].distance) {

                      break;

                  }

              }

              return levels[i - 1].object;

          }

          return null;

      },

      raycast: function(raycaster, intersects) {

          const levels = this.levels;

          if (levels.length > 0) {

              _v1$4.setFromMatrixPosition(this.matrixWorld);

              const distance = raycaster.ray.origin.distanceTo(_v1$4);

              this.getObjectForDistance(distance).raycast(raycaster, intersects);

          }

      },

      update: function(camera) {

          const levels = this.levels;

          if (levels.length > 1) {

              _v1$4.setFromMatrixPosition(camera.matrixWorld);
              _v2$2.setFromMatrixPosition(this.matrixWorld);

              const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;

              levels[0].object.visible = true;

              let i, l;

              for (i = 1, l = levels.length; i < l; i++) {

                  if (distance >= levels[i].distance) {

                      levels[i - 1].object.visible = false;
                      levels[i].object.visible = true;

                  } else {

                      break;

                  }

              }

              this._currentLevel = i - 1;

              for (; i < l; i++) {

                  levels[i].object.visible = false;

              }

          }

      },

      toJSON: function(meta) {

          const data = Object3D.prototype.toJSON.call(this, meta);

          if (this.autoUpdate === false) data.object.autoUpdate = false;

          data.object.levels = [];

          const levels = this.levels;

          for (let i = 0, l = levels.length; i < l; i++) {

              const level = levels[i];

              data.object.levels.push({
                  object: level.object.uuid,
                  distance: level.distance
              });

          }

          return data;

      }

  });

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function SkinnedMesh(geometry, material) {

      if (geometry && geometry.isGeometry) {

          console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');

      }

      Mesh.call(this, geometry, material);

      this.type = 'SkinnedMesh';

      this.bindMode = 'attached';
      this.bindMatrix = new Matrix4();
      this.bindMatrixInverse = new Matrix4();

  }

  SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {

      constructor: SkinnedMesh,

      isSkinnedMesh: true,

      copy: function(source) {

          Mesh.prototype.copy.call(this, source);

          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);

          this.skeleton = source.skeleton;

          return this;

      },

      bind: function(skeleton, bindMatrix) {

          this.skeleton = skeleton;

          if (bindMatrix === undefined) {

              this.updateMatrixWorld(true);

              this.skeleton.calculateInverses();

              bindMatrix = this.matrixWorld;

          }

          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.getInverse(bindMatrix);

      },

      pose: function() {

          this.skeleton.pose();

      },

      normalizeSkinWeights: function() {

          const vector = new Vector4();

          const skinWeight = this.geometry.attributes.skinWeight;

          for (let i = 0, l = skinWeight.count; i < l; i++) {

              vector.x = skinWeight.getX(i);
              vector.y = skinWeight.getY(i);
              vector.z = skinWeight.getZ(i);
              vector.w = skinWeight.getW(i);

              const scale = 1.0 / vector.manhattanLength();

              if (scale !== Infinity) {

                  vector.multiplyScalar(scale);

              } else {

                  vector.set(1, 0, 0, 0); // do something reasonable

              }

              skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);

          }

      },

      updateMatrixWorld: function(force) {

          Mesh.prototype.updateMatrixWorld.call(this, force);

          if (this.bindMode === 'attached') {

              this.bindMatrixInverse.getInverse(this.matrixWorld);

          } else if (this.bindMode === 'detached') {

              this.bindMatrixInverse.getInverse(this.bindMatrix);

          } else {

              console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);

          }

      },

      boneTransform: (function() {

          const basePosition = new Vector3();

          const skinIndex = new Vector4();
          const skinWeight = new Vector4();

          const vector = new Vector3();
          const matrix = new Matrix4();

          return function(index, target) {

              const skeleton = this.skeleton;
              const geometry = this.geometry;

              skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
              skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

              basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);

              target.set(0, 0, 0);

              for (let i = 0; i < 4; i++) {

                  const weight = skinWeight.getComponent(i);

                  if (weight !== 0) {

                      const boneIndex = skinIndex.getComponent(i);

                      matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

                      target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);

                  }

              }

              return target.applyMatrix4(this.bindMatrixInverse);

          };

      }())

  });

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author michael guerrero / http://realitymeltdown.com
   * @author ikerr / http://verold.com
   */

  const _offsetMatrix = new Matrix4();
  const _identityMatrix = new Matrix4();

  function Skeleton(bones, boneInverses) {

      // copy the bone array

      bones = bones || [];

      this.bones = bones.slice(0);
      this.boneMatrices = new Float32Array(this.bones.length * 16);

      this.frame = -1;

      // use the supplied bone inverses or calculate the inverses

      if (boneInverses === undefined) {

          this.calculateInverses();

      } else {

          if (this.bones.length === boneInverses.length) {

              this.boneInverses = boneInverses.slice(0);

          } else {

              console.warn('THREE.Skeleton boneInverses is the wrong length.');

              this.boneInverses = [];

              for (let i = 0, il = this.bones.length; i < il; i++) {

                  this.boneInverses.push(new Matrix4());

              }

          }

      }

  }

  Object.assign(Skeleton.prototype, {

      calculateInverses: function() {

          this.boneInverses = [];

          for (let i = 0, il = this.bones.length; i < il; i++) {

              const inverse = new Matrix4();

              if (this.bones[i]) {

                  inverse.getInverse(this.bones[i].matrixWorld);

              }

              this.boneInverses.push(inverse);

          }

      },

      pose: function() {

          // recover the bind-time world matrices

          for (let i = 0, il = this.bones.length; i < il; i++) {

              const bone = this.bones[i];

              if (bone) {

                  bone.matrixWorld.getInverse(this.boneInverses[i]);

              }

          }

          // compute the local matrices, positions, rotations and scales

          for (let i = 0, il = this.bones.length; i < il; i++) {

              const bone = this.bones[i];

              if (bone) {

                  if (bone.parent && bone.parent.isBone) {

                      bone.matrix.getInverse(bone.parent.matrixWorld);
                      bone.matrix.multiply(bone.matrixWorld);

                  } else {

                      bone.matrix.copy(bone.matrixWorld);

                  }

                  bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);

              }

          }

      },

      update: function() {

          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;

          // flatten bone matrices to array

          for (let i = 0, il = bones.length; i < il; i++) {

              // compute the offset between the current and the original transform

              const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

              _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
              _offsetMatrix.toArray(boneMatrices, i * 16);

          }

          if (boneTexture !== undefined) {

              boneTexture.needsUpdate = true;

          }

      },

      clone: function() {

          return new Skeleton(this.bones, this.boneInverses);

      },

      getBoneByName: function(name) {

          for (let i = 0, il = this.bones.length; i < il; i++) {

              const bone = this.bones[i];

              if (bone.name === name) {

                  return bone;

              }

          }

          return undefined;

      },

      dispose: function() {

          if (this.boneTexture) {

              this.boneTexture.dispose();

              this.boneTexture = undefined;

          }

      }

  });

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function Bone() {

      Object3D.call(this);

      this.type = 'Bone';

  }

  Bone.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Bone,

      isBone: true

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const _instanceLocalMatrix = new Matrix4();
  const _instanceWorldMatrix = new Matrix4();

  const _instanceIntersects = [];

  const _mesh = new Mesh();

  function InstancedMesh(geometry, material, count) {

      Mesh.call(this, geometry, material);

      this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);

      this.count = count;

      this.frustumCulled = false;

  }

  InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {

      constructor: InstancedMesh,

      isInstancedMesh: true,

      copy: function(source) {

          Mesh.prototype.copy.call(this, source);

          this.instanceMatrix.copy(source.instanceMatrix);
          this.count = source.count;

          return this;

      },

      getMatrixAt: function(index, matrix) {

          matrix.fromArray(this.instanceMatrix.array, index * 16);

      },

      raycast: function(raycaster, intersects) {

          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;

          _mesh.geometry = this.geometry;
          _mesh.material = this.material;

          if (_mesh.material === undefined) return;

          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {

              // calculate the world matrix for each instance

              this.getMatrixAt(instanceId, _instanceLocalMatrix);

              _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);

              // the mesh represents this single instance

              _mesh.matrixWorld = _instanceWorldMatrix;

              _mesh.raycast(raycaster, _instanceIntersects);

              // process the result of raycast

              for (let i = 0, l = _instanceIntersects.length; i < l; i++) {

                  const intersect = _instanceIntersects[i];
                  intersect.instanceId = instanceId;
                  intersect.object = this;
                  intersects.push(intersect);

              }

              _instanceIntersects.length = 0;

          }

      },

      setMatrixAt: function(index, matrix) {

          matrix.toArray(this.instanceMatrix.array, index * 16);

      },

      updateMorphTargets: function() {

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */

  function LineBasicMaterial(parameters) {

      Material.call(this);

      this.type = 'LineBasicMaterial';

      this.color = new Color(0xffffff);

      this.linewidth = 1;
      this.linecap = 'round';
      this.linejoin = 'round';

      this.morphTargets = false;

      this.setValues(parameters);

  }

  LineBasicMaterial.prototype = Object.create(Material.prototype);
  LineBasicMaterial.prototype.constructor = LineBasicMaterial;

  LineBasicMaterial.prototype.isLineBasicMaterial = true;

  LineBasicMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);

      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;

      this.morphTargets = source.morphTargets;

      return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const _start = new Vector3();
  const _end = new Vector3();
  const _inverseMatrix$1 = new Matrix4();
  const _ray$1 = new Ray();
  const _sphere$2 = new Sphere();

  function Line(geometry, material, mode) {

      if (mode === 1) {

          console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');

      }

      Object3D.call(this);

      this.type = 'Line';

      this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
      this.material = material !== undefined ? material : new LineBasicMaterial();

      this.updateMorphTargets();

  }

  Line.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Line,

      isLine: true,

      copy: function(source) {

          Object3D.prototype.copy.call(this, source);

          this.material = source.material;
          this.geometry = source.geometry;

          return this;

      },

      computeLineDistances: function() {

          const geometry = this.geometry;

          if (geometry.isBufferGeometry) {

              // we assume non-indexed geometry

              if (geometry.index === null) {

                  const positionAttribute = geometry.attributes.position;
                  const lineDistances = [0];

                  for (let i = 1, l = positionAttribute.count; i < l; i++) {

                      _start.fromBufferAttribute(positionAttribute, i - 1);
                      _end.fromBufferAttribute(positionAttribute, i);

                      lineDistances[i] = lineDistances[i - 1];
                      lineDistances[i] += _start.distanceTo(_end);

                  }

                  geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));

              } else {

                  console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');

              }

          } else if (geometry.isGeometry) {

              const vertices = geometry.vertices;
              const lineDistances = geometry.lineDistances;

              lineDistances[0] = 0;

              for (let i = 1, l = vertices.length; i < l; i++) {

                  lineDistances[i] = lineDistances[i - 1];
                  lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);

              }

          }

          return this;

      },

      raycast: function(raycaster, intersects) {

          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;

          // Checking boundingSphere distance to ray

          if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

          _sphere$2.copy(geometry.boundingSphere);
          _sphere$2.applyMatrix4(matrixWorld);
          _sphere$2.radius += threshold;

          if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;

          //

          _inverseMatrix$1.getInverse(matrixWorld);
          _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;

          const vStart = new Vector3();
          const vEnd = new Vector3();
          const interSegment = new Vector3();
          const interRay = new Vector3();
          const step = (this && this.isLineSegments) ? 2 : 1;

          if (geometry.isBufferGeometry) {

              const index = geometry.index;
              const attributes = geometry.attributes;
              const positions = attributes.position.array;

              if (index !== null) {

                  const indices = index.array;

                  for (let i = 0, l = indices.length - 1; i < l; i += step) {

                      const a = indices[i];
                      const b = indices[i + 1];

                      vStart.fromArray(positions, a * 3);
                      vEnd.fromArray(positions, b * 3);

                      const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

                      if (distSq > localThresholdSq) continue;

                      interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                      const distance = raycaster.ray.origin.distanceTo(interRay);

                      if (distance < raycaster.near || distance > raycaster.far) continue;

                      intersects.push({

                          distance: distance,
                          // What do we want? intersection point on the ray or on the segment??
                          // point: raycaster.ray.at( distance ),
                          point: interSegment.clone().applyMatrix4(this.matrixWorld),
                          index: i,
                          face: null,
                          faceIndex: null,
                          object: this

                      });

                  }

              } else {

                  for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {

                      vStart.fromArray(positions, 3 * i);
                      vEnd.fromArray(positions, 3 * i + 3);

                      const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

                      if (distSq > localThresholdSq) continue;

                      interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                      const distance = raycaster.ray.origin.distanceTo(interRay);

                      if (distance < raycaster.near || distance > raycaster.far) continue;

                      intersects.push({

                          distance: distance,
                          // What do we want? intersection point on the ray or on the segment??
                          // point: raycaster.ray.at( distance ),
                          point: interSegment.clone().applyMatrix4(this.matrixWorld),
                          index: i,
                          face: null,
                          faceIndex: null,
                          object: this

                      });

                  }

              }

          } else if (geometry.isGeometry) {

              const vertices = geometry.vertices;
              const nbVertices = vertices.length;

              for (let i = 0; i < nbVertices - 1; i += step) {

                  const distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

                  if (distSq > localThresholdSq) continue;

                  interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                  const distance = raycaster.ray.origin.distanceTo(interRay);

                  if (distance < raycaster.near || distance > raycaster.far) continue;

                  intersects.push({

                      distance: distance,
                      // What do we want? intersection point on the ray or on the segment??
                      // point: raycaster.ray.at( distance ),
                      point: interSegment.clone().applyMatrix4(this.matrixWorld),
                      index: i,
                      face: null,
                      faceIndex: null,
                      object: this

                  });

              }

          }

      },

      updateMorphTargets: function() {

          const geometry = this.geometry;

          if (geometry.isBufferGeometry) {

              const morphAttributes = geometry.morphAttributes;
              const keys = Object.keys(morphAttributes);

              if (keys.length > 0) {

                  const morphAttribute = morphAttributes[keys[0]];

                  if (morphAttribute !== undefined) {

                      this.morphTargetInfluences = [];
                      this.morphTargetDictionary = {};

                      for (let m = 0, ml = morphAttribute.length; m < ml; m++) {

                          const name = morphAttribute[m].name || String(m);

                          this.morphTargetInfluences.push(0);
                          this.morphTargetDictionary[name] = m;

                      }

                  }

              }

          } else {

              const morphTargets = geometry.morphTargets;

              if (morphTargets !== undefined && morphTargets.length > 0) {

                  console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');

              }

          }

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const _start$1 = new Vector3();
  const _end$1 = new Vector3();

  function LineSegments(geometry, material) {

      Line.call(this, geometry, material);

      this.type = 'LineSegments';

  }

  LineSegments.prototype = Object.assign(Object.create(Line.prototype), {

      constructor: LineSegments,

      isLineSegments: true,

      computeLineDistances: function() {

          const geometry = this.geometry;

          if (geometry.isBufferGeometry) {

              // we assume non-indexed geometry

              if (geometry.index === null) {

                  const positionAttribute = geometry.attributes.position;
                  const lineDistances = [];

                  for (let i = 0, l = positionAttribute.count; i < l; i += 2) {

                      _start$1.fromBufferAttribute(positionAttribute, i);
                      _end$1.fromBufferAttribute(positionAttribute, i + 1);

                      lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                      lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);

                  }

                  geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));

              } else {

                  console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');

              }

          } else if (geometry.isGeometry) {

              const vertices = geometry.vertices;
              const lineDistances = geometry.lineDistances;

              for (let i = 0, l = vertices.length; i < l; i += 2) {

                  _start$1.copy(vertices[i]);
                  _end$1.copy(vertices[i + 1]);

                  lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                  lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);

              }

          }

          return this;

      }

  });

  /**
   * @author mgreter / http://github.com/mgreter
   */

  function LineLoop(geometry, material) {

      Line.call(this, geometry, material);

      this.type = 'LineLoop';

  }

  LineLoop.prototype = Object.assign(Object.create(Line.prototype), {

      constructor: LineLoop,

      isLineLoop: true,

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   *
   *  morphTargets: <bool>
   * }
   */

  function PointsMaterial(parameters) {

      Material.call(this);

      this.type = 'PointsMaterial';

      this.color = new Color(0xffffff);

      this.map = null;

      this.alphaMap = null;

      this.size = 1;
      this.sizeAttenuation = true;

      this.morphTargets = false;

      this.setValues(parameters);

  }

  PointsMaterial.prototype = Object.create(Material.prototype);
  PointsMaterial.prototype.constructor = PointsMaterial;

  PointsMaterial.prototype.isPointsMaterial = true;

  PointsMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);

      this.map = source.map;

      this.alphaMap = source.alphaMap;

      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;

      this.morphTargets = source.morphTargets;

      return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  const _inverseMatrix$2 = new Matrix4();
  const _ray$2 = new Ray();
  const _sphere$3 = new Sphere();
  const _position$1 = new Vector3();

  function Points(geometry, material) {

      Object3D.call(this);

      this.type = 'Points';

      this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
      this.material = material !== undefined ? material : new PointsMaterial();

      this.updateMorphTargets();

  }

  Points.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Points,

      isPoints: true,

      copy: function(source) {

          Object3D.prototype.copy.call(this, source);

          this.material = source.material;
          this.geometry = source.geometry;

          return this;

      },

      raycast: function(raycaster, intersects) {

          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;

          // Checking boundingSphere distance to ray

          if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

          _sphere$3.copy(geometry.boundingSphere);
          _sphere$3.applyMatrix4(matrixWorld);
          _sphere$3.radius += threshold;

          if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;

          //

          _inverseMatrix$2.getInverse(matrixWorld);
          _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;

          if (geometry.isBufferGeometry) {

              const index = geometry.index;
              const attributes = geometry.attributes;
              const positions = attributes.position.array;

              if (index !== null) {

                  const indices = index.array;

                  for (let i = 0, il = indices.length; i < il; i++) {

                      const a = indices[i];

                      _position$1.fromArray(positions, a * 3);

                      testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);

                  }

              } else {

                  for (let i = 0, l = positions.length / 3; i < l; i++) {

                      _position$1.fromArray(positions, i * 3);

                      testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);

                  }

              }

          } else {

              const vertices = geometry.vertices;

              for (let i = 0, l = vertices.length; i < l; i++) {

                  testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);

              }

          }

      },

      updateMorphTargets: function() {

          const geometry = this.geometry;

          if (geometry.isBufferGeometry) {

              const morphAttributes = geometry.morphAttributes;
              const keys = Object.keys(morphAttributes);

              if (keys.length > 0) {

                  const morphAttribute = morphAttributes[keys[0]];

                  if (morphAttribute !== undefined) {

                      this.morphTargetInfluences = [];
                      this.morphTargetDictionary = {};

                      for (let m = 0, ml = morphAttribute.length; m < ml; m++) {

                          const name = morphAttribute[m].name || String(m);

                          this.morphTargetInfluences.push(0);
                          this.morphTargetDictionary[name] = m;

                      }

                  }

              }

          } else {

              const morphTargets = geometry.morphTargets;

              if (morphTargets !== undefined && morphTargets.length > 0) {

                  console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');

              }

          }

      }

  });

  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {

      const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);

      if (rayPointDistanceSq < localThresholdSq) {

          const intersectPoint = new Vector3();

          _ray$2.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);

          const distance = raycaster.ray.origin.distanceTo(intersectPoint);

          if (distance < raycaster.near || distance > raycaster.far) return;

          intersects.push({

              distance: distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint,
              index: index,
              face: null,
              object: object

          });

      }

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

      Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

      this.format = format !== undefined ? format : RGBFormat;

      this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
      this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

      this.generateMipmaps = false;

  }

  VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {

      constructor: VideoTexture,

      isVideoTexture: true,

      update: function() {

          const video = this.image;

          if (video.readyState >= video.HAVE_CURRENT_DATA) {

              this.needsUpdate = true;

          }

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

      Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

      this.image = { width: width, height: height };
      this.mipmaps = mipmaps;

      // no flipping for cube textures
      // (also flipping doesn't work for compressed textures )

      this.flipY = false;

      // can't generate mipmaps for compressed textures
      // mips must be embedded in DDS files

      this.generateMipmaps = false;

  }

  CompressedTexture.prototype = Object.create(Texture.prototype);
  CompressedTexture.prototype.constructor = CompressedTexture;

  CompressedTexture.prototype.isCompressedTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

      Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

      this.needsUpdate = true;

  }

  CanvasTexture.prototype = Object.create(Texture.prototype);
  CanvasTexture.prototype.constructor = CanvasTexture;
  CanvasTexture.prototype.isCanvasTexture = true;

  /**
   * @author Matt DesLauriers / @mattdesl
   * @author atix / arthursilber.de
   */

  function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {

      format = format !== undefined ? format : DepthFormat;

      if (format !== DepthFormat && format !== DepthStencilFormat) {

          throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');

      }

      if (type === undefined && format === DepthFormat) type = UnsignedShortType;
      if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;

      Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

      this.image = { width: width, height: height };

      this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
      this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

      this.flipY = false;
      this.generateMipmaps = false;

  }

  DepthTexture.prototype = Object.create(Texture.prototype);
  DepthTexture.prototype.constructor = DepthTexture;
  DepthTexture.prototype.isDepthTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WireframeGeometry(geometry) {

      BufferGeometry.call(this);

      this.type = 'WireframeGeometry';

      // buffer

      const vertices = [];

      // helper variables

      const edge = [0, 0],
          edges = {};
      const keys = ['a', 'b', 'c'];

      // different logic for Geometry and BufferGeometry

      if (geometry && geometry.isGeometry) {

          // create a data structure that contains all edges without duplicates

          const faces = geometry.faces;

          for (let i = 0, l = faces.length; i < l; i++) {

              const face = faces[i];

              for (let j = 0; j < 3; j++) {

                  const edge1 = face[keys[j]];
                  const edge2 = face[keys[(j + 1) % 3]];
                  edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                  edge[1] = Math.max(edge1, edge2);

                  const key = edge[0] + ',' + edge[1];

                  if (edges[key] === undefined) {

                      edges[key] = { index1: edge[0], index2: edge[1] };

                  }

              }

          }

          // generate vertices

          for (const key in edges) {

              const e = edges[key];

              let vertex = geometry.vertices[e.index1];
              vertices.push(vertex.x, vertex.y, vertex.z);

              vertex = geometry.vertices[e.index2];
              vertices.push(vertex.x, vertex.y, vertex.z);

          }

      } else if (geometry && geometry.isBufferGeometry) {

          let vertex = new Vector3();

          if (geometry.index !== null) {

              // indexed BufferGeometry

              const position = geometry.attributes.position;
              const indices = geometry.index;
              let groups = geometry.groups;

              if (groups.length === 0) {

                  groups = [{ start: 0, count: indices.count, materialIndex: 0 }];

              }

              // create a data structure that contains all eges without duplicates

              for (let o = 0, ol = groups.length; o < ol; ++o) {

                  const group = groups[o];

                  const start = group.start;
                  const count = group.count;

                  for (let i = start, l = (start + count); i < l; i += 3) {

                      for (let j = 0; j < 3; j++) {

                          const edge1 = indices.getX(i + j);
                          const edge2 = indices.getX(i + (j + 1) % 3);
                          edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                          edge[1] = Math.max(edge1, edge2);

                          const key = edge[0] + ',' + edge[1];

                          if (edges[key] === undefined) {

                              edges[key] = { index1: edge[0], index2: edge[1] };

                          }

                      }

                  }

              }

              // generate vertices

              for (const key in edges) {

                  const e = edges[key];

                  vertex.fromBufferAttribute(position, e.index1);
                  vertices.push(vertex.x, vertex.y, vertex.z);

                  vertex.fromBufferAttribute(position, e.index2);
                  vertices.push(vertex.x, vertex.y, vertex.z);

              }

          } else {

              // non-indexed BufferGeometry

              const position = geometry.attributes.position;

              for (let i = 0, l = (position.count / 3); i < l; i++) {

                  for (let j = 0; j < 3; j++) {

                      // three edges per triangle, an edge is represented as (index1, index2)
                      // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

                      const index1 = 3 * i + j;
                      vertex.fromBufferAttribute(position, index1);
                      vertices.push(vertex.x, vertex.y, vertex.z);

                      const index2 = 3 * i + ((j + 1) % 3);
                      vertex.fromBufferAttribute(position, index2);
                      vertices.push(vertex.x, vertex.y, vertex.z);

                  }

              }

          }

      }

      // build geometry

      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

  }

  WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
  WireframeGeometry.prototype.constructor = WireframeGeometry;

  /**
   * @author zz85 / https://github.com/zz85
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Parametric Surfaces Geometry
   * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
   */

  // ParametricGeometry

  function ParametricGeometry(func, slices, stacks) {

      Geometry.call(this);

      this.type = 'ParametricGeometry';

      this.parameters = {
          func: func,
          slices: slices,
          stacks: stacks
      };

      this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
      this.mergeVertices();

  }

  ParametricGeometry.prototype = Object.create(Geometry.prototype);
  ParametricGeometry.prototype.constructor = ParametricGeometry;

  // ParametricBufferGeometry

  function ParametricBufferGeometry(func, slices, stacks) {

      BufferGeometry.call(this);

      this.type = 'ParametricBufferGeometry';

      this.parameters = {
          func: func,
          slices: slices,
          stacks: stacks
      };

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      const EPS = 0.00001;

      const normal = new Vector3();

      const p0 = new Vector3(),
          p1 = new Vector3();
      const pu = new Vector3(),
          pv = new Vector3();

      if (func.length < 3) {

          console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');

      }

      // generate vertices, normals and uvs

      const sliceCount = slices + 1;

      for (let i = 0; i <= stacks; i++) {

          const v = i / stacks;

          for (let j = 0; j <= slices; j++) {

              const u = j / slices;

              // vertex

              func(u, v, p0);
              vertices.push(p0.x, p0.y, p0.z);

              // normal

              // approximate tangent vectors via finite differences

              if (u - EPS >= 0) {

                  func(u - EPS, v, p1);
                  pu.subVectors(p0, p1);

              } else {

                  func(u + EPS, v, p1);
                  pu.subVectors(p1, p0);

              }

              if (v - EPS >= 0) {

                  func(u, v - EPS, p1);
                  pv.subVectors(p0, p1);

              } else {

                  func(u, v + EPS, p1);
                  pv.subVectors(p1, p0);

              }

              // cross product of tangent vectors returns surface normal

              normal.crossVectors(pu, pv).normalize();
              normals.push(normal.x, normal.y, normal.z);

              // uv

              uvs.push(u, v);

          }

      }

      // generate indices

      for (let i = 0; i < stacks; i++) {

          for (let j = 0; j < slices; j++) {

              const a = i * sliceCount + j;
              const b = i * sliceCount + j + 1;
              const c = (i + 1) * sliceCount + j + 1;
              const d = (i + 1) * sliceCount + j;

              // faces one and two

              indices.push(a, b, d);
              indices.push(b, c, d);

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

  }

  ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

  /**
   * @author clockworkgeek / https://github.com/clockworkgeek
   * @author timothypratley / https://github.com/timothypratley
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PolyhedronGeometry

  function PolyhedronGeometry(vertices, indices, radius, detail) {

      Geometry.call(this);

      this.type = 'PolyhedronGeometry';

      this.parameters = {
          vertices: vertices,
          indices: indices,
          radius: radius,
          detail: detail
      };

      this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
      this.mergeVertices();

  }

  PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
  PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

  // PolyhedronBufferGeometry

  function PolyhedronBufferGeometry(vertices, indices, radius, detail) {

      BufferGeometry.call(this);

      this.type = 'PolyhedronBufferGeometry';

      this.parameters = {
          vertices: vertices,
          indices: indices,
          radius: radius,
          detail: detail
      };

      radius = radius || 1;
      detail = detail || 0;

      // default buffer data

      const vertexBuffer = [];
      const uvBuffer = [];

      // the subdivision creates the vertex buffer data

      subdivide(detail);

      // all vertices should lie on a conceptual sphere with a given radius

      applyRadius(radius);

      // finally, create the uv data

      generateUVs();

      // build non-indexed geometry

      this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
      this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

      if (detail === 0) {

          this.computeVertexNormals(); // flat normals

      } else {

          this.normalizeNormals(); // smooth normals

      }

      // helper functions

      function subdivide(detail) {

          const a = new Vector3();
          const b = new Vector3();
          const c = new Vector3();

          // iterate over all faces and apply a subdivison with the given detail value

          for (let i = 0; i < indices.length; i += 3) {

              // get the vertices of the face

              getVertexByIndex(indices[i + 0], a);
              getVertexByIndex(indices[i + 1], b);
              getVertexByIndex(indices[i + 2], c);

              // perform subdivision

              subdivideFace(a, b, c, detail);

          }

      }

      function subdivideFace(a, b, c, detail) {

          const cols = Math.pow(2, detail);

          // we use this multidimensional array as a data structure for creating the subdivision

          const v = [];

          // construct all of the vertices for this subdivision

          for (let i = 0; i <= cols; i++) {

              v[i] = [];

              const aj = a.clone().lerp(c, i / cols);
              const bj = b.clone().lerp(c, i / cols);

              const rows = cols - i;

              for (let j = 0; j <= rows; j++) {

                  if (j === 0 && i === cols) {

                      v[i][j] = aj;

                  } else {

                      v[i][j] = aj.clone().lerp(bj, j / rows);

                  }

              }

          }

          // construct all of the faces

          for (let i = 0; i < cols; i++) {

              for (let j = 0; j < 2 * (cols - i) - 1; j++) {

                  const k = Math.floor(j / 2);

                  if (j % 2 === 0) {

                      pushVertex(v[i][k + 1]);
                      pushVertex(v[i + 1][k]);
                      pushVertex(v[i][k]);

                  } else {

                      pushVertex(v[i][k + 1]);
                      pushVertex(v[i + 1][k + 1]);
                      pushVertex(v[i + 1][k]);

                  }

              }

          }

      }

      function applyRadius(radius) {

          const vertex = new Vector3();

          // iterate over the entire buffer and apply the radius to each vertex

          for (let i = 0; i < vertexBuffer.length; i += 3) {

              vertex.x = vertexBuffer[i + 0];
              vertex.y = vertexBuffer[i + 1];
              vertex.z = vertexBuffer[i + 2];

              vertex.normalize().multiplyScalar(radius);

              vertexBuffer[i + 0] = vertex.x;
              vertexBuffer[i + 1] = vertex.y;
              vertexBuffer[i + 2] = vertex.z;

          }

      }

      function generateUVs() {

          const vertex = new Vector3();

          for (let i = 0; i < vertexBuffer.length; i += 3) {

              vertex.x = vertexBuffer[i + 0];
              vertex.y = vertexBuffer[i + 1];
              vertex.z = vertexBuffer[i + 2];

              const u = azimuth(vertex) / 2 / Math.PI + 0.5;
              const v = inclination(vertex) / Math.PI + 0.5;
              uvBuffer.push(u, 1 - v);

          }

          correctUVs();

          correctSeam();

      }

      function correctSeam() {

          // handle case when face straddles the seam, see #3269

          for (let i = 0; i < uvBuffer.length; i += 6) {

              // uv data of a single face

              const x0 = uvBuffer[i + 0];
              const x1 = uvBuffer[i + 2];
              const x2 = uvBuffer[i + 4];

              const max = Math.max(x0, x1, x2);
              const min = Math.min(x0, x1, x2);

              // 0.9 is somewhat arbitrary

              if (max > 0.9 && min < 0.1) {

                  if (x0 < 0.2) uvBuffer[i + 0] += 1;
                  if (x1 < 0.2) uvBuffer[i + 2] += 1;
                  if (x2 < 0.2) uvBuffer[i + 4] += 1;

              }

          }

      }

      function pushVertex(vertex) {

          vertexBuffer.push(vertex.x, vertex.y, vertex.z);

      }

      function getVertexByIndex(index, vertex) {

          const stride = index * 3;

          vertex.x = vertices[stride + 0];
          vertex.y = vertices[stride + 1];
          vertex.z = vertices[stride + 2];

      }

      function correctUVs() {

          const a = new Vector3();
          const b = new Vector3();
          const c = new Vector3();

          const centroid = new Vector3();

          const uvA = new Vector2();
          const uvB = new Vector2();
          const uvC = new Vector2();

          for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {

              a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
              b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
              c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);

              uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
              uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
              uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);

              centroid.copy(a).add(b).add(c).divideScalar(3);

              const azi = azimuth(centroid);

              correctUV(uvA, j + 0, a, azi);
              correctUV(uvB, j + 2, b, azi);
              correctUV(uvC, j + 4, c, azi);

          }

      }

      function correctUV(uv, stride, vector, azimuth) {

          if ((azimuth < 0) && (uv.x === 1)) {

              uvBuffer[stride] = uv.x - 1;

          }

          if ((vector.x === 0) && (vector.z === 0)) {

              uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;

          }

      }

      // Angle around the Y axis, counter-clockwise when looking from above.

      function azimuth(vector) {

          return Math.atan2(vector.z, -vector.x);

      }


      // Angle above the XZ plane.

      function inclination(vector) {

          return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));

      }

  }

  PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TetrahedronGeometry

  function TetrahedronGeometry(radius, detail) {

      Geometry.call(this);

      this.type = 'TetrahedronGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

      this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
      this.mergeVertices();

  }

  TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
  TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

  // TetrahedronBufferGeometry

  function TetrahedronBufferGeometry(radius, detail) {

      const vertices = [
          1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
      ];

      const indices = [
          2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
      ];

      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

      this.type = 'TetrahedronBufferGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

  }

  TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // OctahedronGeometry

  function OctahedronGeometry(radius, detail) {

      Geometry.call(this);

      this.type = 'OctahedronGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

      this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
      this.mergeVertices();

  }

  OctahedronGeometry.prototype = Object.create(Geometry.prototype);
  OctahedronGeometry.prototype.constructor = OctahedronGeometry;

  // OctahedronBufferGeometry

  function OctahedronBufferGeometry(radius, detail) {

      const vertices = [
          1, 0, 0, -1, 0, 0, 0, 1, 0,
          0, -1, 0, 0, 0, 1, 0, 0, -1
      ];

      const indices = [
          0, 2, 4, 0, 4, 3, 0, 3, 5,
          0, 5, 2, 1, 2, 5, 1, 5, 3,
          1, 3, 4, 1, 4, 2
      ];

      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

      this.type = 'OctahedronBufferGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

  }

  OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // IcosahedronGeometry

  function IcosahedronGeometry(radius, detail) {

      Geometry.call(this);

      this.type = 'IcosahedronGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

      this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
      this.mergeVertices();

  }

  IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
  IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

  // IcosahedronBufferGeometry

  function IcosahedronBufferGeometry(radius, detail) {

      const t = (1 + Math.sqrt(5)) / 2;

      const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
          0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
          t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
      ];

      const indices = [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
          1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
          3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
          4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
      ];

      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

      this.type = 'IcosahedronBufferGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

  }

  IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

  /**
   * @author Abe Pazos / https://hamoid.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // DodecahedronGeometry

  function DodecahedronGeometry(radius, detail) {

      Geometry.call(this);

      this.type = 'DodecahedronGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

      this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
      this.mergeVertices();

  }

  DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
  DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

  // DodecahedronBufferGeometry

  function DodecahedronBufferGeometry(radius, detail) {

      const t = (1 + Math.sqrt(5)) / 2;
      const r = 1 / t;

      const vertices = [

          // (±1, ±1, ±1)
          -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1,
          1, -1, -1, 1, -1, 1,
          1, 1, -1, 1, 1, 1,

          // (0, ±1/φ, ±φ)
          0, -r, -t, 0, -r, t,
          0, r, -t, 0, r, t,

          // (±1/φ, ±φ, 0)
          -r, -t, 0, -r, t, 0,
          r, -t, 0, r, t, 0,

          // (±φ, 0, ±1/φ)
          -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r
      ];

      const indices = [
          3, 11, 7, 3, 7, 15, 3, 15, 13,
          7, 19, 17, 7, 17, 6, 7, 6, 15,
          17, 4, 8, 17, 8, 10, 17, 10, 6,
          8, 0, 16, 8, 16, 2, 8, 2, 10,
          0, 12, 1, 0, 1, 18, 0, 18, 16,
          6, 10, 2, 6, 2, 13, 6, 13, 15,
          2, 16, 18, 2, 18, 3, 2, 3, 13,
          18, 1, 9, 18, 9, 11, 18, 11, 3,
          4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7,
          19, 5, 14, 19, 14, 4, 19, 4, 17,
          1, 12, 14, 1, 14, 5, 1, 5, 9
      ];

      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

      this.type = 'DodecahedronBufferGeometry';

      this.parameters = {
          radius: radius,
          detail: detail
      };

  }

  DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

  /**
   * @author oosmoxiecode / https://github.com/oosmoxiecode
   * @author WestLangley / https://github.com/WestLangley
   * @author zz85 / https://github.com/zz85
   * @author miningold / https://github.com/miningold
   * @author jonobr1 / https://github.com/jonobr1
   * @author Mugen87 / https://github.com/Mugen87
   *
   */

  // TubeGeometry

  function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {

      Geometry.call(this);

      this.type = 'TubeGeometry';

      this.parameters = {
          path: path,
          tubularSegments: tubularSegments,
          radius: radius,
          radialSegments: radialSegments,
          closed: closed
      };

      if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');

      const bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);

      // expose internals

      this.tangents = bufferGeometry.tangents;
      this.normals = bufferGeometry.normals;
      this.binormals = bufferGeometry.binormals;

      // create geometry

      this.fromBufferGeometry(bufferGeometry);
      this.mergeVertices();

  }

  TubeGeometry.prototype = Object.create(Geometry.prototype);
  TubeGeometry.prototype.constructor = TubeGeometry;

  // TubeBufferGeometry

  function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {

      BufferGeometry.call(this);

      this.type = 'TubeBufferGeometry';

      this.parameters = {
          path: path,
          tubularSegments: tubularSegments,
          radius: radius,
          radialSegments: radialSegments,
          closed: closed
      };

      tubularSegments = tubularSegments || 64;
      radius = radius || 1;
      radialSegments = radialSegments || 8;
      closed = closed || false;

      const frames = path.computeFrenetFrames(tubularSegments, closed);

      // expose internals

      this.tangents = frames.tangents;
      this.normals = frames.normals;
      this.binormals = frames.binormals;

      // helper variables

      const vertex = new Vector3();
      const normal = new Vector3();
      const uv = new Vector2();
      let P = new Vector3();

      // buffer

      const vertices = [];
      const normals = [];
      const uvs = [];
      const indices = [];

      // create buffer data

      generateBufferData();

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      // functions

      function generateBufferData() {

          for (let i = 0; i < tubularSegments; i++) {

              generateSegment(i);

          }

          // if the geometry is not closed, generate the last row of vertices and normals
          // at the regular position on the given path
          //
          // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

          generateSegment((closed === false) ? tubularSegments : 0);

          // uvs are generated in a separate function.
          // this makes it easy compute correct values for closed geometries

          generateUVs();

          // finally create faces

          generateIndices();

      }

      function generateSegment(i) {

          // we use getPointAt to sample evenly distributed points from the given path

          P = path.getPointAt(i / tubularSegments, P);

          // retrieve corresponding normal and binormal

          const N = frames.normals[i];
          const B = frames.binormals[i];

          // generate normals and vertices for the current segment

          for (let j = 0; j <= radialSegments; j++) {

              const v = j / radialSegments * Math.PI * 2;

              const sin = Math.sin(v);
              const cos = -Math.cos(v);

              // normal

              normal.x = (cos * N.x + sin * B.x);
              normal.y = (cos * N.y + sin * B.y);
              normal.z = (cos * N.z + sin * B.z);
              normal.normalize();

              normals.push(normal.x, normal.y, normal.z);

              // vertex

              vertex.x = P.x + radius * normal.x;
              vertex.y = P.y + radius * normal.y;
              vertex.z = P.z + radius * normal.z;

              vertices.push(vertex.x, vertex.y, vertex.z);

          }

      }

      function generateIndices() {

          for (let j = 1; j <= tubularSegments; j++) {

              for (let i = 1; i <= radialSegments; i++) {

                  const a = (radialSegments + 1) * (j - 1) + (i - 1);
                  const b = (radialSegments + 1) * j + (i - 1);
                  const c = (radialSegments + 1) * j + i;
                  const d = (radialSegments + 1) * (j - 1) + i;

                  // faces

                  indices.push(a, b, d);
                  indices.push(b, c, d);

              }

          }

      }

      function generateUVs() {

          for (let i = 0; i <= tubularSegments; i++) {

              for (let j = 0; j <= radialSegments; j++) {

                  uv.x = i / tubularSegments;
                  uv.y = j / radialSegments;

                  uvs.push(uv.x, uv.y);

              }

          }

      }

  }

  TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

  TubeBufferGeometry.prototype.toJSON = function() {

      const data = BufferGeometry.prototype.toJSON.call(this);

      data.path = this.parameters.path.toJSON();

      return data;

  };

  /**
   * @author oosmoxiecode
   * @author Mugen87 / https://github.com/Mugen87
   *
   * based on http://www.blackpawn.com/texts/pqtorus/
   */

  // TorusKnotGeometry

  function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {

      Geometry.call(this);

      this.type = 'TorusKnotGeometry';

      this.parameters = {
          radius: radius,
          tube: tube,
          tubularSegments: tubularSegments,
          radialSegments: radialSegments,
          p: p,
          q: q
      };

      if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');

      this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
      this.mergeVertices();

  }

  TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
  TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

  // TorusKnotBufferGeometry

  function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {

      BufferGeometry.call(this);

      this.type = 'TorusKnotBufferGeometry';

      this.parameters = {
          radius: radius,
          tube: tube,
          tubularSegments: tubularSegments,
          radialSegments: radialSegments,
          p: p,
          q: q
      };

      radius = radius || 1;
      tube = tube || 0.4;
      tubularSegments = Math.floor(tubularSegments) || 64;
      radialSegments = Math.floor(radialSegments) || 8;
      p = p || 2;
      q = q || 3;

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // helper variables

      const vertex = new Vector3();
      const normal = new Vector3();

      const P1 = new Vector3();
      const P2 = new Vector3();

      const B = new Vector3();
      const T = new Vector3();
      const N = new Vector3();

      // generate vertices, normals and uvs

      for (let i = 0; i <= tubularSegments; ++i) {

          // the radian "u" is used to calculate the position on the torus curve of the current tubular segement

          const u = i / tubularSegments * p * Math.PI * 2;

          // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
          // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

          calculatePositionOnCurve(u, p, q, radius, P1);
          calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

          // calculate orthonormal basis

          T.subVectors(P2, P1);
          N.addVectors(P2, P1);
          B.crossVectors(T, N);
          N.crossVectors(B, T);

          // normalize B, N. T can be ignored, we don't use it

          B.normalize();
          N.normalize();

          for (let j = 0; j <= radialSegments; ++j) {

              // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
              // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

              const v = j / radialSegments * Math.PI * 2;
              const cx = -tube * Math.cos(v);
              const cy = tube * Math.sin(v);

              // now calculate the final vertex position.
              // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

              vertex.x = P1.x + (cx * N.x + cy * B.x);
              vertex.y = P1.y + (cx * N.y + cy * B.y);
              vertex.z = P1.z + (cx * N.z + cy * B.z);

              vertices.push(vertex.x, vertex.y, vertex.z);

              // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

              normal.subVectors(vertex, P1).normalize();

              normals.push(normal.x, normal.y, normal.z);

              // uv

              uvs.push(i / tubularSegments);
              uvs.push(j / radialSegments);

          }

      }

      // generate indices

      for (let j = 1; j <= tubularSegments; j++) {

          for (let i = 1; i <= radialSegments; i++) {

              // indices

              const a = (radialSegments + 1) * (j - 1) + (i - 1);
              const b = (radialSegments + 1) * j + (i - 1);
              const c = (radialSegments + 1) * j + i;
              const d = (radialSegments + 1) * (j - 1) + i;

              // faces

              indices.push(a, b, d);
              indices.push(b, c, d);

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      // this function calculates the current position on the torus curve

      function calculatePositionOnCurve(u, p, q, radius, position) {

          const cu = Math.cos(u);
          const su = Math.sin(u);
          const quOverP = q / p * u;
          const cs = Math.cos(quOverP);

          position.x = radius * (2 + cs) * 0.5 * cu;
          position.y = radius * (2 + cs) * su * 0.5;
          position.z = radius * Math.sin(quOverP) * 0.5;

      }

  }

  TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

  /**
   * @author oosmoxiecode
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TorusGeometry

  function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {

      Geometry.call(this);

      this.type = 'TorusGeometry';

      this.parameters = {
          radius: radius,
          tube: tube,
          radialSegments: radialSegments,
          tubularSegments: tubularSegments,
          arc: arc
      };

      this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
      this.mergeVertices();

  }

  TorusGeometry.prototype = Object.create(Geometry.prototype);
  TorusGeometry.prototype.constructor = TorusGeometry;

  // TorusBufferGeometry

  function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {

      BufferGeometry.call(this);

      this.type = 'TorusBufferGeometry';

      this.parameters = {
          radius: radius,
          tube: tube,
          radialSegments: radialSegments,
          tubularSegments: tubularSegments,
          arc: arc
      };

      radius = radius || 1;
      tube = tube || 0.4;
      radialSegments = Math.floor(radialSegments) || 8;
      tubularSegments = Math.floor(tubularSegments) || 6;
      arc = arc || Math.PI * 2;

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // helper variables

      const center = new Vector3();
      const vertex = new Vector3();
      const normal = new Vector3();

      // generate vertices, normals and uvs

      for (let j = 0; j <= radialSegments; j++) {

          for (let i = 0; i <= tubularSegments; i++) {

              const u = i / tubularSegments * arc;
              const v = j / radialSegments * Math.PI * 2;

              // vertex

              vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
              vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
              vertex.z = tube * Math.sin(v);

              vertices.push(vertex.x, vertex.y, vertex.z);

              // normal

              center.x = radius * Math.cos(u);
              center.y = radius * Math.sin(u);
              normal.subVectors(vertex, center).normalize();

              normals.push(normal.x, normal.y, normal.z);

              // uv

              uvs.push(i / tubularSegments);
              uvs.push(j / radialSegments);

          }

      }

      // generate indices

      for (let j = 1; j <= radialSegments; j++) {

          for (let i = 1; i <= tubularSegments; i++) {

              // indices

              const a = (tubularSegments + 1) * j + i - 1;
              const b = (tubularSegments + 1) * (j - 1) + i - 1;
              const c = (tubularSegments + 1) * (j - 1) + i;
              const d = (tubularSegments + 1) * j + i;

              // faces

              indices.push(a, b, d);
              indices.push(b, c, d);

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

  }

  TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

  /**
   * @author Mugen87 / https://github.com/Mugen87
   * Port from https://github.com/mapbox/earcut (v2.2.2)
   */

  const Earcut = {

      triangulate: function(data, holeIndices, dim) {

          dim = dim || 2;

          let hasHoles = holeIndices && holeIndices.length,
              outerLen = hasHoles ? holeIndices[0] * dim : data.length,
              outerNode = linkedList(data, 0, outerLen, dim, true),
              triangles = [];

          if (!outerNode || outerNode.next === outerNode.prev) return triangles;

          let minX, minY, maxX, maxY, x, y, invSize;

          if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

          // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
          if (data.length > 80 * dim) {

              minX = maxX = data[0];
              minY = maxY = data[1];

              for (let i = dim; i < outerLen; i += dim) {

                  x = data[i];
                  y = data[i + 1];
                  if (x < minX) minX = x;
                  if (y < minY) minY = y;
                  if (x > maxX) maxX = x;
                  if (y > maxY) maxY = y;

              }

              // minX, minY and invSize are later used to transform coords into integers for z-order calculation
              invSize = Math.max(maxX - minX, maxY - minY);
              invSize = invSize !== 0 ? 1 / invSize : 0;

          }

          earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

          return triangles;

      }

  };

  // create a circular doubly linked list from polygon points in the specified winding order
  function linkedList(data, start, end, dim, clockwise) {

      let i, last;

      if (clockwise === (signedArea(data, start, end, dim) > 0)) {

          for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);

      } else {

          for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);

      }

      if (last && equals(last, last.next)) {

          removeNode(last);
          last = last.next;

      }

      return last;

  }

  // eliminate colinear or duplicate points
  function filterPoints(start, end) {

      if (!start) return start;
      if (!end) end = start;

      let p = start,
          again;
      do {

          again = false;

          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {

              removeNode(p);
              p = end = p.prev;
              if (p === p.next) break;
              again = true;

          } else {

              p = p.next;

          }

      } while (again || p !== end);

      return end;

  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {

      if (!ear) return;

      // interlink polygon nodes in z-order
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

      let stop = ear,
          prev, next;

      // iterate through ears, slicing them one by one
      while (ear.prev !== ear.next) {

          prev = ear.prev;
          next = ear.next;

          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {

              // cut off the triangle
              triangles.push(prev.i / dim);
              triangles.push(ear.i / dim);
              triangles.push(next.i / dim);

              removeNode(ear);

              // skipping the next vertex leads to less sliver triangles
              ear = next.next;
              stop = next.next;

              continue;

          }

          ear = next;

          // if we looped through the whole remaining polygon and can't find any more ears
          if (ear === stop) {

              // try filtering points and slicing again
              if (!pass) {

                  earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                  // if this didn't work, try curing all small self-intersections locally

              } else if (pass === 1) {

                  ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                  earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                  // as a last resort, try splitting the remaining polygon into two

              } else if (pass === 2) {

                  splitEarcut(ear, triangles, dim, minX, minY, invSize);

              }

              break;

          }

      }

  }

  // check whether a polygon node forms a valid ear with adjacent nodes
  function isEar(ear) {

      let a = ear.prev,
          b = ear,
          c = ear.next;

      if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

      // now make sure we don't have other points inside the potential ear
      let p = ear.next.next;

      while (p !== ear.prev) {

          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
              area(p.prev, p, p.next) >= 0) return false;
          p = p.next;

      }

      return true;

  }

  function isEarHashed(ear, minX, minY, invSize) {

      let a = ear.prev,
          b = ear,
          c = ear.next;

      if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

      // triangle bbox; min & max are calculated like this for speed
      let minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
          minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
          maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
          maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

      // z-order range for the current triangle bbox;
      let minZ = zOrder(minTX, minTY, minX, minY, invSize),
          maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

      let p = ear.prevZ,
          n = ear.nextZ;

      // look for points inside the triangle in both directions
      while (p && p.z >= minZ && n && n.z <= maxZ) {

          if (p !== ear.prev && p !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
              area(p.prev, p, p.next) >= 0) return false;
          p = p.prevZ;

          if (n !== ear.prev && n !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
              area(n.prev, n, n.next) >= 0) return false;
          n = n.nextZ;

      }

      // look for remaining points in decreasing z-order
      while (p && p.z >= minZ) {

          if (p !== ear.prev && p !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
              area(p.prev, p, p.next) >= 0) return false;
          p = p.prevZ;

      }

      // look for remaining points in increasing z-order
      while (n && n.z <= maxZ) {

          if (n !== ear.prev && n !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
              area(n.prev, n, n.next) >= 0) return false;
          n = n.nextZ;

      }

      return true;

  }

  // go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections(start, triangles, dim) {

      let p = start;
      do {

          let a = p.prev,
              b = p.next.next;

          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

              triangles.push(a.i / dim);
              triangles.push(p.i / dim);
              triangles.push(b.i / dim);

              // remove two nodes involved
              removeNode(p);
              removeNode(p.next);

              p = start = b;

          }

          p = p.next;

      } while (p !== start);

      return filterPoints(p);

  }

  // try splitting polygon into two and triangulate them independently
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {

      // look for a valid diagonal that divides the polygon into two
      let a = start;
      do {

          let b = a.next.next;
          while (b !== a.prev) {

              if (a.i !== b.i && isValidDiagonal(a, b)) {

                  // split the polygon in two by the diagonal
                  let c = splitPolygon(a, b);

                  // filter colinear points around the cuts
                  a = filterPoints(a, a.next);
                  c = filterPoints(c, c.next);

                  // run earcut on each half
                  earcutLinked(a, triangles, dim, minX, minY, invSize);
                  earcutLinked(c, triangles, dim, minX, minY, invSize);
                  return;

              }

              b = b.next;

          }

          a = a.next;

      } while (a !== start);

  }

  // link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles(data, holeIndices, outerNode, dim) {

      let queue = [],
          i, len, start, end, list;

      for (i = 0, len = holeIndices.length; i < len; i++) {

          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next) list.steiner = true;
          queue.push(getLeftmost(list));

      }

      queue.sort(compareX);

      // process holes from left to right
      for (i = 0; i < queue.length; i++) {

          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);

      }

      return outerNode;

  }

  function compareX(a, b) {

      return a.x - b.x;

  }

  // find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole(hole, outerNode) {

      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {

          const b = splitPolygon(outerNode, hole);

          // filter collinear points around the cuts
          filterPoints(outerNode, outerNode.next);
          filterPoints(b, b.next);

      }

  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge(hole, outerNode) {

      let p = outerNode,
          hx = hole.x,
          hy = hole.y,
          qx = -Infinity,
          m;

      // find a segment intersected by a ray from the hole's leftmost point to the left;
      // segment's endpoint with lesser x will be potential connection point
      do {

          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {

              let x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
              if (x <= hx && x > qx) {

                  qx = x;
                  if (x === hx) {

                      if (hy === p.y) return p;
                      if (hy === p.next.y) return p.next;

                  }

                  m = p.x < p.next.x ? p : p.next;

              }

          }

          p = p.next;

      } while (p !== outerNode);

      if (!m) return null;

      if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

      // look for points inside the triangle of hole point, segment intersection and endpoint;
      // if there are no points found, we have a valid connection;
      // otherwise choose the point of the minimum angle with the ray as connection point

      let stop = m,
          mx = m.x,
          my = m.y,
          tanMin = Infinity,
          tan;

      p = m;

      do {

          if (hx >= p.x && p.x >= mx && hx !== p.x &&
              pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

              tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

              if (locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {

                  m = p;
                  tanMin = tan;

              }

          }

          p = p.next;

      } while (p !== stop);

      return m;

  }

  // whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector(m, p) {

      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;

  }

  // interlink polygon nodes in z-order
  function indexCurve(start, minX, minY, invSize) {

      let p = start;
      do {

          if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;

      } while (p !== start);

      p.prevZ.nextZ = null;
      p.prevZ = null;

      sortLinked(p);

  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked(list) {

      let i, p, q, e, tail, numMerges, pSize, qSize,
          inSize = 1;

      do {

          p = list;
          list = null;
          tail = null;
          numMerges = 0;

          while (p) {

              numMerges++;
              q = p;
              pSize = 0;
              for (i = 0; i < inSize; i++) {

                  pSize++;
                  q = q.nextZ;
                  if (!q) break;

              }

              qSize = inSize;

              while (pSize > 0 || (qSize > 0 && q)) {

                  if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {

                      e = p;
                      p = p.nextZ;
                      pSize--;

                  } else {

                      e = q;
                      q = q.nextZ;
                      qSize--;

                  }

                  if (tail) tail.nextZ = e;
                  else list = e;

                  e.prevZ = tail;
                  tail = e;

              }

              p = q;

          }

          tail.nextZ = null;
          inSize *= 2;

      } while (numMerges > 1);

      return list;

  }

  // z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder(x, y, minX, minY, invSize) {

      // coords are transformed into non-negative 15-bit integer range
      x = 32767 * (x - minX) * invSize;
      y = 32767 * (y - minY) * invSize;

      x = (x | (x << 8)) & 0x00FF00FF;
      x = (x | (x << 4)) & 0x0F0F0F0F;
      x = (x | (x << 2)) & 0x33333333;
      x = (x | (x << 1)) & 0x55555555;

      y = (y | (y << 8)) & 0x00FF00FF;
      y = (y | (y << 4)) & 0x0F0F0F0F;
      y = (y | (y << 2)) & 0x33333333;
      y = (y | (y << 1)) & 0x55555555;

      return x | (y << 1);

  }

  // find the leftmost node of a polygon ring
  function getLeftmost(start) {

      let p = start,
          leftmost = start;
      do {

          if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
          p = p.next;

      } while (p !== start);

      return leftmost;

  }

  // check if a point lies within a convex triangle
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {

      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
          (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
          (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;

  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal(a, b) {

      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
          (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
              (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
              equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case

  }

  // signed area of a triangle
  function area(p, q, r) {

      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);

  }

  // check if two points are equal
  function equals(p1, p2) {

      return p1.x === p2.x && p1.y === p2.y;

  }

  // check if two segments intersect
  function intersects(p1, q1, p2, q2) {

      const o1 = sign(area(p1, q1, p2));
      const o2 = sign(area(p1, q1, q2));
      const o3 = sign(area(p2, q2, p1));
      const o4 = sign(area(p2, q2, q1));

      if (o1 !== o2 && o3 !== o4) return true; // general case

      if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
      if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
      if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
      if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

      return false;

  }

  // for collinear points p, q, r, check if point q lies on segment pr
  function onSegment(p, q, r) {

      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);

  }

  function sign(num) {

      return num > 0 ? 1 : num < 0 ? -1 : 0;

  }

  // check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon(a, b) {

      let p = a;
      do {

          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
              intersects(p, p.next, a, b)) return true;
          p = p.next;

      } while (p !== a);

      return false;

  }

  // check if a polygon diagonal is locally inside the polygon
  function locallyInside(a, b) {

      return area(a.prev, a, a.next) < 0 ?
          area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
          area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;

  }

  // check if the middle point of a polygon diagonal is inside the polygon
  function middleInside(a, b) {

      let p = a,
          inside = false,
          px = (a.x + b.x) / 2,
          py = (a.y + b.y) / 2;
      do {

          if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
              (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
              inside = !inside;
          p = p.next;

      } while (p !== a);

      return inside;

  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon(a, b) {

      let a2 = new Node(a.i, a.x, a.y),
          b2 = new Node(b.i, b.x, b.y),
          an = a.next,
          bp = b.prev;

      a.next = b;
      b.prev = a;

      a2.next = an;
      an.prev = a2;

      b2.next = a2;
      a2.prev = b2;

      bp.next = b2;
      b2.prev = bp;

      return b2;

  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode(i, x, y, last) {

      const p = new Node(i, x, y);

      if (!last) {

          p.prev = p;
          p.next = p;

      } else {

          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;

      }

      return p;

  }

  function removeNode(p) {

      p.next.prev = p.prev;
      p.prev.next = p.next;

      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;

  }

  function Node(i, x, y) {

      // vertex index in coordinates array
      this.i = i;

      // vertex coordinates
      this.x = x;
      this.y = y;

      // previous and next vertex nodes in a polygon ring
      this.prev = null;
      this.next = null;

      // z-order curve value
      this.z = null;

      // previous and next nodes in z-order
      this.prevZ = null;
      this.nextZ = null;

      // indicates whether this is a steiner point
      this.steiner = false;

  }

  function signedArea(data, start, end, dim) {

      let sum = 0;
      for (let i = start, j = end - dim; i < end; i += dim) {

          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;

      }

      return sum;

  }

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  const ShapeUtils = {

      // calculate area of the contour polygon

      area: function(contour) {

          const n = contour.length;
          let a = 0.0;

          for (let p = n - 1, q = 0; q < n; p = q++) {

              a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;

          }

          return a * 0.5;

      },

      isClockWise: function(pts) {

          return ShapeUtils.area(pts) < 0;

      },

      triangulateShape: function(contour, holes) {

          const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
          const holeIndices = []; // array of hole indices
          const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

          removeDupEndPts(contour);
          addContour(vertices, contour);

          //

          let holeIndex = contour.length;

          holes.forEach(removeDupEndPts);

          for (let i = 0; i < holes.length; i++) {

              holeIndices.push(holeIndex);
              holeIndex += holes[i].length;
              addContour(vertices, holes[i]);

          }

          //

          const triangles = Earcut.triangulate(vertices, holeIndices);

          //

          for (let i = 0; i < triangles.length; i += 3) {

              faces.push(triangles.slice(i, i + 3));

          }

          return faces;

      }

  };

  function removeDupEndPts(points) {

      const l = points.length;

      if (l > 2 && points[l - 1].equals(points[0])) {

          points.pop();

      }

  }

  function addContour(vertices, contour) {

      for (let i = 0; i < contour.length; i++) {

          vertices.push(contour[i].x);
          vertices.push(contour[i].y);

      }

  }

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  depth: <float>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
   *  bevelOffset: <float>, // how far from shape outline does bevel start
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */

  // ExtrudeGeometry

  function ExtrudeGeometry(shapes, options) {

      Geometry.call(this);

      this.type = 'ExtrudeGeometry';

      this.parameters = {
          shapes: shapes,
          options: options
      };

      this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
      this.mergeVertices();

  }

  ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
  ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

  ExtrudeGeometry.prototype.toJSON = function() {

      const data = Geometry.prototype.toJSON.call(this);

      const shapes = this.parameters.shapes;
      const options = this.parameters.options;

      return toJSON(shapes, options, data);

  };

  // ExtrudeBufferGeometry

  function ExtrudeBufferGeometry(shapes, options) {

      BufferGeometry.call(this);

      this.type = 'ExtrudeBufferGeometry';

      this.parameters = {
          shapes: shapes,
          options: options
      };

      shapes = Array.isArray(shapes) ? shapes : [shapes];

      const scope = this;

      const verticesArray = [];
      const uvArray = [];

      for (let i = 0, l = shapes.length; i < l; i++) {

          const shape = shapes[i];
          addShape(shape);

      }

      // build geometry

      this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));

      this.computeVertexNormals();

      // functions

      function addShape(shape) {

          const placeholder = [];

          // options

          const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
          const steps = options.steps !== undefined ? options.steps : 1;
          let depth = options.depth !== undefined ? options.depth : 100;

          let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
          let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
          let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
          let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
          let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

          const extrudePath = options.extrudePath;

          const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

          // deprecated options

          if (options.amount !== undefined) {

              console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
              depth = options.amount;

          }

          //

          let extrudePts, extrudeByPath = false;
          let splineTube, binormal, normal, position2;

          if (extrudePath) {

              extrudePts = extrudePath.getSpacedPoints(steps);

              extrudeByPath = true;
              bevelEnabled = false; // bevels not supported for path extrusion

              // SETUP TNB variables

              // TODO1 - have a .isClosed in spline?

              splineTube = extrudePath.computeFrenetFrames(steps, false);

              // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

              binormal = new Vector3();
              normal = new Vector3();
              position2 = new Vector3();

          }

          // Safeguards if bevels are not enabled

          if (!bevelEnabled) {

              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
              bevelOffset = 0;

          }

          // Variables initialization

          const shapePoints = shape.extractPoints(curveSegments);

          let vertices = shapePoints.shape;
          const holes = shapePoints.holes;

          const reverse = !ShapeUtils.isClockWise(vertices);

          if (reverse) {

              vertices = vertices.reverse();

              // Maybe we should also check if holes are in the opposite direction, just to be safe ...

              for (let h = 0, hl = holes.length; h < hl; h++) {

                  const ahole = holes[h];

                  if (ShapeUtils.isClockWise(ahole)) {

                      holes[h] = ahole.reverse();

                  }

              }

          }


          const faces = ShapeUtils.triangulateShape(vertices, holes);

          /* Vertices */

          const contour = vertices; // vertices has all points but contour has only points of circumference

          for (let h = 0, hl = holes.length; h < hl; h++) {

              const ahole = holes[h];

              vertices = vertices.concat(ahole);

          }


          function scalePt2(pt, vec, size) {

              if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");

              return vec.clone().multiplyScalar(size).add(pt);

          }

          const vlen = vertices.length,
              flen = faces.length;


          // Find directions for point movement


          function getBevelVec(inPt, inPrev, inNext) {

              // computes for inPt the corresponding point inPt' on a new contour
              //   shifted by 1 unit (length of normalized vector) to the left
              // if we walk along contour clockwise, this new contour is outside the old one
              //
              // inPt' is the intersection of the two lines parallel to the two
              //  adjacent edges of inPt at a distance of 1 unit on the left side.

              let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

              // good reading for geometry algorithms (here: line-line intersection)
              // http://geomalgorithms.com/a05-_intersect-1.html

              const v_prev_x = inPt.x - inPrev.x,
                  v_prev_y = inPt.y - inPrev.y;
              const v_next_x = inNext.x - inPt.x,
                  v_next_y = inNext.y - inPt.y;

              const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);

              // check for collinear edges
              const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);

              if (Math.abs(collinear0) > Number.EPSILON) {

                  // not collinear

                  // length of vectors for normalizing

                  const v_prev_len = Math.sqrt(v_prev_lensq);
                  const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

                  // shift adjacent points by unit vectors to the left

                  const ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                  const ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);

                  const ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                  const ptNextShift_y = (inNext.y + v_next_x / v_next_len);

                  // scaling factor for v_prev to intersection point

                  const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                          (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                      (v_prev_x * v_next_y - v_prev_y * v_next_x);

                  // vector from inPt to intersection point

                  v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                  v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);

                  // Don't normalize!, otherwise sharp corners become ugly
                  //  but prevent crazy spikes
                  const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                  if (v_trans_lensq <= 2) {

                      return new Vector2(v_trans_x, v_trans_y);

                  } else {

                      shrink_by = Math.sqrt(v_trans_lensq / 2);

                  }

              } else {

                  // handle special case of collinear edges

                  let direction_eq = false; // assumes: opposite

                  if (v_prev_x > Number.EPSILON) {

                      if (v_next_x > Number.EPSILON) {

                          direction_eq = true;

                      }

                  } else {

                      if (v_prev_x < -Number.EPSILON) {

                          if (v_next_x < -Number.EPSILON) {

                              direction_eq = true;

                          }

                      } else {

                          if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {

                              direction_eq = true;

                          }

                      }

                  }

                  if (direction_eq) {

                      // console.log("Warning: lines are a straight sequence");
                      v_trans_x = -v_prev_y;
                      v_trans_y = v_prev_x;
                      shrink_by = Math.sqrt(v_prev_lensq);

                  } else {

                      // console.log("Warning: lines are a straight spike");
                      v_trans_x = v_prev_x;
                      v_trans_y = v_prev_y;
                      shrink_by = Math.sqrt(v_prev_lensq / 2);

                  }

              }

              return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);

          }


          const contourMovements = [];

          for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

              if (j === il) j = 0;
              if (k === il) k = 0;

              //  (j)---(i)---(k)
              // console.log('i,j,k', i, j , k)

              contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);

          }

          const holesMovements = [];
          let oneHoleMovements, verticesMovements = contourMovements.concat();

          for (let h = 0, hl = holes.length; h < hl; h++) {

              const ahole = holes[h];

              oneHoleMovements = [];

              for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

                  if (j === il) j = 0;
                  if (k === il) k = 0;

                  //  (j)---(i)---(k)
                  oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);

              }

              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);

          }


          // Loop bevelSegments, 1 for the front, 1 for the back

          for (let b = 0; b < bevelSegments; b++) {

              //for ( b = bevelSegments; b > 0; b -- ) {

              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

              // contract shape

              for (let i = 0, il = contour.length; i < il; i++) {

                  const vert = scalePt2(contour[i], contourMovements[i], bs);

                  v(vert.x, vert.y, -z);

              }

              // expand holes

              for (let h = 0, hl = holes.length; h < hl; h++) {

                  const ahole = holes[h];
                  oneHoleMovements = holesMovements[h];

                  for (let i = 0, il = ahole.length; i < il; i++) {

                      const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

                      v(vert.x, vert.y, -z);

                  }

              }

          }

          const bs = bevelSize + bevelOffset;

          // Back facing vertices

          for (let i = 0; i < vlen; i++) {

              const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

              if (!extrudeByPath) {

                  v(vert.x, vert.y, 0);

              } else {

                  // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

                  normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);

                  position2.copy(extrudePts[0]).add(normal).add(binormal);

                  v(position2.x, position2.y, position2.z);

              }

          }

          // Add stepped vertices...
          // Including front facing vertices

          for (let s = 1; s <= steps; s++) {

              for (let i = 0; i < vlen; i++) {

                  const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

                  if (!extrudeByPath) {

                      v(vert.x, vert.y, depth / steps * s);

                  } else {

                      // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                      normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                      binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);

                      position2.copy(extrudePts[s]).add(normal).add(binormal);

                      v(position2.x, position2.y, position2.z);

                  }

              }

          }


          // Add bevel segments planes

          //for ( b = 1; b <= bevelSegments; b ++ ) {
          for (let b = bevelSegments - 1; b >= 0; b--) {

              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

              // contract shape

              for (let i = 0, il = contour.length; i < il; i++) {

                  const vert = scalePt2(contour[i], contourMovements[i], bs);
                  v(vert.x, vert.y, depth + z);

              }

              // expand holes

              for (let h = 0, hl = holes.length; h < hl; h++) {

                  const ahole = holes[h];
                  oneHoleMovements = holesMovements[h];

                  for (let i = 0, il = ahole.length; i < il; i++) {

                      const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

                      if (!extrudeByPath) {

                          v(vert.x, vert.y, depth + z);

                      } else {

                          v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);

                      }

                  }

              }

          }

          /* Faces */

          // Top and bottom faces

          buildLidFaces();

          // Sides faces

          buildSideFaces();


          /////  Internal functions

          function buildLidFaces() {

              const start = verticesArray.length / 3;

              if (bevelEnabled) {

                  let layer = 0; // steps + 1
                  let offset = vlen * layer;

                  // Bottom faces

                  for (let i = 0; i < flen; i++) {

                      const face = faces[i];
                      f3(face[2] + offset, face[1] + offset, face[0] + offset);

                  }

                  layer = steps + bevelSegments * 2;
                  offset = vlen * layer;

                  // Top faces

                  for (let i = 0; i < flen; i++) {

                      const face = faces[i];
                      f3(face[0] + offset, face[1] + offset, face[2] + offset);

                  }

              } else {

                  // Bottom faces

                  for (let i = 0; i < flen; i++) {

                      const face = faces[i];
                      f3(face[2], face[1], face[0]);

                  }

                  // Top faces

                  for (let i = 0; i < flen; i++) {

                      const face = faces[i];
                      f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);

                  }

              }

              scope.addGroup(start, verticesArray.length / 3 - start, 0);

          }

          // Create faces for the z-sides of the shape

          function buildSideFaces() {

              const start = verticesArray.length / 3;
              let layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;

              for (let h = 0, hl = holes.length; h < hl; h++) {

                  const ahole = holes[h];
                  sidewalls(ahole, layeroffset);

                  //, true
                  layeroffset += ahole.length;

              }


              scope.addGroup(start, verticesArray.length / 3 - start, 1);


          }

          function sidewalls(contour, layeroffset) {

              let i = contour.length;

              while (--i >= 0) {

                  const j = i;
                  let k = i - 1;
                  if (k < 0) k = contour.length - 1;

                  //console.log('b', i,j, i-1, k,vertices.length);

                  for (let s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {

                      const slen1 = vlen * s;
                      const slen2 = vlen * (s + 1);

                      const a = layeroffset + j + slen1,
                          b = layeroffset + k + slen1,
                          c = layeroffset + k + slen2,
                          d = layeroffset + j + slen2;

                      f4(a, b, c, d);

                  }

              }

          }

          function v(x, y, z) {

              placeholder.push(x);
              placeholder.push(y);
              placeholder.push(z);

          }


          function f3(a, b, c) {

              addVertex(a);
              addVertex(b);
              addVertex(c);

              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);

              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[2]);

          }

          function f4(a, b, c, d) {

              addVertex(a);
              addVertex(b);
              addVertex(d);

              addVertex(b);
              addVertex(c);
              addVertex(d);


              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);

              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[3]);

              addUV(uvs[1]);
              addUV(uvs[2]);
              addUV(uvs[3]);

          }

          function addVertex(index) {

              verticesArray.push(placeholder[index * 3 + 0]);
              verticesArray.push(placeholder[index * 3 + 1]);
              verticesArray.push(placeholder[index * 3 + 2]);

          }


          function addUV(vector2) {

              uvArray.push(vector2.x);
              uvArray.push(vector2.y);

          }

      }

  }

  ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

  ExtrudeBufferGeometry.prototype.toJSON = function() {

      const data = BufferGeometry.prototype.toJSON.call(this);

      const shapes = this.parameters.shapes;
      const options = this.parameters.options;

      return toJSON(shapes, options, data);

  };

  //

  const WorldUVGenerator = {

      generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {

          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];

          return [
              new Vector2(a_x, a_y),
              new Vector2(b_x, b_y),
              new Vector2(c_x, c_y)
          ];

      },

      generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {

          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const a_z = vertices[indexA * 3 + 2];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const b_z = vertices[indexB * 3 + 2];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          const c_z = vertices[indexC * 3 + 2];
          const d_x = vertices[indexD * 3];
          const d_y = vertices[indexD * 3 + 1];
          const d_z = vertices[indexD * 3 + 2];

          if (Math.abs(a_y - b_y) < 0.01) {

              return [
                  new Vector2(a_x, 1 - a_z),
                  new Vector2(b_x, 1 - b_z),
                  new Vector2(c_x, 1 - c_z),
                  new Vector2(d_x, 1 - d_z)
              ];

          } else {

              return [
                  new Vector2(a_y, 1 - a_z),
                  new Vector2(b_y, 1 - b_z),
                  new Vector2(c_y, 1 - c_z),
                  new Vector2(d_y, 1 - d_z)
              ];

          }

      }
  };

  function toJSON(shapes, options, data) {

      //

      data.shapes = [];

      if (Array.isArray(shapes)) {

          for (let i = 0, l = shapes.length; i < l; i++) {

              const shape = shapes[i];

              data.shapes.push(shape.uuid);

          }

      } else {

          data.shapes.push(shapes.uuid);

      }

      //

      if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();

      return data;

  }

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author alteredq / http://alteredqualia.com/
   *
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
   *  bevelOffset: <float> // how far from text outline does bevel start
   * }
   */

  // TextGeometry

  function TextGeometry(text, parameters) {

      Geometry.call(this);

      this.type = 'TextGeometry';

      this.parameters = {
          text: text,
          parameters: parameters
      };

      this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
      this.mergeVertices();

  }

  TextGeometry.prototype = Object.create(Geometry.prototype);
  TextGeometry.prototype.constructor = TextGeometry;

  // TextBufferGeometry

  function TextBufferGeometry(text, parameters) {

      parameters = parameters || {};

      const font = parameters.font;

      if (!(font && font.isFont)) {

          console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
          return new Geometry();

      }

      const shapes = font.generateShapes(text, parameters.size);

      // translate parameters to ExtrudeGeometry API

      parameters.depth = parameters.height !== undefined ? parameters.height : 50;

      // defaults

      if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
      if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
      if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

      ExtrudeBufferGeometry.call(this, shapes, parameters);

      this.type = 'TextBufferGeometry';

  }

  TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
  TextBufferGeometry.prototype.constructor = TextBufferGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   */

  // SphereGeometry

  function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

      Geometry.call(this);

      this.type = 'SphereGeometry';

      this.parameters = {
          radius: radius,
          widthSegments: widthSegments,
          heightSegments: heightSegments,
          phiStart: phiStart,
          phiLength: phiLength,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
      this.mergeVertices();

  }

  SphereGeometry.prototype = Object.create(Geometry.prototype);
  SphereGeometry.prototype.constructor = SphereGeometry;

  // SphereBufferGeometry

  function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

      BufferGeometry.call(this);

      this.type = 'SphereBufferGeometry';

      this.parameters = {
          radius: radius,
          widthSegments: widthSegments,
          heightSegments: heightSegments,
          phiStart: phiStart,
          phiLength: phiLength,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      radius = radius || 1;

      widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
      heightSegments = Math.max(2, Math.floor(heightSegments) || 6);

      phiStart = phiStart !== undefined ? phiStart : 0;
      phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

      const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);

      let index = 0;
      const grid = [];

      const vertex = new Vector3();
      const normal = new Vector3();

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // generate vertices, normals and uvs

      for (let iy = 0; iy <= heightSegments; iy++) {

          const verticesRow = [];

          const v = iy / heightSegments;

          // special case for the poles

          let uOffset = 0;

          if (iy == 0 && thetaStart == 0) {

              uOffset = 0.5 / widthSegments;

          } else if (iy == heightSegments && thetaEnd == Math.PI) {

              uOffset = -0.5 / widthSegments;

          }

          for (let ix = 0; ix <= widthSegments; ix++) {

              const u = ix / widthSegments;

              // vertex

              vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
              vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);

              vertices.push(vertex.x, vertex.y, vertex.z);

              // normal

              normal.copy(vertex).normalize();
              normals.push(normal.x, normal.y, normal.z);

              // uv

              uvs.push(u + uOffset, 1 - v);

              verticesRow.push(index++);

          }

          grid.push(verticesRow);

      }

      // indices

      for (let iy = 0; iy < heightSegments; iy++) {

          for (let ix = 0; ix < widthSegments; ix++) {

              const a = grid[iy][ix + 1];
              const b = grid[iy][ix];
              const c = grid[iy + 1][ix];
              const d = grid[iy + 1][ix + 1];

              if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
              if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

  }

  SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

  /**
   * @author Kaleb Murphy
   * @author Mugen87 / https://github.com/Mugen87
   */

  // RingGeometry

  function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

      Geometry.call(this);

      this.type = 'RingGeometry';

      this.parameters = {
          innerRadius: innerRadius,
          outerRadius: outerRadius,
          thetaSegments: thetaSegments,
          phiSegments: phiSegments,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
      this.mergeVertices();

  }

  RingGeometry.prototype = Object.create(Geometry.prototype);
  RingGeometry.prototype.constructor = RingGeometry;

  // RingBufferGeometry

  function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

      BufferGeometry.call(this);

      this.type = 'RingBufferGeometry';

      this.parameters = {
          innerRadius: innerRadius,
          outerRadius: outerRadius,
          thetaSegments: thetaSegments,
          phiSegments: phiSegments,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      innerRadius = innerRadius || 0.5;
      outerRadius = outerRadius || 1;

      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

      thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
      phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // some helper variables

      let radius = innerRadius;
      const radiusStep = ((outerRadius - innerRadius) / phiSegments);
      const vertex = new Vector3();
      const uv = new Vector2();

      // generate vertices, normals and uvs

      for (let j = 0; j <= phiSegments; j++) {

          for (let i = 0; i <= thetaSegments; i++) {

              // values are generate from the inside of the ring to the outside

              const segment = thetaStart + i / thetaSegments * thetaLength;

              // vertex

              vertex.x = radius * Math.cos(segment);
              vertex.y = radius * Math.sin(segment);

              vertices.push(vertex.x, vertex.y, vertex.z);

              // normal

              normals.push(0, 0, 1);

              // uv

              uv.x = (vertex.x / outerRadius + 1) / 2;
              uv.y = (vertex.y / outerRadius + 1) / 2;

              uvs.push(uv.x, uv.y);

          }

          // increase the radius for next row of vertices

          radius += radiusStep;

      }

      // indices

      for (let j = 0; j < phiSegments; j++) {

          const thetaSegmentLevel = j * (thetaSegments + 1);

          for (let i = 0; i < thetaSegments; i++) {

              const segment = i + thetaSegmentLevel;

              const a = segment;
              const b = segment + thetaSegments + 1;
              const c = segment + thetaSegments + 2;
              const d = segment + 1;

              // faces

              indices.push(a, b, d);
              indices.push(b, c, d);

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

  }

  RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  RingBufferGeometry.prototype.constructor = RingBufferGeometry;

  /**
   * @author zz85 / https://github.com/zz85
   * @author bhouston / http://clara.io
   * @author Mugen87 / https://github.com/Mugen87
   */

  // LatheGeometry

  function LatheGeometry(points, segments, phiStart, phiLength) {

      Geometry.call(this);

      this.type = 'LatheGeometry';

      this.parameters = {
          points: points,
          segments: segments,
          phiStart: phiStart,
          phiLength: phiLength
      };

      this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
      this.mergeVertices();

  }

  LatheGeometry.prototype = Object.create(Geometry.prototype);
  LatheGeometry.prototype.constructor = LatheGeometry;

  // LatheBufferGeometry

  function LatheBufferGeometry(points, segments, phiStart, phiLength) {

      BufferGeometry.call(this);

      this.type = 'LatheBufferGeometry';

      this.parameters = {
          points: points,
          segments: segments,
          phiStart: phiStart,
          phiLength: phiLength
      };

      segments = Math.floor(segments) || 12;
      phiStart = phiStart || 0;
      phiLength = phiLength || Math.PI * 2;

      // clamp phiLength so it's in range of [ 0, 2PI ]

      phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);


      // buffers

      const indices = [];
      const vertices = [];
      const uvs = [];

      // helper variables

      const inverseSegments = 1.0 / segments;
      const vertex = new Vector3();
      const uv = new Vector2();

      // generate vertices and uvs

      for (let i = 0; i <= segments; i++) {

          const phi = phiStart + i * inverseSegments * phiLength;

          const sin = Math.sin(phi);
          const cos = Math.cos(phi);

          for (let j = 0; j <= (points.length - 1); j++) {

              // vertex

              vertex.x = points[j].x * sin;
              vertex.y = points[j].y;
              vertex.z = points[j].x * cos;

              vertices.push(vertex.x, vertex.y, vertex.z);

              // uv

              uv.x = i / segments;
              uv.y = j / (points.length - 1);

              uvs.push(uv.x, uv.y);


          }

      }

      // indices

      for (let i = 0; i < segments; i++) {

          for (let j = 0; j < (points.length - 1); j++) {

              const base = j + i * points.length;

              const a = base;
              const b = base + points.length;
              const c = base + points.length + 1;
              const d = base + 1;

              // faces

              indices.push(a, b, d);
              indices.push(b, c, d);

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      // generate normals

      this.computeVertexNormals();

      // if the geometry is closed, we need to average the normals along the seam.
      // because the corresponding vertices are identical (but still have different UVs).

      if (phiLength === Math.PI * 2) {

          const normals = this.attributes.normal.array;
          const n1 = new Vector3();
          const n2 = new Vector3();
          const n = new Vector3();

          // this is the buffer offset for the last line of vertices

          const base = segments * points.length * 3;

          for (let i = 0, j = 0; i < points.length; i++, j += 3) {

              // select the normal of the vertex in the first line

              n1.x = normals[j + 0];
              n1.y = normals[j + 1];
              n1.z = normals[j + 2];

              // select the normal of the vertex in the last line

              n2.x = normals[base + j + 0];
              n2.y = normals[base + j + 1];
              n2.z = normals[base + j + 2];

              // average normals

              n.addVectors(n1, n2).normalize();

              // assign the new values to both normals

              normals[j + 0] = normals[base + j + 0] = n.x;
              normals[j + 1] = normals[base + j + 1] = n.y;
              normals[j + 2] = normals[base + j + 2] = n.z;

          }

      }

  }

  LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

  /**
   * @author jonobr1 / http://jonobr1.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // ShapeGeometry

  function ShapeGeometry(shapes, curveSegments) {

      Geometry.call(this);

      this.type = 'ShapeGeometry';

      if (typeof curveSegments === 'object') {

          console.warn('THREE.ShapeGeometry: Options parameter has been removed.');

          curveSegments = curveSegments.curveSegments;

      }

      this.parameters = {
          shapes: shapes,
          curveSegments: curveSegments
      };

      this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
      this.mergeVertices();

  }

  ShapeGeometry.prototype = Object.create(Geometry.prototype);
  ShapeGeometry.prototype.constructor = ShapeGeometry;

  ShapeGeometry.prototype.toJSON = function() {

      const data = Geometry.prototype.toJSON.call(this);

      const shapes = this.parameters.shapes;

      return toJSON$1(shapes, data);

  };

  // ShapeBufferGeometry

  function ShapeBufferGeometry(shapes, curveSegments) {

      BufferGeometry.call(this);

      this.type = 'ShapeBufferGeometry';

      this.parameters = {
          shapes: shapes,
          curveSegments: curveSegments
      };

      curveSegments = curveSegments || 12;

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // helper variables

      let groupStart = 0;
      let groupCount = 0;

      // allow single and array values for "shapes" parameter

      if (Array.isArray(shapes) === false) {

          addShape(shapes);

      } else {

          for (let i = 0; i < shapes.length; i++) {

              addShape(shapes[i]);

              this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

              groupStart += groupCount;
              groupCount = 0;

          }

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));


      // helper functions

      function addShape(shape) {

          const indexOffset = vertices.length / 3;
          const points = shape.extractPoints(curveSegments);

          let shapeVertices = points.shape;
          const shapeHoles = points.holes;

          // check direction of vertices

          if (ShapeUtils.isClockWise(shapeVertices) === false) {

              shapeVertices = shapeVertices.reverse();

          }

          for (let i = 0, l = shapeHoles.length; i < l; i++) {

              const shapeHole = shapeHoles[i];

              if (ShapeUtils.isClockWise(shapeHole) === true) {

                  shapeHoles[i] = shapeHole.reverse();

              }

          }

          const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

          // join vertices of inner and outer paths to a single array

          for (let i = 0, l = shapeHoles.length; i < l; i++) {

              const shapeHole = shapeHoles[i];
              shapeVertices = shapeVertices.concat(shapeHole);

          }

          // vertices, normals, uvs

          for (let i = 0, l = shapeVertices.length; i < l; i++) {

              const vertex = shapeVertices[i];

              vertices.push(vertex.x, vertex.y, 0);
              normals.push(0, 0, 1);
              uvs.push(vertex.x, vertex.y); // world uvs

          }

          // incides

          for (let i = 0, l = faces.length; i < l; i++) {

              const face = faces[i];

              const a = face[0] + indexOffset;
              const b = face[1] + indexOffset;
              const c = face[2] + indexOffset;

              indices.push(a, b, c);
              groupCount += 3;

          }

      }

  }

  ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

  ShapeBufferGeometry.prototype.toJSON = function() {

      const data = BufferGeometry.prototype.toJSON.call(this);

      const shapes = this.parameters.shapes;

      return toJSON$1(shapes, data);

  };

  //

  function toJSON$1(shapes, data) {

      data.shapes = [];

      if (Array.isArray(shapes)) {

          for (let i = 0, l = shapes.length; i < l; i++) {

              const shape = shapes[i];

              data.shapes.push(shape.uuid);

          }

      } else {

          data.shapes.push(shapes.uuid);

      }

      return data;

  }

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  function EdgesGeometry(geometry, thresholdAngle) {

      BufferGeometry.call(this);

      this.type = 'EdgesGeometry';

      this.parameters = {
          thresholdAngle: thresholdAngle
      };

      thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;

      // buffer

      const vertices = [];

      // helper variables

      const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
      const edge = [0, 0],
          edges = {};
      let edge1, edge2, key;
      const keys = ['a', 'b', 'c'];

      // prepare source geometry

      let geometry2;

      if (geometry.isBufferGeometry) {

          geometry2 = new Geometry();
          geometry2.fromBufferGeometry(geometry);

      } else {

          geometry2 = geometry.clone();

      }

      geometry2.mergeVertices();
      geometry2.computeFaceNormals();

      const sourceVertices = geometry2.vertices;
      const faces = geometry2.faces;

      // now create a data structure where each entry represents an edge with its adjoining faces

      for (let i = 0, l = faces.length; i < l; i++) {

          const face = faces[i];

          for (let j = 0; j < 3; j++) {

              edge1 = face[keys[j]];
              edge2 = face[keys[(j + 1) % 3]];
              edge[0] = Math.min(edge1, edge2);
              edge[1] = Math.max(edge1, edge2);

              key = edge[0] + ',' + edge[1];

              if (edges[key] === undefined) {

                  edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: undefined };

              } else {

                  edges[key].face2 = i;

              }

          }

      }

      // generate vertices

      for (key in edges) {

          const e = edges[key];

          // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

          if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {

              let vertex = sourceVertices[e.index1];
              vertices.push(vertex.x, vertex.y, vertex.z);

              vertex = sourceVertices[e.index2];
              vertices.push(vertex.x, vertex.y, vertex.z);

          }

      }

      // build geometry

      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

  }

  EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
  EdgesGeometry.prototype.constructor = EdgesGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // CylinderGeometry

  function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

      Geometry.call(this);

      this.type = 'CylinderGeometry';

      this.parameters = {
          radiusTop: radiusTop,
          radiusBottom: radiusBottom,
          height: height,
          radialSegments: radialSegments,
          heightSegments: heightSegments,
          openEnded: openEnded,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
      this.mergeVertices();

  }

  CylinderGeometry.prototype = Object.create(Geometry.prototype);
  CylinderGeometry.prototype.constructor = CylinderGeometry;

  // CylinderBufferGeometry

  function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

      BufferGeometry.call(this);

      this.type = 'CylinderBufferGeometry';

      this.parameters = {
          radiusTop: radiusTop,
          radiusBottom: radiusBottom,
          height: height,
          radialSegments: radialSegments,
          heightSegments: heightSegments,
          openEnded: openEnded,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      const scope = this;

      radiusTop = radiusTop !== undefined ? radiusTop : 1;
      radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
      height = height || 1;

      radialSegments = Math.floor(radialSegments) || 8;
      heightSegments = Math.floor(heightSegments) || 1;

      openEnded = openEnded !== undefined ? openEnded : false;
      thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // helper variables

      let index = 0;
      const indexArray = [];
      const halfHeight = height / 2;
      let groupStart = 0;

      // generate geometry

      generateTorso();

      if (openEnded === false) {

          if (radiusTop > 0) generateCap(true);
          if (radiusBottom > 0) generateCap(false);

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      function generateTorso() {

          const normal = new Vector3();
          const vertex = new Vector3();

          let groupCount = 0;

          // this will be used to calculate the normal
          const slope = (radiusBottom - radiusTop) / height;

          // generate vertices, normals and uvs

          for (let y = 0; y <= heightSegments; y++) {

              const indexRow = [];

              const v = y / heightSegments;

              // calculate the radius of the current row

              const radius = v * (radiusBottom - radiusTop) + radiusTop;

              for (let x = 0; x <= radialSegments; x++) {

                  const u = x / radialSegments;

                  const theta = u * thetaLength + thetaStart;

                  const sinTheta = Math.sin(theta);
                  const cosTheta = Math.cos(theta);

                  // vertex

                  vertex.x = radius * sinTheta;
                  vertex.y = -v * height + halfHeight;
                  vertex.z = radius * cosTheta;
                  vertices.push(vertex.x, vertex.y, vertex.z);

                  // normal

                  normal.set(sinTheta, slope, cosTheta).normalize();
                  normals.push(normal.x, normal.y, normal.z);

                  // uv

                  uvs.push(u, 1 - v);

                  // save index of vertex in respective row

                  indexRow.push(index++);

              }

              // now save vertices of the row in our index array

              indexArray.push(indexRow);

          }

          // generate indices

          for (let x = 0; x < radialSegments; x++) {

              for (let y = 0; y < heightSegments; y++) {

                  // we use the index array to access the correct indices

                  const a = indexArray[y][x];
                  const b = indexArray[y + 1][x];
                  const c = indexArray[y + 1][x + 1];
                  const d = indexArray[y][x + 1];

                  // faces

                  indices.push(a, b, d);
                  indices.push(b, c, d);

                  // update group counter

                  groupCount += 6;

              }

          }

          // add a group to the geometry. this will ensure multi material support

          scope.addGroup(groupStart, groupCount, 0);

          // calculate new start value for groups

          groupStart += groupCount;

      }

      function generateCap(top) {

          let centerIndexStart, centerIndexEnd;

          const uv = new Vector2();
          const vertex = new Vector3();

          let groupCount = 0;

          const radius = (top === true) ? radiusTop : radiusBottom;
          const sign = (top === true) ? 1 : -1;

          // save the index of the first center vertex
          centerIndexStart = index;

          // first we generate the center vertex data of the cap.
          // because the geometry needs one set of uvs per face,
          // we must generate a center vertex per face/segment

          for (let x = 1; x <= radialSegments; x++) {

              // vertex

              vertices.push(0, halfHeight * sign, 0);

              // normal

              normals.push(0, sign, 0);

              // uv

              uvs.push(0.5, 0.5);

              // increase index

              index++;

          }

          // save the index of the last center vertex

          centerIndexEnd = index;

          // now we generate the surrounding vertices, normals and uvs

          for (let x = 0; x <= radialSegments; x++) {

              const u = x / radialSegments;
              const theta = u * thetaLength + thetaStart;

              const cosTheta = Math.cos(theta);
              const sinTheta = Math.sin(theta);

              // vertex

              vertex.x = radius * sinTheta;
              vertex.y = halfHeight * sign;
              vertex.z = radius * cosTheta;
              vertices.push(vertex.x, vertex.y, vertex.z);

              // normal

              normals.push(0, sign, 0);

              // uv

              uv.x = (cosTheta * 0.5) + 0.5;
              uv.y = (sinTheta * 0.5 * sign) + 0.5;
              uvs.push(uv.x, uv.y);

              // increase index

              index++;

          }

          // generate indices

          for (let x = 0; x < radialSegments; x++) {

              const c = centerIndexStart + x;
              const i = centerIndexEnd + x;

              if (top === true) {

                  // face top

                  indices.push(i, i + 1, c);

              } else {

                  // face bottom

                  indices.push(i + 1, i, c);

              }

              groupCount += 3;

          }

          // add a group to the geometry. this will ensure multi material support

          scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

          // calculate new start value for groups

          groupStart += groupCount;

      }

  }

  CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

  /**
   * @author abelnation / http://github.com/abelnation
   */

  // ConeGeometry

  function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

      CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

      this.type = 'ConeGeometry';

      this.parameters = {
          radius: radius,
          height: height,
          radialSegments: radialSegments,
          heightSegments: heightSegments,
          openEnded: openEnded,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

  }

  ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
  ConeGeometry.prototype.constructor = ConeGeometry;

  // ConeBufferGeometry

  function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

      CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

      this.type = 'ConeBufferGeometry';

      this.parameters = {
          radius: radius,
          height: height,
          radialSegments: radialSegments,
          heightSegments: heightSegments,
          openEnded: openEnded,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

  }

  ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
  ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   * @author hughes
   */

  // CircleGeometry

  function CircleGeometry(radius, segments, thetaStart, thetaLength) {

      Geometry.call(this);

      this.type = 'CircleGeometry';

      this.parameters = {
          radius: radius,
          segments: segments,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
      this.mergeVertices();

  }

  CircleGeometry.prototype = Object.create(Geometry.prototype);
  CircleGeometry.prototype.constructor = CircleGeometry;

  // CircleBufferGeometry

  function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {

      BufferGeometry.call(this);

      this.type = 'CircleBufferGeometry';

      this.parameters = {
          radius: radius,
          segments: segments,
          thetaStart: thetaStart,
          thetaLength: thetaLength
      };

      radius = radius || 1;
      segments = segments !== undefined ? Math.max(3, segments) : 8;

      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

      // buffers

      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];

      // helper variables

      const vertex = new Vector3();
      const uv = new Vector2();

      // center point

      vertices.push(0, 0, 0);
      normals.push(0, 0, 1);
      uvs.push(0.5, 0.5);

      for (let s = 0, i = 3; s <= segments; s++, i += 3) {

          const segment = thetaStart + s / segments * thetaLength;

          // vertex

          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);

          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          normals.push(0, 0, 1);

          // uvs

          uv.x = (vertices[i] / radius + 1) / 2;
          uv.y = (vertices[i + 1] / radius + 1) / 2;

          uvs.push(uv.x, uv.y);

      }

      // indices

      for (let i = 1; i <= segments; i++) {

          indices.push(i, i + 1, 0);

      }

      // build geometry

      this.setIndex(indices);
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

  }

  CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

  var Geometries = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      WireframeGeometry: WireframeGeometry,
      ParametricGeometry: ParametricGeometry,
      ParametricBufferGeometry: ParametricBufferGeometry,
      TetrahedronGeometry: TetrahedronGeometry,
      TetrahedronBufferGeometry: TetrahedronBufferGeometry,
      OctahedronGeometry: OctahedronGeometry,
      OctahedronBufferGeometry: OctahedronBufferGeometry,
      IcosahedronGeometry: IcosahedronGeometry,
      IcosahedronBufferGeometry: IcosahedronBufferGeometry,
      DodecahedronGeometry: DodecahedronGeometry,
      DodecahedronBufferGeometry: DodecahedronBufferGeometry,
      PolyhedronGeometry: PolyhedronGeometry,
      PolyhedronBufferGeometry: PolyhedronBufferGeometry,
      TubeGeometry: TubeGeometry,
      TubeBufferGeometry: TubeBufferGeometry,
      TorusKnotGeometry: TorusKnotGeometry,
      TorusKnotBufferGeometry: TorusKnotBufferGeometry,
      TorusGeometry: TorusGeometry,
      TorusBufferGeometry: TorusBufferGeometry,
      TextGeometry: TextGeometry,
      TextBufferGeometry: TextBufferGeometry,
      SphereGeometry: SphereGeometry,
      SphereBufferGeometry: SphereBufferGeometry,
      RingGeometry: RingGeometry,
      RingBufferGeometry: RingBufferGeometry,
      PlaneGeometry: PlaneGeometry,
      PlaneBufferGeometry: PlaneBufferGeometry,
      LatheGeometry: LatheGeometry,
      LatheBufferGeometry: LatheBufferGeometry,
      ShapeGeometry: ShapeGeometry,
      ShapeBufferGeometry: ShapeBufferGeometry,
      ExtrudeGeometry: ExtrudeGeometry,
      ExtrudeBufferGeometry: ExtrudeBufferGeometry,
      EdgesGeometry: EdgesGeometry,
      ConeGeometry: ConeGeometry,
      ConeBufferGeometry: ConeBufferGeometry,
      CylinderGeometry: CylinderGeometry,
      CylinderBufferGeometry: CylinderBufferGeometry,
      CircleGeometry: CircleGeometry,
      CircleBufferGeometry: CircleBufferGeometry,
      BoxGeometry: BoxGeometry,
      BoxBufferGeometry: BoxBufferGeometry
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * parameters = {
   *  color: <THREE.Color>
   * }
   */

  function ShadowMaterial(parameters) {

      Material.call(this);

      this.type = 'ShadowMaterial';

      this.color = new Color(0x000000);
      this.transparent = true;

      this.setValues(parameters);

  }

  ShadowMaterial.prototype = Object.create(Material.prototype);
  ShadowMaterial.prototype.constructor = ShadowMaterial;

  ShadowMaterial.prototype.isShadowMaterial = true;

  ShadowMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);

      return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function RawShaderMaterial(parameters) {

      ShaderMaterial.call(this, parameters);

      this.type = 'RawShaderMaterial';

  }

  RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
  RawShaderMaterial.prototype.constructor = RawShaderMaterial;

  RawShaderMaterial.prototype.isRawShaderMaterial = true;

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshStandardMaterial(parameters) {

      Material.call(this);

      this.defines = { 'STANDARD': '' };

      this.type = 'MeshStandardMaterial';

      this.color = new Color(0xffffff); // diffuse
      this.roughness = 1.0;
      this.metalness = 0.0;

      this.map = null;

      this.lightMap = null;
      this.lightMapIntensity = 1.0;

      this.aoMap = null;
      this.aoMapIntensity = 1.0;

      this.emissive = new Color(0x000000);
      this.emissiveIntensity = 1.0;
      this.emissiveMap = null;

      this.bumpMap = null;
      this.bumpScale = 1;

      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);

      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;

      this.roughnessMap = null;

      this.metalnessMap = null;

      this.alphaMap = null;

      this.envMap = null;
      this.envMapIntensity = 1.0;

      this.refractionRatio = 0.98;

      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';

      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;

      this.vertexTangents = false;

      this.setValues(parameters);

  }

  MeshStandardMaterial.prototype = Object.create(Material.prototype);
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

  MeshStandardMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.defines = { 'STANDARD': '' };

      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;

      this.map = source.map;

      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;

      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;

      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;

      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;

      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);

      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;

      this.roughnessMap = source.roughnessMap;

      this.metalnessMap = source.metalnessMap;

      this.alphaMap = source.alphaMap;

      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;

      this.refractionRatio = source.refractionRatio;

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;

      this.vertexTangents = source.vertexTangents;

      return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  clearcoat: <float>,
   *  clearcoatMap: new THREE.Texture( <Image> ),
   *  clearcoatRoughness: <float>,
   *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
   *  clearcoatNormalScale: <Vector2>,
   *  clearcoatNormalMap: new THREE.Texture( <Image> ),
   *
   *  reflectivity: <float>,
   *
   *  sheen: <Color>,
   *
   *  transparency: <float>
   * }
   */

  function MeshPhysicalMaterial(parameters) {

      MeshStandardMaterial.call(this);

      this.defines = {

          'STANDARD': '',
          'PHYSICAL': ''

      };

      this.type = 'MeshPhysicalMaterial';

      this.clearcoat = 0.0;
      this.clearcoatMap = null;
      this.clearcoatRoughness = 0.0;
      this.clearcoatRoughnessMap = null;
      this.clearcoatNormalScale = new Vector2(1, 1);
      this.clearcoatNormalMap = null;

      this.reflectivity = 0.5; // maps to F0 = 0.04

      this.sheen = null; // null will disable sheen bsdf

      this.transparency = 0.0;

      this.setValues(parameters);

  }

  MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

  MeshPhysicalMaterial.prototype.copy = function(source) {

      MeshStandardMaterial.prototype.copy.call(this, source);

      this.defines = {

          'STANDARD': '',
          'PHYSICAL': ''

      };

      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);

      this.reflectivity = source.reflectivity;

      if (source.sheen) {

          this.sheen = (this.sheen || new Color()).copy(source.sheen);

      } else {

          this.sheen = null;

      }

      this.transparency = source.transparency;

      return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.MultiplyOperation,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshPhongMaterial(parameters) {

      Material.call(this);

      this.type = 'MeshPhongMaterial';

      this.color = new Color(0xffffff); // diffuse
      this.specular = new Color(0x111111);
      this.shininess = 30;

      this.map = null;

      this.lightMap = null;
      this.lightMapIntensity = 1.0;

      this.aoMap = null;
      this.aoMapIntensity = 1.0;

      this.emissive = new Color(0x000000);
      this.emissiveIntensity = 1.0;
      this.emissiveMap = null;

      this.bumpMap = null;
      this.bumpScale = 1;

      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);

      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;

      this.specularMap = null;

      this.alphaMap = null;

      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;

      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';

      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;

      this.setValues(parameters);

  }

  MeshPhongMaterial.prototype = Object.create(Material.prototype);
  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

  MeshPhongMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;

      this.map = source.map;

      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;

      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;

      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;

      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;

      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);

      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;

      this.specularMap = source.specularMap;

      this.alphaMap = source.alphaMap;

      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;

      return this;

  };

  /**
   * @author takahirox / http://github.com/takahirox
   *
   * parameters = {
   *  color: <hex>,
   *
   *  map: new THREE.Texture( <Image> ),
   *  gradientMap: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshToonMaterial(parameters) {

      Material.call(this);

      this.defines = { 'TOON': '' };

      this.type = 'MeshToonMaterial';

      this.color = new Color(0xffffff);

      this.map = null;
      this.gradientMap = null;

      this.lightMap = null;
      this.lightMapIntensity = 1.0;

      this.aoMap = null;
      this.aoMapIntensity = 1.0;

      this.emissive = new Color(0x000000);
      this.emissiveIntensity = 1.0;
      this.emissiveMap = null;

      this.bumpMap = null;
      this.bumpScale = 1;

      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);

      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;

      this.alphaMap = null;

      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';

      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;

      this.setValues(parameters);

  }

  MeshToonMaterial.prototype = Object.create(Material.prototype);
  MeshToonMaterial.prototype.constructor = MeshToonMaterial;

  MeshToonMaterial.prototype.isMeshToonMaterial = true;

  MeshToonMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);

      this.map = source.map;
      this.gradientMap = source.gradientMap;

      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;

      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;

      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;

      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;

      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);

      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;

      this.alphaMap = source.alphaMap;

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;

      return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshNormalMaterial(parameters) {

      Material.call(this);

      this.type = 'MeshNormalMaterial';

      this.bumpMap = null;
      this.bumpScale = 1;

      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);

      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;

      this.wireframe = false;
      this.wireframeLinewidth = 1;

      this.fog = false;

      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;

      this.setValues(parameters);

  }

  MeshNormalMaterial.prototype = Object.create(Material.prototype);
  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

  MeshNormalMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;

      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);

      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;

      return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshLambertMaterial(parameters) {

      Material.call(this);

      this.type = 'MeshLambertMaterial';

      this.color = new Color(0xffffff); // diffuse

      this.map = null;

      this.lightMap = null;
      this.lightMapIntensity = 1.0;

      this.aoMap = null;
      this.aoMapIntensity = 1.0;

      this.emissive = new Color(0x000000);
      this.emissiveIntensity = 1.0;
      this.emissiveMap = null;

      this.specularMap = null;

      this.alphaMap = null;

      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;

      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';

      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;

      this.setValues(parameters);

  }

  MeshLambertMaterial.prototype = Object.create(Material.prototype);
  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

  MeshLambertMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.color.copy(source.color);

      this.map = source.map;

      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;

      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;

      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;

      this.specularMap = source.specularMap;

      this.alphaMap = source.alphaMap;

      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;

      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;

      return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  matcap: new THREE.Texture( <Image> ),
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshMatcapMaterial(parameters) {

      Material.call(this);

      this.defines = { 'MATCAP': '' };

      this.type = 'MeshMatcapMaterial';

      this.color = new Color(0xffffff); // diffuse

      this.matcap = null;

      this.map = null;

      this.bumpMap = null;
      this.bumpScale = 1;

      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);

      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;

      this.alphaMap = null;

      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;

      this.setValues(parameters);

  }

  MeshMatcapMaterial.prototype = Object.create(Material.prototype);
  MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

  MeshMatcapMaterial.prototype.copy = function(source) {

      Material.prototype.copy.call(this, source);

      this.defines = { 'MATCAP': '' };

      this.color.copy(source.color);

      this.matcap = source.matcap;

      this.map = source.map;

      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;

      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);

      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;

      this.alphaMap = source.alphaMap;

      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;

      return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */

  function LineDashedMaterial(parameters) {

      LineBasicMaterial.call(this);

      this.type = 'LineDashedMaterial';

      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;

      this.setValues(parameters);

  }

  LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
  LineDashedMaterial.prototype.constructor = LineDashedMaterial;

  LineDashedMaterial.prototype.isLineDashedMaterial = true;

  LineDashedMaterial.prototype.copy = function(source) {

      LineBasicMaterial.prototype.copy.call(this, source);

      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;

      return this;

  };

  var Materials = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      ShadowMaterial: ShadowMaterial,
      SpriteMaterial: SpriteMaterial,
      RawShaderMaterial: RawShaderMaterial,
      ShaderMaterial: ShaderMaterial,
      PointsMaterial: PointsMaterial,
      MeshPhysicalMaterial: MeshPhysicalMaterial,
      MeshStandardMaterial: MeshStandardMaterial,
      MeshPhongMaterial: MeshPhongMaterial,
      MeshToonMaterial: MeshToonMaterial,
      MeshNormalMaterial: MeshNormalMaterial,
      MeshLambertMaterial: MeshLambertMaterial,
      MeshDepthMaterial: MeshDepthMaterial,
      MeshDistanceMaterial: MeshDistanceMaterial,
      MeshBasicMaterial: MeshBasicMaterial,
      MeshMatcapMaterial: MeshMatcapMaterial,
      LineDashedMaterial: LineDashedMaterial,
      LineBasicMaterial: LineBasicMaterial,
      Material: Material
  });

  /**
   * @author tschw
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  const AnimationUtils = {

      // same as Array.prototype.slice, but also works on typed arrays
      arraySlice: function(array, from, to) {

          if (AnimationUtils.isTypedArray(array)) {

              // in ios9 array.subarray(from, undefined) will return empty array
              // but array.subarray(from) or array.subarray(from, len) is correct
              return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));

          }

          return array.slice(from, to);

      },

      // converts an array to a specific type
      convertArray: function(array, type, forceClone) {

          if (!array || // let 'undefined' and 'null' pass
              !forceClone && array.constructor === type) return array;

          if (typeof type.BYTES_PER_ELEMENT === 'number') {

              return new type(array); // create typed array

          }

          return Array.prototype.slice.call(array); // create Array

      },

      isTypedArray: function(object) {

          return ArrayBuffer.isView(object) &&
              !(object instanceof DataView);

      },

      // returns an array by which times and values can be sorted
      getKeyframeOrder: function(times) {

          function compareTime(i, j) {

              return times[i] - times[j];

          }

          const n = times.length;
          const result = new Array(n);
          for (let i = 0; i !== n; ++i) result[i] = i;

          result.sort(compareTime);

          return result;

      },

      // uses the array previously returned by 'getKeyframeOrder' to sort data
      sortedArray: function(values, stride, order) {

          const nValues = values.length;
          const result = new values.constructor(nValues);

          for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {

              const srcOffset = order[i] * stride;

              for (let j = 0; j !== stride; ++j) {

                  result[dstOffset++] = values[srcOffset + j];

              }

          }

          return result;

      },

      // function for parsing AOS keyframe formats
      flattenJSON: function(jsonKeys, times, values, valuePropertyName) {

          let i = 1,
              key = jsonKeys[0];

          while (key !== undefined && key[valuePropertyName] === undefined) {

              key = jsonKeys[i++];

          }

          if (key === undefined) return; // no data

          let value = key[valuePropertyName];
          if (value === undefined) return; // no data

          if (Array.isArray(value)) {

              do {

                  value = key[valuePropertyName];

                  if (value !== undefined) {

                      times.push(key.time);
                      values.push.apply(values, value); // push all elements

                  }

                  key = jsonKeys[i++];

              } while (key !== undefined);

          } else if (value.toArray !== undefined) {

              // ...assume THREE.Math-ish

              do {

                  value = key[valuePropertyName];

                  if (value !== undefined) {

                      times.push(key.time);
                      value.toArray(values, values.length);

                  }

                  key = jsonKeys[i++];

              } while (key !== undefined);

          } else {

              // otherwise push as-is

              do {

                  value = key[valuePropertyName];

                  if (value !== undefined) {

                      times.push(key.time);
                      values.push(value);

                  }

                  key = jsonKeys[i++];

              } while (key !== undefined);

          }

      },

      subclip: function(sourceClip, name, startFrame, endFrame, fps) {

          fps = fps || 30;

          const clip = sourceClip.clone();

          clip.name = name;

          const tracks = [];

          for (let i = 0; i < clip.tracks.length; ++i) {

              const track = clip.tracks[i];
              const valueSize = track.getValueSize();

              const times = [];
              const values = [];

              for (let j = 0; j < track.times.length; ++j) {

                  const frame = track.times[j] * fps;

                  if (frame < startFrame || frame >= endFrame) continue;

                  times.push(track.times[j]);

                  for (let k = 0; k < valueSize; ++k) {

                      values.push(track.values[j * valueSize + k]);

                  }

              }

              if (times.length === 0) continue;

              track.times = AnimationUtils.convertArray(times, track.times.constructor);
              track.values = AnimationUtils.convertArray(values, track.values.constructor);

              tracks.push(track);

          }

          clip.tracks = tracks;

          // find minimum .times value across all tracks in the trimmed clip

          let minStartTime = Infinity;

          for (let i = 0; i < clip.tracks.length; ++i) {

              if (minStartTime > clip.tracks[i].times[0]) {

                  minStartTime = clip.tracks[i].times[0];

              }

          }

          // shift all tracks such that clip begins at t=0

          for (let i = 0; i < clip.tracks.length; ++i) {

              clip.tracks[i].shift(-1 * minStartTime);

          }

          clip.resetDuration();

          return clip;

      },

      makeClipAdditive: function(targetClip, referenceFrame, referenceClip, fps) {

          if (referenceFrame === undefined) referenceFrame = 0;
          if (referenceClip === undefined) referenceClip = targetClip;
          if (fps === undefined || fps <= 0) fps = 30;

          const numTracks = targetClip.tracks.length;
          const referenceTime = referenceFrame / fps;

          // Make each track's values relative to the values at the reference frame
          for (let i = 0; i < numTracks; ++i) {

              const referenceTrack = referenceClip.tracks[i];
              const referenceTrackType = referenceTrack.ValueTypeName;

              // Skip this track if it's non-numeric
              if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;

              // Find the track in the target clip whose name and type matches the reference track
              const targetTrack = targetClip.tracks.find(function(track) {

                  return track.name === referenceTrack.name &&
                      track.ValueTypeName === referenceTrackType;

              });

              if (targetTrack === undefined) continue;

              const valueSize = referenceTrack.getValueSize();
              const lastIndex = referenceTrack.times.length - 1;
              let referenceValue;

              // Find the value to subtract out of the track
              if (referenceTime <= referenceTrack.times[0]) {

                  // Reference frame is earlier than the first keyframe, so just use the first keyframe
                  referenceValue = AnimationUtils.arraySlice(referenceTrack.values, 0, referenceTrack.valueSize);

              } else if (referenceTime >= referenceTrack.times[lastIndex]) {

                  // Reference frame is after the last keyframe, so just use the last keyframe
                  const startIndex = lastIndex * valueSize;
                  referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex);

              } else {

                  // Interpolate to the reference value
                  const interpolant = referenceTrack.createInterpolant();
                  interpolant.evaluate(referenceTime);
                  referenceValue = interpolant.resultBuffer;

              }

              // Conjugate the quaternion
              if (referenceTrackType === 'quaternion') {

                  const referenceQuat = new Quaternion(
                      referenceValue[0],
                      referenceValue[1],
                      referenceValue[2],
                      referenceValue[3]
                  ).normalize().conjugate();
                  referenceQuat.toArray(referenceValue);

              }

              // Subtract the reference value from all of the track values

              const numTimes = targetTrack.times.length;
              for (let j = 0; j < numTimes; ++j) {

                  const valueStart = j * valueSize;

                  if (referenceTrackType === 'quaternion') {

                      // Multiply the conjugate for quaternion track types
                      Quaternion.multiplyQuaternionsFlat(
                          targetTrack.values,
                          valueStart,
                          referenceValue,
                          0,
                          targetTrack.values,
                          valueStart
                      );

                  } else {

                      // Subtract each value for all other numeric track types
                      for (let k = 0; k < valueSize; ++k) {

                          targetTrack.values[valueStart + k] -= referenceValue[k];

                      }

                  }

              }

          }

          targetClip.blendMode = AdditiveAnimationBlendMode;

          return targetClip;

      }

  };

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   * @author tschw
   */

  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;

      this.resultBuffer = resultBuffer !== undefined ?
          resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;

  }

  Object.assign(Interpolant.prototype, {

      evaluate: function(t) {

          let pp = this.parameterPositions,
              i1 = this._cachedIndex,

              t1 = pp[i1],
              t0 = pp[i1 - 1];

          validate_interval: {

                  seek: {

                      let right;

                      linear_scan: {

                          //- See http://jsperf.com/comparison-to-undefined/3
                          //- slower code:
                          //-
                          //- 				if ( t >= t1 || t1 === undefined ) {
                          forward_scan: if (!(t < t1)) {

                                  for (let giveUpAt = i1 + 2;;) {

                                      if (t1 === undefined) {

                                          if (t < t0) break forward_scan;

                                          // after end

                                          i1 = pp.length;
                                          this._cachedIndex = i1;
                                          return this.afterEnd_(i1 - 1, t, t0);

                                      }

                                      if (i1 === giveUpAt) break; // this loop

                                      t0 = t1;
                                      t1 = pp[++i1];

                                      if (t < t1) {

                                          // we have arrived at the sought interval
                                          break seek;

                                      }

                                  }

                                  // prepare binary search on the right side of the index
                                  right = pp.length;
                                  break linear_scan;

                              }

                              //- slower code:
                              //-					if ( t < t0 || t0 === undefined ) {
                          if (!(t >= t0)) {

                              // looping?

                              const t1global = pp[1];

                              if (t < t1global) {

                                  i1 = 2; // + 1, using the scan for the details
                                  t0 = t1global;

                              }

                              // linear reverse scan

                              for (let giveUpAt = i1 - 2;;) {

                                  if (t0 === undefined) {

                                      // before start

                                      this._cachedIndex = 0;
                                      return this.beforeStart_(0, t, t1);

                                  }

                                  if (i1 === giveUpAt) break; // this loop

                                  t1 = t0;
                                  t0 = pp[--i1 - 1];

                                  if (t >= t0) {

                                      // we have arrived at the sought interval
                                      break seek;

                                  }

                              }

                              // prepare binary search on the left side of the index
                              right = i1;
                              i1 = 0;
                              break linear_scan;

                          }

                          // the interval is valid

                          break validate_interval;

                      } // linear scan

                      // binary search

                      while (i1 < right) {

                          const mid = (i1 + right) >>> 1;

                          if (t < pp[mid]) {

                              right = mid;

                          } else {

                              i1 = mid + 1;

                          }

                      }

                      t1 = pp[i1];
                      t0 = pp[i1 - 1];

                      // check boundary cases, again

                      if (t0 === undefined) {

                          this._cachedIndex = 0;
                          return this.beforeStart_(0, t, t1);

                      }

                      if (t1 === undefined) {

                          i1 = pp.length;
                          this._cachedIndex = i1;
                          return this.afterEnd_(i1 - 1, t0, t);

                      }

                  } // seek

                  this._cachedIndex = i1;

                  this.intervalChanged_(i1, t0, t1);

              } // validate_interval

          return this.interpolate_(i1, t0, t, t1);

      },

      settings: null, // optional, subclass-specific settings structure
      // Note: The indirection allows central control of many interpolants.

      // --- Protected interface

      DefaultSettings_: {},

      getSettings_: function() {

          return this.settings || this.DefaultSettings_;

      },

      copySampleValue_: function(index) {

          // copies a sample value to the result buffer

          const result = this.resultBuffer,
              values = this.sampleValues,
              stride = this.valueSize,
              offset = index * stride;

          for (let i = 0; i !== stride; ++i) {

              result[i] = values[offset + i];

          }

          return result;

      },

      // Template methods for derived classes:

      interpolate_: function( /* i1, t0, t, t1 */ ) {

          throw new Error('call to abstract method');
          // implementations shall return this.resultBuffer

      },

      intervalChanged_: function( /* i1, t0, t1 */ ) {

          // empty

      }

  });

  // DECLARE ALIAS AFTER assign prototype
  Object.assign(Interpolant.prototype, {

      //( 0, t, t0 ), returns this.resultBuffer
      beforeStart_: Interpolant.prototype.copySampleValue_,

      //( N-1, tN-1, t ), returns this.resultBuffer
      afterEnd_: Interpolant.prototype.copySampleValue_,

  });

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   *
   * @author tschw
   */

  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;

  }

  CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

      constructor: CubicInterpolant,

      DefaultSettings_: {

          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding

      },

      intervalChanged_: function(i1, t0, t1) {

          let pp = this.parameterPositions,
              iPrev = i1 - 2,
              iNext = i1 + 1,

              tPrev = pp[iPrev],
              tNext = pp[iNext];

          if (tPrev === undefined) {

              switch (this.getSettings_().endingStart) {

                  case ZeroSlopeEnding:

                      // f'(t0) = 0
                      iPrev = i1;
                      tPrev = 2 * t0 - t1;

                      break;

                  case WrapAroundEnding:

                      // use the other end of the curve
                      iPrev = pp.length - 2;
                      tPrev = t0 + pp[iPrev] - pp[iPrev + 1];

                      break;

                  default: // ZeroCurvatureEnding

                      // f''(t0) = 0 a.k.a. Natural Spline
                      iPrev = i1;
                      tPrev = t1;

              }

          }

          if (tNext === undefined) {

              switch (this.getSettings_().endingEnd) {

                  case ZeroSlopeEnding:

                      // f'(tN) = 0
                      iNext = i1;
                      tNext = 2 * t1 - t0;

                      break;

                  case WrapAroundEnding:

                      // use the other end of the curve
                      iNext = 1;
                      tNext = t1 + pp[1] - pp[0];

                      break;

                  default: // ZeroCurvatureEnding

                      // f''(tN) = 0, a.k.a. Natural Spline
                      iNext = i1 - 1;
                      tNext = t0;

              }

          }

          const halfDt = (t1 - t0) * 0.5,
              stride = this.valueSize;

          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;

      },

      interpolate_: function(i1, t0, t, t1) {

          const result = this.resultBuffer,
              values = this.sampleValues,
              stride = this.valueSize,

              o1 = i1 * stride,
              o0 = o1 - stride,
              oP = this._offsetPrev,
              oN = this._offsetNext,
              wP = this._weightPrev,
              wN = this._weightNext,

              p = (t - t0) / (t1 - t0),
              pp = p * p,
              ppp = pp * p;

          // evaluate polynomials

          const sP = -wP * ppp + 2 * wP * pp - wP * p;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
          const sN = wN * ppp - wN * pp;

          // combine data linearly

          for (let i = 0; i !== stride; ++i) {

              result[i] =
                  sP * values[oP + i] +
                  s0 * values[o0 + i] +
                  s1 * values[o1 + i] +
                  sN * values[oN + i];

          }

          return result;

      }

  });

  /**
   * @author tschw
   */

  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

  }

  LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

      constructor: LinearInterpolant,

      interpolate_: function(i1, t0, t, t1) {

          const result = this.resultBuffer,
              values = this.sampleValues,
              stride = this.valueSize,

              offset1 = i1 * stride,
              offset0 = offset1 - stride,

              weight1 = (t - t0) / (t1 - t0),
              weight0 = 1 - weight1;

          for (let i = 0; i !== stride; ++i) {

              result[i] =
                  values[offset0 + i] * weight0 +
                  values[offset1 + i] * weight1;

          }

          return result;

      }

  });

  /**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   *
   * @author tschw
   */

  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

  }

  DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

      constructor: DiscreteInterpolant,

      interpolate_: function(i1 /*, t0, t, t1 */ ) {

          return this.copySampleValue_(i1 - 1);

      }

  });

  /**
   *
   * A timed sequence of keyframes for a specific property.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function KeyframeTrack(name, times, values, interpolation) {

      if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
      if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);

      this.name = name;

      this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
      this.values = AnimationUtils.convertArray(values, this.ValueBufferType);

      this.setInterpolation(interpolation || this.DefaultInterpolation);

  }

  // Static methods

  Object.assign(KeyframeTrack, {

      // Serialization (in static context, because of constructor invocation
      // and automatic invocation of .toJSON):

      toJSON: function(track) {

          const trackType = track.constructor;

          let json;

          // derived classes can define a static toJSON method
          if (trackType.toJSON !== undefined) {

              json = trackType.toJSON(track);

          } else {

              // by default, we assume the data can be serialized as-is
              json = {

                  'name': track.name,
                  'times': AnimationUtils.convertArray(track.times, Array),
                  'values': AnimationUtils.convertArray(track.values, Array)

              };

              const interpolation = track.getInterpolation();

              if (interpolation !== track.DefaultInterpolation) {

                  json.interpolation = interpolation;

              }

          }

          json.type = track.ValueTypeName; // mandatory

          return json;

      }

  });

  Object.assign(KeyframeTrack.prototype, {

      constructor: KeyframeTrack,

      TimeBufferType: Float32Array,

      ValueBufferType: Float32Array,

      DefaultInterpolation: InterpolateLinear,

      InterpolantFactoryMethodDiscrete: function(result) {

          return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);

      },

      InterpolantFactoryMethodLinear: function(result) {

          return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);

      },

      InterpolantFactoryMethodSmooth: function(result) {

          return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);

      },

      setInterpolation: function(interpolation) {

          let factoryMethod;

          switch (interpolation) {

              case InterpolateDiscrete:

                  factoryMethod = this.InterpolantFactoryMethodDiscrete;

                  break;

              case InterpolateLinear:

                  factoryMethod = this.InterpolantFactoryMethodLinear;

                  break;

              case InterpolateSmooth:

                  factoryMethod = this.InterpolantFactoryMethodSmooth;

                  break;

          }

          if (factoryMethod === undefined) {

              const message = "unsupported interpolation for " +
                  this.ValueTypeName + " keyframe track named " + this.name;

              if (this.createInterpolant === undefined) {

                  // fall back to default, unless the default itself is messed up
                  if (interpolation !== this.DefaultInterpolation) {

                      this.setInterpolation(this.DefaultInterpolation);

                  } else {

                      throw new Error(message); // fatal, in this case

                  }

              }

              console.warn('THREE.KeyframeTrack:', message);
              return this;

          }

          this.createInterpolant = factoryMethod;

          return this;

      },

      getInterpolation: function() {

          switch (this.createInterpolant) {

              case this.InterpolantFactoryMethodDiscrete:

                  return InterpolateDiscrete;

              case this.InterpolantFactoryMethodLinear:

                  return InterpolateLinear;

              case this.InterpolantFactoryMethodSmooth:

                  return InterpolateSmooth;

          }

      },

      getValueSize: function() {

          return this.values.length / this.times.length;

      },

      // move all keyframes either forwards or backwards in time
      shift: function(timeOffset) {

          if (timeOffset !== 0.0) {

              const times = this.times;

              for (let i = 0, n = times.length; i !== n; ++i) {

                  times[i] += timeOffset;

              }

          }

          return this;

      },

      // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
      scale: function(timeScale) {

          if (timeScale !== 1.0) {

              const times = this.times;

              for (let i = 0, n = times.length; i !== n; ++i) {

                  times[i] *= timeScale;

              }

          }

          return this;

      },

      // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
      // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
      trim: function(startTime, endTime) {

          const times = this.times,
              nKeys = times.length;

          let from = 0,
              to = nKeys - 1;

          while (from !== nKeys && times[from] < startTime) {

              ++from;

          }

          while (to !== -1 && times[to] > endTime) {

              --to;

          }

          ++to; // inclusive -> exclusive bound

          if (from !== 0 || to !== nKeys) {

              // empty tracks are forbidden, so keep at least one keyframe
              if (from >= to) {

                  to = Math.max(to, 1);
                  from = to - 1;

              }

              const stride = this.getValueSize();
              this.times = AnimationUtils.arraySlice(times, from, to);
              this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);

          }

          return this;

      },

      // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
      validate: function() {

          let valid = true;

          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {

              console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
              valid = false;

          }

          const times = this.times,
              values = this.values,

              nKeys = times.length;

          if (nKeys === 0) {

              console.error('THREE.KeyframeTrack: Track is empty.', this);
              valid = false;

          }

          let prevTime = null;

          for (let i = 0; i !== nKeys; i++) {

              const currTime = times[i];

              if (typeof currTime === 'number' && isNaN(currTime)) {

                  console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                  valid = false;
                  break;

              }

              if (prevTime !== null && prevTime > currTime) {

                  console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                  valid = false;
                  break;

              }

              prevTime = currTime;

          }

          if (values !== undefined) {

              if (AnimationUtils.isTypedArray(values)) {

                  for (let i = 0, n = values.length; i !== n; ++i) {

                      const value = values[i];

                      if (isNaN(value)) {

                          console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                          valid = false;
                          break;

                      }

                  }

              }

          }

          return valid;

      },

      // removes equivalent sequential keys as common in morph target sequences
      // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
      optimize: function() {

          // times or values may be shared with other tracks, so overwriting is unsafe
          const times = AnimationUtils.arraySlice(this.times),
              values = AnimationUtils.arraySlice(this.values),
              stride = this.getValueSize(),

              smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

              lastIndex = times.length - 1;

          let writeIndex = 1;

          for (let i = 1; i < lastIndex; ++i) {

              let keep = false;

              const time = times[i];
              const timeNext = times[i + 1];

              // remove adjacent keyframes scheduled at the same time

              if (time !== timeNext && (i !== 1 || time !== time[0])) {

                  if (!smoothInterpolation) {

                      // remove unnecessary keyframes same as their neighbors

                      const offset = i * stride,
                          offsetP = offset - stride,
                          offsetN = offset + stride;

                      for (let j = 0; j !== stride; ++j) {

                          const value = values[offset + j];

                          if (value !== values[offsetP + j] ||
                              value !== values[offsetN + j]) {

                              keep = true;
                              break;

                          }

                      }

                  } else {

                      keep = true;

                  }

              }

              // in-place compaction

              if (keep) {

                  if (i !== writeIndex) {

                      times[writeIndex] = times[i];

                      const readOffset = i * stride,
                          writeOffset = writeIndex * stride;

                      for (let j = 0; j !== stride; ++j) {

                          values[writeOffset + j] = values[readOffset + j];

                      }

                  }

                  ++writeIndex;

              }

          }

          // flush last keyframe (compaction looks ahead)

          if (lastIndex > 0) {

              times[writeIndex] = times[lastIndex];

              for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {

                  values[writeOffset + j] = values[readOffset + j];

              }

              ++writeIndex;

          }

          if (writeIndex !== times.length) {

              this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
              this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);

          } else {

              this.times = times;
              this.values = values;

          }

          return this;

      },

      clone: function() {

          const times = AnimationUtils.arraySlice(this.times, 0);
          const values = AnimationUtils.arraySlice(this.values, 0);

          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values);

          // Interpolant argument to constructor is not saved, so copy the factory method directly.
          track.createInterpolant = this.createInterpolant;

          return track;

      }

  });

  /**
   *
   * A Track of Boolean keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function BooleanKeyframeTrack(name, times, values) {

      KeyframeTrack.call(this, name, times, values);

  }

  BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

      constructor: BooleanKeyframeTrack,

      ValueTypeName: 'bool',
      ValueBufferType: Array,

      DefaultInterpolation: InterpolateDiscrete,

      InterpolantFactoryMethodLinear: undefined,
      InterpolantFactoryMethodSmooth: undefined

      // Note: Actually this track could have a optimized / compressed
      // representation of a single value and a custom interpolant that
      // computes "firstValue ^ isOdd( index )".

  });

  /**
   *
   * A Track of keyframe values that represent color.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function ColorKeyframeTrack(name, times, values, interpolation) {

      KeyframeTrack.call(this, name, times, values, interpolation);

  }

  ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

      constructor: ColorKeyframeTrack,

      ValueTypeName: 'color'

      // ValueBufferType is inherited

      // DefaultInterpolation is inherited

      // Note: Very basic implementation and nothing special yet.
      // However, this is the place for color space parameterization.

  });

  /**
   *
   * A Track of numeric keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function NumberKeyframeTrack(name, times, values, interpolation) {

      KeyframeTrack.call(this, name, times, values, interpolation);

  }

  NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

      constructor: NumberKeyframeTrack,

      ValueTypeName: 'number'

      // ValueBufferType is inherited

      // DefaultInterpolation is inherited

  });

  /**
   * Spherical linear unit quaternion interpolant.
   *
   * @author tschw
   */

  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

  }

  QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

      constructor: QuaternionLinearInterpolant,

      interpolate_: function(i1, t0, t, t1) {

          const result = this.resultBuffer,
              values = this.sampleValues,
              stride = this.valueSize,

              alpha = (t - t0) / (t1 - t0);

          let offset = i1 * stride;

          for (let end = offset + stride; offset !== end; offset += 4) {

              Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);

          }

          return result;

      }

  });

  /**
   *
   * A Track of quaternion keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function QuaternionKeyframeTrack(name, times, values, interpolation) {

      KeyframeTrack.call(this, name, times, values, interpolation);

  }

  QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

      constructor: QuaternionKeyframeTrack,

      ValueTypeName: 'quaternion',

      // ValueBufferType is inherited

      DefaultInterpolation: InterpolateLinear,

      InterpolantFactoryMethodLinear: function(result) {

          return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);

      },

      InterpolantFactoryMethodSmooth: undefined // not yet implemented

  });

  /**
   *
   * A Track that interpolates Strings
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function StringKeyframeTrack(name, times, values, interpolation) {

      KeyframeTrack.call(this, name, times, values, interpolation);

  }

  StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

      constructor: StringKeyframeTrack,

      ValueTypeName: 'string',
      ValueBufferType: Array,

      DefaultInterpolation: InterpolateDiscrete,

      InterpolantFactoryMethodLinear: undefined,

      InterpolantFactoryMethodSmooth: undefined

  });

  /**
   *
   * A Track of vectored keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function VectorKeyframeTrack(name, times, values, interpolation) {

      KeyframeTrack.call(this, name, times, values, interpolation);

  }

  VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

      constructor: VectorKeyframeTrack,

      ValueTypeName: 'vector'

      // ValueBufferType is inherited

      // DefaultInterpolation is inherited

  });

  /**
   *
   * Reusable set of Tracks that represent an animation.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  function AnimationClip(name, duration, tracks, blendMode) {

      this.name = name;
      this.tracks = tracks;
      this.duration = (duration !== undefined) ? duration : -1;
      this.blendMode = (blendMode !== undefined) ? blendMode : NormalAnimationBlendMode;

      this.uuid = MathUtils.generateUUID();

      // this means it should figure out its duration by scanning the tracks
      if (this.duration < 0) {

          this.resetDuration();

      }

  }

  function getTrackTypeForValueTypeName(typeName) {

      switch (typeName.toLowerCase()) {

          case 'scalar':
          case 'double':
          case 'float':
          case 'number':
          case 'integer':

              return NumberKeyframeTrack;

          case 'vector':
          case 'vector2':
          case 'vector3':
          case 'vector4':

              return VectorKeyframeTrack;

          case 'color':

              return ColorKeyframeTrack;

          case 'quaternion':

              return QuaternionKeyframeTrack;

          case 'bool':
          case 'boolean':

              return BooleanKeyframeTrack;

          case 'string':

              return StringKeyframeTrack;

      }

      throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);

  }

  function parseKeyframeTrack(json) {

      if (json.type === undefined) {

          throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');

      }

      const trackType = getTrackTypeForValueTypeName(json.type);

      if (json.times === undefined) {

          const times = [],
              values = [];

          AnimationUtils.flattenJSON(json.keys, times, values, 'value');

          json.times = times;
          json.values = values;

      }

      // derived classes can define a static parse method
      if (trackType.parse !== undefined) {

          return trackType.parse(json);

      } else {

          // by default, we assume a constructor compatible with the base
          return new trackType(json.name, json.times, json.values, json.interpolation);

      }

  }

  Object.assign(AnimationClip, {

      parse: function(json) {

          const tracks = [],
              jsonTracks = json.tracks,
              frameTime = 1.0 / (json.fps || 1.0);

          for (let i = 0, n = jsonTracks.length; i !== n; ++i) {

              tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));

          }

          return new AnimationClip(json.name, json.duration, tracks, json.blendMode);

      },

      toJSON: function(clip) {

          const tracks = [],
              clipTracks = clip.tracks;

          const json = {

              'name': clip.name,
              'duration': clip.duration,
              'tracks': tracks,
              'uuid': clip.uuid,
              'blendMode': clip.blendMode

          };

          for (let i = 0, n = clipTracks.length; i !== n; ++i) {

              tracks.push(KeyframeTrack.toJSON(clipTracks[i]));

          }

          return json;

      },

      CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {

          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];

          for (let i = 0; i < numMorphTargets; i++) {

              let times = [];
              let values = [];

              times.push(
                  (i + numMorphTargets - 1) % numMorphTargets,
                  i,
                  (i + 1) % numMorphTargets);

              values.push(0, 1, 0);

              const order = AnimationUtils.getKeyframeOrder(times);
              times = AnimationUtils.sortedArray(times, 1, order);
              values = AnimationUtils.sortedArray(values, 1, order);

              // if there is a key at the first frame, duplicate it as the
              // last frame as well for perfect loop.
              if (!noLoop && times[0] === 0) {

                  times.push(numMorphTargets);
                  values.push(values[0]);

              }

              tracks.push(
                  new NumberKeyframeTrack(
                      '.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
                      times, values
                  ).scale(1.0 / fps));

          }

          return new AnimationClip(name, -1, tracks);

      },

      findByName: function(objectOrClipArray, name) {

          let clipArray = objectOrClipArray;

          if (!Array.isArray(objectOrClipArray)) {

              const o = objectOrClipArray;
              clipArray = o.geometry && o.geometry.animations || o.animations;

          }

          for (let i = 0; i < clipArray.length; i++) {

              if (clipArray[i].name === name) {

                  return clipArray[i];

              }

          }

          return null;

      },

      CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {

          const animationToMorphTargets = {};

          // tested with https://regex101.com/ on trick sequences
          // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
          const pattern = /^([\w-]*?)([\d]+)$/;

          // sort morph target names into animation groups based
          // patterns like Walk_001, Walk_002, Run_001, Run_002
          for (let i = 0, il = morphTargets.length; i < il; i++) {

              const morphTarget = morphTargets[i];
              const parts = morphTarget.name.match(pattern);

              if (parts && parts.length > 1) {

                  const name = parts[1];

                  let animationMorphTargets = animationToMorphTargets[name];

                  if (!animationMorphTargets) {

                      animationToMorphTargets[name] = animationMorphTargets = [];

                  }

                  animationMorphTargets.push(morphTarget);

              }

          }

          const clips = [];

          for (const name in animationToMorphTargets) {

              clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));

          }

          return clips;

      },

      // parse the animation.hierarchy format
      parseAnimation: function(animation, bones) {

          if (!animation) {

              console.error('THREE.AnimationClip: No animation in JSONLoader data.');
              return null;

          }

          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {

              // only return track if there are actually keys.
              if (animationKeys.length !== 0) {

                  const times = [];
                  const values = [];

                  AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);

                  // empty keys are filtered out, so check again
                  if (times.length !== 0) {

                      destTracks.push(new trackType(trackName, times, values));

                  }

              }

          };

          const tracks = [];

          const clipName = animation.name || 'default';
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;

          // automatic length determination in AnimationClip.
          let duration = animation.length || -1;

          const hierarchyTracks = animation.hierarchy || [];

          for (let h = 0; h < hierarchyTracks.length; h++) {

              const animationKeys = hierarchyTracks[h].keys;

              // skip empty tracks
              if (!animationKeys || animationKeys.length === 0) continue;

              // process morph targets
              if (animationKeys[0].morphTargets) {

                  // figure out all morph targets used in this track
                  const morphTargetNames = {};

                  let k;

                  for (k = 0; k < animationKeys.length; k++) {

                      if (animationKeys[k].morphTargets) {

                          for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {

                              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;

                          }

                      }

                  }

                  // create a track for each morph target with all zero
                  // morphTargetInfluences except for the keys in which
                  // the morphTarget is named.
                  for (const morphTargetName in morphTargetNames) {

                      const times = [];
                      const values = [];

                      for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {

                          const animationKey = animationKeys[k];

                          times.push(animationKey.time);
                          values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);

                      }

                      tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));

                  }

                  duration = morphTargetNames.length * (fps || 1.0);

              } else {

                  // ...assume skeletal animation

                  const boneName = '.bones[' + bones[h].name + ']';

                  addNonemptyTrack(
                      VectorKeyframeTrack, boneName + '.position',
                      animationKeys, 'pos', tracks);

                  addNonemptyTrack(
                      QuaternionKeyframeTrack, boneName + '.quaternion',
                      animationKeys, 'rot', tracks);

                  addNonemptyTrack(
                      VectorKeyframeTrack, boneName + '.scale',
                      animationKeys, 'scl', tracks);

              }

          }

          if (tracks.length === 0) {

              return null;

          }

          const clip = new AnimationClip(clipName, duration, tracks, blendMode);

          return clip;

      }

  });

  Object.assign(AnimationClip.prototype, {

      resetDuration: function() {

          const tracks = this.tracks;
          let duration = 0;

          for (let i = 0, n = tracks.length; i !== n; ++i) {

              const track = this.tracks[i];

              duration = Math.max(duration, track.times[track.times.length - 1]);

          }

          this.duration = duration;

          return this;

      },

      trim: function() {

          for (let i = 0; i < this.tracks.length; i++) {

              this.tracks[i].trim(0, this.duration);

          }

          return this;

      },

      validate: function() {

          let valid = true;

          for (let i = 0; i < this.tracks.length; i++) {

              valid = valid && this.tracks[i].validate();

          }

          return valid;

      },

      optimize: function() {

          for (let i = 0; i < this.tracks.length; i++) {

              this.tracks[i].optimize();

          }

          return this;

      },

      clone: function() {

          const tracks = [];

          for (let i = 0; i < this.tracks.length; i++) {

              tracks.push(this.tracks[i].clone());

          }

          return new AnimationClip(this.name, this.duration, tracks, this.blendMode);

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const Cache = {

      enabled: false,

      files: {},

      add: function(key, file) {

          if (this.enabled === false) return;

          // console.log( 'THREE.Cache', 'Adding key:', key );

          this.files[key] = file;

      },

      get: function(key) {

          if (this.enabled === false) return;

          // console.log( 'THREE.Cache', 'Checking key:', key );

          return this.files[key];

      },

      remove: function(key) {

          delete this.files[key];

      },

      clear: function() {

          this.files = {};

      }

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LoadingManager(onLoad, onProgress, onError) {

      const scope = this;

      let isLoading = false;
      let itemsLoaded = 0;
      let itemsTotal = 0;
      let urlModifier = undefined;
      const handlers = [];

      // Refer to #5689 for the reason why we don't set .onStart
      // in the constructor

      this.onStart = undefined;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;

      this.itemStart = function(url) {

          itemsTotal++;

          if (isLoading === false) {

              if (scope.onStart !== undefined) {

                  scope.onStart(url, itemsLoaded, itemsTotal);

              }

          }

          isLoading = true;

      };

      this.itemEnd = function(url) {

          itemsLoaded++;

          if (scope.onProgress !== undefined) {

              scope.onProgress(url, itemsLoaded, itemsTotal);

          }

          if (itemsLoaded === itemsTotal) {

              isLoading = false;

              if (scope.onLoad !== undefined) {

                  scope.onLoad();

              }

          }

      };

      this.itemError = function(url) {

          if (scope.onError !== undefined) {

              scope.onError(url);

          }

      };

      this.resolveURL = function(url) {

          if (urlModifier) {

              return urlModifier(url);

          }

          return url;

      };

      this.setURLModifier = function(transform) {

          urlModifier = transform;

          return this;

      };

      this.addHandler = function(regex, loader) {

          handlers.push(regex, loader);

          return this;

      };

      this.removeHandler = function(regex) {

          const index = handlers.indexOf(regex);

          if (index !== -1) {

              handlers.splice(index, 2);

          }

          return this;

      };

      this.getHandler = function(file) {

          for (let i = 0, l = handlers.length; i < l; i += 2) {

              const regex = handlers[i];
              const loader = handlers[i + 1];

              if (regex.global) regex.lastIndex = 0; // see #17920

              if (regex.test(file)) {

                  return loader;

              }

          }

          return null;

      };

  }

  const DefaultLoadingManager = new LoadingManager();

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Loader(manager) {

      this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

      this.crossOrigin = 'anonymous';
      this.path = '';
      this.resourcePath = '';
      this.requestHeader = {};

  }

  Object.assign(Loader.prototype, {

      load: function( /* url, onLoad, onProgress, onError */ ) {},

      loadAsync: function(url, onProgress) {

          const scope = this;

          return new Promise(function(resolve, reject) {

              scope.load(url, resolve, onProgress, reject);

          });

      },

      parse: function( /* data */ ) {},

      setCrossOrigin: function(crossOrigin) {

          this.crossOrigin = crossOrigin;
          return this;

      },

      setPath: function(path) {

          this.path = path;
          return this;

      },

      setResourcePath: function(resourcePath) {

          this.resourcePath = resourcePath;
          return this;

      },

      setRequestHeader: function(requestHeader) {

          this.requestHeader = requestHeader;
          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const loading = {};

  function FileLoader(manager) {

      Loader.call(this, manager);

  }

  FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: FileLoader,

      load: function(url, onLoad, onProgress, onError) {

          if (url === undefined) url = '';

          if (this.path !== undefined) url = this.path + url;

          url = this.manager.resolveURL(url);

          const scope = this;

          const cached = Cache.get(url);

          if (cached !== undefined) {

              scope.manager.itemStart(url);

              setTimeout(function() {

                  if (onLoad) onLoad(cached);

                  scope.manager.itemEnd(url);

              }, 0);

              return cached;

          }

          // Check if request is duplicate

          if (loading[url] !== undefined) {

              loading[url].push({

                  onLoad: onLoad,
                  onProgress: onProgress,
                  onError: onError

              });

              return;

          }

          // Check for data: URI
          const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
          const dataUriRegexResult = url.match(dataUriRegex);
          let request;

          // Safari can not handle Data URIs through XMLHttpRequest so process manually
          if (dataUriRegexResult) {

              const mimeType = dataUriRegexResult[1];
              const isBase64 = !!dataUriRegexResult[2];

              let data = dataUriRegexResult[3];
              data = decodeURIComponent(data);

              if (isBase64) data = atob(data);

              try {

                  let response;
                  const responseType = (this.responseType || '').toLowerCase();

                  switch (responseType) {

                      case 'arraybuffer':
                      case 'blob':

                          const view = new Uint8Array(data.length);

                          for (let i = 0; i < data.length; i++) {

                              view[i] = data.charCodeAt(i);

                          }

                          if (responseType === 'blob') {

                              response = new Blob([view.buffer], { type: mimeType });

                          } else {

                              response = view.buffer;

                          }

                          break;

                      case 'document':

                          const parser = new DOMParser();
                          response = parser.parseFromString(data, mimeType);

                          break;

                      case 'json':

                          response = JSON.parse(data);

                          break;

                      default: // 'text' or other

                          response = data;

                          break;

                  }

                  // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                  setTimeout(function() {

                      if (onLoad) onLoad(response);

                      scope.manager.itemEnd(url);

                  }, 0);

              } catch (error) {

                  // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                  setTimeout(function() {

                      if (onError) onError(error);

                      scope.manager.itemError(url);
                      scope.manager.itemEnd(url);

                  }, 0);

              }

          } else {

              // Initialise array for duplicate requests

              loading[url] = [];

              loading[url].push({

                  onLoad: onLoad,
                  onProgress: onProgress,
                  onError: onError

              });

              request = new XMLHttpRequest();

              request.open('GET', url, true);

              request.addEventListener('load', function(event) {

                  const response = this.response;

                  const callbacks = loading[url];

                  delete loading[url];

                  if (this.status === 200 || this.status === 0) {

                      // Some browsers return HTTP Status 0 when using non-http protocol
                      // e.g. 'file://' or 'data://'. Handle as success.

                      if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');

                      // Add to cache only on HTTP success, so that we do not cache
                      // error response bodies as proper responses to requests.
                      Cache.add(url, response);

                      for (let i = 0, il = callbacks.length; i < il; i++) {

                          const callback = callbacks[i];
                          if (callback.onLoad) callback.onLoad(response);

                      }

                      scope.manager.itemEnd(url);

                  } else {

                      for (let i = 0, il = callbacks.length; i < il; i++) {

                          const callback = callbacks[i];
                          if (callback.onError) callback.onError(event);

                      }

                      scope.manager.itemError(url);
                      scope.manager.itemEnd(url);

                  }

              }, false);

              request.addEventListener('progress', function(event) {

                  const callbacks = loading[url];

                  for (let i = 0, il = callbacks.length; i < il; i++) {

                      const callback = callbacks[i];
                      if (callback.onProgress) callback.onProgress(event);

                  }

              }, false);

              request.addEventListener('error', function(event) {

                  const callbacks = loading[url];

                  delete loading[url];

                  for (let i = 0, il = callbacks.length; i < il; i++) {

                      const callback = callbacks[i];
                      if (callback.onError) callback.onError(event);

                  }

                  scope.manager.itemError(url);
                  scope.manager.itemEnd(url);

              }, false);

              request.addEventListener('abort', function(event) {

                  const callbacks = loading[url];

                  delete loading[url];

                  for (let i = 0, il = callbacks.length; i < il; i++) {

                      const callback = callbacks[i];
                      if (callback.onError) callback.onError(event);

                  }

                  scope.manager.itemError(url);
                  scope.manager.itemEnd(url);

              }, false);

              if (this.responseType !== undefined) request.responseType = this.responseType;
              if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

              if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

              for (const header in this.requestHeader) {

                  request.setRequestHeader(header, this.requestHeader[header]);

              }

              request.send(null);

          }

          scope.manager.itemStart(url);

          return request;

      },

      setResponseType: function(value) {

          this.responseType = value;
          return this;

      },

      setWithCredentials: function(value) {

          this.withCredentials = value;
          return this;

      },

      setMimeType: function(value) {

          this.mimeType = value;
          return this;

      }

  });

  /**
   * @author bhouston / http://clara.io/
   */

  function AnimationLoader(manager) {

      Loader.call(this, manager);

  }

  AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: AnimationLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.load(url, function(text) {

              try {

                  onLoad(scope.parse(JSON.parse(text)));

              } catch (e) {

                  if (onError) {

                      onError(e);

                  } else {

                      console.error(e);

                  }

                  scope.manager.itemError(url);

              }

          }, onProgress, onError);

      },

      parse: function(json) {

          const animations = [];

          for (let i = 0; i < json.length; i++) {

              const clip = AnimationClip.parse(json[i]);

              animations.push(clip);

          }

          return animations;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */

  function CompressedTextureLoader(manager) {

      Loader.call(this, manager);

  }

  CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: CompressedTextureLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const images = [];

          const texture = new CompressedTexture();
          texture.image = images;

          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType('arraybuffer');

          let loaded = 0;

          function loadTexture(i) {

              loader.load(url[i], function(buffer) {

                  const texDatas = scope.parse(buffer, true);

                  images[i] = {
                      width: texDatas.width,
                      height: texDatas.height,
                      format: texDatas.format,
                      mipmaps: texDatas.mipmaps
                  };

                  loaded += 1;

                  if (loaded === 6) {

                      if (texDatas.mipmapCount === 1)
                          texture.minFilter = LinearFilter;

                      texture.format = texDatas.format;
                      texture.needsUpdate = true;

                      if (onLoad) onLoad(texture);

                  }

              }, onProgress, onError);

          }

          if (Array.isArray(url)) {

              for (let i = 0, il = url.length; i < il; ++i) {

                  loadTexture(i);

              }

          } else {

              // compressed cubemap texture stored in a single DDS file

              loader.load(url, function(buffer) {

                  const texDatas = scope.parse(buffer, true);

                  if (texDatas.isCubemap) {

                      const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                      for (let f = 0; f < faces; f++) {

                          images[f] = { mipmaps: [] };

                          for (let i = 0; i < texDatas.mipmapCount; i++) {

                              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                              images[f].format = texDatas.format;
                              images[f].width = texDatas.width;
                              images[f].height = texDatas.height;

                          }

                      }

                  } else {

                      texture.image.width = texDatas.width;
                      texture.image.height = texDatas.height;
                      texture.mipmaps = texDatas.mipmaps;

                  }

                  if (texDatas.mipmapCount === 1) {

                      texture.minFilter = LinearFilter;

                  }

                  texture.format = texDatas.format;
                  texture.needsUpdate = true;

                  if (onLoad) onLoad(texture);

              }, onProgress, onError);

          }

          return texture;

      }

  });

  /**
   * @author Nikos M. / https://github.com/foo123/
   *
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */

  function DataTextureLoader(manager) {

      Loader.call(this, manager);

  }

  DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: DataTextureLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const texture = new DataTexture();

          const loader = new FileLoader(this.manager);
          loader.setResponseType('arraybuffer');
          loader.setPath(this.path);
          loader.load(url, function(buffer) {

              const texData = scope.parse(buffer);

              if (!texData) return;

              if (texData.image !== undefined) {

                  texture.image = texData.image;

              } else if (texData.data !== undefined) {

                  texture.image.width = texData.width;
                  texture.image.height = texData.height;
                  texture.image.data = texData.data;

              }

              texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
              texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

              texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
              texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

              texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

              if (texData.format !== undefined) {

                  texture.format = texData.format;

              }

              if (texData.type !== undefined) {

                  texture.type = texData.type;

              }

              if (texData.mipmaps !== undefined) {

                  texture.mipmaps = texData.mipmaps;
                  texture.minFilter = LinearMipmapLinearFilter; // presumably...

              }

              if (texData.mipmapCount === 1) {

                  texture.minFilter = LinearFilter;

              }

              texture.needsUpdate = true;

              if (onLoad) onLoad(texture, texData);

          }, onProgress, onError);


          return texture;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ImageLoader(manager) {

      Loader.call(this, manager);

  }

  ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: ImageLoader,

      load: function(url, onLoad, onProgress, onError) {

          if (this.path !== undefined) url = this.path + url;

          url = this.manager.resolveURL(url);

          const scope = this;

          const cached = Cache.get(url);

          if (cached !== undefined) {

              scope.manager.itemStart(url);

              setTimeout(function() {

                  if (onLoad) onLoad(cached);

                  scope.manager.itemEnd(url);

              }, 0);

              return cached;

          }

          const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

          function onImageLoad() {

              image.removeEventListener('load', onImageLoad, false);
              image.removeEventListener('error', onImageError, false);

              Cache.add(url, this);

              if (onLoad) onLoad(this);

              scope.manager.itemEnd(url);

          }

          function onImageError(event) {

              image.removeEventListener('load', onImageLoad, false);
              image.removeEventListener('error', onImageError, false);

              if (onError) onError(event);

              scope.manager.itemError(url);
              scope.manager.itemEnd(url);

          }

          image.addEventListener('load', onImageLoad, false);
          image.addEventListener('error', onImageError, false);

          if (url.substr(0, 5) !== 'data:') {

              if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;

          }

          scope.manager.itemStart(url);

          image.src = url;

          return image;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */


  function CubeTextureLoader(manager) {

      Loader.call(this, manager);

  }

  CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: CubeTextureLoader,

      load: function(urls, onLoad, onProgress, onError) {

          const texture = new CubeTexture();

          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);

          let loaded = 0;

          function loadTexture(i) {

              loader.load(urls[i], function(image) {

                  texture.images[i] = image;

                  loaded++;

                  if (loaded === 6) {

                      texture.needsUpdate = true;

                      if (onLoad) onLoad(texture);

                  }

              }, undefined, onError);

          }

          for (let i = 0; i < urls.length; ++i) {

              loadTexture(i);

          }

          return texture;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function TextureLoader(manager) {

      Loader.call(this, manager);

  }

  TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: TextureLoader,

      load: function(url, onLoad, onProgress, onError) {

          const texture = new Texture();

          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);

          loader.load(url, function(image) {

              texture.image = image;

              // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
              const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;

              texture.format = isJPEG ? RGBFormat : RGBAFormat;
              texture.needsUpdate = true;

              if (onLoad !== undefined) {

                  onLoad(texture);

              }

          }, onProgress, onError);

          return texture;

      }

  });

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Extensible curve object
   *
   * Some common of curve methods:
   * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
   * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/

  /**************************************************************
   *	Abstract Curve base class
   **************************************************************/

  function Curve() {

      this.type = 'Curve';

      this.arcLengthDivisions = 200;

  }

  Object.assign(Curve.prototype, {

      // Virtual base class method to overwrite and implement in subclasses
      //	- t [0 .. 1]

      getPoint: function( /* t, optionalTarget */ ) {

          console.warn('THREE.Curve: .getPoint() not implemented.');
          return null;

      },

      // Get point at relative position in curve according to arc length
      // - u [0 .. 1]

      getPointAt: function(u, optionalTarget) {

          const t = this.getUtoTmapping(u);
          return this.getPoint(t, optionalTarget);

      },

      // Get sequence of points using getPoint( t )

      getPoints: function(divisions) {

          if (divisions === undefined) divisions = 5;

          const points = [];

          for (let d = 0; d <= divisions; d++) {

              points.push(this.getPoint(d / divisions));

          }

          return points;

      },

      // Get sequence of points using getPointAt( u )

      getSpacedPoints: function(divisions) {

          if (divisions === undefined) divisions = 5;

          const points = [];

          for (let d = 0; d <= divisions; d++) {

              points.push(this.getPointAt(d / divisions));

          }

          return points;

      },

      // Get total curve arc length

      getLength: function() {

          const lengths = this.getLengths();
          return lengths[lengths.length - 1];

      },

      // Get list of cumulative segment lengths

      getLengths: function(divisions) {

          if (divisions === undefined) divisions = this.arcLengthDivisions;

          if (this.cacheArcLengths &&
              (this.cacheArcLengths.length === divisions + 1) &&
              !this.needsUpdate) {

              return this.cacheArcLengths;

          }

          this.needsUpdate = false;

          const cache = [];
          let current, last = this.getPoint(0);
          let sum = 0;

          cache.push(0);

          for (let p = 1; p <= divisions; p++) {

              current = this.getPoint(p / divisions);
              sum += current.distanceTo(last);
              cache.push(sum);
              last = current;

          }

          this.cacheArcLengths = cache;

          return cache; // { sums: cache, sum: sum }; Sum is in the last element.

      },

      updateArcLengths: function() {

          this.needsUpdate = true;
          this.getLengths();

      },

      // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

      getUtoTmapping: function(u, distance) {

          const arcLengths = this.getLengths();

          let i = 0,
              il = arcLengths.length;

          let targetArcLength; // The targeted u distance value to get

          if (distance) {

              targetArcLength = distance;

          } else {

              targetArcLength = u * arcLengths[il - 1];

          }

          // binary search for the index with largest value smaller than target u distance

          let low = 0,
              high = il - 1,
              comparison;

          while (low <= high) {

              i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

              comparison = arcLengths[i] - targetArcLength;

              if (comparison < 0) {

                  low = i + 1;

              } else if (comparison > 0) {

                  high = i - 1;

              } else {

                  high = i;
                  break;

                  // DONE

              }

          }

          i = high;

          if (arcLengths[i] === targetArcLength) {

              return i / (il - 1);

          }

          // we could get finer grain at lengths, or use simple interpolation between two points

          const lengthBefore = arcLengths[i];
          const lengthAfter = arcLengths[i + 1];

          const segmentLength = lengthAfter - lengthBefore;

          // determine where we are between the 'before' and 'after' points

          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

          // add that fractional amount to t

          const t = (i + segmentFraction) / (il - 1);

          return t;

      },

      // Returns a unit vector tangent at t
      // In case any sub curve does not implement its tangent derivation,
      // 2 points a small delta apart will be used to find its gradient
      // which seems to give a reasonable approximation

      getTangent: function(t, optionalTarget) {

          const delta = 0.0001;
          let t1 = t - delta;
          let t2 = t + delta;

          // Capping in case of danger

          if (t1 < 0) t1 = 0;
          if (t2 > 1) t2 = 1;

          const pt1 = this.getPoint(t1);
          const pt2 = this.getPoint(t2);

          const tangent = optionalTarget || ((pt1.isVector2) ? new Vector2() : new Vector3());

          tangent.copy(pt2).sub(pt1).normalize();

          return tangent;

      },

      getTangentAt: function(u, optionalTarget) {

          const t = this.getUtoTmapping(u);
          return this.getTangent(t, optionalTarget);

      },

      computeFrenetFrames: function(segments, closed) {

          // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

          const normal = new Vector3();

          const tangents = [];
          const normals = [];
          const binormals = [];

          const vec = new Vector3();
          const mat = new Matrix4();

          // compute the tangent vectors for each segment on the curve

          for (let i = 0; i <= segments; i++) {

              const u = i / segments;

              tangents[i] = this.getTangentAt(u, new Vector3());
              tangents[i].normalize();

          }

          // select an initial normal vector perpendicular to the first tangent vector,
          // and in the direction of the minimum tangent xyz component

          normals[0] = new Vector3();
          binormals[0] = new Vector3();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);

          if (tx <= min) {

              min = tx;
              normal.set(1, 0, 0);

          }

          if (ty <= min) {

              min = ty;
              normal.set(0, 1, 0);

          }

          if (tz <= min) {

              normal.set(0, 0, 1);

          }

          vec.crossVectors(tangents[0], normal).normalize();

          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);


          // compute the slowly-varying normal and binormal vectors for each segment on the curve

          for (let i = 1; i <= segments; i++) {

              normals[i] = normals[i - 1].clone();

              binormals[i] = binormals[i - 1].clone();

              vec.crossVectors(tangents[i - 1], tangents[i]);

              if (vec.length() > Number.EPSILON) {

                  vec.normalize();

                  const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

                  normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));

              }

              binormals[i].crossVectors(tangents[i], normals[i]);

          }

          // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

          if (closed === true) {

              let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
              theta /= segments;

              if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {

                  theta = -theta;

              }

              for (let i = 1; i <= segments; i++) {

                  // twist a little...
                  normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                  binormals[i].crossVectors(tangents[i], normals[i]);

              }

          }

          return {
              tangents: tangents,
              normals: normals,
              binormals: binormals
          };

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(source) {

          this.arcLengthDivisions = source.arcLengthDivisions;

          return this;

      },

      toJSON: function() {

          const data = {
              metadata: {
                  version: 4.5,
                  type: 'Curve',
                  generator: 'Curve.toJSON'
              }
          };

          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;

          return data;

      },

      fromJSON: function(json) {

          this.arcLengthDivisions = json.arcLengthDivisions;

          return this;

      }

  });

  function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

      Curve.call(this);

      this.type = 'EllipseCurve';

      this.aX = aX || 0;
      this.aY = aY || 0;

      this.xRadius = xRadius || 1;
      this.yRadius = yRadius || 1;

      this.aStartAngle = aStartAngle || 0;
      this.aEndAngle = aEndAngle || 2 * Math.PI;

      this.aClockwise = aClockwise || false;

      this.aRotation = aRotation || 0;

  }

  EllipseCurve.prototype = Object.create(Curve.prototype);
  EllipseCurve.prototype.constructor = EllipseCurve;

  EllipseCurve.prototype.isEllipseCurve = true;

  EllipseCurve.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector2();

      const twoPi = Math.PI * 2;
      let deltaAngle = this.aEndAngle - this.aStartAngle;
      const samePoints = Math.abs(deltaAngle) < Number.EPSILON;

      // ensures that deltaAngle is 0 .. 2 PI
      while (deltaAngle < 0) deltaAngle += twoPi;
      while (deltaAngle > twoPi) deltaAngle -= twoPi;

      if (deltaAngle < Number.EPSILON) {

          if (samePoints) {

              deltaAngle = 0;

          } else {

              deltaAngle = twoPi;

          }

      }

      if (this.aClockwise === true && !samePoints) {

          if (deltaAngle === twoPi) {

              deltaAngle = -twoPi;

          } else {

              deltaAngle = deltaAngle - twoPi;

          }

      }

      const angle = this.aStartAngle + t * deltaAngle;
      let x = this.aX + this.xRadius * Math.cos(angle);
      let y = this.aY + this.yRadius * Math.sin(angle);

      if (this.aRotation !== 0) {

          const cos = Math.cos(this.aRotation);
          const sin = Math.sin(this.aRotation);

          const tx = x - this.aX;
          const ty = y - this.aY;

          // Rotate the point about the center of the ellipse.
          x = tx * cos - ty * sin + this.aX;
          y = tx * sin + ty * cos + this.aY;

      }

      return point.set(x, y);

  };

  EllipseCurve.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.aX = source.aX;
      this.aY = source.aY;

      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;

      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;

      this.aClockwise = source.aClockwise;

      this.aRotation = source.aRotation;

      return this;

  };


  EllipseCurve.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.aX = this.aX;
      data.aY = this.aY;

      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;

      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;

      data.aClockwise = this.aClockwise;

      data.aRotation = this.aRotation;

      return data;

  };

  EllipseCurve.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.aX = json.aX;
      this.aY = json.aY;

      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;

      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;

      this.aClockwise = json.aClockwise;

      this.aRotation = json.aRotation;

      return this;

  };

  function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

      EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

      this.type = 'ArcCurve';

  }

  ArcCurve.prototype = Object.create(EllipseCurve.prototype);
  ArcCurve.prototype.constructor = ArcCurve;

  ArcCurve.prototype.isArcCurve = true;

  /**
   * @author zz85 https://github.com/zz85
   *
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */


  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

      let c0 = 0,
          c1 = 0,
          c2 = 0,
          c3 = 0;

      /*
       * Compute coefficients for a cubic polynomial
       *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
       * such that
       *   p(0) = x0, p(1) = x1
       *  and
       *   p'(0) = t0, p'(1) = t1.
       */
      function init(x0, x1, t0, t1) {

          c0 = x0;
          c1 = t0;
          c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
          c3 = 2 * x0 - 2 * x1 + t0 + t1;

      }

      return {

          initCatmullRom: function(x0, x1, x2, x3, tension) {

              init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));

          },

          initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {

              // compute tangents when parameterized in [t1,t2]
              let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
              let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

              // rescale tangents for parametrization in [0,1]
              t1 *= dt1;
              t2 *= dt1;

              init(x1, x2, t1, t2);

          },

          calc: function(t) {

              const t2 = t * t;
              const t3 = t2 * t;
              return c0 + c1 * t + c2 * t2 + c3 * t3;

          }

      };

  }

  //

  const tmp = new Vector3();
  const px = new CubicPoly(),
      py = new CubicPoly(),
      pz = new CubicPoly();

  function CatmullRomCurve3(points, closed, curveType, tension) {

      Curve.call(this);

      this.type = 'CatmullRomCurve3';

      this.points = points || [];
      this.closed = closed || false;
      this.curveType = curveType || 'centripetal';
      this.tension = tension || 0.5;

  }

  CatmullRomCurve3.prototype = Object.create(Curve.prototype);
  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

  CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector3();

      const points = this.points;
      const l = points.length;

      const p = (l - (this.closed ? 0 : 1)) * t;
      let intPoint = Math.floor(p);
      let weight = p - intPoint;

      if (this.closed) {

          intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;

      } else if (weight === 0 && intPoint === l - 1) {

          intPoint = l - 2;
          weight = 1;

      }

      let p0, p1, p2, p3; // 4 points

      if (this.closed || intPoint > 0) {

          p0 = points[(intPoint - 1) % l];

      } else {

          // extrapolate first point
          tmp.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp;

      }

      p1 = points[intPoint % l];
      p2 = points[(intPoint + 1) % l];

      if (this.closed || intPoint + 2 < l) {

          p3 = points[(intPoint + 2) % l];

      } else {

          // extrapolate last point
          tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
          p3 = tmp;

      }

      if (this.curveType === 'centripetal' || this.curveType === 'chordal') {

          // init Centripetal / Chordal Catmull-Rom
          const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
          let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
          let dt2 = Math.pow(p2.distanceToSquared(p3), pow);

          // safety check for repeated points
          if (dt1 < 1e-4) dt1 = 1.0;
          if (dt0 < 1e-4) dt0 = dt1;
          if (dt2 < 1e-4) dt2 = dt1;

          px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
          py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
          pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);

      } else if (this.curveType === 'catmullrom') {

          px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
          py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
          pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);

      }

      point.set(
          px.calc(weight),
          py.calc(weight),
          pz.calc(weight)
      );

      return point;

  };

  CatmullRomCurve3.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.points = [];

      for (let i = 0, l = source.points.length; i < l; i++) {

          const point = source.points[i];

          this.points.push(point.clone());

      }

      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;

      return this;

  };

  CatmullRomCurve3.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.points = [];

      for (let i = 0, l = this.points.length; i < l; i++) {

          const point = this.points[i];
          data.points.push(point.toArray());

      }

      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;

      return data;

  };

  CatmullRomCurve3.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.points = [];

      for (let i = 0, l = json.points.length; i < l; i++) {

          const point = json.points[i];
          this.points.push(new Vector3().fromArray(point));

      }

      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;

      return this;

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/Bézier_curve
   */

  function CatmullRom(t, p0, p1, p2, p3) {

      const v0 = (p2 - p0) * 0.5;
      const v1 = (p3 - p1) * 0.5;
      const t2 = t * t;
      const t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

  }

  //

  function QuadraticBezierP0(t, p) {

      const k = 1 - t;
      return k * k * p;

  }

  function QuadraticBezierP1(t, p) {

      return 2 * (1 - t) * t * p;

  }

  function QuadraticBezierP2(t, p) {

      return t * t * p;

  }

  function QuadraticBezier(t, p0, p1, p2) {

      return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
          QuadraticBezierP2(t, p2);

  }

  //

  function CubicBezierP0(t, p) {

      const k = 1 - t;
      return k * k * k * p;

  }

  function CubicBezierP1(t, p) {

      const k = 1 - t;
      return 3 * k * k * t * p;

  }

  function CubicBezierP2(t, p) {

      return 3 * (1 - t) * t * t * p;

  }

  function CubicBezierP3(t, p) {

      return t * t * t * p;

  }

  function CubicBezier(t, p0, p1, p2, p3) {

      return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
          CubicBezierP3(t, p3);

  }

  function CubicBezierCurve(v0, v1, v2, v3) {

      Curve.call(this);

      this.type = 'CubicBezierCurve';

      this.v0 = v0 || new Vector2();
      this.v1 = v1 || new Vector2();
      this.v2 = v2 || new Vector2();
      this.v3 = v3 || new Vector2();

  }

  CubicBezierCurve.prototype = Object.create(Curve.prototype);
  CubicBezierCurve.prototype.constructor = CubicBezierCurve;

  CubicBezierCurve.prototype.isCubicBezierCurve = true;

  CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector2();

      const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;

      point.set(
          CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
          CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
      );

      return point;

  };

  CubicBezierCurve.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);

      return this;

  };

  CubicBezierCurve.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();

      return data;

  };

  CubicBezierCurve.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);

      return this;

  };

  function CubicBezierCurve3(v0, v1, v2, v3) {

      Curve.call(this);

      this.type = 'CubicBezierCurve3';

      this.v0 = v0 || new Vector3();
      this.v1 = v1 || new Vector3();
      this.v2 = v2 || new Vector3();
      this.v3 = v3 || new Vector3();

  }

  CubicBezierCurve3.prototype = Object.create(Curve.prototype);
  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

  CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector3();

      const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;

      point.set(
          CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
          CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
          CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
      );

      return point;

  };

  CubicBezierCurve3.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);

      return this;

  };

  CubicBezierCurve3.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();

      return data;

  };

  CubicBezierCurve3.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);

      return this;

  };

  function LineCurve(v1, v2) {

      Curve.call(this);

      this.type = 'LineCurve';

      this.v1 = v1 || new Vector2();
      this.v2 = v2 || new Vector2();

  }

  LineCurve.prototype = Object.create(Curve.prototype);
  LineCurve.prototype.constructor = LineCurve;

  LineCurve.prototype.isLineCurve = true;

  LineCurve.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector2();

      if (t === 1) {

          point.copy(this.v2);

      } else {

          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);

      }

      return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve.prototype.getPointAt = function(u, optionalTarget) {

      return this.getPoint(u, optionalTarget);

  };

  LineCurve.prototype.getTangent = function(t, optionalTarget) {

      const tangent = optionalTarget || new Vector2();

      tangent.copy(this.v2).sub(this.v1).normalize();

      return tangent;

  };

  LineCurve.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.v1.copy(source.v1);
      this.v2.copy(source.v2);

      return this;

  };

  LineCurve.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();

      return data;

  };

  LineCurve.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);

      return this;

  };

  function LineCurve3(v1, v2) {

      Curve.call(this);

      this.type = 'LineCurve3';

      this.v1 = v1 || new Vector3();
      this.v2 = v2 || new Vector3();

  }

  LineCurve3.prototype = Object.create(Curve.prototype);
  LineCurve3.prototype.constructor = LineCurve3;

  LineCurve3.prototype.isLineCurve3 = true;

  LineCurve3.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector3();

      if (t === 1) {

          point.copy(this.v2);

      } else {

          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);

      }

      return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve3.prototype.getPointAt = function(u, optionalTarget) {

      return this.getPoint(u, optionalTarget);

  };

  LineCurve3.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.v1.copy(source.v1);
      this.v2.copy(source.v2);

      return this;

  };

  LineCurve3.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();

      return data;

  };

  LineCurve3.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);

      return this;

  };

  function QuadraticBezierCurve(v0, v1, v2) {

      Curve.call(this);

      this.type = 'QuadraticBezierCurve';

      this.v0 = v0 || new Vector2();
      this.v1 = v1 || new Vector2();
      this.v2 = v2 || new Vector2();

  }

  QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

  QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector2();

      const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;

      point.set(
          QuadraticBezier(t, v0.x, v1.x, v2.x),
          QuadraticBezier(t, v0.y, v1.y, v2.y)
      );

      return point;

  };

  QuadraticBezierCurve.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);

      return this;

  };

  QuadraticBezierCurve.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();

      return data;

  };

  QuadraticBezierCurve.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);

      return this;

  };

  function QuadraticBezierCurve3(v0, v1, v2) {

      Curve.call(this);

      this.type = 'QuadraticBezierCurve3';

      this.v0 = v0 || new Vector3();
      this.v1 = v1 || new Vector3();
      this.v2 = v2 || new Vector3();

  }

  QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

  QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector3();

      const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;

      point.set(
          QuadraticBezier(t, v0.x, v1.x, v2.x),
          QuadraticBezier(t, v0.y, v1.y, v2.y),
          QuadraticBezier(t, v0.z, v1.z, v2.z)
      );

      return point;

  };

  QuadraticBezierCurve3.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);

      return this;

  };

  QuadraticBezierCurve3.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();

      return data;

  };

  QuadraticBezierCurve3.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);

      return this;

  };

  function SplineCurve(points /* array of Vector2 */ ) {

      Curve.call(this);

      this.type = 'SplineCurve';

      this.points = points || [];

  }

  SplineCurve.prototype = Object.create(Curve.prototype);
  SplineCurve.prototype.constructor = SplineCurve;

  SplineCurve.prototype.isSplineCurve = true;

  SplineCurve.prototype.getPoint = function(t, optionalTarget) {

      const point = optionalTarget || new Vector2();

      const points = this.points;
      const p = (points.length - 1) * t;

      const intPoint = Math.floor(p);
      const weight = p - intPoint;

      const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      const p1 = points[intPoint];
      const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

      point.set(
          CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
          CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
      );

      return point;

  };

  SplineCurve.prototype.copy = function(source) {

      Curve.prototype.copy.call(this, source);

      this.points = [];

      for (let i = 0, l = source.points.length; i < l; i++) {

          const point = source.points[i];

          this.points.push(point.clone());

      }

      return this;

  };

  SplineCurve.prototype.toJSON = function() {

      const data = Curve.prototype.toJSON.call(this);

      data.points = [];

      for (let i = 0, l = this.points.length; i < l; i++) {

          const point = this.points[i];
          data.points.push(point.toArray());

      }

      return data;

  };

  SplineCurve.prototype.fromJSON = function(json) {

      Curve.prototype.fromJSON.call(this, json);

      this.points = [];

      for (let i = 0, l = json.points.length; i < l; i++) {

          const point = json.points[i];
          this.points.push(new Vector2().fromArray(point));

      }

      return this;

  };

  var Curves = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      ArcCurve: ArcCurve,
      CatmullRomCurve3: CatmullRomCurve3,
      CubicBezierCurve: CubicBezierCurve,
      CubicBezierCurve3: CubicBezierCurve3,
      EllipseCurve: EllipseCurve,
      LineCurve: LineCurve,
      LineCurve3: LineCurve3,
      QuadraticBezierCurve: QuadraticBezierCurve,
      QuadraticBezierCurve3: QuadraticBezierCurve3,
      SplineCurve: SplineCurve
  });

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   **/

  /**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/

  function CurvePath() {

      Curve.call(this);

      this.type = 'CurvePath';

      this.curves = [];
      this.autoClose = false; // Automatically closes the path

  }

  CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {

      constructor: CurvePath,

      add: function(curve) {

          this.curves.push(curve);

      },

      closePath: function() {

          // Add a line curve if start and end of lines are not connected
          const startPoint = this.curves[0].getPoint(0);
          const endPoint = this.curves[this.curves.length - 1].getPoint(1);

          if (!startPoint.equals(endPoint)) {

              this.curves.push(new LineCurve(endPoint, startPoint));

          }

      },

      // To get accurate point with reference to
      // entire path distance at time t,
      // following has to be done:

      // 1. Length of each sub path have to be known
      // 2. Locate and identify type of curve
      // 3. Get t for the curve
      // 4. Return curve.getPointAt(t')

      getPoint: function(t) {

          const d = t * this.getLength();
          const curveLengths = this.getCurveLengths();
          let i = 0;

          // To think about boundaries points.

          while (i < curveLengths.length) {

              if (curveLengths[i] >= d) {

                  const diff = curveLengths[i] - d;
                  const curve = this.curves[i];

                  const segmentLength = curve.getLength();
                  const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

                  return curve.getPointAt(u);

              }

              i++;

          }

          return null;

          // loop where sum != 0, sum > d , sum+1 <d

      },

      // We cannot use the default THREE.Curve getPoint() with getLength() because in
      // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
      // getPoint() depends on getLength

      getLength: function() {

          const lens = this.getCurveLengths();
          return lens[lens.length - 1];

      },

      // cacheLengths must be recalculated.
      updateArcLengths: function() {

          this.needsUpdate = true;
          this.cacheLengths = null;
          this.getCurveLengths();

      },

      // Compute lengths and cache them
      // We cannot overwrite getLengths() because UtoT mapping uses it.

      getCurveLengths: function() {

          // We use cache values if curves and cache array are same length

          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {

              return this.cacheLengths;

          }

          // Get length of sub-curve
          // Push sums into cached array

          const lengths = [];
          let sums = 0;

          for (let i = 0, l = this.curves.length; i < l; i++) {

              sums += this.curves[i].getLength();
              lengths.push(sums);

          }

          this.cacheLengths = lengths;

          return lengths;

      },

      getSpacedPoints: function(divisions) {

          if (divisions === undefined) divisions = 40;

          const points = [];

          for (let i = 0; i <= divisions; i++) {

              points.push(this.getPoint(i / divisions));

          }

          if (this.autoClose) {

              points.push(points[0]);

          }

          return points;

      },

      getPoints: function(divisions) {

          divisions = divisions || 12;

          const points = [];
          let last;

          for (let i = 0, curves = this.curves; i < curves.length; i++) {

              const curve = curves[i];
              const resolution = (curve && curve.isEllipseCurve) ? divisions * 2 :
                  (curve && (curve.isLineCurve || curve.isLineCurve3)) ? 1 :
                  (curve && curve.isSplineCurve) ? divisions * curve.points.length :
                  divisions;

              const pts = curve.getPoints(resolution);

              for (let j = 0; j < pts.length; j++) {

                  const point = pts[j];

                  if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

                  points.push(point);
                  last = point;

              }

          }

          if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {

              points.push(points[0]);

          }

          return points;

      },

      copy: function(source) {

          Curve.prototype.copy.call(this, source);

          this.curves = [];

          for (let i = 0, l = source.curves.length; i < l; i++) {

              const curve = source.curves[i];

              this.curves.push(curve.clone());

          }

          this.autoClose = source.autoClose;

          return this;

      },

      toJSON: function() {

          const data = Curve.prototype.toJSON.call(this);

          data.autoClose = this.autoClose;
          data.curves = [];

          for (let i = 0, l = this.curves.length; i < l; i++) {

              const curve = this.curves[i];
              data.curves.push(curve.toJSON());

          }

          return data;

      },

      fromJSON: function(json) {

          Curve.prototype.fromJSON.call(this, json);

          this.autoClose = json.autoClose;
          this.curves = [];

          for (let i = 0, l = json.curves.length; i < l; i++) {

              const curve = json.curves[i];
              this.curves.push(new Curves[curve.type]().fromJSON(curve));

          }

          return this;

      }

  });

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Creates free form 2d path using series of points, lines or curves.
   **/

  function Path(points) {

      CurvePath.call(this);

      this.type = 'Path';

      this.currentPoint = new Vector2();

      if (points) {

          this.setFromPoints(points);

      }

  }

  Path.prototype = Object.assign(Object.create(CurvePath.prototype), {

      constructor: Path,

      setFromPoints: function(points) {

          this.moveTo(points[0].x, points[0].y);

          for (let i = 1, l = points.length; i < l; i++) {

              this.lineTo(points[i].x, points[i].y);

          }

          return this;

      },

      moveTo: function(x, y) {

          this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

          return this;

      },

      lineTo: function(x, y) {

          const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
          this.curves.push(curve);

          this.currentPoint.set(x, y);

          return this;

      },

      quadraticCurveTo: function(aCPx, aCPy, aX, aY) {

          const curve = new QuadraticBezierCurve(
              this.currentPoint.clone(),
              new Vector2(aCPx, aCPy),
              new Vector2(aX, aY)
          );

          this.curves.push(curve);

          this.currentPoint.set(aX, aY);

          return this;

      },

      bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

          const curve = new CubicBezierCurve(
              this.currentPoint.clone(),
              new Vector2(aCP1x, aCP1y),
              new Vector2(aCP2x, aCP2y),
              new Vector2(aX, aY)
          );

          this.curves.push(curve);

          this.currentPoint.set(aX, aY);

          return this;

      },

      splineThru: function(pts /*Array of Vector*/ ) {

          const npts = [this.currentPoint.clone()].concat(pts);

          const curve = new SplineCurve(npts);
          this.curves.push(curve);

          this.currentPoint.copy(pts[pts.length - 1]);

          return this;

      },

      arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;

          this.absarc(aX + x0, aY + y0, aRadius,
              aStartAngle, aEndAngle, aClockwise);

          return this;

      },

      absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

          this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

          return this;

      },

      ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;

          this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

          return this;

      },

      absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

          const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

          if (this.curves.length > 0) {

              // if a previous curve is present, attempt to join
              const firstPoint = curve.getPoint(0);

              if (!firstPoint.equals(this.currentPoint)) {

                  this.lineTo(firstPoint.x, firstPoint.y);

              }

          }

          this.curves.push(curve);

          const lastPoint = curve.getPoint(1);
          this.currentPoint.copy(lastPoint);

          return this;

      },

      copy: function(source) {

          CurvePath.prototype.copy.call(this, source);

          this.currentPoint.copy(source.currentPoint);

          return this;

      },

      toJSON: function() {

          const data = CurvePath.prototype.toJSON.call(this);

          data.currentPoint = this.currentPoint.toArray();

          return data;

      },

      fromJSON: function(json) {

          CurvePath.prototype.fromJSON.call(this, json);

          this.currentPoint.fromArray(json.currentPoint);

          return this;

      }

  });

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Defines a 2d shape plane using paths.
   **/

  // STEP 1 Create a path.
  // STEP 2 Turn path into shape.
  // STEP 3 ExtrudeGeometry takes in Shape/Shapes
  // STEP 3a - Extract points from each shape, turn to vertices
  // STEP 3b - Triangulate each shape, add faces.

  function Shape(points) {

      Path.call(this, points);

      this.uuid = MathUtils.generateUUID();

      this.type = 'Shape';

      this.holes = [];

  }

  Shape.prototype = Object.assign(Object.create(Path.prototype), {

      constructor: Shape,

      getPointsHoles: function(divisions) {

          const holesPts = [];

          for (let i = 0, l = this.holes.length; i < l; i++) {

              holesPts[i] = this.holes[i].getPoints(divisions);

          }

          return holesPts;

      },

      // get points of shape and holes (keypoints based on segments parameter)

      extractPoints: function(divisions) {

          return {

              shape: this.getPoints(divisions),
              holes: this.getPointsHoles(divisions)

          };

      },

      copy: function(source) {

          Path.prototype.copy.call(this, source);

          this.holes = [];

          for (let i = 0, l = source.holes.length; i < l; i++) {

              const hole = source.holes[i];

              this.holes.push(hole.clone());

          }

          return this;

      },

      toJSON: function() {

          const data = Path.prototype.toJSON.call(this);

          data.uuid = this.uuid;
          data.holes = [];

          for (let i = 0, l = this.holes.length; i < l; i++) {

              const hole = this.holes[i];
              data.holes.push(hole.toJSON());

          }

          return data;

      },

      fromJSON: function(json) {

          Path.prototype.fromJSON.call(this, json);

          this.uuid = json.uuid;
          this.holes = [];

          for (let i = 0, l = json.holes.length; i < l; i++) {

              const hole = json.holes[i];
              this.holes.push(new Path().fromJSON(hole));

          }

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Light(color, intensity) {

      Object3D.call(this);

      this.type = 'Light';

      this.color = new Color(color);
      this.intensity = intensity !== undefined ? intensity : 1;

      this.receiveShadow = undefined;

  }

  Light.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Light,

      isLight: true,

      copy: function(source) {

          Object3D.prototype.copy.call(this, source);

          this.color.copy(source.color);
          this.intensity = source.intensity;

          return this;

      },

      toJSON: function(meta) {

          const data = Object3D.prototype.toJSON.call(this, meta);

          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;

          if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();

          if (this.distance !== undefined) data.object.distance = this.distance;
          if (this.angle !== undefined) data.object.angle = this.angle;
          if (this.decay !== undefined) data.object.decay = this.decay;
          if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;

          if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();

          return data;

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function HemisphereLight(skyColor, groundColor, intensity) {

      Light.call(this, skyColor, intensity);

      this.type = 'HemisphereLight';

      this.castShadow = undefined;

      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();

      this.groundColor = new Color(groundColor);

  }

  HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {

      constructor: HemisphereLight,

      isHemisphereLight: true,

      copy: function(source) {

          Light.prototype.copy.call(this, source);

          this.groundColor.copy(source.groundColor);

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LightShadow(camera) {

      this.camera = camera;

      this.bias = 0;
      this.normalBias = 0;
      this.radius = 1;

      this.mapSize = new Vector2(512, 512);

      this.map = null;
      this.mapPass = null;
      this.matrix = new Matrix4();

      this.autoUpdate = true;
      this.needsUpdate = false;

      this._frustum = new Frustum();
      this._frameExtents = new Vector2(1, 1);

      this._viewportCount = 1;

      this._viewports = [

          new Vector4(0, 0, 1, 1)

      ];

  }

  Object.assign(LightShadow.prototype, {

      _projScreenMatrix: new Matrix4(),

      _lightPositionWorld: new Vector3(),

      _lookTarget: new Vector3(),

      getViewportCount: function() {

          return this._viewportCount;

      },

      getFrustum: function() {

          return this._frustum;

      },

      updateMatrices: function(light) {

          const shadowCamera = this.camera,
              shadowMatrix = this.matrix,
              projScreenMatrix = this._projScreenMatrix,
              lookTarget = this._lookTarget,
              lightPositionWorld = this._lightPositionWorld;

          lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(lightPositionWorld);

          lookTarget.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(lookTarget);
          shadowCamera.updateMatrixWorld();

          projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(projScreenMatrix);

          shadowMatrix.set(
              0.5, 0.0, 0.0, 0.5,
              0.0, 0.5, 0.0, 0.5,
              0.0, 0.0, 0.5, 0.5,
              0.0, 0.0, 0.0, 1.0
          );

          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);

      },

      getViewport: function(viewportIndex) {

          return this._viewports[viewportIndex];

      },

      getFrameExtents: function() {

          return this._frameExtents;

      },

      copy: function(source) {

          this.camera = source.camera.clone();

          this.bias = source.bias;
          this.radius = source.radius;

          this.mapSize.copy(source.mapSize);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      toJSON: function() {

          const object = {};

          if (this.bias !== 0) object.bias = this.bias;
          if (this.normalBias !== 0) object.normalBias = this.normalBias;
          if (this.radius !== 1) object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();

          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;

          return object;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function SpotLightShadow() {

      LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));

  }

  SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

      constructor: SpotLightShadow,

      isSpotLightShadow: true,

      updateMatrices: function(light) {

          const camera = this.camera;

          const fov = MathUtils.RAD2DEG * 2 * light.angle;
          const aspect = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;

          if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {

              camera.fov = fov;
              camera.aspect = aspect;
              camera.far = far;
              camera.updateProjectionMatrix();

          }

          LightShadow.prototype.updateMatrices.call(this, light);

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function SpotLight(color, intensity, distance, angle, penumbra, decay) {

      Light.call(this, color, intensity);

      this.type = 'SpotLight';

      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();

      this.target = new Object3D();

      Object.defineProperty(this, 'power', {
          get: function() {

              // intensity = power per solid angle.
              // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
              return this.intensity * Math.PI;

          },
          set: function(power) {

              // intensity = power per solid angle.
              // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
              this.intensity = power / Math.PI;

          }
      });

      this.distance = (distance !== undefined) ? distance : 0;
      this.angle = (angle !== undefined) ? angle : Math.PI / 3;
      this.penumbra = (penumbra !== undefined) ? penumbra : 0;
      this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.

      this.shadow = new SpotLightShadow();

  }

  SpotLight.prototype = Object.assign(Object.create(Light.prototype), {

      constructor: SpotLight,

      isSpotLight: true,

      copy: function(source) {

          Light.prototype.copy.call(this, source);

          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;

          this.target = source.target.clone();

          this.shadow = source.shadow.clone();

          return this;

      }

  });

  function PointLightShadow() {

      LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));

      this._frameExtents = new Vector2(4, 2);

      this._viewportCount = 6;

      this._viewports = [
          // These viewports map a cube-map onto a 2D texture with the
          // following orientation:
          //
          //  xzXZ
          //   y Y
          //
          // X - Positive x direction
          // x - Negative x direction
          // Y - Positive y direction
          // y - Negative y direction
          // Z - Positive z direction
          // z - Negative z direction

          // positive X
          new Vector4(2, 1, 1, 1),
          // negative X
          new Vector4(0, 1, 1, 1),
          // positive Z
          new Vector4(3, 1, 1, 1),
          // negative Z
          new Vector4(1, 1, 1, 1),
          // positive Y
          new Vector4(3, 0, 1, 1),
          // negative Y
          new Vector4(1, 0, 1, 1)
      ];

      this._cubeDirections = [
          new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
          new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
      ];

      this._cubeUps = [
          new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
          new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
      ];

  }

  PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

      constructor: PointLightShadow,

      isPointLightShadow: true,

      updateMatrices: function(light, viewportIndex) {

          if (viewportIndex === undefined) viewportIndex = 0;

          const camera = this.camera,
              shadowMatrix = this.matrix,
              lightPositionWorld = this._lightPositionWorld,
              lookTarget = this._lookTarget,
              projScreenMatrix = this._projScreenMatrix;

          lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(lightPositionWorld);

          lookTarget.copy(camera.position);
          lookTarget.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(lookTarget);
          camera.updateMatrixWorld();

          shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);

          projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(projScreenMatrix);

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */


  function PointLight(color, intensity, distance, decay) {

      Light.call(this, color, intensity);

      this.type = 'PointLight';

      Object.defineProperty(this, 'power', {
          get: function() {

              // intensity = power per solid angle.
              // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
              return this.intensity * 4 * Math.PI;

          },
          set: function(power) {

              // intensity = power per solid angle.
              // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
              this.intensity = power / (4 * Math.PI);

          }
      });

      this.distance = (distance !== undefined) ? distance : 0;
      this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.

      this.shadow = new PointLightShadow();

  }

  PointLight.prototype = Object.assign(Object.create(Light.prototype), {

      constructor: PointLight,

      isPointLight: true,

      copy: function(source) {

          Light.prototype.copy.call(this, source);

          this.distance = source.distance;
          this.decay = source.decay;

          this.shadow = source.shadow.clone();

          return this;

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author arose / http://github.com/arose
   */

  function OrthographicCamera(left, right, top, bottom, near, far) {

      Camera.call(this);

      this.type = 'OrthographicCamera';

      this.zoom = 1;
      this.view = null;

      this.left = (left !== undefined) ? left : -1;
      this.right = (right !== undefined) ? right : 1;
      this.top = (top !== undefined) ? top : 1;
      this.bottom = (bottom !== undefined) ? bottom : -1;

      this.near = (near !== undefined) ? near : 0.1;
      this.far = (far !== undefined) ? far : 2000;

      this.updateProjectionMatrix();

  }

  OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {

      constructor: OrthographicCamera,

      isOrthographicCamera: true,

      copy: function(source, recursive) {

          Camera.prototype.copy.call(this, source, recursive);

          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;

          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);

          return this;

      },

      setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {

          if (this.view === null) {

              this.view = {
                  enabled: true,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1
              };

          }

          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;

          this.updateProjectionMatrix();

      },

      clearViewOffset: function() {

          if (this.view !== null) {

              this.view.enabled = false;

          }

          this.updateProjectionMatrix();

      },

      updateProjectionMatrix: function() {

          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;

          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;

          if (this.view !== null && this.view.enabled) {

              const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
              const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;

              left += scaleW * this.view.offsetX;
              right = left + scaleW * this.view.width;
              top -= scaleH * this.view.offsetY;
              bottom = top - scaleH * this.view.height;

          }

          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);

          this.projectionMatrixInverse.getInverse(this.projectionMatrix);

      },

      toJSON: function(meta) {

          const data = Object3D.prototype.toJSON.call(this, meta);

          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;

          if (this.view !== null) data.object.view = Object.assign({}, this.view);

          return data;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectionalLightShadow() {

      LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));

  }

  DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

      constructor: DirectionalLightShadow,

      isDirectionalLightShadow: true,

      updateMatrices: function(light) {

          LightShadow.prototype.updateMatrices.call(this, light);

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function DirectionalLight(color, intensity) {

      Light.call(this, color, intensity);

      this.type = 'DirectionalLight';

      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();

      this.target = new Object3D();

      this.shadow = new DirectionalLightShadow();

  }

  DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {

      constructor: DirectionalLight,

      isDirectionalLight: true,

      copy: function(source) {

          Light.prototype.copy.call(this, source);

          this.target = source.target.clone();

          this.shadow = source.shadow.clone();

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AmbientLight(color, intensity) {

      Light.call(this, color, intensity);

      this.type = 'AmbientLight';

      this.castShadow = undefined;

  }

  AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {

      constructor: AmbientLight,

      isAmbientLight: true

  });

  /**
   * @author abelnation / http://github.com/abelnation
   */

  function RectAreaLight(color, intensity, width, height) {

      Light.call(this, color, intensity);

      this.type = 'RectAreaLight';

      this.width = (width !== undefined) ? width : 10;
      this.height = (height !== undefined) ? height : 10;

  }

  RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {

      constructor: RectAreaLight,

      isRectAreaLight: true,

      copy: function(source) {

          Light.prototype.copy.call(this, source);

          this.width = source.width;
          this.height = source.height;

          return this;

      },

      toJSON: function(meta) {

          const data = Light.prototype.toJSON.call(this, meta);

          data.object.width = this.width;
          data.object.height = this.height;

          return data;

      }

  });

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * Primary reference:
   *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
   *
   * Secondary reference:
   *   https://www.ppsloan.org/publications/StupidSH36.pdf
   */

  // 3-band SH defined by 9 coefficients

  function SphericalHarmonics3() {

      this.coefficients = [];

      for (let i = 0; i < 9; i++) {

          this.coefficients.push(new Vector3());

      }

  }

  Object.assign(SphericalHarmonics3.prototype, {

      isSphericalHarmonics3: true,

      set: function(coefficients) {

          for (let i = 0; i < 9; i++) {

              this.coefficients[i].copy(coefficients[i]);

          }

          return this;

      },

      zero: function() {

          for (let i = 0; i < 9; i++) {

              this.coefficients[i].set(0, 0, 0);

          }

          return this;

      },

      // get the radiance in the direction of the normal
      // target is a Vector3
      getAt: function(normal, target) {

          // normal is assumed to be unit length

          const x = normal.x,
              y = normal.y,
              z = normal.z;

          const coeff = this.coefficients;

          // band 0
          target.copy(coeff[0]).multiplyScalar(0.282095);

          // band 1
          target.addScaledVector(coeff[1], 0.488603 * y);
          target.addScaledVector(coeff[2], 0.488603 * z);
          target.addScaledVector(coeff[3], 0.488603 * x);

          // band 2
          target.addScaledVector(coeff[4], 1.092548 * (x * y));
          target.addScaledVector(coeff[5], 1.092548 * (y * z));
          target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
          target.addScaledVector(coeff[7], 1.092548 * (x * z));
          target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));

          return target;

      },

      // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
      // target is a Vector3
      // https://graphics.stanford.edu/papers/envmap/envmap.pdf
      getIrradianceAt: function(normal, target) {

          // normal is assumed to be unit length

          const x = normal.x,
              y = normal.y,
              z = normal.z;

          const coeff = this.coefficients;

          // band 0
          target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095

          // band 1
          target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603
          target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
          target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);

          // band 2
          target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548
          target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
          target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3
          target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
          target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

          return target;

      },

      add: function(sh) {

          for (let i = 0; i < 9; i++) {

              this.coefficients[i].add(sh.coefficients[i]);

          }

          return this;

      },

      addScaledSH: function(sh, s) {

          for (let i = 0; i < 9; i++) {

              this.coefficients[i].addScaledVector(sh.coefficients[i], s);

          }

          return this;

      },

      scale: function(s) {

          for (let i = 0; i < 9; i++) {

              this.coefficients[i].multiplyScalar(s);

          }

          return this;

      },

      lerp: function(sh, alpha) {

          for (let i = 0; i < 9; i++) {

              this.coefficients[i].lerp(sh.coefficients[i], alpha);

          }

          return this;

      },

      equals: function(sh) {

          for (let i = 0; i < 9; i++) {

              if (!this.coefficients[i].equals(sh.coefficients[i])) {

                  return false;

              }

          }

          return true;

      },

      copy: function(sh) {

          return this.set(sh.coefficients);

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      fromArray: function(array, offset) {

          if (offset === undefined) offset = 0;

          const coefficients = this.coefficients;

          for (let i = 0; i < 9; i++) {

              coefficients[i].fromArray(array, offset + (i * 3));

          }

          return this;

      },

      toArray: function(array, offset) {

          if (array === undefined) array = [];
          if (offset === undefined) offset = 0;

          const coefficients = this.coefficients;

          for (let i = 0; i < 9; i++) {

              coefficients[i].toArray(array, offset + (i * 3));

          }

          return array;

      }

  });

  Object.assign(SphericalHarmonics3, {

      // evaluate the basis functions
      // shBasis is an Array[ 9 ]
      getBasisAt: function(normal, shBasis) {

          // normal is assumed to be unit length

          const x = normal.x,
              y = normal.y,
              z = normal.z;

          // band 0
          shBasis[0] = 0.282095;

          // band 1
          shBasis[1] = 0.488603 * y;
          shBasis[2] = 0.488603 * z;
          shBasis[3] = 0.488603 * x;

          // band 2
          shBasis[4] = 1.092548 * x * y;
          shBasis[5] = 1.092548 * y * z;
          shBasis[6] = 0.315392 * (3 * z * z - 1);
          shBasis[7] = 1.092548 * x * z;
          shBasis[8] = 0.546274 * (x * x - y * y);

      }

  });

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * A LightProbe is a source of indirect-diffuse light
   */

  function LightProbe(sh, intensity) {

      Light.call(this, undefined, intensity);

      this.type = 'LightProbe';

      this.sh = (sh !== undefined) ? sh : new SphericalHarmonics3();

  }

  LightProbe.prototype = Object.assign(Object.create(Light.prototype), {

      constructor: LightProbe,

      isLightProbe: true,

      copy: function(source) {

          Light.prototype.copy.call(this, source);

          this.sh.copy(source.sh);

          return this;

      },

      fromJSON: function(json) {

          this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
          this.sh.fromArray(json.sh);

          return this;

      },

      toJSON: function(meta) {

          const data = Light.prototype.toJSON.call(this, meta);

          data.object.sh = this.sh.toArray();

          return data;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function MaterialLoader(manager) {

      Loader.call(this, manager);

      this.textures = {};

  }

  MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: MaterialLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.load(url, function(text) {

              try {

                  onLoad(scope.parse(JSON.parse(text)));

              } catch (e) {

                  if (onError) {

                      onError(e);

                  } else {

                      console.error(e);

                  }

                  scope.manager.itemError(url);

              }

          }, onProgress, onError);

      },

      parse: function(json) {

          const textures = this.textures;

          function getTexture(name) {

              if (textures[name] === undefined) {

                  console.warn('THREE.MaterialLoader: Undefined texture', name);

              }

              return textures[name];

          }

          const material = new Materials[json.type]();

          if (json.uuid !== undefined) material.uuid = json.uuid;
          if (json.name !== undefined) material.name = json.name;
          if (json.color !== undefined) material.color.setHex(json.color);
          if (json.roughness !== undefined) material.roughness = json.roughness;
          if (json.metalness !== undefined) material.metalness = json.metalness;
          if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
          if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
          if (json.specular !== undefined) material.specular.setHex(json.specular);
          if (json.shininess !== undefined) material.shininess = json.shininess;
          if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
          if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
          if (json.fog !== undefined) material.fog = json.fog;
          if (json.flatShading !== undefined) material.flatShading = json.flatShading;
          if (json.blending !== undefined) material.blending = json.blending;
          if (json.combine !== undefined) material.combine = json.combine;
          if (json.side !== undefined) material.side = json.side;
          if (json.opacity !== undefined) material.opacity = json.opacity;
          if (json.transparent !== undefined) material.transparent = json.transparent;
          if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
          if (json.depthTest !== undefined) material.depthTest = json.depthTest;
          if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
          if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;

          if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
          if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
          if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
          if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
          if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
          if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
          if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
          if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;

          if (json.wireframe !== undefined) material.wireframe = json.wireframe;
          if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
          if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
          if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;

          if (json.rotation !== undefined) material.rotation = json.rotation;

          if (json.linewidth !== 1) material.linewidth = json.linewidth;
          if (json.dashSize !== undefined) material.dashSize = json.dashSize;
          if (json.gapSize !== undefined) material.gapSize = json.gapSize;
          if (json.scale !== undefined) material.scale = json.scale;

          if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
          if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
          if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;

          if (json.skinning !== undefined) material.skinning = json.skinning;
          if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
          if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
          if (json.dithering !== undefined) material.dithering = json.dithering;

          if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;

          if (json.visible !== undefined) material.visible = json.visible;

          if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;

          if (json.userData !== undefined) material.userData = json.userData;

          if (json.vertexColors !== undefined) {

              if (typeof json.vertexColors === 'number') {

                  material.vertexColors = (json.vertexColors > 0) ? true : false;

              } else {

                  material.vertexColors = json.vertexColors;

              }

          }

          // Shader Material

          if (json.uniforms !== undefined) {

              for (const name in json.uniforms) {

                  const uniform = json.uniforms[name];

                  material.uniforms[name] = {};

                  switch (uniform.type) {

                      case 't':
                          material.uniforms[name].value = getTexture(uniform.value);
                          break;

                      case 'c':
                          material.uniforms[name].value = new Color().setHex(uniform.value);
                          break;

                      case 'v2':
                          material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                          break;

                      case 'v3':
                          material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                          break;

                      case 'v4':
                          material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                          break;

                      case 'm3':
                          material.uniforms[name].value = new Matrix3().fromArray(uniform.value);

                      case 'm4':
                          material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                          break;

                      default:
                          material.uniforms[name].value = uniform.value;

                  }

              }

          }

          if (json.defines !== undefined) material.defines = json.defines;
          if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
          if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

          if (json.extensions !== undefined) {

              for (const key in json.extensions) {

                  material.extensions[key] = json.extensions[key];

              }

          }

          // Deprecated

          if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading

          // for PointsMaterial

          if (json.size !== undefined) material.size = json.size;
          if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

          // maps

          if (json.map !== undefined) material.map = getTexture(json.map);
          if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);

          if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);

          if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
          if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;

          if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
          if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
          if (json.normalScale !== undefined) {

              let normalScale = json.normalScale;

              if (Array.isArray(normalScale) === false) {

                  // Blender exporter used to export a scalar. See #7459

                  normalScale = [normalScale, normalScale];

              }

              material.normalScale = new Vector2().fromArray(normalScale);

          }

          if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
          if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
          if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;

          if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
          if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);

          if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
          if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;

          if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);

          if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
          if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;

          if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
          if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;

          if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
          if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;

          if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
          if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;

          if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);

          if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
          if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
          if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
          if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);

          return material;

      },

      setTextures: function(value) {

          this.textures = value;
          return this;

      }

  });

  /**
   * @author Don McCurdy / https://www.donmccurdy.com
   */

  const LoaderUtils = {

      decodeText: function(array) {

          if (typeof TextDecoder !== 'undefined') {

              return new TextDecoder().decode(array);

          }

          // Avoid the String.fromCharCode.apply(null, array) shortcut, which
          // throws a "maximum call stack size exceeded" error for large arrays.

          let s = '';

          for (let i = 0, il = array.length; i < il; i++) {

              // Implicitly assumes little-endian.
              s += String.fromCharCode(array[i]);

          }

          try {

              // merges multi-byte utf-8 characters.

              return decodeURIComponent(escape(s));

          } catch (e) { // see #16358

              return s;

          }

      },

      extractUrlBase: function(url) {

          const index = url.lastIndexOf('/');

          if (index === -1) return './';

          return url.substr(0, index + 1);

      }

  };

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferGeometry() {

      BufferGeometry.call(this);

      this.type = 'InstancedBufferGeometry';
      this.instanceCount = Infinity;

  }

  InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {

      constructor: InstancedBufferGeometry,

      isInstancedBufferGeometry: true,

      copy: function(source) {

          BufferGeometry.prototype.copy.call(this, source);

          this.instanceCount = source.instanceCount;

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      toJSON: function() {

          const data = BufferGeometry.prototype.toJSON.call(this);

          data.instanceCount = this.instanceCount;

          data.isInstancedBufferGeometry = true;

          return data;

      }

  });

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {

      if (typeof(normalized) === 'number') {

          meshPerAttribute = normalized;

          normalized = false;

          console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');

      }

      BufferAttribute.call(this, array, itemSize, normalized);

      this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {

      constructor: InstancedBufferAttribute,

      isInstancedBufferAttribute: true,

      copy: function(source) {

          BufferAttribute.prototype.copy.call(this, source);

          this.meshPerAttribute = source.meshPerAttribute;

          return this;

      },

      toJSON: function() {

          const data = BufferAttribute.prototype.toJSON.call(this);

          data.meshPerAttribute = this.meshPerAttribute;

          data.isInstancedBufferAttribute = true;

          return data;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometryLoader(manager) {

      Loader.call(this, manager);

  }

  BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: BufferGeometryLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.load(url, function(text) {

              try {

                  onLoad(scope.parse(JSON.parse(text)));

              } catch (e) {

                  if (onError) {

                      onError(e);

                  } else {

                      console.error(e);

                  }

                  scope.manager.itemError(url);

              }

          }, onProgress, onError);

      },

      parse: function(json) {

          const interleavedBufferMap = {};
          const arrayBufferMap = {};

          function getInterleavedBuffer(json, uuid) {

              if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];

              const interleavedBuffers = json.interleavedBuffers;
              const interleavedBuffer = interleavedBuffers[uuid];

              const buffer = getArrayBuffer(json, interleavedBuffer.buffer);

              const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
              const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
              ib.uuid = interleavedBuffer.uuid;

              interleavedBufferMap[uuid] = ib;

              return ib;

          }

          function getArrayBuffer(json, uuid) {

              if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];

              const arrayBuffers = json.arrayBuffers;
              const arrayBuffer = arrayBuffers[uuid];

              const ab = new Uint32Array(arrayBuffer).buffer;

              arrayBufferMap[uuid] = ab;

              return ab;

          }

          const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

          const index = json.data.index;

          if (index !== undefined) {

              const typedArray = new TYPED_ARRAYS[index.type](index.array);
              geometry.setIndex(new BufferAttribute(typedArray, 1));

          }

          const attributes = json.data.attributes;

          for (const key in attributes) {

              const attribute = attributes[key];
              let bufferAttribute;

              if (attribute.isInterleavedBufferAttribute) {

                  const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);

              } else {

                  const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                  const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                  bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);

              }

              if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
              geometry.setAttribute(key, bufferAttribute);

          }

          const morphAttributes = json.data.morphAttributes;

          if (morphAttributes) {

              for (const key in morphAttributes) {

                  const attributeArray = morphAttributes[key];

                  const array = [];

                  for (let i = 0, il = attributeArray.length; i < il; i++) {

                      const attribute = attributeArray[i];
                      let bufferAttribute;

                      if (attribute.isInterleavedBufferAttribute) {

                          const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                          bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);

                      } else {

                          const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                          bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);

                      }

                      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                      array.push(bufferAttribute);

                  }

                  geometry.morphAttributes[key] = array;

              }

          }

          const morphTargetsRelative = json.data.morphTargetsRelative;

          if (morphTargetsRelative) {

              geometry.morphTargetsRelative = true;

          }

          const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

          if (groups !== undefined) {

              for (let i = 0, n = groups.length; i !== n; ++i) {

                  const group = groups[i];

                  geometry.addGroup(group.start, group.count, group.materialIndex);

              }

          }

          const boundingSphere = json.data.boundingSphere;

          if (boundingSphere !== undefined) {

              const center = new Vector3();

              if (boundingSphere.center !== undefined) {

                  center.fromArray(boundingSphere.center);

              }

              geometry.boundingSphere = new Sphere(center, boundingSphere.radius);

          }

          if (json.name) geometry.name = json.name;
          if (json.userData) geometry.userData = json.userData;

          return geometry;

      }

  });

  const TYPED_ARRAYS = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      // Workaround for IE11 pre KB2929437. See #11440
      Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array
  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ObjectLoader(manager) {

      Loader.call(this, manager);

  }

  ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: ObjectLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;

          const loader = new FileLoader(scope.manager);
          loader.setPath(this.path);
          loader.load(url, function(text) {

              let json = null;

              try {

                  json = JSON.parse(text);

              } catch (error) {

                  if (onError !== undefined) onError(error);

                  console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);

                  return;

              }

              const metadata = json.metadata;

              if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {

                  console.error('THREE.ObjectLoader: Can\'t load ' + url);
                  return;

              }

              scope.parse(json, onLoad);

          }, onProgress, onError);

      },

      parse: function(json, onLoad) {

          const shapes = this.parseShape(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);

          const images = this.parseImages(json.images, function() {

              if (onLoad !== undefined) onLoad(object);

          });

          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);

          const object = this.parseObject(json.object, geometries, materials);

          if (json.animations) {

              object.animations = this.parseAnimations(json.animations);

          }

          if (json.images === undefined || json.images.length === 0) {

              if (onLoad !== undefined) onLoad(object);

          }

          return object;

      },

      parseShape: function(json) {

          const shapes = {};

          if (json !== undefined) {

              for (let i = 0, l = json.length; i < l; i++) {

                  const shape = new Shape().fromJSON(json[i]);

                  shapes[shape.uuid] = shape;

              }

          }

          return shapes;

      },

      parseGeometries: function(json, shapes) {

          const geometries = {};
          let geometryShapes;

          if (json !== undefined) {

              const bufferGeometryLoader = new BufferGeometryLoader();

              for (let i = 0, l = json.length; i < l; i++) {

                  let geometry;
                  const data = json[i];

                  switch (data.type) {

                      case 'PlaneGeometry':
                      case 'PlaneBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.width,
                              data.height,
                              data.widthSegments,
                              data.heightSegments
                          );

                          break;

                      case 'BoxGeometry':
                      case 'BoxBufferGeometry':
                      case 'CubeGeometry': // backwards compatible

                          geometry = new Geometries[data.type](
                              data.width,
                              data.height,
                              data.depth,
                              data.widthSegments,
                              data.heightSegments,
                              data.depthSegments
                          );

                          break;

                      case 'CircleGeometry':
                      case 'CircleBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.radius,
                              data.segments,
                              data.thetaStart,
                              data.thetaLength
                          );

                          break;

                      case 'CylinderGeometry':
                      case 'CylinderBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.radiusTop,
                              data.radiusBottom,
                              data.height,
                              data.radialSegments,
                              data.heightSegments,
                              data.openEnded,
                              data.thetaStart,
                              data.thetaLength
                          );

                          break;

                      case 'ConeGeometry':
                      case 'ConeBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.radius,
                              data.height,
                              data.radialSegments,
                              data.heightSegments,
                              data.openEnded,
                              data.thetaStart,
                              data.thetaLength
                          );

                          break;

                      case 'SphereGeometry':
                      case 'SphereBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.radius,
                              data.widthSegments,
                              data.heightSegments,
                              data.phiStart,
                              data.phiLength,
                              data.thetaStart,
                              data.thetaLength
                          );

                          break;

                      case 'DodecahedronGeometry':
                      case 'DodecahedronBufferGeometry':
                      case 'IcosahedronGeometry':
                      case 'IcosahedronBufferGeometry':
                      case 'OctahedronGeometry':
                      case 'OctahedronBufferGeometry':
                      case 'TetrahedronGeometry':
                      case 'TetrahedronBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.radius,
                              data.detail
                          );

                          break;

                      case 'RingGeometry':
                      case 'RingBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.innerRadius,
                              data.outerRadius,
                              data.thetaSegments,
                              data.phiSegments,
                              data.thetaStart,
                              data.thetaLength
                          );

                          break;

                      case 'TorusGeometry':
                      case 'TorusBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.radius,
                              data.tube,
                              data.radialSegments,
                              data.tubularSegments,
                              data.arc
                          );

                          break;

                      case 'TorusKnotGeometry':
                      case 'TorusKnotBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.radius,
                              data.tube,
                              data.tubularSegments,
                              data.radialSegments,
                              data.p,
                              data.q
                          );

                          break;

                      case 'TubeGeometry':
                      case 'TubeBufferGeometry':

                          // This only works for built-in curves (e.g. CatmullRomCurve3).
                          // User defined curves or instances of CurvePath will not be deserialized.
                          geometry = new Geometries[data.type](
                              new Curves[data.path.type]().fromJSON(data.path),
                              data.tubularSegments,
                              data.radius,
                              data.radialSegments,
                              data.closed
                          );

                          break;

                      case 'LatheGeometry':
                      case 'LatheBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.points,
                              data.segments,
                              data.phiStart,
                              data.phiLength
                          );

                          break;

                      case 'PolyhedronGeometry':
                      case 'PolyhedronBufferGeometry':

                          geometry = new Geometries[data.type](
                              data.vertices,
                              data.indices,
                              data.radius,
                              data.details
                          );

                          break;

                      case 'ShapeGeometry':
                      case 'ShapeBufferGeometry':

                          geometryShapes = [];

                          for (let j = 0, jl = data.shapes.length; j < jl; j++) {

                              const shape = shapes[data.shapes[j]];

                              geometryShapes.push(shape);

                          }

                          geometry = new Geometries[data.type](
                              geometryShapes,
                              data.curveSegments
                          );

                          break;


                      case 'ExtrudeGeometry':
                      case 'ExtrudeBufferGeometry':

                          geometryShapes = [];

                          for (let j = 0, jl = data.shapes.length; j < jl; j++) {

                              const shape = shapes[data.shapes[j]];

                              geometryShapes.push(shape);

                          }

                          const extrudePath = data.options.extrudePath;

                          if (extrudePath !== undefined) {

                              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);

                          }

                          geometry = new Geometries[data.type](
                              geometryShapes,
                              data.options
                          );

                          break;

                      case 'BufferGeometry':
                      case 'InstancedBufferGeometry':

                          geometry = bufferGeometryLoader.parse(data);

                          break;

                      case 'Geometry':

                          console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');

                          break;

                      default:

                          console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');

                          continue;

                  }

                  geometry.uuid = data.uuid;

                  if (data.name !== undefined) geometry.name = data.name;
                  if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;

                  geometries[data.uuid] = geometry;

              }

          }

          return geometries;

      },

      parseMaterials: function(json, textures) {

          const cache = {}; // MultiMaterial
          const materials = {};

          if (json !== undefined) {

              const loader = new MaterialLoader();
              loader.setTextures(textures);

              for (let i = 0, l = json.length; i < l; i++) {

                  const data = json[i];

                  if (data.type === 'MultiMaterial') {

                      // Deprecated

                      const array = [];

                      for (let j = 0; j < data.materials.length; j++) {

                          const material = data.materials[j];

                          if (cache[material.uuid] === undefined) {

                              cache[material.uuid] = loader.parse(material);

                          }

                          array.push(cache[material.uuid]);

                      }

                      materials[data.uuid] = array;

                  } else {

                      if (cache[data.uuid] === undefined) {

                          cache[data.uuid] = loader.parse(data);

                      }

                      materials[data.uuid] = cache[data.uuid];

                  }

              }

          }

          return materials;

      },

      parseAnimations: function(json) {

          const animations = [];

          for (let i = 0; i < json.length; i++) {

              const data = json[i];

              const clip = AnimationClip.parse(data);

              if (data.uuid !== undefined) clip.uuid = data.uuid;

              animations.push(clip);

          }

          return animations;

      },

      parseImages: function(json, onLoad) {

          const scope = this;
          const images = {};

          let loader;

          function loadImage(url) {

              scope.manager.itemStart(url);

              return loader.load(url, function() {

                  scope.manager.itemEnd(url);

              }, undefined, function() {

                  scope.manager.itemError(url);
                  scope.manager.itemEnd(url);

              });

          }

          if (json !== undefined && json.length > 0) {

              const manager = new LoadingManager(onLoad);

              loader = new ImageLoader(manager);
              loader.setCrossOrigin(this.crossOrigin);

              for (let i = 0, il = json.length; i < il; i++) {

                  const image = json[i];
                  const url = image.url;

                  if (Array.isArray(url)) {

                      // load array of images e.g CubeTexture

                      images[image.uuid] = [];

                      for (let j = 0, jl = url.length; j < jl; j++) {

                          const currentUrl = url[j];

                          const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;

                          images[image.uuid].push(loadImage(path));

                      }

                  } else {

                      // load single image

                      const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;

                      images[image.uuid] = loadImage(path);

                  }

              }

          }

          return images;

      },

      parseTextures: function(json, images) {

          function parseConstant(value, type) {

              if (typeof value === 'number') return value;

              console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);

              return type[value];

          }

          const textures = {};

          if (json !== undefined) {

              for (let i = 0, l = json.length; i < l; i++) {

                  const data = json[i];

                  if (data.image === undefined) {

                      console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);

                  }

                  if (images[data.image] === undefined) {

                      console.warn('THREE.ObjectLoader: Undefined image', data.image);

                  }

                  let texture;

                  if (Array.isArray(images[data.image])) {

                      texture = new CubeTexture(images[data.image]);

                  } else {

                      texture = new Texture(images[data.image]);

                  }

                  texture.needsUpdate = true;

                  texture.uuid = data.uuid;

                  if (data.name !== undefined) texture.name = data.name;

                  if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);

                  if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                  if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                  if (data.center !== undefined) texture.center.fromArray(data.center);
                  if (data.rotation !== undefined) texture.rotation = data.rotation;

                  if (data.wrap !== undefined) {

                      texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                      texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);

                  }

                  if (data.format !== undefined) texture.format = data.format;
                  if (data.type !== undefined) texture.type = data.type;
                  if (data.encoding !== undefined) texture.encoding = data.encoding;

                  if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                  if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                  if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;

                  if (data.flipY !== undefined) texture.flipY = data.flipY;

                  if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
                  if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;

                  textures[data.uuid] = texture;

              }

          }

          return textures;

      },

      parseObject: function(data, geometries, materials) {

          let object;

          function getGeometry(name) {

              if (geometries[name] === undefined) {

                  console.warn('THREE.ObjectLoader: Undefined geometry', name);

              }

              return geometries[name];

          }

          function getMaterial(name) {

              if (name === undefined) return undefined;

              if (Array.isArray(name)) {

                  const array = [];

                  for (let i = 0, l = name.length; i < l; i++) {

                      const uuid = name[i];

                      if (materials[uuid] === undefined) {

                          console.warn('THREE.ObjectLoader: Undefined material', uuid);

                      }

                      array.push(materials[uuid]);

                  }

                  return array;

              }

              if (materials[name] === undefined) {

                  console.warn('THREE.ObjectLoader: Undefined material', name);

              }

              return materials[name];

          }

          let geometry, material;

          switch (data.type) {

              case 'Scene':

                  object = new Scene();

                  if (data.background !== undefined) {

                      if (Number.isInteger(data.background)) {

                          object.background = new Color(data.background);

                      }

                  }

                  if (data.fog !== undefined) {

                      if (data.fog.type === 'Fog') {

                          object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);

                      } else if (data.fog.type === 'FogExp2') {

                          object.fog = new FogExp2(data.fog.color, data.fog.density);

                      }

                  }

                  break;

              case 'PerspectiveCamera':

                  object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);

                  if (data.focus !== undefined) object.focus = data.focus;
                  if (data.zoom !== undefined) object.zoom = data.zoom;
                  if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                  if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                  if (data.view !== undefined) object.view = Object.assign({}, data.view);

                  break;

              case 'OrthographicCamera':

                  object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);

                  if (data.zoom !== undefined) object.zoom = data.zoom;
                  if (data.view !== undefined) object.view = Object.assign({}, data.view);

                  break;

              case 'AmbientLight':

                  object = new AmbientLight(data.color, data.intensity);

                  break;

              case 'DirectionalLight':

                  object = new DirectionalLight(data.color, data.intensity);

                  break;

              case 'PointLight':

                  object = new PointLight(data.color, data.intensity, data.distance, data.decay);

                  break;

              case 'RectAreaLight':

                  object = new RectAreaLight(data.color, data.intensity, data.width, data.height);

                  break;

              case 'SpotLight':

                  object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);

                  break;

              case 'HemisphereLight':

                  object = new HemisphereLight(data.color, data.groundColor, data.intensity);

                  break;

              case 'LightProbe':

                  object = new LightProbe().fromJSON(data);

                  break;

              case 'SkinnedMesh':

                  console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

              case 'Mesh':

                  geometry = getGeometry(data.geometry);
                  material = getMaterial(data.material);

                  object = new Mesh(geometry, material);

                  break;

              case 'InstancedMesh':

                  geometry = getGeometry(data.geometry);
                  material = getMaterial(data.material);
                  const count = data.count;
                  const instanceMatrix = data.instanceMatrix;

                  object = new InstancedMesh(geometry, material, count);
                  object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);

                  break;

              case 'LOD':

                  object = new LOD();

                  break;

              case 'Line':

                  object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);

                  break;

              case 'LineLoop':

                  object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));

                  break;

              case 'LineSegments':

                  object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));

                  break;

              case 'PointCloud':
              case 'Points':

                  object = new Points(getGeometry(data.geometry), getMaterial(data.material));

                  break;

              case 'Sprite':

                  object = new Sprite(getMaterial(data.material));

                  break;

              case 'Group':

                  object = new Group();

                  break;

              default:

                  object = new Object3D();

          }

          object.uuid = data.uuid;

          if (data.name !== undefined) object.name = data.name;

          if (data.matrix !== undefined) {

              object.matrix.fromArray(data.matrix);

              if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
              if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);

          } else {

              if (data.position !== undefined) object.position.fromArray(data.position);
              if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
              if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
              if (data.scale !== undefined) object.scale.fromArray(data.scale);

          }

          if (data.castShadow !== undefined) object.castShadow = data.castShadow;
          if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

          if (data.shadow) {

              if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
              if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
              if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
              if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
              if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);

          }

          if (data.visible !== undefined) object.visible = data.visible;
          if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
          if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
          if (data.userData !== undefined) object.userData = data.userData;
          if (data.layers !== undefined) object.layers.mask = data.layers;

          if (data.children !== undefined) {

              const children = data.children;

              for (let i = 0; i < children.length; i++) {

                  object.add(this.parseObject(children[i], geometries, materials));

              }

          }

          if (data.type === 'LOD') {

              if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;

              const levels = data.levels;

              for (let l = 0; l < levels.length; l++) {

                  const level = levels[l];
                  const child = object.getObjectByProperty('uuid', level.object);

                  if (child !== undefined) {

                      object.addLevel(child, level.distance);

                  }

              }

          }

          return object;

      }

  });

  const TEXTURE_MAPPING = {
      UVMapping: UVMapping,
      CubeReflectionMapping: CubeReflectionMapping,
      CubeRefractionMapping: CubeRefractionMapping,
      EquirectangularReflectionMapping: EquirectangularReflectionMapping,
      EquirectangularRefractionMapping: EquirectangularRefractionMapping,
      CubeUVReflectionMapping: CubeUVReflectionMapping,
      CubeUVRefractionMapping: CubeUVRefractionMapping
  };

  const TEXTURE_WRAPPING = {
      RepeatWrapping: RepeatWrapping,
      ClampToEdgeWrapping: ClampToEdgeWrapping,
      MirroredRepeatWrapping: MirroredRepeatWrapping
  };

  const TEXTURE_FILTER = {
      NearestFilter: NearestFilter,
      NearestMipmapNearestFilter: NearestMipmapNearestFilter,
      NearestMipmapLinearFilter: NearestMipmapLinearFilter,
      LinearFilter: LinearFilter,
      LinearMipmapNearestFilter: LinearMipmapNearestFilter,
      LinearMipmapLinearFilter: LinearMipmapLinearFilter
  };

  /**
   * @author thespite / http://clicktorelease.com/
   */


  function ImageBitmapLoader(manager) {

      if (typeof createImageBitmap === 'undefined') {

          console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');

      }

      if (typeof fetch === 'undefined') {

          console.warn('THREE.ImageBitmapLoader: fetch() not supported.');

      }

      Loader.call(this, manager);

      this.options = { premultiplyAlpha: 'none' };

  }

  ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: ImageBitmapLoader,

      isImageBitmapLoader: true,

      setOptions: function setOptions(options) {

          this.options = options;

          return this;

      },

      load: function(url, onLoad, onProgress, onError) {

          if (url === undefined) url = '';

          if (this.path !== undefined) url = this.path + url;

          url = this.manager.resolveURL(url);

          const scope = this;

          const cached = Cache.get(url);

          if (cached !== undefined) {

              scope.manager.itemStart(url);

              setTimeout(function() {

                  if (onLoad) onLoad(cached);

                  scope.manager.itemEnd(url);

              }, 0);

              return cached;

          }

          fetch(url).then(function(res) {

              return res.blob();

          }).then(function(blob) {

              return createImageBitmap(blob, scope.options);

          }).then(function(imageBitmap) {

              Cache.add(url, imageBitmap);

              if (onLoad) onLoad(imageBitmap);

              scope.manager.itemEnd(url);

          }).catch(function(e) {

              if (onError) onError(e);

              scope.manager.itemError(url);
              scope.manager.itemEnd(url);

          });

          scope.manager.itemStart(url);

      }

  });

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
   **/

  function ShapePath() {

      this.type = 'ShapePath';

      this.color = new Color();

      this.subPaths = [];
      this.currentPath = null;

  }

  Object.assign(ShapePath.prototype, {

      moveTo: function(x, y) {

          this.currentPath = new Path();
          this.subPaths.push(this.currentPath);
          this.currentPath.moveTo(x, y);

          return this;

      },

      lineTo: function(x, y) {

          this.currentPath.lineTo(x, y);

          return this;

      },

      quadraticCurveTo: function(aCPx, aCPy, aX, aY) {

          this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);

          return this;

      },

      bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

          this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);

          return this;

      },

      splineThru: function(pts) {

          this.currentPath.splineThru(pts);

          return this;

      },

      toShapes: function(isCCW, noHoles) {

          function toShapesNoHoles(inSubpaths) {

              const shapes = [];

              for (let i = 0, l = inSubpaths.length; i < l; i++) {

                  const tmpPath = inSubpaths[i];

                  const tmpShape = new Shape();
                  tmpShape.curves = tmpPath.curves;

                  shapes.push(tmpShape);

              }

              return shapes;

          }

          function isPointInsidePolygon(inPt, inPolygon) {

              const polyLen = inPolygon.length;

              // inPt on polygon contour => immediate success    or
              // toggling of inside/outside at every single! intersection point of an edge
              //  with the horizontal line through inPt, left of inPt
              //  not counting lowerY endpoints of edges and whole edges on that line
              let inside = false;
              for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {

                  let edgeLowPt = inPolygon[p];
                  let edgeHighPt = inPolygon[q];

                  let edgeDx = edgeHighPt.x - edgeLowPt.x;
                  let edgeDy = edgeHighPt.y - edgeLowPt.y;

                  if (Math.abs(edgeDy) > Number.EPSILON) {

                      // not parallel
                      if (edgeDy < 0) {

                          edgeLowPt = inPolygon[q];
                          edgeDx = -edgeDx;
                          edgeHighPt = inPolygon[p];
                          edgeDy = -edgeDy;

                      }

                      if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue;

                      if (inPt.y === edgeLowPt.y) {

                          if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                          // continue;				// no intersection or edgeLowPt => doesn't count !!!

                      } else {

                          const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                          if (perpEdge === 0) return true; // inPt is on contour ?
                          if (perpEdge < 0) continue;
                          inside = !inside; // true intersection left of inPt

                      }

                  } else {

                      // parallel or collinear
                      if (inPt.y !== edgeLowPt.y) continue; // parallel
                      // edge lies on the same horizontal line as inPt
                      if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                          ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return true; // inPt: Point on contour !
                      // continue;

                  }

              }

              return inside;

          }

          const isClockWise = ShapeUtils.isClockWise;

          const subPaths = this.subPaths;
          if (subPaths.length === 0) return [];

          if (noHoles === true) return toShapesNoHoles(subPaths);


          let solid, tmpPath, tmpShape, shapes = [];

          if (subPaths.length === 1) {

              tmpPath = subPaths[0];
              tmpShape = new Shape();
              tmpShape.curves = tmpPath.curves;
              shapes.push(tmpShape);
              return shapes;

          }

          let holesFirst = !isClockWise(subPaths[0].getPoints());
          holesFirst = isCCW ? !holesFirst : holesFirst;

          // console.log("Holes first", holesFirst);

          const betterShapeHoles = [];
          const newShapes = [];
          let newShapeHoles = [];
          let mainIdx = 0;
          let tmpPoints;

          newShapes[mainIdx] = undefined;
          newShapeHoles[mainIdx] = [];

          for (let i = 0, l = subPaths.length; i < l; i++) {

              tmpPath = subPaths[i];
              tmpPoints = tmpPath.getPoints();
              solid = isClockWise(tmpPoints);
              solid = isCCW ? !solid : solid;

              if (solid) {

                  if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++;

                  newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                  newShapes[mainIdx].s.curves = tmpPath.curves;

                  if (holesFirst) mainIdx++;
                  newShapeHoles[mainIdx] = [];

                  //console.log('cw', i);

              } else {

                  newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });

                  //console.log('ccw', i);

              }

          }

          // only Holes? -> probably all Shapes with wrong orientation
          if (!newShapes[0]) return toShapesNoHoles(subPaths);


          if (newShapes.length > 1) {

              let ambiguous = false;
              const toChange = [];

              for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

                  betterShapeHoles[sIdx] = [];

              }

              for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

                  const sho = newShapeHoles[sIdx];

                  for (let hIdx = 0; hIdx < sho.length; hIdx++) {

                      const ho = sho[hIdx];
                      let hole_unassigned = true;

                      for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {

                          if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {

                              if (sIdx !== s2Idx) toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                              if (hole_unassigned) {

                                  hole_unassigned = false;
                                  betterShapeHoles[s2Idx].push(ho);

                              } else {

                                  ambiguous = true;

                              }

                          }

                      }

                      if (hole_unassigned) {

                          betterShapeHoles[sIdx].push(ho);

                      }

                  }

              }
              // console.log("ambiguous: ", ambiguous);

              if (toChange.length > 0) {

                  // console.log("to change: ", toChange);
                  if (!ambiguous) newShapeHoles = betterShapeHoles;

              }

          }

          let tmpHoles;

          for (let i = 0, il = newShapes.length; i < il; i++) {

              tmpShape = newShapes[i].s;
              shapes.push(tmpShape);
              tmpHoles = newShapeHoles[i];

              for (let j = 0, jl = tmpHoles.length; j < jl; j++) {

                  tmpShape.holes.push(tmpHoles[j].h);

              }

          }

          //console.log("shape", shapes);

          return shapes;

      }

  });

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author mrdoob / http://mrdoob.com/
   */


  function Font(data) {

      this.type = 'Font';

      this.data = data;

  }

  Object.assign(Font.prototype, {

      isFont: true,

      generateShapes: function(text, size) {

          if (size === undefined) size = 100;

          const shapes = [];
          const paths = createPaths(text, size, this.data);

          for (let p = 0, pl = paths.length; p < pl; p++) {

              Array.prototype.push.apply(shapes, paths[p].toShapes());

          }

          return shapes;

      }

  });

  function createPaths(text, size, data) {

      const chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988
      const scale = size / data.resolution;
      const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

      const paths = [];

      let offsetX = 0,
          offsetY = 0;

      for (let i = 0; i < chars.length; i++) {

          const char = chars[i];

          if (char === '\n') {

              offsetX = 0;
              offsetY -= line_height;

          } else {

              const ret = createPath(char, scale, offsetX, offsetY, data);
              offsetX += ret.offsetX;
              paths.push(ret.path);

          }

      }

      return paths;

  }

  function createPath(char, scale, offsetX, offsetY, data) {

      const glyph = data.glyphs[char] || data.glyphs['?'];

      if (!glyph) {

          console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');

          return;

      }

      const path = new ShapePath();

      let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

      if (glyph.o) {

          const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

          for (let i = 0, l = outline.length; i < l;) {

              const action = outline[i++];

              switch (action) {

                  case 'm': // moveTo

                      x = outline[i++] * scale + offsetX;
                      y = outline[i++] * scale + offsetY;

                      path.moveTo(x, y);

                      break;

                  case 'l': // lineTo

                      x = outline[i++] * scale + offsetX;
                      y = outline[i++] * scale + offsetY;

                      path.lineTo(x, y);

                      break;

                  case 'q': // quadraticCurveTo

                      cpx = outline[i++] * scale + offsetX;
                      cpy = outline[i++] * scale + offsetY;
                      cpx1 = outline[i++] * scale + offsetX;
                      cpy1 = outline[i++] * scale + offsetY;

                      path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

                      break;

                  case 'b': // bezierCurveTo

                      cpx = outline[i++] * scale + offsetX;
                      cpy = outline[i++] * scale + offsetY;
                      cpx1 = outline[i++] * scale + offsetX;
                      cpy1 = outline[i++] * scale + offsetY;
                      cpx2 = outline[i++] * scale + offsetX;
                      cpy2 = outline[i++] * scale + offsetY;

                      path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);

                      break;

              }

          }

      }

      return { offsetX: glyph.ha * scale, path: path };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FontLoader(manager) {

      Loader.call(this, manager);

  }

  FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: FontLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.load(url, function(text) {

              let json;

              try {

                  json = JSON.parse(text);

              } catch (e) {

                  console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                  json = JSON.parse(text.substring(65, text.length - 2));

              }

              const font = scope.parse(json);

              if (onLoad) onLoad(font);

          }, onProgress, onError);

      },

      parse: function(json) {

          return new Font(json);

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  let _context;

  const AudioContext = {

      getContext: function() {

          if (_context === undefined) {

              _context = new(window.AudioContext || window.webkitAudioContext)();

          }

          return _context;

      },

      setContext: function(value) {

          _context = value;

      }

  };

  /**
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function AudioLoader(manager) {

      Loader.call(this, manager);

  }

  AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {

      constructor: AudioLoader,

      load: function(url, onLoad, onProgress, onError) {

          const scope = this;

          const loader = new FileLoader(scope.manager);
          loader.setResponseType('arraybuffer');
          loader.setPath(scope.path);
          loader.load(url, function(buffer) {

              try {

                  // Create a copy of the buffer. The `decodeAudioData` method
                  // detaches the buffer when complete, preventing reuse.
                  const bufferCopy = buffer.slice(0);

                  const context = AudioContext.getContext();
                  context.decodeAudioData(bufferCopy, function(audioBuffer) {

                      onLoad(audioBuffer);

                  });

              } catch (e) {

                  if (onError) {

                      onError(e);

                  } else {

                      console.error(e);

                  }

                  scope.manager.itemError(url);

              }

          }, onProgress, onError);

      }

  });

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function HemisphereLightProbe(skyColor, groundColor, intensity) {

      LightProbe.call(this, undefined, intensity);

      const color1 = new Color().set(skyColor);
      const color2 = new Color().set(groundColor);

      const sky = new Vector3(color1.r, color1.g, color1.b);
      const ground = new Vector3(color2.r, color2.g, color2.b);

      // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
      const c0 = Math.sqrt(Math.PI);
      const c1 = c0 * Math.sqrt(0.75);

      this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
      this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);

  }

  HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {

      constructor: HemisphereLightProbe,

      isHemisphereLightProbe: true,

      copy: function(source) { // modifying colors not currently supported

          LightProbe.prototype.copy.call(this, source);

          return this;

      },

      toJSON: function(meta) {

          const data = LightProbe.prototype.toJSON.call(this, meta);

          // data.sh = this.sh.toArray(); // todo

          return data;

      }

  });

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function AmbientLightProbe(color, intensity) {

      LightProbe.call(this, undefined, intensity);

      const color1 = new Color().set(color);

      // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
      this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));

  }

  AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {

      constructor: AmbientLightProbe,

      isAmbientLightProbe: true,

      copy: function(source) { // modifying color not currently supported

          LightProbe.prototype.copy.call(this, source);

          return this;

      },

      toJSON: function(meta) {

          const data = LightProbe.prototype.toJSON.call(this, meta);

          // data.sh = this.sh.toArray(); // todo

          return data;

      }

  });

  const _eyeRight = new Matrix4();
  const _eyeLeft = new Matrix4();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function StereoCamera() {

      this.type = 'StereoCamera';

      this.aspect = 1;

      this.eyeSep = 0.064;

      this.cameraL = new PerspectiveCamera();
      this.cameraL.layers.enable(1);
      this.cameraL.matrixAutoUpdate = false;

      this.cameraR = new PerspectiveCamera();
      this.cameraR.layers.enable(2);
      this.cameraR.matrixAutoUpdate = false;

      this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null
      };

  }

  Object.assign(StereoCamera.prototype, {

      update: function(camera) {

          const cache = this._cache;

          const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
              cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
              cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

          if (needsUpdate) {

              cache.focus = camera.focus;
              cache.fov = camera.fov;
              cache.aspect = camera.aspect * this.aspect;
              cache.near = camera.near;
              cache.far = camera.far;
              cache.zoom = camera.zoom;
              cache.eyeSep = this.eyeSep;

              // Off-axis stereoscopic effect based on
              // http://paulbourke.net/stereographics/stereorender/

              const projectionMatrix = camera.projectionMatrix.clone();
              const eyeSepHalf = cache.eyeSep / 2;
              const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
              const ymax = (cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5)) / cache.zoom;
              let xmin, xmax;

              // translate xOffset

              _eyeLeft.elements[12] = -eyeSepHalf;
              _eyeRight.elements[12] = eyeSepHalf;

              // for left eye

              xmin = -ymax * cache.aspect + eyeSepOnProjection;
              xmax = ymax * cache.aspect + eyeSepOnProjection;

              projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
              projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

              this.cameraL.projectionMatrix.copy(projectionMatrix);

              // for right eye

              xmin = -ymax * cache.aspect - eyeSepOnProjection;
              xmax = ymax * cache.aspect - eyeSepOnProjection;

              projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
              projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

              this.cameraR.projectionMatrix.copy(projectionMatrix);

          }

          this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
          this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Clock(autoStart) {

      this.autoStart = (autoStart !== undefined) ? autoStart : true;

      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;

      this.running = false;

  }

  Object.assign(Clock.prototype, {

      start: function() {

          this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;

      },

      stop: function() {

          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;

      },

      getElapsedTime: function() {

          this.getDelta();
          return this.elapsedTime;

      },

      getDelta: function() {

          let diff = 0;

          if (this.autoStart && !this.running) {

              this.start();
              return 0;

          }

          if (this.running) {

              const newTime = (typeof performance === 'undefined' ? Date : performance).now();

              diff = (newTime - this.oldTime) / 1000;
              this.oldTime = newTime;

              this.elapsedTime += diff;

          }

          return diff;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const _position$2 = new Vector3();
  const _quaternion$3 = new Quaternion();
  const _scale$1 = new Vector3();
  const _orientation = new Vector3();

  function AudioListener() {

      Object3D.call(this);

      this.type = 'AudioListener';

      this.context = AudioContext.getContext();

      this.gain = this.context.createGain();
      this.gain.connect(this.context.destination);

      this.filter = null;

      this.timeDelta = 0;

      // private

      this._clock = new Clock();

  }

  AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: AudioListener,

      getInput: function() {

          return this.gain;

      },

      removeFilter: function() {

          if (this.filter !== null) {

              this.gain.disconnect(this.filter);
              this.filter.disconnect(this.context.destination);
              this.gain.connect(this.context.destination);
              this.filter = null;

          }

          return this;

      },

      getFilter: function() {

          return this.filter;

      },

      setFilter: function(value) {

          if (this.filter !== null) {

              this.gain.disconnect(this.filter);
              this.filter.disconnect(this.context.destination);

          } else {

              this.gain.disconnect(this.context.destination);

          }

          this.filter = value;
          this.gain.connect(this.filter);
          this.filter.connect(this.context.destination);

          return this;

      },

      getMasterVolume: function() {

          return this.gain.gain.value;

      },

      setMasterVolume: function(value) {

          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);

          return this;

      },

      updateMatrixWorld: function(force) {

          Object3D.prototype.updateMatrixWorld.call(this, force);

          const listener = this.context.listener;
          const up = this.up;

          this.timeDelta = this._clock.getDelta();

          this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);

          _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);

          if (listener.positionX) {

              // code path for Chrome (see #14393)

              const endTime = this.context.currentTime + this.timeDelta;

              listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
              listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
              listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
              listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
              listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
              listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
              listener.upX.linearRampToValueAtTime(up.x, endTime);
              listener.upY.linearRampToValueAtTime(up.y, endTime);
              listener.upZ.linearRampToValueAtTime(up.z, endTime);

          } else {

              listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
              listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);

          }

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function Audio(listener) {

      Object3D.call(this);

      this.type = 'Audio';

      this.listener = listener;
      this.context = listener.context;

      this.gain = this.context.createGain();
      this.gain.connect(listener.getInput());

      this.autoplay = false;

      this.buffer = null;
      this.detune = 0;
      this.loop = false;
      this.loopStart = 0;
      this.loopEnd = 0;
      this.offset = 0;
      this.duration = undefined;
      this.playbackRate = 1;
      this.isPlaying = false;
      this.hasPlaybackControl = true;
      this.sourceType = 'empty';

      this._startedAt = 0;
      this._progress = 0;

      this.filters = [];

  }

  Audio.prototype = Object.assign(Object.create(Object3D.prototype), {

      constructor: Audio,

      getOutput: function() {

          return this.gain;

      },

      setNodeSource: function(audioNode) {

          this.hasPlaybackControl = false;
          this.sourceType = 'audioNode';
          this.source = audioNode;
          this.connect();

          return this;

      },

      setMediaElementSource: function(mediaElement) {

          this.hasPlaybackControl = false;
          this.sourceType = 'mediaNode';
          this.source = this.context.createMediaElementSource(mediaElement);
          this.connect();

          return this;

      },

      setMediaStreamSource: function(mediaStream) {

          this.hasPlaybackControl = false;
          this.sourceType = 'mediaStreamNode';
          this.source = this.context.createMediaStreamSource(mediaStream);
          this.connect();

          return this;

      },

      setBuffer: function(audioBuffer) {

          this.buffer = audioBuffer;
          this.sourceType = 'buffer';

          if (this.autoplay) this.play();

          return this;

      },

      play: function(delay) {

          if (delay === undefined) delay = 0;

          if (this.isPlaying === true) {

              console.warn('THREE.Audio: Audio is already playing.');
              return;

          }

          if (this.hasPlaybackControl === false) {

              console.warn('THREE.Audio: this Audio has no playback control.');
              return;

          }

          this._startedAt = this.context.currentTime + delay;

          const source = this.context.createBufferSource();
          source.buffer = this.buffer;
          source.loop = this.loop;
          source.loopStart = this.loopStart;
          source.loopEnd = this.loopEnd;
          source.onended = this.onEnded.bind(this);
          source.start(this._startedAt, this._progress + this.offset, this.duration);

          this.isPlaying = true;

          this.source = source;

          this.setDetune(this.detune);
          this.setPlaybackRate(this.playbackRate);

          return this.connect();

      },

      pause: function() {

          if (this.hasPlaybackControl === false) {

              console.warn('THREE.Audio: this Audio has no playback control.');
              return;

          }

          if (this.isPlaying === true) {

              // update current progress

              this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

              if (this.loop === true) {

                  // ensure _progress does not exceed duration with looped audios

                  this._progress = this._progress % (this.duration || this.buffer.duration);

              }

              this.source.stop();
              this.source.onended = null;

              this.isPlaying = false;

          }

          return this;

      },

      stop: function() {

          if (this.hasPlaybackControl === false) {

              console.warn('THREE.Audio: this Audio has no playback control.');
              return;

          }

          this._progress = 0;

          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;

          return this;

      },

      connect: function() {

          if (this.filters.length > 0) {

              this.source.connect(this.filters[0]);

              for (let i = 1, l = this.filters.length; i < l; i++) {

                  this.filters[i - 1].connect(this.filters[i]);

              }

              this.filters[this.filters.length - 1].connect(this.getOutput());

          } else {

              this.source.connect(this.getOutput());

          }

          return this;

      },

      disconnect: function() {

          if (this.filters.length > 0) {

              this.source.disconnect(this.filters[0]);

              for (let i = 1, l = this.filters.length; i < l; i++) {

                  this.filters[i - 1].disconnect(this.filters[i]);

              }

              this.filters[this.filters.length - 1].disconnect(this.getOutput());

          } else {

              this.source.disconnect(this.getOutput());

          }

          return this;

      },

      getFilters: function() {

          return this.filters;

      },

      setFilters: function(value) {

          if (!value) value = [];

          if (this.isPlaying === true) {

              this.disconnect();
              this.filters = value;
              this.connect();

          } else {

              this.filters = value;

          }

          return this;

      },

      setDetune: function(value) {

          this.detune = value;

          if (this.source.detune === undefined) return; // only set detune when available

          if (this.isPlaying === true) {

              this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);

          }

          return this;

      },

      getDetune: function() {

          return this.detune;

      },

      getFilter: function() {

          return this.getFilters()[0];

      },

      setFilter: function(filter) {

          return this.setFilters(filter ? [filter] : []);

      },

      setPlaybackRate: function(value) {

          if (this.hasPlaybackControl === false) {

              console.warn('THREE.Audio: this Audio has no playback control.');
              return;

          }

          this.playbackRate = value;

          if (this.isPlaying === true) {

              this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);

          }

          return this;

      },

      getPlaybackRate: function() {

          return this.playbackRate;

      },

      onEnded: function() {

          this.isPlaying = false;

      },

      getLoop: function() {

          if (this.hasPlaybackControl === false) {

              console.warn('THREE.Audio: this Audio has no playback control.');
              return false;

          }

          return this.loop;

      },

      setLoop: function(value) {

          if (this.hasPlaybackControl === false) {

              console.warn('THREE.Audio: this Audio has no playback control.');
              return;

          }

          this.loop = value;

          if (this.isPlaying === true) {

              this.source.loop = this.loop;

          }

          return this;

      },

      setLoopStart: function(value) {

          this.loopStart = value;

          return this;

      },

      setLoopEnd: function(value) {

          this.loopEnd = value;

          return this;

      },

      getVolume: function() {

          return this.gain.gain.value;

      },

      setVolume: function(value) {

          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);

          return this;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const _position$3 = new Vector3();
  const _quaternion$4 = new Quaternion();
  const _scale$2 = new Vector3();
  const _orientation$1 = new Vector3();

  function PositionalAudio(listener) {

      Audio.call(this, listener);

      this.panner = this.context.createPanner();
      this.panner.panningModel = 'HRTF';
      this.panner.connect(this.gain);

  }

  PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {

      constructor: PositionalAudio,

      getOutput: function() {

          return this.panner;

      },

      getRefDistance: function() {

          return this.panner.refDistance;

      },

      setRefDistance: function(value) {

          this.panner.refDistance = value;

          return this;

      },

      getRolloffFactor: function() {

          return this.panner.rolloffFactor;

      },

      setRolloffFactor: function(value) {

          this.panner.rolloffFactor = value;

          return this;

      },

      getDistanceModel: function() {

          return this.panner.distanceModel;

      },

      setDistanceModel: function(value) {

          this.panner.distanceModel = value;

          return this;

      },

      getMaxDistance: function() {

          return this.panner.maxDistance;

      },

      setMaxDistance: function(value) {

          this.panner.maxDistance = value;

          return this;

      },

      setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {

          this.panner.coneInnerAngle = coneInnerAngle;
          this.panner.coneOuterAngle = coneOuterAngle;
          this.panner.coneOuterGain = coneOuterGain;

          return this;

      },

      updateMatrixWorld: function(force) {

          Object3D.prototype.updateMatrixWorld.call(this, force);

          if (this.hasPlaybackControl === true && this.isPlaying === false) return;

          this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);

          _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);

          const panner = this.panner;

          if (panner.positionX) {

              // code path for Chrome and Firefox (see #14393)

              const endTime = this.context.currentTime + this.listener.timeDelta;

              panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
              panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
              panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
              panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
              panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
              panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);

          } else {

              panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
              panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);

          }

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AudioAnalyser(audio, fftSize) {

      this.analyser = audio.context.createAnalyser();
      this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

      this.data = new Uint8Array(this.analyser.frequencyBinCount);

      audio.getOutput().connect(this.analyser);

  }

  Object.assign(AudioAnalyser.prototype, {

      getFrequencyData: function() {

          this.analyser.getByteFrequencyData(this.data);

          return this.data;

      },

      getAverageFrequency: function() {

          let value = 0;
          const data = this.getFrequencyData();

          for (let i = 0; i < data.length; i++) {

              value += data[i];

          }

          return value / data.length;

      }

  });

  /**
   *
   * Buffered scene graph property that allows weighted accumulation.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function PropertyMixer(binding, typeName, valueSize) {

      this.binding = binding;
      this.valueSize = valueSize;

      let mixFunction,
          mixFunctionAdditive,
          setIdentity;

      // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
      //
      // interpolators can use .buffer as their .result
      // the data then goes to 'incoming'
      //
      // 'accu0' and 'accu1' are used frame-interleaved for
      // the cumulative result and are compared to detect
      // changes
      //
      // 'orig' stores the original state of the property
      //
      // 'add' is used for additive cumulative results
      //
      // 'work' is optional and is only present for quaternion types. It is used
      // to store intermediate quaternion multiplication results

      switch (typeName) {

          case 'quaternion':
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;

              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;

          case 'string':
          case 'bool':
              mixFunction = this._select;

              // Use the regular mix function and for additive on these types,
              // additive is not relevant for non-numeric types
              mixFunctionAdditive = this._select;

              setIdentity = this._setAdditiveIdentityOther;

              this.buffer = new Array(valueSize * 5);
              break;

          default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;

              this.buffer = new Float64Array(valueSize * 5);

      }

      this._mixBufferRegion = mixFunction;
      this._mixBufferRegionAdditive = mixFunctionAdditive;
      this._setIdentity = setIdentity;
      this._origIndex = 3;
      this._addIndex = 4;

      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;

      this.useCount = 0;
      this.referenceCount = 0;

  }

  Object.assign(PropertyMixer.prototype, {

      // accumulate data in the 'incoming' region into 'accu<i>'
      accumulate: function(accuIndex, weight) {

          // note: happily accumulating nothing when weight = 0, the caller knows
          // the weight and shouldn't have made the call in the first place

          const buffer = this.buffer,
              stride = this.valueSize,
              offset = accuIndex * stride + stride;

          let currentWeight = this.cumulativeWeight;

          if (currentWeight === 0) {

              // accuN := incoming * weight

              for (let i = 0; i !== stride; ++i) {

                  buffer[offset + i] = buffer[i];

              }

              currentWeight = weight;

          } else {

              // accuN := accuN + incoming * weight

              currentWeight += weight;
              const mix = weight / currentWeight;
              this._mixBufferRegion(buffer, offset, 0, mix, stride);

          }

          this.cumulativeWeight = currentWeight;

      },

      // accumulate data in the 'incoming' region into 'add'
      accumulateAdditive: function(weight) {

          const buffer = this.buffer,
              stride = this.valueSize,
              offset = stride * this._addIndex;

          if (this.cumulativeWeightAdditive === 0) {

              // add = identity

              this._setIdentity();

          }

          // add := add + incoming * weight

          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;

      },

      // apply the state of 'accu<i>' to the binding when accus differ
      apply: function(accuIndex) {

          const stride = this.valueSize,
              buffer = this.buffer,
              offset = accuIndex * stride + stride,

              weight = this.cumulativeWeight,
              weightAdditive = this.cumulativeWeightAdditive,

              binding = this.binding;

          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;

          if (weight < 1) {

              // accuN := accuN + original * ( 1 - cumulativeWeight )

              const originalValueOffset = stride * this._origIndex;

              this._mixBufferRegion(
                  buffer, offset, originalValueOffset, 1 - weight, stride);

          }

          if (weightAdditive > 0) {

              // accuN := accuN + additive accuN

              this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);

          }

          for (let i = stride, e = stride + stride; i !== e; ++i) {

              if (buffer[i] !== buffer[i + stride]) {

                  // value has changed -> update scene graph

                  binding.setValue(buffer, offset);
                  break;

              }

          }

      },

      // remember the state of the bound property and copy it to both accus
      saveOriginalState: function() {

          const binding = this.binding;

          const buffer = this.buffer,
              stride = this.valueSize,

              originalValueOffset = stride * this._origIndex;

          binding.getValue(buffer, originalValueOffset);

          // accu[0..1] := orig -- initially detect changes against the original
          for (let i = stride, e = originalValueOffset; i !== e; ++i) {

              buffer[i] = buffer[originalValueOffset + (i % stride)];

          }

          // Add to identity for additive
          this._setIdentity();

          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;

      },

      // apply the state previously taken via 'saveOriginalState' to the binding
      restoreOriginalState: function() {

          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);

      },

      _setAdditiveIdentityNumeric: function() {

          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;

          for (let i = startIndex; i < endIndex; i++) {

              this.buffer[i] = 0;

          }

      },

      _setAdditiveIdentityQuaternion: function() {

          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * 4 + 3] = 1;

      },

      _setAdditiveIdentityOther: function() {

          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;

          for (let i = 0; i < this.valueSize; i++) {

              this.buffer[targetIndex + i] = this.buffer[startIndex + i];

          }

      },


      // mix functions

      _select: function(buffer, dstOffset, srcOffset, t, stride) {

          if (t >= 0.5) {

              for (let i = 0; i !== stride; ++i) {

                  buffer[dstOffset + i] = buffer[srcOffset + i];

              }

          }

      },

      _slerp: function(buffer, dstOffset, srcOffset, t) {

          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);

      },

      _slerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {

          const workOffset = this._workIndex * stride;

          // Store result in intermediate buffer offset
          Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);

          // Slerp to the intermediate result
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);

      },

      _lerp: function(buffer, dstOffset, srcOffset, t, stride) {

          const s = 1 - t;

          for (let i = 0; i !== stride; ++i) {

              const j = dstOffset + i;

              buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;

          }

      },

      _lerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {

          for (let i = 0; i !== stride; ++i) {

              const j = dstOffset + i;

              buffer[j] = buffer[j] + buffer[srcOffset + i] * t;

          }

      }

  });

  /**
   *
   * A reference to a real property in the scene graph.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  // Characters [].:/ are reserved for track binding syntax.
  const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
  const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

  // Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
  const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

  // Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

  // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

  // Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

  // Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

  const _trackRe = new RegExp('' +
      '^' +
      _directoryRe +
      _nodeRe +
      _objectRe +
      _propertyRe +
      '$'
  );

  const _supportedObjectNames = ['material', 'materials', 'bones'];

  function Composite(targetGroup, path, optionalParsedPath) {

      const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);

      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);

  }

  Object.assign(Composite.prototype, {

      getValue: function(array, offset) {

          this.bind(); // bind all binding

          const firstValidIndex = this._targetGroup.nCachedObjects_,
              binding = this._bindings[firstValidIndex];

          // and only call .getValue on the first
          if (binding !== undefined) binding.getValue(array, offset);

      },

      setValue: function(array, offset) {

          const bindings = this._bindings;

          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

              bindings[i].setValue(array, offset);

          }

      },

      bind: function() {

          const bindings = this._bindings;

          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

              bindings[i].bind();

          }

      },

      unbind: function() {

          const bindings = this._bindings;

          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

              bindings[i].unbind();

          }

      }

  });


  function PropertyBinding(rootNode, path, parsedPath) {

      this.path = path;
      this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);

      this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;

      this.rootNode = rootNode;

  }

  Object.assign(PropertyBinding, {

      Composite: Composite,

      create: function(root, path, parsedPath) {

          if (!(root && root.isAnimationObjectGroup)) {

              return new PropertyBinding(root, path, parsedPath);

          } else {

              return new PropertyBinding.Composite(root, path, parsedPath);

          }

      },

      /**
       * Replaces spaces with underscores and removes unsupported characters from
       * node names, to ensure compatibility with parseTrackName().
       *
       * @param {string} name Node name to be sanitized.
       * @return {string}
       */
      sanitizeNodeName: function(name) {

          return name.replace(/\s/g, '_').replace(_reservedRe, '');

      },

      parseTrackName: function(trackName) {

          const matches = _trackRe.exec(trackName);

          if (!matches) {

              throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);

          }

          const results = {
              // directoryName: matches[ 1 ], // (tschw) currently unused
              nodeName: matches[2],
              objectName: matches[3],
              objectIndex: matches[4],
              propertyName: matches[5], // required
              propertyIndex: matches[6]
          };

          const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

          if (lastDot !== undefined && lastDot !== -1) {

              const objectName = results.nodeName.substring(lastDot + 1);

              // Object names must be checked against an allowlist. Otherwise, there
              // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
              // 'bar' could be the objectName, or part of a nodeName (which can
              // include '.' characters).
              if (_supportedObjectNames.indexOf(objectName) !== -1) {

                  results.nodeName = results.nodeName.substring(0, lastDot);
                  results.objectName = objectName;

              }

          }

          if (results.propertyName === null || results.propertyName.length === 0) {

              throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);

          }

          return results;

      },

      findNode: function(root, nodeName) {

          if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {

              return root;

          }

          // search into skeleton bones.
          if (root.skeleton) {

              const bone = root.skeleton.getBoneByName(nodeName);

              if (bone !== undefined) {

                  return bone;

              }

          }

          // search into node subtree.
          if (root.children) {

              const searchNodeSubtree = function(children) {

                  for (let i = 0; i < children.length; i++) {

                      const childNode = children[i];

                      if (childNode.name === nodeName || childNode.uuid === nodeName) {

                          return childNode;

                      }

                      const result = searchNodeSubtree(childNode.children);

                      if (result) return result;

                  }

                  return null;

              };

              const subTreeNode = searchNodeSubtree(root.children);

              if (subTreeNode) {

                  return subTreeNode;

              }

          }

          return null;

      }

  });

  Object.assign(PropertyBinding.prototype, { // prototype, continued

      // these are used to "bind" a nonexistent property
      _getValue_unavailable: function() {},
      _setValue_unavailable: function() {},

      BindingType: {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3
      },

      Versioning: {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2
      },

      GetterByBindingType: [

          function getValue_direct(buffer, offset) {

              buffer[offset] = this.node[this.propertyName];

          },

          function getValue_array(buffer, offset) {

              const source = this.resolvedProperty;

              for (let i = 0, n = source.length; i !== n; ++i) {

                  buffer[offset++] = source[i];

              }

          },

          function getValue_arrayElement(buffer, offset) {

              buffer[offset] = this.resolvedProperty[this.propertyIndex];

          },

          function getValue_toArray(buffer, offset) {

              this.resolvedProperty.toArray(buffer, offset);

          }

      ],

      SetterByBindingTypeAndVersioning: [

          [
              // Direct

              function setValue_direct(buffer, offset) {

                  this.targetObject[this.propertyName] = buffer[offset];

              },

              function setValue_direct_setNeedsUpdate(buffer, offset) {

                  this.targetObject[this.propertyName] = buffer[offset];
                  this.targetObject.needsUpdate = true;

              },

              function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {

                  this.targetObject[this.propertyName] = buffer[offset];
                  this.targetObject.matrixWorldNeedsUpdate = true;

              }

          ],
          [

              // EntireArray

              function setValue_array(buffer, offset) {

                  const dest = this.resolvedProperty;

                  for (let i = 0, n = dest.length; i !== n; ++i) {

                      dest[i] = buffer[offset++];

                  }

              },

              function setValue_array_setNeedsUpdate(buffer, offset) {

                  const dest = this.resolvedProperty;

                  for (let i = 0, n = dest.length; i !== n; ++i) {

                      dest[i] = buffer[offset++];

                  }

                  this.targetObject.needsUpdate = true;

              },

              function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {

                  const dest = this.resolvedProperty;

                  for (let i = 0, n = dest.length; i !== n; ++i) {

                      dest[i] = buffer[offset++];

                  }

                  this.targetObject.matrixWorldNeedsUpdate = true;

              }

          ],
          [

              // ArrayElement

              function setValue_arrayElement(buffer, offset) {

                  this.resolvedProperty[this.propertyIndex] = buffer[offset];

              },

              function setValue_arrayElement_setNeedsUpdate(buffer, offset) {

                  this.resolvedProperty[this.propertyIndex] = buffer[offset];
                  this.targetObject.needsUpdate = true;

              },

              function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {

                  this.resolvedProperty[this.propertyIndex] = buffer[offset];
                  this.targetObject.matrixWorldNeedsUpdate = true;

              }

          ],
          [

              // HasToFromArray

              function setValue_fromArray(buffer, offset) {

                  this.resolvedProperty.fromArray(buffer, offset);

              },

              function setValue_fromArray_setNeedsUpdate(buffer, offset) {

                  this.resolvedProperty.fromArray(buffer, offset);
                  this.targetObject.needsUpdate = true;

              },

              function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {

                  this.resolvedProperty.fromArray(buffer, offset);
                  this.targetObject.matrixWorldNeedsUpdate = true;

              }

          ]

      ],

      getValue: function getValue_unbound(targetArray, offset) {

          this.bind();
          this.getValue(targetArray, offset);

          // Note: This class uses a State pattern on a per-method basis:
          // 'bind' sets 'this.getValue' / 'setValue' and shadows the
          // prototype version of these methods with one that represents
          // the bound state. When the property is not found, the methods
          // become no-ops.

      },

      setValue: function getValue_unbound(sourceArray, offset) {

          this.bind();
          this.setValue(sourceArray, offset);

      },

      // create getter / setter pair for a property in the scene graph
      bind: function() {

          let targetObject = this.node,
              parsedPath = this.parsedPath,

              objectName = parsedPath.objectName,
              propertyName = parsedPath.propertyName,
              propertyIndex = parsedPath.propertyIndex;

          if (!targetObject) {

              targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;

              this.node = targetObject;

          }

          // set fail state so we can just 'return' on error
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;

          // ensure there is a value node
          if (!targetObject) {

              console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
              return;

          }

          if (objectName) {

              let objectIndex = parsedPath.objectIndex;

              // special cases were we need to reach deeper into the hierarchy to get the face materials....
              switch (objectName) {

                  case 'materials':

                      if (!targetObject.material) {

                          console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                          return;

                      }

                      if (!targetObject.material.materials) {

                          console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                          return;

                      }

                      targetObject = targetObject.material.materials;

                      break;

                  case 'bones':

                      if (!targetObject.skeleton) {

                          console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                          return;

                      }

                      // potential future optimization: skip this if propertyIndex is already an integer
                      // and convert the integer string to a true integer.

                      targetObject = targetObject.skeleton.bones;

                      // support resolving morphTarget names into indices.
                      for (let i = 0; i < targetObject.length; i++) {

                          if (targetObject[i].name === objectIndex) {

                              objectIndex = i;
                              break;

                          }

                      }

                      break;

                  default:

                      if (targetObject[objectName] === undefined) {

                          console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                          return;

                      }

                      targetObject = targetObject[objectName];

              }


              if (objectIndex !== undefined) {

                  if (targetObject[objectIndex] === undefined) {

                      console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                      return;

                  }

                  targetObject = targetObject[objectIndex];

              }

          }

          // resolve property
          const nodeProperty = targetObject[propertyName];

          if (nodeProperty === undefined) {

              const nodeName = parsedPath.nodeName;

              console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                  '.' + propertyName + ' but it wasn\'t found.', targetObject);
              return;

          }

          // determine versioning scheme
          let versioning = this.Versioning.None;

          this.targetObject = targetObject;

          if (targetObject.needsUpdate !== undefined) { // material

              versioning = this.Versioning.NeedsUpdate;

          } else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform

              versioning = this.Versioning.MatrixWorldNeedsUpdate;

          }

          // determine how the property gets bound
          let bindingType = this.BindingType.Direct;

          if (propertyIndex !== undefined) {

              // access a sub element of the property array (only primitives are supported right now)

              if (propertyName === "morphTargetInfluences") {

                  // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                  // support resolving morphTarget names into indices.
                  if (!targetObject.geometry) {

                      console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                      return;

                  }

                  if (targetObject.geometry.isBufferGeometry) {

                      if (!targetObject.geometry.morphAttributes) {

                          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                          return;

                      }

                      if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {

                          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];

                      }


                  } else {

                      console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                      return;

                  }

              }

              bindingType = this.BindingType.ArrayElement;

              this.resolvedProperty = nodeProperty;
              this.propertyIndex = propertyIndex;

          } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {

              // must use copy for Object3D.Euler/Quaternion

              bindingType = this.BindingType.HasFromToArray;

              this.resolvedProperty = nodeProperty;

          } else if (Array.isArray(nodeProperty)) {

              bindingType = this.BindingType.EntireArray;

              this.resolvedProperty = nodeProperty;

          } else {

              this.propertyName = propertyName;

          }

          // select getter / setter
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];

      },

      unbind: function() {

          this.node = null;

          // back to the prototype version of getValue / setValue
          // note: avoiding to mutate the shape of 'this' via 'delete'
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;

      }

  });

  // DECLARE ALIAS AFTER assign prototype
  Object.assign(PropertyBinding.prototype, {

      // initial state of these methods that calls 'bind'
      _getValue_unbound: PropertyBinding.prototype.getValue,
      _setValue_unbound: PropertyBinding.prototype.setValue,

  });

  /**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   *  - Add objects you would otherwise pass as 'root' to the
   *    constructor or the .clipAction method of AnimationMixer.
   *
   *  - Instead pass this object as 'root'.
   *
   *  - You can also add and remove objects later when the mixer
   *    is running.
   *
   * Note:
   *
   *    Objects of this class appear as one object to the mixer,
   *    so cache control of the individual objects must be done
   *    on the group.
   *
   * Limitation:
   *
   *  - The animated properties must be compatible among the
   *    all objects in the group.
   *
   *  - A single property can either be controlled through a
   *    target group or directly, but not both.
   *
   * @author tschw
   */

  function AnimationObjectGroup() {

      this.uuid = MathUtils.generateUUID();

      // cached objects followed by the active ones
      this._objects = Array.prototype.slice.call(arguments);

      this.nCachedObjects_ = 0; // threshold
      // note: read by PropertyBinding.Composite

      const indices = {};
      this._indicesByUUID = indices; // for bookkeeping

      for (let i = 0, n = arguments.length; i !== n; ++i) {

          indices[arguments[i].uuid] = i;

      }

      this._paths = []; // inside: string
      this._parsedPaths = []; // inside: { we don't care, here }
      this._bindings = []; // inside: Array< PropertyBinding >
      this._bindingsIndicesByPath = {}; // inside: indices in these arrays

      const scope = this;

      this.stats = {

          objects: {
              get total() {

                  return scope._objects.length;

              },
              get inUse() {

                  return this.total - scope.nCachedObjects_;

              }
          },
          get bindingsPerObject() {

              return scope._bindings.length;

          }

      };

  }

  Object.assign(AnimationObjectGroup.prototype, {

      isAnimationObjectGroup: true,

      add: function() {

          const objects = this._objects,
              indicesByUUID = this._indicesByUUID,
              paths = this._paths,
              parsedPaths = this._parsedPaths,
              bindings = this._bindings,
              nBindings = bindings.length;

          let knownObject = undefined,
              nObjects = objects.length,
              nCachedObjects = this.nCachedObjects_;

          for (let i = 0, n = arguments.length; i !== n; ++i) {

              const object = arguments[i],
                  uuid = object.uuid;
              let index = indicesByUUID[uuid];

              if (index === undefined) {

                  // unknown object -> add it to the ACTIVE region

                  index = nObjects++;
                  indicesByUUID[uuid] = index;
                  objects.push(object);

                  // accounting is done, now do the same for all bindings

                  for (let j = 0, m = nBindings; j !== m; ++j) {

                      bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));

                  }

              } else if (index < nCachedObjects) {

                  knownObject = objects[index];

                  // move existing object to the ACTIVE region

                  const firstActiveIndex = --nCachedObjects,
                      lastCachedObject = objects[firstActiveIndex];

                  indicesByUUID[lastCachedObject.uuid] = index;
                  objects[index] = lastCachedObject;

                  indicesByUUID[uuid] = firstActiveIndex;
                  objects[firstActiveIndex] = object;

                  // accounting is done, now do the same for all bindings

                  for (let j = 0, m = nBindings; j !== m; ++j) {

                      const bindingsForPath = bindings[j],
                          lastCached = bindingsForPath[firstActiveIndex];

                      let binding = bindingsForPath[index];

                      bindingsForPath[index] = lastCached;

                      if (binding === undefined) {

                          // since we do not bother to create new bindings
                          // for objects that are cached, the binding may
                          // or may not exist

                          binding = new PropertyBinding(object, paths[j], parsedPaths[j]);

                      }

                      bindingsForPath[firstActiveIndex] = binding;

                  }

              } else if (objects[index] !== knownObject) {

                  console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                      'detected. Clean the caches or recreate your infrastructure when reloading scenes.');

              } // else the object is already where we want it to be

          } // for arguments

          this.nCachedObjects_ = nCachedObjects;

      },

      remove: function() {

          const objects = this._objects,
              indicesByUUID = this._indicesByUUID,
              bindings = this._bindings,
              nBindings = bindings.length;

          let nCachedObjects = this.nCachedObjects_;

          for (let i = 0, n = arguments.length; i !== n; ++i) {

              const object = arguments[i],
                  uuid = object.uuid,
                  index = indicesByUUID[uuid];

              if (index !== undefined && index >= nCachedObjects) {

                  // move existing object into the CACHED region

                  const lastCachedIndex = nCachedObjects++,
                      firstActiveObject = objects[lastCachedIndex];

                  indicesByUUID[firstActiveObject.uuid] = index;
                  objects[index] = firstActiveObject;

                  indicesByUUID[uuid] = lastCachedIndex;
                  objects[lastCachedIndex] = object;

                  // accounting is done, now do the same for all bindings

                  for (let j = 0, m = nBindings; j !== m; ++j) {

                      const bindingsForPath = bindings[j],
                          firstActive = bindingsForPath[lastCachedIndex],
                          binding = bindingsForPath[index];

                      bindingsForPath[index] = firstActive;
                      bindingsForPath[lastCachedIndex] = binding;

                  }

              }

          } // for arguments

          this.nCachedObjects_ = nCachedObjects;

      },

      // remove & forget
      uncache: function() {

          const objects = this._objects,
              indicesByUUID = this._indicesByUUID,
              bindings = this._bindings,
              nBindings = bindings.length;

          let nCachedObjects = this.nCachedObjects_,
              nObjects = objects.length;

          for (let i = 0, n = arguments.length; i !== n; ++i) {

              const object = arguments[i],
                  uuid = object.uuid,
                  index = indicesByUUID[uuid];

              if (index !== undefined) {

                  delete indicesByUUID[uuid];

                  if (index < nCachedObjects) {

                      // object is cached, shrink the CACHED region

                      const firstActiveIndex = --nCachedObjects,
                          lastCachedObject = objects[firstActiveIndex],
                          lastIndex = --nObjects,
                          lastObject = objects[lastIndex];

                      // last cached object takes this object's place
                      indicesByUUID[lastCachedObject.uuid] = index;
                      objects[index] = lastCachedObject;

                      // last object goes to the activated slot and pop
                      indicesByUUID[lastObject.uuid] = firstActiveIndex;
                      objects[firstActiveIndex] = lastObject;
                      objects.pop();

                      // accounting is done, now do the same for all bindings

                      for (let j = 0, m = nBindings; j !== m; ++j) {

                          const bindingsForPath = bindings[j],
                              lastCached = bindingsForPath[firstActiveIndex],
                              last = bindingsForPath[lastIndex];

                          bindingsForPath[index] = lastCached;
                          bindingsForPath[firstActiveIndex] = last;
                          bindingsForPath.pop();

                      }

                  } else {

                      // object is active, just swap with the last and pop

                      const lastIndex = --nObjects,
                          lastObject = objects[lastIndex];

                      indicesByUUID[lastObject.uuid] = index;
                      objects[index] = lastObject;
                      objects.pop();

                      // accounting is done, now do the same for all bindings

                      for (let j = 0, m = nBindings; j !== m; ++j) {

                          const bindingsForPath = bindings[j];

                          bindingsForPath[index] = bindingsForPath[lastIndex];
                          bindingsForPath.pop();

                      }

                  } // cached or active

              } // if object is known

          } // for arguments

          this.nCachedObjects_ = nCachedObjects;

      },

      // Internal interface used by befriended PropertyBinding.Composite:

      subscribe_: function(path, parsedPath) {

          // returns an array of bindings for the given path that is changed
          // according to the contained objects in the group

          let indicesByPath = this._bindingsIndicesByPath,
              index = indicesByPath[path],
              bindings = this._bindings;

          if (index !== undefined) return bindings[index];

          const paths = this._paths,
              parsedPaths = this._parsedPaths,
              objects = this._objects,
              nObjects = objects.length,
              nCachedObjects = this.nCachedObjects_,
              bindingsForPath = new Array(nObjects);

          index = bindings.length;

          indicesByPath[path] = index;

          paths.push(path);
          parsedPaths.push(parsedPath);
          bindings.push(bindingsForPath);

          for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {

              const object = objects[i];
              bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);

          }

          return bindingsForPath;

      },

      unsubscribe_: function(path) {

          // tells the group to forget about a property path and no longer
          // update the array previously obtained with 'subscribe_'

          const indicesByPath = this._bindingsIndicesByPath,
              index = indicesByPath[path];

          if (index !== undefined) {

              const paths = this._paths,
                  parsedPaths = this._parsedPaths,
                  bindings = this._bindings,
                  lastBindingsIndex = bindings.length - 1,
                  lastBindings = bindings[lastBindingsIndex],
                  lastBindingsPath = path[lastBindingsIndex];

              indicesByPath[lastBindingsPath] = index;

              bindings[index] = lastBindings;
              bindings.pop();

              parsedPaths[index] = parsedPaths[lastBindingsIndex];
              parsedPaths.pop();

              paths[index] = paths[lastBindingsIndex];
              paths.pop();

          }

      }

  });

  /**
   *
   * Action provided by AnimationMixer for scheduling clip playback on specific
   * objects.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   *
   */

  function AnimationAction(mixer, clip, localRoot, blendMode) {

      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot || null;
      this.blendMode = blendMode || clip.blendMode;

      const tracks = clip.tracks,
          nTracks = tracks.length,
          interpolants = new Array(nTracks);

      const interpolantSettings = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
      };

      for (let i = 0; i !== nTracks; ++i) {

          const interpolant = tracks[i].createInterpolant(null);
          interpolants[i] = interpolant;
          interpolant.settings = interpolantSettings;

      }

      this._interpolantSettings = interpolantSettings;

      this._interpolants = interpolants; // bound by the mixer

      // inside: PropertyMixer (managed by the mixer)
      this._propertyBindings = new Array(nTracks);

      this._cacheIndex = null; // for the memory manager
      this._byClipCacheIndex = null; // for the memory manager

      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;

      this.loop = LoopRepeat;
      this._loopCount = -1;

      // global mixer time when the action is to be started
      // it's set back to 'null' upon start of the action
      this._startTime = null;

      // scaled local time of the action
      // gets clamped or wrapped to 0..clip.duration according to loop
      this.time = 0;

      this.timeScale = 1;
      this._effectiveTimeScale = 1;

      this.weight = 1;
      this._effectiveWeight = 1;

      this.repetitions = Infinity; // no. of repetitions when looping

      this.paused = false; // true -> zero effective time scale
      this.enabled = true; // false -> zero effective weight

      this.clampWhenFinished = false; // keep feeding the last frame?

      this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
      this.zeroSlopeAtEnd = true; // clips for start, loop and end

  }

  Object.assign(AnimationAction.prototype, {

      // State & Scheduling

      play: function() {

          this._mixer._activateAction(this);

          return this;

      },

      stop: function() {

          this._mixer._deactivateAction(this);

          return this.reset();

      },

      reset: function() {

          this.paused = false;
          this.enabled = true;

          this.time = 0; // restart clip
          this._loopCount = -1; // forget previous loops
          this._startTime = null; // forget scheduling

          return this.stopFading().stopWarping();

      },

      isRunning: function() {

          return this.enabled && !this.paused && this.timeScale !== 0 &&
              this._startTime === null && this._mixer._isActiveAction(this);

      },

      // return true when play has been called
      isScheduled: function() {

          return this._mixer._isActiveAction(this);

      },

      startAt: function(time) {

          this._startTime = time;

          return this;

      },

      setLoop: function(mode, repetitions) {

          this.loop = mode;
          this.repetitions = repetitions;

          return this;

      },

      // Weight

      // set the weight stopping any scheduled fading
      // although .enabled = false yields an effective weight of zero, this
      // method does *not* change .enabled, because it would be confusing
      setEffectiveWeight: function(weight) {

          this.weight = weight;

          // note: same logic as when updated at runtime
          this._effectiveWeight = this.enabled ? weight : 0;

          return this.stopFading();

      },

      // return the weight considering fading and .enabled
      getEffectiveWeight: function() {

          return this._effectiveWeight;

      },

      fadeIn: function(duration) {

          return this._scheduleFading(duration, 0, 1);

      },

      fadeOut: function(duration) {

          return this._scheduleFading(duration, 1, 0);

      },

      crossFadeFrom: function(fadeOutAction, duration, warp) {

          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);

          if (warp) {

              const fadeInDuration = this._clip.duration,
                  fadeOutDuration = fadeOutAction._clip.duration,

                  startEndRatio = fadeOutDuration / fadeInDuration,
                  endStartRatio = fadeInDuration / fadeOutDuration;

              fadeOutAction.warp(1.0, startEndRatio, duration);
              this.warp(endStartRatio, 1.0, duration);

          }

          return this;

      },

      crossFadeTo: function(fadeInAction, duration, warp) {

          return fadeInAction.crossFadeFrom(this, duration, warp);

      },

      stopFading: function() {

          let weightInterpolant = this._weightInterpolant;

          if (weightInterpolant !== null) {

              this._weightInterpolant = null;
              this._mixer._takeBackControlInterpolant(weightInterpolant);

          }

          return this;

      },

      // Time Scale Control

      // set the time scale stopping any scheduled warping
      // although .paused = true yields an effective time scale of zero, this
      // method does *not* change .paused, because it would be confusing
      setEffectiveTimeScale: function(timeScale) {

          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;

          return this.stopWarping();

      },

      // return the time scale considering warping and .paused
      getEffectiveTimeScale: function() {

          return this._effectiveTimeScale;

      },

      setDuration: function(duration) {

          this.timeScale = this._clip.duration / duration;

          return this.stopWarping();

      },

      syncWith: function(action) {

          this.time = action.time;
          this.timeScale = action.timeScale;

          return this.stopWarping();

      },

      halt: function(duration) {

          return this.warp(this._effectiveTimeScale, 0, duration);

      },

      warp: function(startTimeScale, endTimeScale, duration) {

          const mixer = this._mixer,
              now = mixer.time,
              timeScale = this.timeScale;

          let interpolant = this._timeScaleInterpolant;

          if (interpolant === null) {

              interpolant = mixer._lendControlInterpolant();
              this._timeScaleInterpolant = interpolant;

          }

          const times = interpolant.parameterPositions,
              values = interpolant.sampleValues;

          times[0] = now;
          times[1] = now + duration;

          values[0] = startTimeScale / timeScale;
          values[1] = endTimeScale / timeScale;

          return this;

      },

      stopWarping: function() {

          let timeScaleInterpolant = this._timeScaleInterpolant;

          if (timeScaleInterpolant !== null) {

              this._timeScaleInterpolant = null;
              this._mixer._takeBackControlInterpolant(timeScaleInterpolant);

          }

          return this;

      },

      // Object Accessors

      getMixer: function() {

          return this._mixer;

      },

      getClip: function() {

          return this._clip;

      },

      getRoot: function() {

          return this._localRoot || this._mixer._root;

      },

      // Interna

      _update: function(time, deltaTime, timeDirection, accuIndex) {

          // called by the mixer

          if (!this.enabled) {

              // call ._updateWeight() to update ._effectiveWeight

              this._updateWeight(time);
              return;

          }

          const startTime = this._startTime;

          if (startTime !== null) {

              // check for scheduled start of action

              const timeRunning = (time - startTime) * timeDirection;
              if (timeRunning < 0 || timeDirection === 0) {

                  return; // yet to come / don't decide when delta = 0

              }

              // start

              this._startTime = null; // unschedule
              deltaTime = timeDirection * timeRunning;

          }

          // apply time scale and advance time

          deltaTime *= this._updateTimeScale(time);
          const clipTime = this._updateTime(deltaTime);

          // note: _updateTime may disable the action resulting in
          // an effective weight of 0

          const weight = this._updateWeight(time);

          if (weight > 0) {

              const interpolants = this._interpolants;
              const propertyMixers = this._propertyBindings;

              switch (this.blendMode) {

                  case AdditiveAnimationBlendMode:

                      for (let j = 0, m = interpolants.length; j !== m; ++j) {

                          interpolants[j].evaluate(clipTime);
                          propertyMixers[j].accumulateAdditive(weight);

                      }

                      break;

                  case NormalAnimationBlendMode:
                  default:

                      for (let j = 0, m = interpolants.length; j !== m; ++j) {

                          interpolants[j].evaluate(clipTime);
                          propertyMixers[j].accumulate(accuIndex, weight);

                      }

              }

          }

      },

      _updateWeight: function(time) {

          let weight = 0;

          if (this.enabled) {

              weight = this.weight;
              const interpolant = this._weightInterpolant;

              if (interpolant !== null) {

                  const interpolantValue = interpolant.evaluate(time)[0];

                  weight *= interpolantValue;

                  if (time > interpolant.parameterPositions[1]) {

                      this.stopFading();

                      if (interpolantValue === 0) {

                          // faded out, disable
                          this.enabled = false;

                      }

                  }

              }

          }

          this._effectiveWeight = weight;
          return weight;

      },

      _updateTimeScale: function(time) {

          let timeScale = 0;

          if (!this.paused) {

              timeScale = this.timeScale;

              const interpolant = this._timeScaleInterpolant;

              if (interpolant !== null) {

                  const interpolantValue = interpolant.evaluate(time)[0];

                  timeScale *= interpolantValue;

                  if (time > interpolant.parameterPositions[1]) {

                      this.stopWarping();

                      if (timeScale === 0) {

                          // motion has halted, pause
                          this.paused = true;

                      } else {

                          // warp done - apply final time scale
                          this.timeScale = timeScale;

                      }

                  }

              }

          }

          this._effectiveTimeScale = timeScale;
          return timeScale;

      },

      _updateTime: function(deltaTime) {

          const duration = this._clip.duration;
          const loop = this.loop;

          let time = this.time + deltaTime;
          let loopCount = this._loopCount;

          const pingPong = (loop === LoopPingPong);

          if (deltaTime === 0) {

              if (loopCount === -1) return time;

              return (pingPong && (loopCount & 1) === 1) ? duration - time : time;

          }

          if (loop === LoopOnce) {

              if (loopCount === -1) {

                  // just started

                  this._loopCount = 0;
                  this._setEndings(true, true, false);

              }

              handle_stop: {

                  if (time >= duration) {

                      time = duration;

                  } else if (time < 0) {

                      time = 0;

                  } else {

                      this.time = time;

                      break handle_stop;

                  }

                  if (this.clampWhenFinished) this.paused = true;
                  else this.enabled = false;

                  this.time = time;

                  this._mixer.dispatchEvent({
                      type: 'finished',
                      action: this,
                      direction: deltaTime < 0 ? -1 : 1
                  });

              }

          } else { // repetitive Repeat or PingPong

              if (loopCount === -1) {

                  // just started

                  if (deltaTime >= 0) {

                      loopCount = 0;

                      this._setEndings(true, this.repetitions === 0, pingPong);

                  } else {

                      // when looping in reverse direction, the initial
                      // transition through zero counts as a repetition,
                      // so leave loopCount at -1

                      this._setEndings(this.repetitions === 0, true, pingPong);

                  }

              }

              if (time >= duration || time < 0) {

                  // wrap around

                  const loopDelta = Math.floor(time / duration); // signed
                  time -= duration * loopDelta;

                  loopCount += Math.abs(loopDelta);

                  const pending = this.repetitions - loopCount;

                  if (pending <= 0) {

                      // have to stop (switch state, clamp time, fire event)

                      if (this.clampWhenFinished) this.paused = true;
                      else this.enabled = false;

                      time = deltaTime > 0 ? duration : 0;

                      this.time = time;

                      this._mixer.dispatchEvent({
                          type: 'finished',
                          action: this,
                          direction: deltaTime > 0 ? 1 : -1
                      });

                  } else {

                      // keep running

                      if (pending === 1) {

                          // entering the last round

                          const atStart = deltaTime < 0;
                          this._setEndings(atStart, !atStart, pingPong);

                      } else {

                          this._setEndings(false, false, pingPong);

                      }

                      this._loopCount = loopCount;

                      this.time = time;

                      this._mixer.dispatchEvent({
                          type: 'loop',
                          action: this,
                          loopDelta: loopDelta
                      });

                  }

              } else {

                  this.time = time;

              }

              if (pingPong && (loopCount & 1) === 1) {

                  // invert time for the "pong round"

                  return duration - time;

              }

          }

          return time;

      },

      _setEndings: function(atStart, atEnd, pingPong) {

          const settings = this._interpolantSettings;

          if (pingPong) {

              settings.endingStart = ZeroSlopeEnding;
              settings.endingEnd = ZeroSlopeEnding;

          } else {

              // assuming for LoopOnce atStart == atEnd == true

              if (atStart) {

                  settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

              } else {

                  settings.endingStart = WrapAroundEnding;

              }

              if (atEnd) {

                  settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

              } else {

                  settings.endingEnd = WrapAroundEnding;

              }

          }

      },

      _scheduleFading: function(duration, weightNow, weightThen) {

          const mixer = this._mixer,
              now = mixer.time;
          let interpolant = this._weightInterpolant;

          if (interpolant === null) {

              interpolant = mixer._lendControlInterpolant();
              this._weightInterpolant = interpolant;

          }

          const times = interpolant.parameterPositions,
              values = interpolant.sampleValues;

          times[0] = now;
          values[0] = weightNow;
          times[1] = now + duration;
          values[1] = weightThen;

          return this;

      }

  });

  /**
   *
   * Player for AnimationClips.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function AnimationMixer(root) {

      this._root = root;
      this._initMemoryManager();
      this._accuIndex = 0;

      this.time = 0;

      this.timeScale = 1.0;

  }

  AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

      constructor: AnimationMixer,

      _bindAction: function(action, prototypeAction) {

          const root = action._localRoot || this._root,
              tracks = action._clip.tracks,
              nTracks = tracks.length,
              bindings = action._propertyBindings,
              interpolants = action._interpolants,
              rootUuid = root.uuid,
              bindingsByRoot = this._bindingsByRootAndName;

          let bindingsByName = bindingsByRoot[rootUuid];

          if (bindingsByName === undefined) {

              bindingsByName = {};
              bindingsByRoot[rootUuid] = bindingsByName;

          }

          for (let i = 0; i !== nTracks; ++i) {

              const track = tracks[i],
                  trackName = track.name;

              let binding = bindingsByName[trackName];

              if (binding !== undefined) {

                  bindings[i] = binding;

              } else {

                  binding = bindings[i];

                  if (binding !== undefined) {

                      // existing binding, make sure the cache knows

                      if (binding._cacheIndex === null) {

                          ++binding.referenceCount;
                          this._addInactiveBinding(binding, rootUuid, trackName);

                      }

                      continue;

                  }

                  const path = prototypeAction && prototypeAction.
                  _propertyBindings[i].binding.parsedPath;

                  binding = new PropertyMixer(
                      PropertyBinding.create(root, trackName, path),
                      track.ValueTypeName, track.getValueSize());

                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);

                  bindings[i] = binding;

              }

              interpolants[i].resultBuffer = binding.buffer;

          }

      },

      _activateAction: function(action) {

          if (!this._isActiveAction(action)) {

              if (action._cacheIndex === null) {

                  // this action has been forgotten by the cache, but the user
                  // appears to be still using it -> rebind

                  const rootUuid = (action._localRoot || this._root).uuid,
                      clipUuid = action._clip.uuid,
                      actionsForClip = this._actionsByClip[clipUuid];

                  this._bindAction(action,
                      actionsForClip && actionsForClip.knownActions[0]);

                  this._addInactiveAction(action, clipUuid, rootUuid);

              }

              const bindings = action._propertyBindings;

              // increment reference counts / sort out state
              for (let i = 0, n = bindings.length; i !== n; ++i) {

                  const binding = bindings[i];

                  if (binding.useCount++ === 0) {

                      this._lendBinding(binding);
                      binding.saveOriginalState();

                  }

              }

              this._lendAction(action);

          }

      },

      _deactivateAction: function(action) {

          if (this._isActiveAction(action)) {

              const bindings = action._propertyBindings;

              // decrement reference counts / sort out state
              for (let i = 0, n = bindings.length; i !== n; ++i) {

                  const binding = bindings[i];

                  if (--binding.useCount === 0) {

                      binding.restoreOriginalState();
                      this._takeBackBinding(binding);

                  }

              }

              this._takeBackAction(action);

          }

      },

      // Memory manager

      _initMemoryManager: function() {

          this._actions = []; // 'nActiveActions' followed by inactive ones
          this._nActiveActions = 0;

          this._actionsByClip = {};
          // inside:
          // {
          // 	knownActions: Array< AnimationAction > - used as prototypes
          // 	actionByRoot: AnimationAction - lookup
          // }


          this._bindings = []; // 'nActiveBindings' followed by inactive ones
          this._nActiveBindings = 0;

          this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


          this._controlInterpolants = []; // same game as above
          this._nActiveControlInterpolants = 0;

          const scope = this;

          this.stats = {

              actions: {
                  get total() {

                      return scope._actions.length;

                  },
                  get inUse() {

                      return scope._nActiveActions;

                  }
              },
              bindings: {
                  get total() {

                      return scope._bindings.length;

                  },
                  get inUse() {

                      return scope._nActiveBindings;

                  }
              },
              controlInterpolants: {
                  get total() {

                      return scope._controlInterpolants.length;

                  },
                  get inUse() {

                      return scope._nActiveControlInterpolants;

                  }
              }

          };

      },

      // Memory management for AnimationAction objects

      _isActiveAction: function(action) {

          const index = action._cacheIndex;
          return index !== null && index < this._nActiveActions;

      },

      _addInactiveAction: function(action, clipUuid, rootUuid) {

          const actions = this._actions,
              actionsByClip = this._actionsByClip;

          let actionsForClip = actionsByClip[clipUuid];

          if (actionsForClip === undefined) {

              actionsForClip = {

                  knownActions: [action],
                  actionByRoot: {}

              };

              action._byClipCacheIndex = 0;

              actionsByClip[clipUuid] = actionsForClip;

          } else {

              const knownActions = actionsForClip.knownActions;

              action._byClipCacheIndex = knownActions.length;
              knownActions.push(action);

          }

          action._cacheIndex = actions.length;
          actions.push(action);

          actionsForClip.actionByRoot[rootUuid] = action;

      },

      _removeInactiveAction: function(action) {

          const actions = this._actions,
              lastInactiveAction = actions[actions.length - 1],
              cacheIndex = action._cacheIndex;

          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();

          action._cacheIndex = null;


          const clipUuid = action._clip.uuid,
              actionsByClip = this._actionsByClip,
              actionsForClip = actionsByClip[clipUuid],
              knownActionsForClip = actionsForClip.knownActions,

              lastKnownAction =
              knownActionsForClip[knownActionsForClip.length - 1],

              byClipCacheIndex = action._byClipCacheIndex;

          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();

          action._byClipCacheIndex = null;


          const actionByRoot = actionsForClip.actionByRoot,
              rootUuid = (action._localRoot || this._root).uuid;

          delete actionByRoot[rootUuid];

          if (knownActionsForClip.length === 0) {

              delete actionsByClip[clipUuid];

          }

          this._removeInactiveBindingsForAction(action);

      },

      _removeInactiveBindingsForAction: function(action) {

          const bindings = action._propertyBindings;

          for (let i = 0, n = bindings.length; i !== n; ++i) {

              const binding = bindings[i];

              if (--binding.referenceCount === 0) {

                  this._removeInactiveBinding(binding);

              }

          }

      },

      _lendAction: function(action) {

          // [ active actions |  inactive actions  ]
          // [  active actions >| inactive actions ]
          //                 s        a
          //                  <-swap->
          //                 a        s

          const actions = this._actions,
              prevIndex = action._cacheIndex,

              lastActiveIndex = this._nActiveActions++,

              firstInactiveAction = actions[lastActiveIndex];

          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;

          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;

      },

      _takeBackAction: function(action) {

          // [  active actions  | inactive actions ]
          // [ active actions |< inactive actions  ]
          //        a        s
          //         <-swap->
          //        s        a

          const actions = this._actions,
              prevIndex = action._cacheIndex,

              firstInactiveIndex = --this._nActiveActions,

              lastActiveAction = actions[firstInactiveIndex];

          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;

          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;

      },

      // Memory management for PropertyMixer objects

      _addInactiveBinding: function(binding, rootUuid, trackName) {

          const bindingsByRoot = this._bindingsByRootAndName,
              bindings = this._bindings;

          let bindingByName = bindingsByRoot[rootUuid];

          if (bindingByName === undefined) {

              bindingByName = {};
              bindingsByRoot[rootUuid] = bindingByName;

          }

          bindingByName[trackName] = binding;

          binding._cacheIndex = bindings.length;
          bindings.push(binding);

      },

      _removeInactiveBinding: function(binding) {

          const bindings = this._bindings,
              propBinding = binding.binding,
              rootUuid = propBinding.rootNode.uuid,
              trackName = propBinding.path,
              bindingsByRoot = this._bindingsByRootAndName,
              bindingByName = bindingsByRoot[rootUuid],

              lastInactiveBinding = bindings[bindings.length - 1],
              cacheIndex = binding._cacheIndex;

          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();

          delete bindingByName[trackName];

          if (Object.keys(bindingByName).length === 0) {

              delete bindingsByRoot[rootUuid];

          }

      },

      _lendBinding: function(binding) {

          const bindings = this._bindings,
              prevIndex = binding._cacheIndex,

              lastActiveIndex = this._nActiveBindings++,

              firstInactiveBinding = bindings[lastActiveIndex];

          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;

          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;

      },

      _takeBackBinding: function(binding) {

          const bindings = this._bindings,
              prevIndex = binding._cacheIndex,

              firstInactiveIndex = --this._nActiveBindings,

              lastActiveBinding = bindings[firstInactiveIndex];

          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;

          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;

      },


      // Memory management of Interpolants for weight and time scale

      _lendControlInterpolant: function() {

          const interpolants = this._controlInterpolants,
              lastActiveIndex = this._nActiveControlInterpolants++;

          let interpolant = interpolants[lastActiveIndex];

          if (interpolant === undefined) {

              interpolant = new LinearInterpolant(
                  new Float32Array(2), new Float32Array(2),
                  1, this._controlInterpolantsResultBuffer);

              interpolant.__cacheIndex = lastActiveIndex;
              interpolants[lastActiveIndex] = interpolant;

          }

          return interpolant;

      },

      _takeBackControlInterpolant: function(interpolant) {

          const interpolants = this._controlInterpolants,
              prevIndex = interpolant.__cacheIndex,

              firstInactiveIndex = --this._nActiveControlInterpolants,

              lastActiveInterpolant = interpolants[firstInactiveIndex];

          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;

          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;

      },

      _controlInterpolantsResultBuffer: new Float32Array(1),

      // return an action for a clip optionally using a custom root target
      // object (this method allocates a lot of dynamic memory in case a
      // previously unknown clip/root combination is specified)
      clipAction: function(clip, optionalRoot, blendMode) {

          const root = optionalRoot || this._root,
              rootUuid = root.uuid;

          let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;

          const clipUuid = clipObject !== null ? clipObject.uuid : clip;

          let actionsForClip = this._actionsByClip[clipUuid],
              prototypeAction = null;

          if (blendMode === undefined) {

              if (clipObject !== null) {

                  blendMode = clipObject.blendMode;

              } else {

                  blendMode = NormalAnimationBlendMode;

              }

          }

          if (actionsForClip !== undefined) {

              const existingAction = actionsForClip.actionByRoot[rootUuid];

              if (existingAction !== undefined && existingAction.blendMode === blendMode) {

                  return existingAction;

              }

              // we know the clip, so we don't have to parse all
              // the bindings again but can just copy
              prototypeAction = actionsForClip.knownActions[0];

              // also, take the clip from the prototype action
              if (clipObject === null)
                  clipObject = prototypeAction._clip;

          }

          // clip must be known when specified via string
          if (clipObject === null) return null;

          // allocate all resources required to run it
          const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

          this._bindAction(newAction, prototypeAction);

          // and make the action known to the memory manager
          this._addInactiveAction(newAction, clipUuid, rootUuid);

          return newAction;

      },

      // get an existing action
      existingAction: function(clip, optionalRoot) {

          const root = optionalRoot || this._root,
              rootUuid = root.uuid,

              clipObject = typeof clip === 'string' ?
              AnimationClip.findByName(root, clip) : clip,

              clipUuid = clipObject ? clipObject.uuid : clip,

              actionsForClip = this._actionsByClip[clipUuid];

          if (actionsForClip !== undefined) {

              return actionsForClip.actionByRoot[rootUuid] || null;

          }

          return null;

      },

      // deactivates all previously scheduled actions
      stopAllAction: function() {

          const actions = this._actions,
              nActions = this._nActiveActions;

          for (let i = nActions - 1; i >= 0; --i) {

              actions[i].stop();

          }

          return this;

      },

      // advance the time and update apply the animation
      update: function(deltaTime) {

          deltaTime *= this.timeScale;

          const actions = this._actions,
              nActions = this._nActiveActions,

              time = this.time += deltaTime,
              timeDirection = Math.sign(deltaTime),

              accuIndex = this._accuIndex ^= 1;

          // run active actions

          for (let i = 0; i !== nActions; ++i) {

              const action = actions[i];

              action._update(time, deltaTime, timeDirection, accuIndex);

          }

          // update scene graph

          const bindings = this._bindings,
              nBindings = this._nActiveBindings;

          for (let i = 0; i !== nBindings; ++i) {

              bindings[i].apply(accuIndex);

          }

          return this;

      },

      // Allows you to seek to a specific time in an animation.
      setTime: function(timeInSeconds) {

          this.time = 0; // Zero out time attribute for AnimationMixer object;
          for (let i = 0; i < this._actions.length; i++) {

              this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.

          }

          return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.

      },

      // return this mixer's root target object
      getRoot: function() {

          return this._root;

      },

      // free all resources specific to a particular clip
      uncacheClip: function(clip) {

          const actions = this._actions,
              clipUuid = clip.uuid,
              actionsByClip = this._actionsByClip,
              actionsForClip = actionsByClip[clipUuid];

          if (actionsForClip !== undefined) {

              // note: just calling _removeInactiveAction would mess up the
              // iteration state and also require updating the state we can
              // just throw away

              const actionsToRemove = actionsForClip.knownActions;

              for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {

                  const action = actionsToRemove[i];

                  this._deactivateAction(action);

                  const cacheIndex = action._cacheIndex,
                      lastInactiveAction = actions[actions.length - 1];

                  action._cacheIndex = null;
                  action._byClipCacheIndex = null;

                  lastInactiveAction._cacheIndex = cacheIndex;
                  actions[cacheIndex] = lastInactiveAction;
                  actions.pop();

                  this._removeInactiveBindingsForAction(action);

              }

              delete actionsByClip[clipUuid];

          }

      },

      // free all resources specific to a particular root target object
      uncacheRoot: function(root) {

          const rootUuid = root.uuid,
              actionsByClip = this._actionsByClip;

          for (const clipUuid in actionsByClip) {

              const actionByRoot = actionsByClip[clipUuid].actionByRoot,
                  action = actionByRoot[rootUuid];

              if (action !== undefined) {

                  this._deactivateAction(action);
                  this._removeInactiveAction(action);

              }

          }

          const bindingsByRoot = this._bindingsByRootAndName,
              bindingByName = bindingsByRoot[rootUuid];

          if (bindingByName !== undefined) {

              for (const trackName in bindingByName) {

                  const binding = bindingByName[trackName];
                  binding.restoreOriginalState();
                  this._removeInactiveBinding(binding);

              }

          }

      },

      // remove a targeted clip from the cache
      uncacheAction: function(clip, optionalRoot) {

          const action = this.existingAction(clip, optionalRoot);

          if (action !== null) {

              this._deactivateAction(action);
              this._removeInactiveAction(action);

          }

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Uniform(value) {

      if (typeof value === 'string') {

          console.warn('THREE.Uniform: Type parameter is no longer needed.');
          value = arguments[1];

      }

      this.value = value;

  }

  Uniform.prototype.clone = function() {

      return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());

  };

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {

      InterleavedBuffer.call(this, array, stride);

      this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {

      constructor: InstancedInterleavedBuffer,

      isInstancedInterleavedBuffer: true,

      copy: function(source) {

          InterleavedBuffer.prototype.copy.call(this, source);

          this.meshPerAttribute = source.meshPerAttribute;

          return this;

      },

      clone: function(data) {

          const ib = InterleavedBuffer.prototype.clone.call(this, data);

          ib.meshPerAttribute = this.meshPerAttribute;

          return ib;

      },

      toJSON: function(data) {

          const json = InterleavedBuffer.prototype.toJSON.call(this, data);

          json.isInstancedInterleavedBuffer = true;
          json.meshPerAttribute = this.meshPerAttribute;

          return json;

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author bhouston / http://clara.io/
   * @author stephomi / http://stephaneginier.com/
   */

  function Raycaster(origin, direction, near, far) {

      this.ray = new Ray(origin, direction);
      // direction is assumed to be normalized (for accurate distance calculations)

      this.near = near || 0;
      this.far = far || Infinity;
      this.camera = null;
      this.layers = new Layers();

      this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {}
      };

      Object.defineProperties(this.params, {
          PointCloud: {
              get: function() {

                  console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                  return this.Points;

              }
          }
      });

  }

  function ascSort(a, b) {

      return a.distance - b.distance;

  }

  function intersectObject(object, raycaster, intersects, recursive) {

      if (object.layers.test(raycaster.layers)) {

          object.raycast(raycaster, intersects);

      }

      if (recursive === true) {

          const children = object.children;

          for (let i = 0, l = children.length; i < l; i++) {

              intersectObject(children[i], raycaster, intersects, true);

          }

      }

  }

  Object.assign(Raycaster.prototype, {

      set: function(origin, direction) {

          // direction is assumed to be normalized (for accurate distance calculations)

          this.ray.set(origin, direction);

      },

      setFromCamera: function(coords, camera) {

          if ((camera && camera.isPerspectiveCamera)) {

              this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
              this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
              this.camera = camera;

          } else if ((camera && camera.isOrthographicCamera)) {

              this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
              this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
              this.camera = camera;

          } else {

              console.error('THREE.Raycaster: Unsupported camera type.');

          }

      },

      intersectObject: function(object, recursive, optionalTarget) {

          const intersects = optionalTarget || [];

          intersectObject(object, this, intersects, recursive);

          intersects.sort(ascSort);

          return intersects;

      },

      intersectObjects: function(objects, recursive, optionalTarget) {

          const intersects = optionalTarget || [];

          if (Array.isArray(objects) === false) {

              console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
              return intersects;

          }

          for (let i = 0, l = objects.length; i < l; i++) {

              intersectObject(objects[i], this, intersects, recursive);

          }

          intersects.sort(ascSort);

          return intersects;

      }

  });

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
   * The azimuthal angle (theta) is measured from the positive z-axis.
   */

  function Spherical(radius, phi, theta) {

      this.radius = (radius !== undefined) ? radius : 1.0;
      this.phi = (phi !== undefined) ? phi : 0; // polar angle
      this.theta = (theta !== undefined) ? theta : 0; // azimuthal angle

      return this;

  }

  Object.assign(Spherical.prototype, {

      set: function(radius, phi, theta) {

          this.radius = radius;
          this.phi = phi;
          this.theta = theta;

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(other) {

          this.radius = other.radius;
          this.phi = other.phi;
          this.theta = other.theta;

          return this;

      },

      // restrict phi to be betwee EPS and PI-EPS
      makeSafe: function() {

          const EPS = 0.000001;
          this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));

          return this;

      },

      setFromVector3: function(v) {

          return this.setFromCartesianCoords(v.x, v.y, v.z);

      },

      setFromCartesianCoords: function(x, y, z) {

          this.radius = Math.sqrt(x * x + y * y + z * z);

          if (this.radius === 0) {

              this.theta = 0;
              this.phi = 0;

          } else {

              this.theta = Math.atan2(x, z);
              this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));

          }

          return this;

      }

  });

  /**
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
   *
   */

  function Cylindrical(radius, theta, y) {

      this.radius = (radius !== undefined) ? radius : 1.0; // distance from the origin to a point in the x-z plane
      this.theta = (theta !== undefined) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
      this.y = (y !== undefined) ? y : 0; // height above the x-z plane

      return this;

  }

  Object.assign(Cylindrical.prototype, {

      set: function(radius, theta, y) {

          this.radius = radius;
          this.theta = theta;
          this.y = y;

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(other) {

          this.radius = other.radius;
          this.theta = other.theta;
          this.y = other.y;

          return this;

      },

      setFromVector3: function(v) {

          return this.setFromCartesianCoords(v.x, v.y, v.z);

      },

      setFromCartesianCoords: function(x, y, z) {

          this.radius = Math.sqrt(x * x + z * z);
          this.theta = Math.atan2(x, z);
          this.y = y;

          return this;

      }

  });

  /**
   * @author bhouston / http://clara.io
   */

  const _vector$7 = new Vector2();

  function Box2(min, max) {

      this.min = (min !== undefined) ? min : new Vector2(+Infinity, +Infinity);
      this.max = (max !== undefined) ? max : new Vector2(-Infinity, -Infinity);

  }

  Object.assign(Box2.prototype, {

      set: function(min, max) {

          this.min.copy(min);
          this.max.copy(max);

          return this;

      },

      setFromPoints: function(points) {

          this.makeEmpty();

          for (let i = 0, il = points.length; i < il; i++) {

              this.expandByPoint(points[i]);

          }

          return this;

      },

      setFromCenterAndSize: function(center, size) {

          const halfSize = _vector$7.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(box) {

          this.min.copy(box.min);
          this.max.copy(box.max);

          return this;

      },

      makeEmpty: function() {

          this.min.x = this.min.y = +Infinity;
          this.max.x = this.max.y = -Infinity;

          return this;

      },

      isEmpty: function() {

          // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

          return (this.max.x < this.min.x) || (this.max.y < this.min.y);

      },

      getCenter: function(target) {

          if (target === undefined) {

              console.warn('THREE.Box2: .getCenter() target is now required');
              target = new Vector2();

          }

          return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);

      },

      getSize: function(target) {

          if (target === undefined) {

              console.warn('THREE.Box2: .getSize() target is now required');
              target = new Vector2();

          }

          return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);

      },

      expandByPoint: function(point) {

          this.min.min(point);
          this.max.max(point);

          return this;

      },

      expandByVector: function(vector) {

          this.min.sub(vector);
          this.max.add(vector);

          return this;

      },

      expandByScalar: function(scalar) {

          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);

          return this;

      },

      containsPoint: function(point) {

          return point.x < this.min.x || point.x > this.max.x ||
              point.y < this.min.y || point.y > this.max.y ? false : true;

      },

      containsBox: function(box) {

          return this.min.x <= box.min.x && box.max.x <= this.max.x &&
              this.min.y <= box.min.y && box.max.y <= this.max.y;

      },

      getParameter: function(point, target) {

          // This can potentially have a divide by zero if the box
          // has a size dimension of 0.

          if (target === undefined) {

              console.warn('THREE.Box2: .getParameter() target is now required');
              target = new Vector2();

          }

          return target.set(
              (point.x - this.min.x) / (this.max.x - this.min.x),
              (point.y - this.min.y) / (this.max.y - this.min.y)
          );

      },

      intersectsBox: function(box) {

          // using 4 splitting planes to rule out intersections

          return box.max.x < this.min.x || box.min.x > this.max.x ||
              box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

      },

      clampPoint: function(point, target) {

          if (target === undefined) {

              console.warn('THREE.Box2: .clampPoint() target is now required');
              target = new Vector2();

          }

          return target.copy(point).clamp(this.min, this.max);

      },

      distanceToPoint: function(point) {

          const clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();

      },

      intersect: function(box) {

          this.min.max(box.min);
          this.max.min(box.max);

          return this;

      },

      union: function(box) {

          this.min.min(box.min);
          this.max.max(box.max);

          return this;

      },

      translate: function(offset) {

          this.min.add(offset);
          this.max.add(offset);

          return this;

      },

      equals: function(box) {

          return box.min.equals(this.min) && box.max.equals(this.max);

      }

  });

  /**
   * @author bhouston / http://clara.io
   */

  const _startP = new Vector3();
  const _startEnd = new Vector3();

  function Line3(start, end) {

      this.start = (start !== undefined) ? start : new Vector3();
      this.end = (end !== undefined) ? end : new Vector3();

  }

  Object.assign(Line3.prototype, {

      set: function(start, end) {

          this.start.copy(start);
          this.end.copy(end);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      },

      copy: function(line) {

          this.start.copy(line.start);
          this.end.copy(line.end);

          return this;

      },

      getCenter: function(target) {

          if (target === undefined) {

              console.warn('THREE.Line3: .getCenter() target is now required');
              target = new Vector3();

          }

          return target.addVectors(this.start, this.end).multiplyScalar(0.5);

      },

      delta: function(target) {

          if (target === undefined) {

              console.warn('THREE.Line3: .delta() target is now required');
              target = new Vector3();

          }

          return target.subVectors(this.end, this.start);

      },

      distanceSq: function() {

          return this.start.distanceToSquared(this.end);

      },

      distance: function() {

          return this.start.distanceTo(this.end);

      },

      at: function(t, target) {

          if (target === undefined) {

              console.warn('THREE.Line3: .at() target is now required');
              target = new Vector3();

          }

          return this.delta(target).multiplyScalar(t).add(this.start);

      },

      closestPointToPointParameter: function(point, clampToLine) {

          _startP.subVectors(point, this.start);
          _startEnd.subVectors(this.end, this.start);

          const startEnd2 = _startEnd.dot(_startEnd);
          const startEnd_startP = _startEnd.dot(_startP);

          let t = startEnd_startP / startEnd2;

          if (clampToLine) {

              t = MathUtils.clamp(t, 0, 1);

          }

          return t;

      },

      closestPointToPoint: function(point, clampToLine, target) {

          const t = this.closestPointToPointParameter(point, clampToLine);

          if (target === undefined) {

              console.warn('THREE.Line3: .closestPointToPoint() target is now required');
              target = new Vector3();

          }

          return this.delta(target).multiplyScalar(t).add(this.start);

      },

      applyMatrix4: function(matrix) {

          this.start.applyMatrix4(matrix);
          this.end.applyMatrix4(matrix);

          return this;

      },

      equals: function(line) {

          return line.start.equals(this.start) && line.end.equals(this.end);

      }

  });

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function ImmediateRenderObject(material) {

      Object3D.call(this);

      this.material = material;
      this.render = function( /* renderCallback */ ) {};

      this.hasPositions = false;
      this.hasNormals = false;
      this.hasColors = false;
      this.hasUvs = false;

      this.positionArray = null;
      this.normalArray = null;
      this.colorArray = null;
      this.uvArray = null;

      this.count = 0;

  }

  ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

  ImmediateRenderObject.prototype.isImmediateRenderObject = true;

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  const _vector$8 = new Vector3();

  function SpotLightHelper(light, color) {

      Object3D.call(this);

      this.light = light;
      this.light.updateMatrixWorld();

      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;

      this.color = color;

      const geometry = new BufferGeometry();

      const positions = [
          0, 0, 0, 0, 0, 1,
          0, 0, 0, 1, 0, 1,
          0, 0, 0, -1, 0, 1,
          0, 0, 0, 0, 1, 1,
          0, 0, 0, 0, -1, 1
      ];

      for (let i = 0, j = 1, l = 32; i < l; i++, j++) {

          const p1 = (i / l) * Math.PI * 2;
          const p2 = (j / l) * Math.PI * 2;

          positions.push(
              Math.cos(p1), Math.sin(p1), 1,
              Math.cos(p2), Math.sin(p2), 1
          );

      }

      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));

      const material = new LineBasicMaterial({ fog: false, toneMapped: false });

      this.cone = new LineSegments(geometry, material);
      this.add(this.cone);

      this.update();

  }

  SpotLightHelper.prototype = Object.create(Object3D.prototype);
  SpotLightHelper.prototype.constructor = SpotLightHelper;

  SpotLightHelper.prototype.dispose = function() {

      this.cone.geometry.dispose();
      this.cone.material.dispose();

  };

  SpotLightHelper.prototype.update = function() {

      this.light.updateMatrixWorld();

      const coneLength = this.light.distance ? this.light.distance : 1000;
      const coneWidth = coneLength * Math.tan(this.light.angle);

      this.cone.scale.set(coneWidth, coneWidth, coneLength);

      _vector$8.setFromMatrixPosition(this.light.target.matrixWorld);

      this.cone.lookAt(_vector$8);

      if (this.color !== undefined) {

          this.cone.material.color.set(this.color);

      } else {

          this.cone.material.color.copy(this.light.color);

      }

  };

  /**
   * @author Sean Griffin / http://twitter.com/sgrif
   * @author Michael Guerrero / http://realitymeltdown.com
   * @author mrdoob / http://mrdoob.com/
   * @author ikerr / http://verold.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  const _vector$9 = new Vector3();
  const _boneMatrix = new Matrix4();
  const _matrixWorldInv = new Matrix4();

  function getBoneList(object) {

      const boneList = [];

      if (object && object.isBone) {

          boneList.push(object);

      }

      for (let i = 0; i < object.children.length; i++) {

          boneList.push.apply(boneList, getBoneList(object.children[i]));

      }

      return boneList;

  }

  function SkeletonHelper(object) {

      const bones = getBoneList(object);

      const geometry = new BufferGeometry();

      const vertices = [];
      const colors = [];

      const color1 = new Color(0, 0, 1);
      const color2 = new Color(0, 1, 0);

      for (let i = 0; i < bones.length; i++) {

          const bone = bones[i];

          if (bone.parent && bone.parent.isBone) {

              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);

          }

      }

      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));

      const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });

      LineSegments.call(this, geometry, material);

      this.type = 'SkeletonHelper';

      this.root = object;
      this.bones = bones;

      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;

  }

  SkeletonHelper.prototype = Object.create(LineSegments.prototype);
  SkeletonHelper.prototype.constructor = SkeletonHelper;

  SkeletonHelper.prototype.isSkeletonHelper = true;

  SkeletonHelper.prototype.updateMatrixWorld = function(force) {

      const bones = this.bones;

      const geometry = this.geometry;
      const position = geometry.getAttribute('position');

      _matrixWorldInv.getInverse(this.root.matrixWorld);

      for (let i = 0, j = 0; i < bones.length; i++) {

          const bone = bones[i];

          if (bone.parent && bone.parent.isBone) {

              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
              _vector$9.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);

              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
              _vector$9.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);

              j += 2;

          }

      }

      geometry.getAttribute('position').needsUpdate = true;

      Object3D.prototype.updateMatrixWorld.call(this, force);

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function PointLightHelper(light, sphereSize, color) {

      this.light = light;
      this.light.updateMatrixWorld();

      this.color = color;

      const geometry = new SphereBufferGeometry(sphereSize, 4, 2);
      const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });

      Mesh.call(this, geometry, material);

      this.type = 'PointLightHelper';

      this.matrix = this.light.matrixWorld;
      this.matrixAutoUpdate = false;

      this.update();


      /*
      const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
      const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

      this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
      this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

      const d = light.distance;

      if ( d === 0.0 ) {

      	this.lightDistance.visible = false;

      } else {

      	this.lightDistance.scale.set( d, d, d );

      }

      this.add( this.lightDistance );
      */

  }

  PointLightHelper.prototype = Object.create(Mesh.prototype);
  PointLightHelper.prototype.constructor = PointLightHelper;

  PointLightHelper.prototype.dispose = function() {

      this.geometry.dispose();
      this.material.dispose();

  };

  PointLightHelper.prototype.update = function() {

      if (this.color !== undefined) {

          this.material.color.set(this.color);

      } else {

          this.material.color.copy(this.light.color);

      }

      /*
      const d = this.light.distance;

      if ( d === 0.0 ) {

      	this.lightDistance.visible = false;

      } else {

      	this.lightDistance.visible = true;
      	this.lightDistance.scale.set( d, d, d );

      }
      */

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  const _vector$a = new Vector3();
  const _color1 = new Color();
  const _color2 = new Color();

  function HemisphereLightHelper(light, size, color) {

      Object3D.call(this);

      this.light = light;
      this.light.updateMatrixWorld();

      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;

      this.color = color;

      const geometry = new OctahedronBufferGeometry(size);
      geometry.rotateY(Math.PI * 0.5);

      this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
      if (this.color === undefined) this.material.vertexColors = true;

      const position = geometry.getAttribute('position');
      const colors = new Float32Array(position.count * 3);

      geometry.setAttribute('color', new BufferAttribute(colors, 3));

      this.add(new Mesh(geometry, this.material));

      this.update();

  }

  HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
  HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

  HemisphereLightHelper.prototype.dispose = function() {

      this.children[0].geometry.dispose();
      this.children[0].material.dispose();

  };

  HemisphereLightHelper.prototype.update = function() {

      const mesh = this.children[0];

      if (this.color !== undefined) {

          this.material.color.set(this.color);

      } else {

          const colors = mesh.geometry.getAttribute('color');

          _color1.copy(this.light.color);
          _color2.copy(this.light.groundColor);

          for (let i = 0, l = colors.count; i < l; i++) {

              const color = (i < (l / 2)) ? _color1 : _color2;

              colors.setXYZ(i, color.r, color.g, color.b);

          }

          colors.needsUpdate = true;

      }

      mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function GridHelper(size, divisions, color1, color2) {

      size = size || 10;
      divisions = divisions || 10;
      color1 = new Color(color1 !== undefined ? color1 : 0x444444);
      color2 = new Color(color2 !== undefined ? color2 : 0x888888);

      const center = divisions / 2;
      const step = size / divisions;
      const halfSize = size / 2;

      const vertices = [],
          colors = [];

      for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {

          vertices.push(-halfSize, 0, k, halfSize, 0, k);
          vertices.push(k, 0, -halfSize, k, 0, halfSize);

          const color = i === center ? color1 : color2;

          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;

      }

      const geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));

      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });

      LineSegments.call(this, geometry, material);

      this.type = 'GridHelper';

  }

  GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {

      constructor: GridHelper,

      copy: function(source) {

          LineSegments.prototype.copy.call(this, source);

          this.geometry.copy(source.geometry);
          this.material.copy(source.material);

          return this;

      },

      clone: function() {

          return new this.constructor().copy(this);

      }

  });

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   * @author Hectate / http://www.github.com/Hectate
   */

  function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {

      radius = radius || 10;
      radials = radials || 16;
      circles = circles || 8;
      divisions = divisions || 64;
      color1 = new Color(color1 !== undefined ? color1 : 0x444444);
      color2 = new Color(color2 !== undefined ? color2 : 0x888888);

      const vertices = [];
      const colors = [];

      // create the radials

      for (let i = 0; i <= radials; i++) {

          const v = (i / radials) * (Math.PI * 2);

          const x = Math.sin(v) * radius;
          const z = Math.cos(v) * radius;

          vertices.push(0, 0, 0);
          vertices.push(x, 0, z);

          const color = (i & 1) ? color1 : color2;

          colors.push(color.r, color.g, color.b);
          colors.push(color.r, color.g, color.b);

      }

      // create the circles

      for (let i = 0; i <= circles; i++) {

          const color = (i & 1) ? color1 : color2;

          const r = radius - (radius / circles * i);

          for (let j = 0; j < divisions; j++) {

              // first vertex

              let v = (j / divisions) * (Math.PI * 2);

              let x = Math.sin(v) * r;
              let z = Math.cos(v) * r;

              vertices.push(x, 0, z);
              colors.push(color.r, color.g, color.b);

              // second vertex

              v = ((j + 1) / divisions) * (Math.PI * 2);

              x = Math.sin(v) * r;
              z = Math.cos(v) * r;

              vertices.push(x, 0, z);
              colors.push(color.r, color.g, color.b);

          }

      }

      const geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));

      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });

      LineSegments.call(this, geometry, material);

      this.type = 'PolarGridHelper';

  }

  PolarGridHelper.prototype = Object.create(LineSegments.prototype);
  PolarGridHelper.prototype.constructor = PolarGridHelper;

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  const _v1$5 = new Vector3();
  const _v2$3 = new Vector3();
  const _v3$1 = new Vector3();

  function DirectionalLightHelper(light, size, color) {

      Object3D.call(this);

      this.light = light;
      this.light.updateMatrixWorld();

      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;

      this.color = color;

      if (size === undefined) size = 1;

      let geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0,
          size, size, 0,
          size, -size, 0, -size, -size, 0, -size, size, 0
      ], 3));

      const material = new LineBasicMaterial({ fog: false, toneMapped: false });

      this.lightPlane = new Line(geometry, material);
      this.add(this.lightPlane);

      geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

      this.targetLine = new Line(geometry, material);
      this.add(this.targetLine);

      this.update();

  }

  DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
  DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

  DirectionalLightHelper.prototype.dispose = function() {

      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();

  };

  DirectionalLightHelper.prototype.update = function() {

      _v1$5.setFromMatrixPosition(this.light.matrixWorld);
      _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
      _v3$1.subVectors(_v2$3, _v1$5);

      this.lightPlane.lookAt(_v2$3);

      if (this.color !== undefined) {

          this.lightPlane.material.color.set(this.color);
          this.targetLine.material.color.set(this.color);

      } else {

          this.lightPlane.material.color.copy(this.light.color);
          this.targetLine.material.color.copy(this.light.color);

      }

      this.targetLine.lookAt(_v2$3);
      this.targetLine.scale.z = _v3$1.length();

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author Mugen87 / https://github.com/Mugen87
   *
   *	- shows frustum, line of sight and up of the camera
   *	- suitable for fast updates
   * 	- based on frustum visualization in lightgl.js shadowmap example
   *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
   */

  const _vector$b = new Vector3();
  const _camera = new Camera();

  function CameraHelper(camera) {

      const geometry = new BufferGeometry();
      const material = new LineBasicMaterial({ color: 0xffffff, vertexColors: true, toneMapped: false });

      const vertices = [];
      const colors = [];

      const pointMap = {};

      // colors

      const colorFrustum = new Color(0xffaa00);
      const colorCone = new Color(0xff0000);
      const colorUp = new Color(0x00aaff);
      const colorTarget = new Color(0xffffff);
      const colorCross = new Color(0x333333);

      // near

      addLine('n1', 'n2', colorFrustum);
      addLine('n2', 'n4', colorFrustum);
      addLine('n4', 'n3', colorFrustum);
      addLine('n3', 'n1', colorFrustum);

      // far

      addLine('f1', 'f2', colorFrustum);
      addLine('f2', 'f4', colorFrustum);
      addLine('f4', 'f3', colorFrustum);
      addLine('f3', 'f1', colorFrustum);

      // sides

      addLine('n1', 'f1', colorFrustum);
      addLine('n2', 'f2', colorFrustum);
      addLine('n3', 'f3', colorFrustum);
      addLine('n4', 'f4', colorFrustum);

      // cone

      addLine('p', 'n1', colorCone);
      addLine('p', 'n2', colorCone);
      addLine('p', 'n3', colorCone);
      addLine('p', 'n4', colorCone);

      // up

      addLine('u1', 'u2', colorUp);
      addLine('u2', 'u3', colorUp);
      addLine('u3', 'u1', colorUp);

      // target

      addLine('c', 't', colorTarget);
      addLine('p', 'c', colorCross);

      // cross

      addLine('cn1', 'cn2', colorCross);
      addLine('cn3', 'cn4', colorCross);

      addLine('cf1', 'cf2', colorCross);
      addLine('cf3', 'cf4', colorCross);

      function addLine(a, b, color) {

          addPoint(a, color);
          addPoint(b, color);

      }

      function addPoint(id, color) {

          vertices.push(0, 0, 0);
          colors.push(color.r, color.g, color.b);

          if (pointMap[id] === undefined) {

              pointMap[id] = [];

          }

          pointMap[id].push((vertices.length / 3) - 1);

      }

      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));

      LineSegments.call(this, geometry, material);

      this.type = 'CameraHelper';

      this.camera = camera;
      if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();

      this.matrix = camera.matrixWorld;
      this.matrixAutoUpdate = false;

      this.pointMap = pointMap;

      this.update();

  }

  CameraHelper.prototype = Object.create(LineSegments.prototype);
  CameraHelper.prototype.constructor = CameraHelper;

  CameraHelper.prototype.update = function() {

      const geometry = this.geometry;
      const pointMap = this.pointMap;

      const w = 1,
          h = 1;

      // we need just camera projection matrix inverse
      // world matrix must be identity

      _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

      // center / target

      setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
      setPoint('t', pointMap, geometry, _camera, 0, 0, 1);

      // near

      setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
      setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
      setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
      setPoint('n4', pointMap, geometry, _camera, w, h, -1);

      // far

      setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
      setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
      setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
      setPoint('f4', pointMap, geometry, _camera, w, h, 1);

      // up

      setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
      setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
      setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);

      // cross

      setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
      setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
      setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
      setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);

      setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
      setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
      setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
      setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);

      geometry.getAttribute('position').needsUpdate = true;

  };

  function setPoint(point, pointMap, geometry, camera, x, y, z) {

      _vector$b.set(x, y, z).unproject(camera);

      const points = pointMap[point];

      if (points !== undefined) {

          const position = geometry.getAttribute('position');

          for (let i = 0, l = points.length; i < l; i++) {

              position.setXYZ(points[i], _vector$b.x, _vector$b.y, _vector$b.z);

          }

      }

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   */

  const _box$3 = new Box3();

  function BoxHelper(object, color) {

      this.object = object;

      if (color === undefined) color = 0xffff00;

      const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
      const positions = new Float32Array(8 * 3);

      const geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(indices, 1));
      geometry.setAttribute('position', new BufferAttribute(positions, 3));

      LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, toneMapped: false }));

      this.type = 'BoxHelper';

      this.matrixAutoUpdate = false;

      this.update();

  }

  BoxHelper.prototype = Object.create(LineSegments.prototype);
  BoxHelper.prototype.constructor = BoxHelper;

  BoxHelper.prototype.update = function(object) {

      if (object !== undefined) {

          console.warn('THREE.BoxHelper: .update() has no longer arguments.');

      }

      if (this.object !== undefined) {

          _box$3.setFromObject(this.object);

      }

      if (_box$3.isEmpty()) return;

      const min = _box$3.min;
      const max = _box$3.max;

      /*
        5____4
      1/___0/|
      | 6__|_7
      2/___3/

      0: max.x, max.y, max.z
      1: min.x, max.y, max.z
      2: min.x, min.y, max.z
      3: max.x, min.y, max.z
      4: max.x, max.y, min.z
      5: min.x, max.y, min.z
      6: min.x, min.y, min.z
      7: max.x, min.y, min.z
      */

      const position = this.geometry.attributes.position;
      const array = position.array;

      array[0] = max.x;
      array[1] = max.y;
      array[2] = max.z;
      array[3] = min.x;
      array[4] = max.y;
      array[5] = max.z;
      array[6] = min.x;
      array[7] = min.y;
      array[8] = max.z;
      array[9] = max.x;
      array[10] = min.y;
      array[11] = max.z;
      array[12] = max.x;
      array[13] = max.y;
      array[14] = min.z;
      array[15] = min.x;
      array[16] = max.y;
      array[17] = min.z;
      array[18] = min.x;
      array[19] = min.y;
      array[20] = min.z;
      array[21] = max.x;
      array[22] = min.y;
      array[23] = min.z;

      position.needsUpdate = true;

      this.geometry.computeBoundingSphere();


  };

  BoxHelper.prototype.setFromObject = function(object) {

      this.object = object;
      this.update();

      return this;

  };

  BoxHelper.prototype.copy = function(source) {

      LineSegments.prototype.copy.call(this, source);

      this.object = source.object;

      return this;

  };

  BoxHelper.prototype.clone = function() {

      return new this.constructor().copy(this);

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3Helper(box, color) {

      this.type = 'Box3Helper';

      this.box = box;

      color = color || 0xffff00;

      const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);

      const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];

      const geometry = new BufferGeometry();

      geometry.setIndex(new BufferAttribute(indices, 1));

      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));

      LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, toneMapped: false }));

      this.type = 'Box3Helper';

      this.geometry.computeBoundingSphere();

  }

  Box3Helper.prototype = Object.create(LineSegments.prototype);
  Box3Helper.prototype.constructor = Box3Helper;

  Box3Helper.prototype.updateMatrixWorld = function(force) {

      const box = this.box;

      if (box.isEmpty()) return;

      box.getCenter(this.position);

      box.getSize(this.scale);

      this.scale.multiplyScalar(0.5);

      Object3D.prototype.updateMatrixWorld.call(this, force);

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function PlaneHelper(plane, size, hex) {

      this.plane = plane;

      this.size = (size === undefined) ? 1 : size;

      const color = (hex !== undefined) ? hex : 0xffff00;

      const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];

      const geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
      geometry.computeBoundingSphere();

      Line.call(this, geometry, new LineBasicMaterial({ color: color, toneMapped: false }));

      this.type = 'PlaneHelper';

      //

      const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];

      const geometry2 = new BufferGeometry();
      geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
      geometry2.computeBoundingSphere();

      this.add(new Mesh(geometry2, new MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));

  }

  PlaneHelper.prototype = Object.create(Line.prototype);
  PlaneHelper.prototype.constructor = PlaneHelper;

  PlaneHelper.prototype.updateMatrixWorld = function(force) {

      let scale = -this.plane.constant;

      if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

      this.scale.set(0.5 * this.size, 0.5 * this.size, scale);

      this.children[0].material.side = (scale < 0) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

      this.lookAt(this.plane.normal);

      Object3D.prototype.updateMatrixWorld.call(this, force);

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author zz85 / http://github.com/zz85
   * @author bhouston / http://clara.io
   *
   * Creates an arrow for visualizing directions
   *
   * Parameters:
   *  dir - Vector3
   *  origin - Vector3
   *  length - Number
   *  color - color in hex value
   *  headLength - Number
   *  headWidth - Number
   */

  const _axis = new Vector3();
  let _lineGeometry, _coneGeometry;

  function ArrowHelper(dir, origin, length, color, headLength, headWidth) {

      // dir is assumed to be normalized

      Object3D.call(this);

      this.type = 'ArrowHelper';

      if (dir === undefined) dir = new Vector3(0, 0, 1);
      if (origin === undefined) origin = new Vector3(0, 0, 0);
      if (length === undefined) length = 1;
      if (color === undefined) color = 0xffff00;
      if (headLength === undefined) headLength = 0.2 * length;
      if (headWidth === undefined) headWidth = 0.2 * headLength;

      if (_lineGeometry === undefined) {

          _lineGeometry = new BufferGeometry();
          _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

          _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
          _coneGeometry.translate(0, -0.5, 0);

      }

      this.position.copy(origin);

      this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: color, toneMapped: false }));
      this.line.matrixAutoUpdate = false;
      this.add(this.line);

      this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: color, toneMapped: false }));
      this.cone.matrixAutoUpdate = false;
      this.add(this.cone);

      this.setDirection(dir);
      this.setLength(length, headLength, headWidth);

  }

  ArrowHelper.prototype = Object.create(Object3D.prototype);
  ArrowHelper.prototype.constructor = ArrowHelper;

  ArrowHelper.prototype.setDirection = function(dir) {

      // dir is assumed to be normalized

      if (dir.y > 0.99999) {

          this.quaternion.set(0, 0, 0, 1);

      } else if (dir.y < -0.99999) {

          this.quaternion.set(1, 0, 0, 0);

      } else {

          _axis.set(dir.z, 0, -dir.x).normalize();

          const radians = Math.acos(dir.y);

          this.quaternion.setFromAxisAngle(_axis, radians);

      }

  };

  ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {

      if (headLength === undefined) headLength = 0.2 * length;
      if (headWidth === undefined) headWidth = 0.2 * headLength;

      this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
      this.line.updateMatrix();

      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();

  };

  ArrowHelper.prototype.setColor = function(color) {

      this.line.material.color.set(color);
      this.cone.material.color.set(color);

  };

  ArrowHelper.prototype.copy = function(source) {

      Object3D.prototype.copy.call(this, source, false);

      this.line.copy(source.line);
      this.cone.copy(source.cone);

      return this;

  };

  ArrowHelper.prototype.clone = function() {

      return new this.constructor().copy(this);

  };

  /**
   * @author sroucheray / http://sroucheray.org/
   * @author mrdoob / http://mrdoob.com/
   */

  function AxesHelper(size) {

      size = size || 1;

      const vertices = [
          0, 0, 0, size, 0, 0,
          0, 0, 0, 0, size, 0,
          0, 0, 0, 0, 0, size
      ];

      const colors = [
          1, 0, 0, 1, 0.6, 0,
          0, 1, 0, 0.6, 1, 0,
          0, 0, 1, 0, 0.6, 1
      ];

      const geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));

      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });

      LineSegments.call(this, geometry, material);

      this.type = 'AxesHelper';

  }

  AxesHelper.prototype = Object.create(LineSegments.prototype);
  AxesHelper.prototype.constructor = AxesHelper;

  /**
   * @author Emmett Lalish / elalish
   *
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   */

  const LOD_MIN = 4;
  const LOD_MAX = 8;
  const SIZE_MAX = Math.pow(2, LOD_MAX);

  // The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];

  const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

  // The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  const MAX_SAMPLES = 20;

  const ENCODINGS = {
      [LinearEncoding]: 0,
      [sRGBEncoding]: 1,
      [RGBEEncoding]: 2,
      [RGBM7Encoding]: 3,
      [RGBM16Encoding]: 4,
      [RGBDEncoding]: 5,
      [GammaEncoding]: 6
  };

  const _flatCamera = new OrthographicCamera();
  const { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();
  let _oldTarget = null;

  // Golden Ratio
  const PHI = (1 + Math.sqrt(5)) / 2;
  const INV_PHI = 1 / PHI;

  // Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  const _axisDirections = [
      new Vector3(1, 1, 1),
      new Vector3(-1, 1, 1),
      new Vector3(1, 1, -1),
      new Vector3(-1, 1, -1),
      new Vector3(0, PHI, INV_PHI),
      new Vector3(0, PHI, -INV_PHI),
      new Vector3(INV_PHI, 0, PHI),
      new Vector3(-INV_PHI, 0, PHI),
      new Vector3(PHI, INV_PHI, 0),
      new Vector3(-PHI, INV_PHI, 0)
  ];

  function PMREMGenerator(renderer) {

      this._renderer = renderer;
      this._pingPongRenderTarget = null;

      this._blurMaterial = _getBlurShader(MAX_SAMPLES);
      this._equirectShader = null;
      this._cubemapShader = null;

      this._compileMaterial(this._blurMaterial);

  }

  PMREMGenerator.prototype = {

      constructor: PMREMGenerator,

      /**
       * Generates a PMREM from a supplied Scene, which can be faster than using an
       * image if networking bandwidth is low. Optional sigma specifies a blur radius
       * in radians to be applied to the scene before PMREM generation. Optional near
       * and far planes ensure the scene is rendered in its entirety (the cubeCamera
       * is placed at the origin).
       */
      fromScene: function(scene, sigma = 0, near = 0.1, far = 100) {

          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets();

          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {

              this._blur(cubeUVRenderTarget, 0, 0, sigma);

          }

          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);

          return cubeUVRenderTarget;

      },

      /**
       * Generates a PMREM from an equirectangular texture, which can be either LDR
       * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
       * as this matches best with the 256 x 256 cubemap output.
       */
      fromEquirectangular: function(equirectangular) {

          return this._fromTexture(equirectangular);

      },

      /**
       * Generates a PMREM from an cubemap texture, which can be either LDR
       * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
       * as this matches best with the 256 x 256 cubemap output.
       */
      fromCubemap: function(cubemap) {

          return this._fromTexture(cubemap);

      },

      /**
       * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
       * your texture's network fetch for increased concurrency.
       */
      compileCubemapShader: function() {

          if (this._cubemapShader === null) {

              this._cubemapShader = _getCubemapShader();
              this._compileMaterial(this._cubemapShader);

          }

      },

      /**
       * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
       * your texture's network fetch for increased concurrency.
       */
      compileEquirectangularShader: function() {

          if (this._equirectShader === null) {

              this._equirectShader = _getEquirectShader();
              this._compileMaterial(this._equirectShader);

          }

      },

      /**
       * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
       * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
       * one of them will cause any others to also become unusable.
       */
      dispose: function() {

          this._blurMaterial.dispose();

          if (this._cubemapShader !== null) this._cubemapShader.dispose();
          if (this._equirectShader !== null) this._equirectShader.dispose();

          for (let i = 0; i < _lodPlanes.length; i++) {

              _lodPlanes[i].dispose();

          }

      },

      // private interface

      _cleanup: function(outputTarget) {

          this._pingPongRenderTarget.dispose();
          this._renderer.setRenderTarget(_oldTarget);
          outputTarget.scissorTest = false;
          _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);

      },

      _fromTexture: function(texture) {

          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets(texture);
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);

          return cubeUVRenderTarget;

      },

      _allocateTargets: function(texture) { // warning: null texture is valid

          const params = {
              magFilter: NearestFilter,
              minFilter: NearestFilter,
              generateMipmaps: false,
              type: UnsignedByteType,
              format: RGBEFormat,
              encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
              depthBuffer: false,
              stencilBuffer: false
          };

          const cubeUVRenderTarget = _createRenderTarget(params);
          cubeUVRenderTarget.depthBuffer = texture ? false : true;
          this._pingPongRenderTarget = _createRenderTarget(params);
          return cubeUVRenderTarget;

      },

      _compileMaterial: function(material) {

          const tmpMesh = new Mesh(_lodPlanes[0], material);
          this._renderer.compile(tmpMesh, _flatCamera);

      },

      _sceneToCubeUV: function(scene, near, far, cubeUVRenderTarget) {

          const fov = 90;
          const aspect = 1;
          const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;

          const outputEncoding = renderer.outputEncoding;
          const toneMapping = renderer.toneMapping;
          const clearColor = renderer.getClearColor();
          const clearAlpha = renderer.getClearAlpha();

          renderer.toneMapping = NoToneMapping;
          renderer.outputEncoding = LinearEncoding;

          let background = scene.background;
          if (background && background.isColor) {

              background.convertSRGBToLinear();
              // Convert linear to RGBE
              const maxComponent = Math.max(background.r, background.g, background.b);
              const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
              background = background.multiplyScalar(Math.pow(2.0, -fExp));
              const alpha = (fExp + 128.0) / 255.0;
              renderer.setClearColor(background, alpha);
              scene.background = null;

          }

          for (let i = 0; i < 6; i++) {

              const col = i % 3;
              if (col == 0) {

                  cubeCamera.up.set(0, upSign[i], 0);
                  cubeCamera.lookAt(forwardSign[i], 0, 0);

              } else if (col == 1) {

                  cubeCamera.up.set(0, 0, upSign[i]);
                  cubeCamera.lookAt(0, forwardSign[i], 0);

              } else {

                  cubeCamera.up.set(0, upSign[i], 0);
                  cubeCamera.lookAt(0, 0, forwardSign[i]);

              }

              _setViewport(cubeUVRenderTarget,
                  col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
              renderer.setRenderTarget(cubeUVRenderTarget);
              renderer.render(scene, cubeCamera);

          }

          renderer.toneMapping = toneMapping;
          renderer.outputEncoding = outputEncoding;
          renderer.setClearColor(clearColor, clearAlpha);

      },

      _textureToCubeUV: function(texture, cubeUVRenderTarget) {

          const renderer = this._renderer;

          if (texture.isCubeTexture) {

              if (this._cubemapShader == null) {

                  this._cubemapShader = _getCubemapShader();

              }

          } else {

              if (this._equirectShader == null) {

                  this._equirectShader = _getEquirectShader();

              }

          }

          const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
          const mesh = new Mesh(_lodPlanes[0], material);

          const uniforms = material.uniforms;

          uniforms['envMap'].value = texture;

          if (!texture.isCubeTexture) {

              uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);

          }

          uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
          uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

          _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera);

      },

      _applyPMREM: function(cubeUVRenderTarget) {

          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;

          for (let i = 1; i < TOTAL_LODS; i++) {

              const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);

              const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

              this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);

          }

          renderer.autoClear = autoClear;

      },

      /**
       * This is a two-pass Gaussian blur for a cubemap. Normally this is done
       * vertically and horizontally, but this breaks down on a cube. Here we apply
       * the blur latitudinally (around the poles), and then longitudinally (towards
       * the poles) to approximate the orthogonally-separable blur. It is least
       * accurate at the poles, but still does a decent job.
       */
      _blur: function(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {

          const pingPongRenderTarget = this._pingPongRenderTarget;

          this._halfBlur(
              cubeUVRenderTarget,
              pingPongRenderTarget,
              lodIn,
              lodOut,
              sigma,
              'latitudinal',
              poleAxis);

          this._halfBlur(
              pingPongRenderTarget,
              cubeUVRenderTarget,
              lodOut,
              lodOut,
              sigma,
              'longitudinal',
              poleAxis);

      },

      _halfBlur: function(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {

          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;

          if (direction !== 'latitudinal' && direction !== 'longitudinal') {

              console.error(
                  'blur direction must be either latitudinal or longitudinal!');

          }

          // Number of standard deviations at which to cut off the discrete approximation.
          const STANDARD_DEVIATIONS = 3;

          const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;

          const pixels = _sizeLods[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

          if (samples > MAX_SAMPLES) {

              console.warn(`sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}`);

          }

          const weights = [];
          let sum = 0;

          for (let i = 0; i < MAX_SAMPLES; ++i) {

              const x = i / sigmaPixels;
              const weight = Math.exp(-x * x / 2);
              weights.push(weight);

              if (i == 0) {

                  sum += weight;

              } else if (i < samples) {

                  sum += 2 * weight;

              }

          }

          for (let i = 0; i < weights.length; i++) {

              weights[i] = weights[i] / sum;

          }

          blurUniforms['envMap'].value = targetIn.texture;
          blurUniforms['samples'].value = samples;
          blurUniforms['weights'].value = weights;
          blurUniforms['latitudinal'].value = direction === 'latitudinal';

          if (poleAxis) {

              blurUniforms['poleAxis'].value = poleAxis;

          }

          blurUniforms['dTheta'].value = radiansPerPixel;
          blurUniforms['mipInt'].value = LOD_MAX - lodIn;
          blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
          blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];

          const outputSize = _sizeLods[lodOut];
          const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
          const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

          _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera);

      }

  };

  function _isLDR(texture) {

      if (texture === undefined || texture.type !== UnsignedByteType) return false;

      return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;

  }

  function _createPlanes() {

      const _lodPlanes = [];
      const _sizeLods = [];
      const _sigmas = [];

      let lod = LOD_MAX;

      for (let i = 0; i < TOTAL_LODS; i++) {

          const sizeLod = Math.pow(2, lod);
          _sizeLods.push(sizeLod);
          let sigma = 1.0 / sizeLod;

          if (i > LOD_MAX - LOD_MIN) {

              sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];

          } else if (i == 0) {

              sigma = 0;

          }

          _sigmas.push(sigma);

          const texelSize = 1.0 / (sizeLod - 1);
          const min = -texelSize / 2;
          const max = 1 + texelSize / 2;
          const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];

          const cubeFaces = 6;
          const vertices = 6;
          const positionSize = 3;
          const uvSize = 2;
          const faceIndexSize = 1;

          const position = new Float32Array(positionSize * vertices * cubeFaces);
          const uv = new Float32Array(uvSize * vertices * cubeFaces);
          const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

          for (let face = 0; face < cubeFaces; face++) {

              const x = (face % 3) * 2 / 3 - 1;
              const y = face > 2 ? 0 : -1;
              const coordinates = [
                  x, y, 0,
                  x + 2 / 3, y, 0,
                  x + 2 / 3, y + 1, 0,
                  x, y, 0,
                  x + 2 / 3, y + 1, 0,
                  x, y + 1, 0
              ];
              position.set(coordinates, positionSize * vertices * face);
              uv.set(uv1, uvSize * vertices * face);
              const fill = [face, face, face, face, face, face];
              faceIndex.set(fill, faceIndexSize * vertices * face);

          }

          const planes = new BufferGeometry();
          planes.setAttribute('position', new BufferAttribute(position, positionSize));
          planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
          planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
          _lodPlanes.push(planes);

          if (lod > LOD_MIN) {

              lod--;

          }

      }

      return { _lodPlanes, _sizeLods, _sigmas };

  }

  function _createRenderTarget(params) {

      const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
      cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
      cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
      cubeUVRenderTarget.scissorTest = true;
      return cubeUVRenderTarget;

  }

  function _setViewport(target, x, y, width, height) {

      target.viewport.set(x, y, width, height);
      target.scissor.set(x, y, width, height);

  }

  function _getBlurShader(maxSamples) {

      const weights = new Float32Array(maxSamples);
      const poleAxis = new Vector3(0, 1, 0);
      const shaderMaterial = new RawShaderMaterial({

          name: 'SphericalGaussianBlur',

          defines: { 'n': maxSamples },

          uniforms: {
              'envMap': { value: null },
              'samples': { value: 1 },
              'weights': { value: weights },
              'latitudinal': { value: false },
              'dTheta': { value: 0 },
              'mipInt': { value: 0 },
              'poleAxis': { value: poleAxis },
              'inputEncoding': { value: ENCODINGS[LinearEncoding] },
              'outputEncoding': { value: ENCODINGS[LinearEncoding] }
          },

          vertexShader: _getCommonVertexShader(),

          fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

vec3 getSample(float theta, vec3 axis) {
	float cosTheta = cos(theta);
	// Rodrigues' axis-angle rotation
	vec3 sampleDirection = vOutputDirection * cosTheta
		+ cross(axis, vOutputDirection) * sin(theta)
		+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
	return bilinearCubeUV(envMap, sampleDirection, mipInt);
}

void main() {
	vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
	if (all(equal(axis, vec3(0.0))))
		axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);
	axis = normalize(axis);
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb += weights[0] * getSample(0.0, axis);
	for (int i = 1; i < n; i++) {
		if (i >= samples)
			break;
		float theta = dTheta * float(i);
		gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);
		gl_FragColor.rgb += weights[i] * getSample(theta, axis);
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

          blending: NoBlending,
          depthTest: false,
          depthWrite: false

      });

      return shaderMaterial;

  }

  function _getEquirectShader() {

      const texelSize = new Vector2(1, 1);
      const shaderMaterial = new RawShaderMaterial({

          name: 'EquirectangularToCubeUV',

          uniforms: {
              'envMap': { value: null },
              'texelSize': { value: texelSize },
              'inputEncoding': { value: ENCODINGS[LinearEncoding] },
              'outputEncoding': { value: ENCODINGS[LinearEncoding] }
          },

          vertexShader: _getCommonVertexShader(),

          fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#include <common>

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv = equirectUv( outputDirection );
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

          blending: NoBlending,
          depthTest: false,
          depthWrite: false

      });

      return shaderMaterial;

  }

  function _getCubemapShader() {

      const shaderMaterial = new RawShaderMaterial({

          name: 'CubemapToCubeUV',

          uniforms: {
              'envMap': { value: null },
              'inputEncoding': { value: ENCODINGS[LinearEncoding] },
              'outputEncoding': { value: ENCODINGS[LinearEncoding] }
          },

          vertexShader: _getCommonVertexShader(),

          fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

          blending: NoBlending,
          depthTest: false,
          depthWrite: false

      });

      return shaderMaterial;

  }

  function _getCommonVertexShader() {

      return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;

// RH coordinate system; PMREM face-indexing convention
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx; // ( 1, v, u ) pos x
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.xz *= -1.0; // ( -u, 1, -v ) pos y
	} else if (face == 2.0) {
		direction.x *= -1.0; // ( -u, v, 1 ) pos z
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.xz *= -1.0; // ( -1, v, -u ) neg x
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.xy *= -1.0; // ( -u, -1, v ) neg y
	} else if (face == 5.0) {
		direction.z *= -1.0; // ( u, v, -1 ) neg z
	}
	return direction;
}

void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;

  }

  function _getEncodings() {

      return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Face4(a, b, c, d, normal, color, materialIndex) {

      console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
      return new Face3(a, b, c, normal, color, materialIndex);

  }

  const LineStrip = 0;
  const LinePieces = 1;
  const NoColors = 0;
  const FaceColors = 1;
  const VertexColors = 2;

  function MeshFaceMaterial(materials) {

      console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
      return materials;

  }

  function MultiMaterial(materials) {

      if (materials === undefined) materials = [];

      console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
      materials.isMultiMaterial = true;
      materials.materials = materials;
      materials.clone = function() {

          return materials.slice();

      };

      return materials;

  }

  function PointCloud(geometry, material) {

      console.warn('THREE.PointCloud has been renamed to THREE.Points.');
      return new Points(geometry, material);

  }

  function Particle(material) {

      console.warn('THREE.Particle has been renamed to THREE.Sprite.');
      return new Sprite(material);

  }

  function ParticleSystem(geometry, material) {

      console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
      return new Points(geometry, material);

  }

  function PointCloudMaterial(parameters) {

      console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
      return new PointsMaterial(parameters);

  }

  function ParticleBasicMaterial(parameters) {

      console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
      return new PointsMaterial(parameters);

  }

  function ParticleSystemMaterial(parameters) {

      console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
      return new PointsMaterial(parameters);

  }

  function Vertex(x, y, z) {

      console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
      return new Vector3(x, y, z);

  }

  //

  function DynamicBufferAttribute(array, itemSize) {

      console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
      return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);

  }

  function Int8Attribute(array, itemSize) {

      console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
      return new Int8BufferAttribute(array, itemSize);

  }

  function Uint8Attribute(array, itemSize) {

      console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
      return new Uint8BufferAttribute(array, itemSize);

  }

  function Uint8ClampedAttribute(array, itemSize) {

      console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
      return new Uint8ClampedBufferAttribute(array, itemSize);

  }

  function Int16Attribute(array, itemSize) {

      console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
      return new Int16BufferAttribute(array, itemSize);

  }

  function Uint16Attribute(array, itemSize) {

      console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
      return new Uint16BufferAttribute(array, itemSize);

  }

  function Int32Attribute(array, itemSize) {

      console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
      return new Int32BufferAttribute(array, itemSize);

  }

  function Uint32Attribute(array, itemSize) {

      console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
      return new Uint32BufferAttribute(array, itemSize);

  }

  function Float32Attribute(array, itemSize) {

      console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
      return new Float32BufferAttribute(array, itemSize);

  }

  function Float64Attribute(array, itemSize) {

      console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
      return new Float64BufferAttribute(array, itemSize);

  }

  //

  Curve.create = function(construct, getPoint) {

      console.log('THREE.Curve.create() has been deprecated');

      construct.prototype = Object.create(Curve.prototype);
      construct.prototype.constructor = construct;
      construct.prototype.getPoint = getPoint;

      return construct;

  };

  //

  Object.assign(CurvePath.prototype, {

      createPointsGeometry: function(divisions) {

          console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

          // generate geometry from path points (for Line or Points objects)

          const pts = this.getPoints(divisions);
          return this.createGeometry(pts);

      },

      createSpacedPointsGeometry: function(divisions) {

          console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

          // generate geometry from equidistant sampling along the path

          const pts = this.getSpacedPoints(divisions);
          return this.createGeometry(pts);

      },

      createGeometry: function(points) {

          console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

          const geometry = new Geometry();

          for (let i = 0, l = points.length; i < l; i++) {

              const point = points[i];
              geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));

          }

          return geometry;

      }

  });

  //

  Object.assign(Path.prototype, {

      fromPoints: function(points) {

          console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
          return this.setFromPoints(points);

      }

  });

  //

  function ClosedSplineCurve3(points) {

      console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

      CatmullRomCurve3.call(this, points);
      this.type = 'catmullrom';
      this.closed = true;

  }

  ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

  //

  function SplineCurve3(points) {

      console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

      CatmullRomCurve3.call(this, points);
      this.type = 'catmullrom';

  }

  SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

  //

  function Spline(points) {

      console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');

      CatmullRomCurve3.call(this, points);
      this.type = 'catmullrom';

  }

  Spline.prototype = Object.create(CatmullRomCurve3.prototype);

  Object.assign(Spline.prototype, {

      initFromArray: function( /* a */ ) {

          console.error('THREE.Spline: .initFromArray() has been removed.');

      },
      getControlPointsArray: function( /* optionalTarget */ ) {

          console.error('THREE.Spline: .getControlPointsArray() has been removed.');

      },
      reparametrizeByArcLength: function( /* samplingCoef */ ) {

          console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');

      }

  });

  //

  function AxisHelper(size) {

      console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
      return new AxesHelper(size);

  }

  function BoundingBoxHelper(object, color) {

      console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
      return new BoxHelper(object, color);

  }

  function EdgesHelper(object, hex) {

      console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
      return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));

  }

  GridHelper.prototype.setColors = function() {

      console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');

  };

  SkeletonHelper.prototype.update = function() {

      console.error('THREE.SkeletonHelper: update() no longer needs to be called.');

  };

  function WireframeHelper(object, hex) {

      console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
      return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));

  }

  //

  Object.assign(Loader.prototype, {

      extractUrlBase: function(url) {

          console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
          return LoaderUtils.extractUrlBase(url);

      }

  });

  Loader.Handlers = {

      add: function( /* regex, loader */ ) {

          console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');

      },

      get: function( /* file */ ) {

          console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');

      }

  };

  function XHRLoader(manager) {

      console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
      return new FileLoader(manager);

  }

  function BinaryTextureLoader(manager) {

      console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
      return new DataTextureLoader(manager);

  }

  Object.assign(ObjectLoader.prototype, {

      setTexturePath: function(value) {

          console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
          return this.setResourcePath(value);

      }

  });

  //

  Object.assign(Box2.prototype, {

      center: function(optionalTarget) {

          console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
          return this.getCenter(optionalTarget);

      },
      empty: function() {

          console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
          return this.isEmpty();

      },
      isIntersectionBox: function(box) {

          console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
          return this.intersectsBox(box);

      },
      size: function(optionalTarget) {

          console.warn('THREE.Box2: .size() has been renamed to .getSize().');
          return this.getSize(optionalTarget);

      }
  });

  Object.assign(Box3.prototype, {

      center: function(optionalTarget) {

          console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
          return this.getCenter(optionalTarget);

      },
      empty: function() {

          console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
          return this.isEmpty();

      },
      isIntersectionBox: function(box) {

          console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
          return this.intersectsBox(box);

      },
      isIntersectionSphere: function(sphere) {

          console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
          return this.intersectsSphere(sphere);

      },
      size: function(optionalTarget) {

          console.warn('THREE.Box3: .size() has been renamed to .getSize().');
          return this.getSize(optionalTarget);

      }
  });

  Object.assign(Sphere.prototype, {

      empty: function() {

          console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
          return this.isEmpty();

      },

  });

  Frustum.prototype.setFromMatrix = function(m) {

      console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
      return this.setFromProjectionMatrix(m);

  };

  Line3.prototype.center = function(optionalTarget) {

      console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
      return this.getCenter(optionalTarget);

  };

  Object.assign(MathUtils, {

      random16: function() {

          console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
          return Math.random();

      },

      nearestPowerOfTwo: function(value) {

          console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
          return MathUtils.floorPowerOfTwo(value);

      },

      nextPowerOfTwo: function(value) {

          console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
          return MathUtils.ceilPowerOfTwo(value);

      }

  });

  Object.assign(Matrix3.prototype, {

      flattenToArrayOffset: function(array, offset) {

          console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
          return this.toArray(array, offset);

      },
      multiplyVector3: function(vector) {

          console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
          return vector.applyMatrix3(this);

      },
      multiplyVector3Array: function( /* a */ ) {

          console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');

      },
      applyToBufferAttribute: function(attribute) {

          console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
          return attribute.applyMatrix3(this);

      },
      applyToVector3Array: function( /* array, offset, length */ ) {

          console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');

      }

  });

  Object.assign(Matrix4.prototype, {

      extractPosition: function(m) {

          console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
          return this.copyPosition(m);

      },
      flattenToArrayOffset: function(array, offset) {

          console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
          return this.toArray(array, offset);

      },
      getPosition: function() {

          console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
          return new Vector3().setFromMatrixColumn(this, 3);

      },
      setRotationFromQuaternion: function(q) {

          console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
          return this.makeRotationFromQuaternion(q);

      },
      multiplyToArray: function() {

          console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');

      },
      multiplyVector3: function(vector) {

          console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
          return vector.applyMatrix4(this);

      },
      multiplyVector4: function(vector) {

          console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
          return vector.applyMatrix4(this);

      },
      multiplyVector3Array: function( /* a */ ) {

          console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');

      },
      rotateAxis: function(v) {

          console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
          v.transformDirection(this);

      },
      crossVector: function(vector) {

          console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
          return vector.applyMatrix4(this);

      },
      translate: function() {

          console.error('THREE.Matrix4: .translate() has been removed.');

      },
      rotateX: function() {

          console.error('THREE.Matrix4: .rotateX() has been removed.');

      },
      rotateY: function() {

          console.error('THREE.Matrix4: .rotateY() has been removed.');

      },
      rotateZ: function() {

          console.error('THREE.Matrix4: .rotateZ() has been removed.');

      },
      rotateByAxis: function() {

          console.error('THREE.Matrix4: .rotateByAxis() has been removed.');

      },
      applyToBufferAttribute: function(attribute) {

          console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
          return attribute.applyMatrix4(this);

      },
      applyToVector3Array: function( /* array, offset, length */ ) {

          console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');

      },
      makeFrustum: function(left, right, bottom, top, near, far) {

          console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
          return this.makePerspective(left, right, top, bottom, near, far);

      }

  });

  Plane.prototype.isIntersectionLine = function(line) {

      console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
      return this.intersectsLine(line);

  };

  Quaternion.prototype.multiplyVector3 = function(vector) {

      console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
      return vector.applyQuaternion(this);

  };

  Object.assign(Ray.prototype, {

      isIntersectionBox: function(box) {

          console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
          return this.intersectsBox(box);

      },
      isIntersectionPlane: function(plane) {

          console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
          return this.intersectsPlane(plane);

      },
      isIntersectionSphere: function(sphere) {

          console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
          return this.intersectsSphere(sphere);

      }

  });

  Object.assign(Triangle.prototype, {

      area: function() {

          console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
          return this.getArea();

      },
      barycoordFromPoint: function(point, target) {

          console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
          return this.getBarycoord(point, target);

      },
      midpoint: function(target) {

          console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
          return this.getMidpoint(target);

      },
      normal: function(target) {

          console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
          return this.getNormal(target);

      },
      plane: function(target) {

          console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
          return this.getPlane(target);

      }

  });

  Object.assign(Triangle, {

      barycoordFromPoint: function(point, a, b, c, target) {

          console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
          return Triangle.getBarycoord(point, a, b, c, target);

      },
      normal: function(a, b, c, target) {

          console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
          return Triangle.getNormal(a, b, c, target);

      }

  });

  Object.assign(Shape.prototype, {

      extractAllPoints: function(divisions) {

          console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
          return this.extractPoints(divisions);

      },
      extrude: function(options) {

          console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
          return new ExtrudeGeometry(this, options);

      },
      makeGeometry: function(options) {

          console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
          return new ShapeGeometry(this, options);

      }

  });

  Object.assign(Vector2.prototype, {

      fromAttribute: function(attribute, index, offset) {

          console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
          return this.fromBufferAttribute(attribute, index, offset);

      },
      distanceToManhattan: function(v) {

          console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
          return this.manhattanDistanceTo(v);

      },
      lengthManhattan: function() {

          console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
          return this.manhattanLength();

      }

  });

  Object.assign(Vector3.prototype, {

      setEulerFromRotationMatrix: function() {

          console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');

      },
      setEulerFromQuaternion: function() {

          console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');

      },
      getPositionFromMatrix: function(m) {

          console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
          return this.setFromMatrixPosition(m);

      },
      getScaleFromMatrix: function(m) {

          console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
          return this.setFromMatrixScale(m);

      },
      getColumnFromMatrix: function(index, matrix) {

          console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
          return this.setFromMatrixColumn(matrix, index);

      },
      applyProjection: function(m) {

          console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
          return this.applyMatrix4(m);

      },
      fromAttribute: function(attribute, index, offset) {

          console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
          return this.fromBufferAttribute(attribute, index, offset);

      },
      distanceToManhattan: function(v) {

          console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
          return this.manhattanDistanceTo(v);

      },
      lengthManhattan: function() {

          console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
          return this.manhattanLength();

      }

  });

  Object.assign(Vector4.prototype, {

      fromAttribute: function(attribute, index, offset) {

          console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
          return this.fromBufferAttribute(attribute, index, offset);

      },
      lengthManhattan: function() {

          console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
          return this.manhattanLength();

      }

  });

  //

  Object.assign(Geometry.prototype, {

      computeTangents: function() {

          console.error('THREE.Geometry: .computeTangents() has been removed.');

      },
      computeLineDistances: function() {

          console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');

      },
      applyMatrix: function(matrix) {

          console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');
          return this.applyMatrix4(matrix);

      }

  });

  Object.assign(Object3D.prototype, {

      getChildByName: function(name) {

          console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
          return this.getObjectByName(name);

      },
      renderDepth: function() {

          console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');

      },
      translate: function(distance, axis) {

          console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
          return this.translateOnAxis(axis, distance);

      },
      getWorldRotation: function() {

          console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');

      },
      applyMatrix: function(matrix) {

          console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
          return this.applyMatrix4(matrix);

      }

  });

  Object.defineProperties(Object3D.prototype, {

      eulerOrder: {
          get: function() {

              console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
              return this.rotation.order;

          },
          set: function(value) {

              console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
              this.rotation.order = value;

          }
      },
      useQuaternion: {
          get: function() {

              console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');

          },
          set: function() {

              console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');

          }
      }

  });

  Object.assign(Mesh.prototype, {

      setDrawMode: function() {

          console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');

      },

  });

  Object.defineProperties(Mesh.prototype, {

      drawMode: {
          get: function() {

              console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
              return TrianglesDrawMode;

          },
          set: function() {

              console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');

          }
      }

  });

  Object.defineProperties(LOD.prototype, {

      objects: {
          get: function() {

              console.warn('THREE.LOD: .objects has been renamed to .levels.');
              return this.levels;

          }
      }

  });

  Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {

      get: function() {

          console.warn('THREE.Skeleton: useVertexTexture has been removed.');

      },
      set: function() {

          console.warn('THREE.Skeleton: useVertexTexture has been removed.');

      }

  });

  SkinnedMesh.prototype.initBones = function() {

      console.error('THREE.SkinnedMesh: initBones() has been removed.');

  };

  Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {

      get: function() {

          console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
          return this.arcLengthDivisions;

      },
      set: function(value) {

          console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
          this.arcLengthDivisions = value;

      }

  });

  //

  PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {

      console.warn("THREE.PerspectiveCamera.setLens is deprecated. " +
          "Use .setFocalLength and .filmGauge for a photographic setup.");

      if (filmGauge !== undefined) this.filmGauge = filmGauge;
      this.setFocalLength(focalLength);

  };

  //

  Object.defineProperties(Light.prototype, {
      onlyShadow: {
          set: function() {

              console.warn('THREE.Light: .onlyShadow has been removed.');

          }
      },
      shadowCameraFov: {
          set: function(value) {

              console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
              this.shadow.camera.fov = value;

          }
      },
      shadowCameraLeft: {
          set: function(value) {

              console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
              this.shadow.camera.left = value;

          }
      },
      shadowCameraRight: {
          set: function(value) {

              console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
              this.shadow.camera.right = value;

          }
      },
      shadowCameraTop: {
          set: function(value) {

              console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
              this.shadow.camera.top = value;

          }
      },
      shadowCameraBottom: {
          set: function(value) {

              console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
              this.shadow.camera.bottom = value;

          }
      },
      shadowCameraNear: {
          set: function(value) {

              console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
              this.shadow.camera.near = value;

          }
      },
      shadowCameraFar: {
          set: function(value) {

              console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
              this.shadow.camera.far = value;

          }
      },
      shadowCameraVisible: {
          set: function() {

              console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');

          }
      },
      shadowBias: {
          set: function(value) {

              console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
              this.shadow.bias = value;

          }
      },
      shadowDarkness: {
          set: function() {

              console.warn('THREE.Light: .shadowDarkness has been removed.');

          }
      },
      shadowMapWidth: {
          set: function(value) {

              console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
              this.shadow.mapSize.width = value;

          }
      },
      shadowMapHeight: {
          set: function(value) {

              console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
              this.shadow.mapSize.height = value;

          }
      }
  });

  //

  Object.defineProperties(BufferAttribute.prototype, {

      length: {
          get: function() {

              console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
              return this.array.length;

          }
      },
      dynamic: {
          get: function() {

              console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
              return this.usage === DynamicDrawUsage;

          },
          set: function( /* value */ ) {

              console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
              this.setUsage(DynamicDrawUsage);

          }
      }

  });

  Object.assign(BufferAttribute.prototype, {
      setDynamic: function(value) {

          console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
          this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
          return this;

      },
      copyIndicesArray: function( /* indices */ ) {

          console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');

      },
      setArray: function( /* array */ ) {

          console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');

      }
  });

  Object.assign(BufferGeometry.prototype, {

      addIndex: function(index) {

          console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
          this.setIndex(index);

      },
      addAttribute: function(name, attribute) {

          console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

          if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {

              console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');

              return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));

          }

          if (name === 'index') {

              console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
              this.setIndex(attribute);

              return this;

          }

          return this.setAttribute(name, attribute);

      },
      addDrawCall: function(start, count, indexOffset) {

          if (indexOffset !== undefined) {

              console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');

          }

          console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
          this.addGroup(start, count);

      },
      clearDrawCalls: function() {

          console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
          this.clearGroups();

      },
      computeTangents: function() {

          console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');

      },
      computeOffsets: function() {

          console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');

      },
      removeAttribute: function(name) {

          console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');

          return this.deleteAttribute(name);

      },
      applyMatrix: function(matrix) {

          console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
          return this.applyMatrix4(matrix);

      }

  });

  Object.defineProperties(BufferGeometry.prototype, {

      drawcalls: {
          get: function() {

              console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
              return this.groups;

          }
      },
      offsets: {
          get: function() {

              console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
              return this.groups;

          }
      }

  });

  Object.defineProperties(InstancedBufferGeometry.prototype, {

      maxInstancedCount: {
          get: function() {

              console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
              return this.instanceCount;

          },
          set: function(value) {

              console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
              this.instanceCount = value;

          }
      }

  });

  Object.defineProperties(Raycaster.prototype, {

      linePrecision: {
          get: function() {

              console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
              return this.params.Line.threshold;

          },
          set: function(value) {

              console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
              this.params.Line.threshold = value;

          }
      }

  });

  Object.defineProperties(InterleavedBuffer.prototype, {

      dynamic: {
          get: function() {

              console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
              return this.usage === DynamicDrawUsage;

          },
          set: function(value) {

              console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
              this.setUsage(value);

          }
      }

  });

  Object.assign(InterleavedBuffer.prototype, {
      setDynamic: function(value) {

          console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
          this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
          return this;

      },
      setArray: function( /* array */ ) {

          console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');

      }
  });

  //

  Object.assign(ExtrudeBufferGeometry.prototype, {

      getArrays: function() {

          console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');

      },

      addShapeList: function() {

          console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');

      },

      addShape: function() {

          console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');

      }

  });

  //

  Object.defineProperties(Uniform.prototype, {

      dynamic: {
          set: function() {

              console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');

          }
      },
      onUpdate: {
          value: function() {

              console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
              return this;

          }
      }

  });

  //

  Object.defineProperties(Material.prototype, {

      wrapAround: {
          get: function() {

              console.warn('THREE.Material: .wrapAround has been removed.');

          },
          set: function() {

              console.warn('THREE.Material: .wrapAround has been removed.');

          }
      },

      overdraw: {
          get: function() {

              console.warn('THREE.Material: .overdraw has been removed.');

          },
          set: function() {

              console.warn('THREE.Material: .overdraw has been removed.');

          }
      },

      wrapRGB: {
          get: function() {

              console.warn('THREE.Material: .wrapRGB has been removed.');
              return new Color();

          }
      },

      shading: {
          get: function() {

              console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');

          },
          set: function(value) {

              console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
              this.flatShading = (value === FlatShading);

          }
      },

      stencilMask: {
          get: function() {

              console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
              return this.stencilFuncMask;

          },
          set: function(value) {

              console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
              this.stencilFuncMask = value;

          }
      }

  });

  Object.defineProperties(MeshPhongMaterial.prototype, {

      metal: {
          get: function() {

              console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
              return false;

          },
          set: function() {

              console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');

          }
      }

  });

  Object.defineProperties(ShaderMaterial.prototype, {

      derivatives: {
          get: function() {

              console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
              return this.extensions.derivatives;

          },
          set: function(value) {

              console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
              this.extensions.derivatives = value;

          }
      }

  });

  //

  Object.assign(WebGLRenderer.prototype, {

      clearTarget: function(renderTarget, color, depth, stencil) {

          console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
          this.setRenderTarget(renderTarget);
          this.clear(color, depth, stencil);

      },
      animate: function(callback) {

          console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
          this.setAnimationLoop(callback);

      },
      getCurrentRenderTarget: function() {

          console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
          return this.getRenderTarget();

      },
      getMaxAnisotropy: function() {

          console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
          return this.capabilities.getMaxAnisotropy();

      },
      getPrecision: function() {

          console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
          return this.capabilities.precision;

      },
      resetGLState: function() {

          console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
          return this.state.reset();

      },
      supportsFloatTextures: function() {

          console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
          return this.extensions.get('OES_texture_float');

      },
      supportsHalfFloatTextures: function() {

          console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
          return this.extensions.get('OES_texture_half_float');

      },
      supportsStandardDerivatives: function() {

          console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
          return this.extensions.get('OES_standard_derivatives');

      },
      supportsCompressedTextureS3TC: function() {

          console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
          return this.extensions.get('WEBGL_compressed_texture_s3tc');

      },
      supportsCompressedTexturePVRTC: function() {

          console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
          return this.extensions.get('WEBGL_compressed_texture_pvrtc');

      },
      supportsBlendMinMax: function() {

          console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
          return this.extensions.get('EXT_blend_minmax');

      },
      supportsVertexTextures: function() {

          console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
          return this.capabilities.vertexTextures;

      },
      supportsInstancedArrays: function() {

          console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
          return this.extensions.get('ANGLE_instanced_arrays');

      },
      enableScissorTest: function(boolean) {

          console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
          this.setScissorTest(boolean);

      },
      initMaterial: function() {

          console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');

      },
      addPrePlugin: function() {

          console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');

      },
      addPostPlugin: function() {

          console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');

      },
      updateShadowMap: function() {

          console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');

      },
      setFaceCulling: function() {

          console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');

      },
      allocTextureUnit: function() {

          console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');

      },
      setTexture: function() {

          console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');

      },
      setTexture2D: function() {

          console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');

      },
      setTextureCube: function() {

          console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');

      },
      getActiveMipMapLevel: function() {

          console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
          return this.getActiveMipmapLevel();

      }

  });

  Object.defineProperties(WebGLRenderer.prototype, {

      shadowMapEnabled: {
          get: function() {

              return this.shadowMap.enabled;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
              this.shadowMap.enabled = value;

          }
      },
      shadowMapType: {
          get: function() {

              return this.shadowMap.type;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
              this.shadowMap.type = value;

          }
      },
      shadowMapCullFace: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
              return undefined;

          },
          set: function( /* value */ ) {

              console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');

          }
      },
      context: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
              return this.getContext();

          }
      },
      vr: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
              return this.xr;

          }
      },
      gammaInput: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
              return false;

          },
          set: function() {

              console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');

          }
      },
      gammaOutput: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
              return false;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
              this.outputEncoding = (value === true) ? sRGBEncoding : LinearEncoding;

          }
      },
      toneMappingWhitePoint: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
              return 1.0;

          },
          set: function() {

              console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');

          }
      },

  });

  Object.defineProperties(WebGLShadowMap.prototype, {

      cullFace: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
              return undefined;

          },
          set: function( /* cullFace */ ) {

              console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');

          }
      },
      renderReverseSided: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
              return undefined;

          },
          set: function() {

              console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');

          }
      },
      renderSingleSided: {
          get: function() {

              console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
              return undefined;

          },
          set: function() {

              console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');

          }
      }

  });

  function WebGLRenderTargetCube(width, height, options) {

      console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
      return new WebGLCubeRenderTarget(width, options);

  }

  //

  Object.defineProperties(WebGLRenderTarget.prototype, {

      wrapS: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
              return this.texture.wrapS;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
              this.texture.wrapS = value;

          }
      },
      wrapT: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
              return this.texture.wrapT;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
              this.texture.wrapT = value;

          }
      },
      magFilter: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
              return this.texture.magFilter;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
              this.texture.magFilter = value;

          }
      },
      minFilter: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
              return this.texture.minFilter;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
              this.texture.minFilter = value;

          }
      },
      anisotropy: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
              return this.texture.anisotropy;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
              this.texture.anisotropy = value;

          }
      },
      offset: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
              return this.texture.offset;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
              this.texture.offset = value;

          }
      },
      repeat: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
              return this.texture.repeat;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
              this.texture.repeat = value;

          }
      },
      format: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
              return this.texture.format;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
              this.texture.format = value;

          }
      },
      type: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
              return this.texture.type;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
              this.texture.type = value;

          }
      },
      generateMipmaps: {
          get: function() {

              console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
              return this.texture.generateMipmaps;

          },
          set: function(value) {

              console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
              this.texture.generateMipmaps = value;

          }
      }

  });

  //

  Object.defineProperties(Audio.prototype, {

      load: {
          value: function(file) {

              console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
              const scope = this;
              const audioLoader = new AudioLoader();
              audioLoader.load(file, function(buffer) {

                  scope.setBuffer(buffer);

              });
              return this;

          }
      },
      startTime: {
          set: function() {

              console.warn('THREE.Audio: .startTime is now .play( delay ).');

          }
      }

  });

  AudioAnalyser.prototype.getData = function() {

      console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
      return this.getFrequencyData();

  };

  //

  CubeCamera.prototype.updateCubeMap = function(renderer, scene) {

      console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
      return this.update(renderer, scene);

  };

  //

  const GeometryUtils = {

      merge: function(geometry1, geometry2, materialIndexOffset) {

          console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
          let matrix;

          if (geometry2.isMesh) {

              geometry2.matrixAutoUpdate && geometry2.updateMatrix();

              matrix = geometry2.matrix;
              geometry2 = geometry2.geometry;

          }

          geometry1.merge(geometry2, matrix, materialIndexOffset);

      },

      center: function(geometry) {

          console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
          return geometry.center();

      }

  };

  ImageUtils.crossOrigin = undefined;

  ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {

      console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');

      const loader = new TextureLoader();
      loader.setCrossOrigin(this.crossOrigin);

      const texture = loader.load(url, onLoad, undefined, onError);

      if (mapping) texture.mapping = mapping;

      return texture;

  };

  ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {

      console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');

      const loader = new CubeTextureLoader();
      loader.setCrossOrigin(this.crossOrigin);

      const texture = loader.load(urls, onLoad, undefined, onError);

      if (mapping) texture.mapping = mapping;

      return texture;

  };

  ImageUtils.loadCompressedTexture = function() {

      console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');

  };

  ImageUtils.loadCompressedTextureCube = function() {

      console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');

  };

  //

  function CanvasRenderer() {

      console.error('THREE.CanvasRenderer has been removed');

  }

  //

  function JSONLoader() {

      console.error('THREE.JSONLoader has been removed.');

  }

  //

  const SceneUtils = {

      createMultiMaterialObject: function( /* geometry, materials */ ) {

          console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');

      },

      detach: function( /* child, parent, scene */ ) {

          console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');

      },

      attach: function( /* child, scene, parent */ ) {

          console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');

      }

  };

  //

  function LensFlare() {

      console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');

  }

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

      /* eslint-disable no-undef */
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
          detail: {
              revision: REVISION,
          }
      }));
      /* eslint-enable no-undef */

  }

  var three_module = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACESFilmicToneMapping: ACESFilmicToneMapping,
    AddEquation: AddEquation,
    AddOperation: AddOperation,
    AdditiveAnimationBlendMode: AdditiveAnimationBlendMode,
    AdditiveBlending: AdditiveBlending,
    AlphaFormat: AlphaFormat,
    AlwaysDepth: AlwaysDepth,
    AlwaysStencilFunc: AlwaysStencilFunc,
    AmbientLight: AmbientLight,
    AmbientLightProbe: AmbientLightProbe,
    AnimationClip: AnimationClip,
    AnimationLoader: AnimationLoader,
    AnimationMixer: AnimationMixer,
    AnimationObjectGroup: AnimationObjectGroup,
    AnimationUtils: AnimationUtils,
    ArcCurve: ArcCurve,
    ArrayCamera: ArrayCamera,
    ArrowHelper: ArrowHelper,
    Audio: Audio,
    AudioAnalyser: AudioAnalyser,
    AudioContext: AudioContext,
    AudioListener: AudioListener,
    AudioLoader: AudioLoader,
    AxesHelper: AxesHelper,
    AxisHelper: AxisHelper,
    BackSide: BackSide,
    BasicDepthPacking: BasicDepthPacking,
    BasicShadowMap: BasicShadowMap,
    BinaryTextureLoader: BinaryTextureLoader,
    Bone: Bone,
    BooleanKeyframeTrack: BooleanKeyframeTrack,
    BoundingBoxHelper: BoundingBoxHelper,
    Box2: Box2,
    Box3: Box3,
    Box3Helper: Box3Helper,
    BoxBufferGeometry: BoxBufferGeometry,
    BoxGeometry: BoxGeometry,
    BoxHelper: BoxHelper,
    BufferAttribute: BufferAttribute,
    BufferGeometry: BufferGeometry,
    BufferGeometryLoader: BufferGeometryLoader,
    ByteType: ByteType,
    Cache: Cache,
    Camera: Camera,
    CameraHelper: CameraHelper,
    CanvasRenderer: CanvasRenderer,
    CanvasTexture: CanvasTexture,
    CatmullRomCurve3: CatmullRomCurve3,
    CineonToneMapping: CineonToneMapping,
    CircleBufferGeometry: CircleBufferGeometry,
    CircleGeometry: CircleGeometry,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    Clock: Clock,
    ClosedSplineCurve3: ClosedSplineCurve3,
    Color: Color,
    ColorKeyframeTrack: ColorKeyframeTrack,
    CompressedTexture: CompressedTexture,
    CompressedTextureLoader: CompressedTextureLoader,
    ConeBufferGeometry: ConeBufferGeometry,
    ConeGeometry: ConeGeometry,
    CubeCamera: CubeCamera,
    CubeGeometry: BoxGeometry,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    CubeTexture: CubeTexture,
    CubeTextureLoader: CubeTextureLoader,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    CubicInterpolant: CubicInterpolant,
    CullFaceBack: CullFaceBack,
    CullFaceFront: CullFaceFront,
    CullFaceFrontBack: CullFaceFrontBack,
    CullFaceNone: CullFaceNone,
    Curve: Curve,
    CurvePath: CurvePath,
    CustomBlending: CustomBlending,
    CustomToneMapping: CustomToneMapping,
    CylinderBufferGeometry: CylinderBufferGeometry,
    CylinderGeometry: CylinderGeometry,
    Cylindrical: Cylindrical,
    DataTexture: DataTexture,
    DataTexture2DArray: DataTexture2DArray,
    DataTexture3D: DataTexture3D,
    DataTextureLoader: DataTextureLoader,
    DecrementStencilOp: DecrementStencilOp,
    DecrementWrapStencilOp: DecrementWrapStencilOp,
    DefaultLoadingManager: DefaultLoadingManager,
    DepthFormat: DepthFormat,
    DepthStencilFormat: DepthStencilFormat,
    DepthTexture: DepthTexture,
    DirectionalLight: DirectionalLight,
    DirectionalLightHelper: DirectionalLightHelper,
    DirectionalLightShadow: DirectionalLightShadow,
    DiscreteInterpolant: DiscreteInterpolant,
    DodecahedronBufferGeometry: DodecahedronBufferGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    DoubleSide: DoubleSide,
    DstAlphaFactor: DstAlphaFactor,
    DstColorFactor: DstColorFactor,
    DynamicBufferAttribute: DynamicBufferAttribute,
    DynamicCopyUsage: DynamicCopyUsage,
    DynamicDrawUsage: DynamicDrawUsage,
    DynamicReadUsage: DynamicReadUsage,
    EdgesGeometry: EdgesGeometry,
    EdgesHelper: EdgesHelper,
    EllipseCurve: EllipseCurve,
    EqualDepth: EqualDepth,
    EqualStencilFunc: EqualStencilFunc,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    Euler: Euler,
    EventDispatcher: EventDispatcher,
    ExtrudeBufferGeometry: ExtrudeBufferGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    Face3: Face3,
    Face4: Face4,
    FaceColors: FaceColors,
    FileLoader: FileLoader,
    FlatShading: FlatShading,
    Float32Attribute: Float32Attribute,
    Float32BufferAttribute: Float32BufferAttribute,
    Float64Attribute: Float64Attribute,
    Float64BufferAttribute: Float64BufferAttribute,
    FloatType: FloatType,
    Fog: Fog,
    FogExp2: FogExp2,
    Font: Font,
    FontLoader: FontLoader,
    FrontFaceDirectionCCW: FrontFaceDirectionCCW,
    FrontFaceDirectionCW: FrontFaceDirectionCW,
    FrontSide: FrontSide,
    Frustum: Frustum,
    GammaEncoding: GammaEncoding,
    Geometry: Geometry,
    GeometryUtils: GeometryUtils,
    GreaterDepth: GreaterDepth,
    GreaterEqualDepth: GreaterEqualDepth,
    GreaterEqualStencilFunc: GreaterEqualStencilFunc,
    GreaterStencilFunc: GreaterStencilFunc,
    GridHelper: GridHelper,
    Group: Group,
    HalfFloatType: HalfFloatType,
    HemisphereLight: HemisphereLight,
    HemisphereLightHelper: HemisphereLightHelper,
    HemisphereLightProbe: HemisphereLightProbe,
    IcosahedronBufferGeometry: IcosahedronBufferGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    ImageBitmapLoader: ImageBitmapLoader,
    ImageLoader: ImageLoader,
    ImageUtils: ImageUtils,
    ImmediateRenderObject: ImmediateRenderObject,
    IncrementStencilOp: IncrementStencilOp,
    IncrementWrapStencilOp: IncrementWrapStencilOp,
    InstancedBufferAttribute: InstancedBufferAttribute,
    InstancedBufferGeometry: InstancedBufferGeometry,
    InstancedInterleavedBuffer: InstancedInterleavedBuffer,
    InstancedMesh: InstancedMesh,
    Int16Attribute: Int16Attribute,
    Int16BufferAttribute: Int16BufferAttribute,
    Int32Attribute: Int32Attribute,
    Int32BufferAttribute: Int32BufferAttribute,
    Int8Attribute: Int8Attribute,
    Int8BufferAttribute: Int8BufferAttribute,
    IntType: IntType,
    InterleavedBuffer: InterleavedBuffer,
    InterleavedBufferAttribute: InterleavedBufferAttribute,
    Interpolant: Interpolant,
    InterpolateDiscrete: InterpolateDiscrete,
    InterpolateLinear: InterpolateLinear,
    InterpolateSmooth: InterpolateSmooth,
    InvertStencilOp: InvertStencilOp,
    JSONLoader: JSONLoader,
    KeepStencilOp: KeepStencilOp,
    KeyframeTrack: KeyframeTrack,
    LOD: LOD,
    LatheBufferGeometry: LatheBufferGeometry,
    LatheGeometry: LatheGeometry,
    Layers: Layers,
    LensFlare: LensFlare,
    LessDepth: LessDepth,
    LessEqualDepth: LessEqualDepth,
    LessEqualStencilFunc: LessEqualStencilFunc,
    LessStencilFunc: LessStencilFunc,
    Light: Light,
    LightProbe: LightProbe,
    LightShadow: LightShadow,
    Line: Line,
    Line3: Line3,
    LineBasicMaterial: LineBasicMaterial,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    LineDashedMaterial: LineDashedMaterial,
    LineLoop: LineLoop,
    LinePieces: LinePieces,
    LineSegments: LineSegments,
    LineStrip: LineStrip,
    LinearEncoding: LinearEncoding,
    LinearFilter: LinearFilter,
    LinearInterpolant: LinearInterpolant,
    LinearMipMapLinearFilter: LinearMipMapLinearFilter,
    LinearMipMapNearestFilter: LinearMipMapNearestFilter,
    LinearMipmapLinearFilter: LinearMipmapLinearFilter,
    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
    LinearToneMapping: LinearToneMapping,
    Loader: Loader,
    LoaderUtils: LoaderUtils,
    LoadingManager: LoadingManager,
    LogLuvEncoding: LogLuvEncoding,
    LoopOnce: LoopOnce,
    LoopPingPong: LoopPingPong,
    LoopRepeat: LoopRepeat,
    LuminanceAlphaFormat: LuminanceAlphaFormat,
    LuminanceFormat: LuminanceFormat,
    MOUSE: MOUSE,
    Material: Material,
    MaterialLoader: MaterialLoader,
    Math: MathUtils,
    MathUtils: MathUtils,
    Matrix3: Matrix3,
    Matrix4: Matrix4,
    MaxEquation: MaxEquation,
    Mesh: Mesh,
    MeshBasicMaterial: MeshBasicMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshFaceMaterial: MeshFaceMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshMatcapMaterial: MeshMatcapMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MinEquation: MinEquation,
    MirroredRepeatWrapping: MirroredRepeatWrapping,
    MixOperation: MixOperation,
    MultiMaterial: MultiMaterial,
    MultiplyBlending: MultiplyBlending,
    MultiplyOperation: MultiplyOperation,
    NearestFilter: NearestFilter,
    NearestMipMapLinearFilter: NearestMipMapLinearFilter,
    NearestMipMapNearestFilter: NearestMipMapNearestFilter,
    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
    NeverDepth: NeverDepth,
    NeverStencilFunc: NeverStencilFunc,
    NoBlending: NoBlending,
    NoColors: NoColors,
    NoToneMapping: NoToneMapping,
    NormalAnimationBlendMode: NormalAnimationBlendMode,
    NormalBlending: NormalBlending,
    NotEqualDepth: NotEqualDepth,
    NotEqualStencilFunc: NotEqualStencilFunc,
    NumberKeyframeTrack: NumberKeyframeTrack,
    Object3D: Object3D,
    ObjectLoader: ObjectLoader,
    ObjectSpaceNormalMap: ObjectSpaceNormalMap,
    OctahedronBufferGeometry: OctahedronBufferGeometry,
    OctahedronGeometry: OctahedronGeometry,
    OneFactor: OneFactor,
    OneMinusDstAlphaFactor: OneMinusDstAlphaFactor,
    OneMinusDstColorFactor: OneMinusDstColorFactor,
    OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor,
    OneMinusSrcColorFactor: OneMinusSrcColorFactor,
    OrthographicCamera: OrthographicCamera,
    PCFShadowMap: PCFShadowMap,
    PCFSoftShadowMap: PCFSoftShadowMap,
    PMREMGenerator: PMREMGenerator,
    ParametricBufferGeometry: ParametricBufferGeometry,
    ParametricGeometry: ParametricGeometry,
    Particle: Particle,
    ParticleBasicMaterial: ParticleBasicMaterial,
    ParticleSystem: ParticleSystem,
    ParticleSystemMaterial: ParticleSystemMaterial,
    Path: Path,
    PerspectiveCamera: PerspectiveCamera,
    Plane: Plane,
    PlaneBufferGeometry: PlaneBufferGeometry,
    PlaneGeometry: PlaneGeometry,
    PlaneHelper: PlaneHelper,
    PointCloud: PointCloud,
    PointCloudMaterial: PointCloudMaterial,
    PointLight: PointLight,
    PointLightHelper: PointLightHelper,
    Points: Points,
    PointsMaterial: PointsMaterial,
    PolarGridHelper: PolarGridHelper,
    PolyhedronBufferGeometry: PolyhedronBufferGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    PositionalAudio: PositionalAudio,
    PropertyBinding: PropertyBinding,
    PropertyMixer: PropertyMixer,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    Quaternion: Quaternion,
    QuaternionKeyframeTrack: QuaternionKeyframeTrack,
    QuaternionLinearInterpolant: QuaternionLinearInterpolant,
    REVISION: REVISION,
    RGBADepthPacking: RGBADepthPacking,
    RGBAFormat: RGBAFormat,
    RGBAIntegerFormat: RGBAIntegerFormat,
    RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,
    RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,
    RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,
    RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,
    RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,
    RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,
    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
    RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,
    RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,
    RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,
    RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,
    RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,
    RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,
    RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,
    RGBA_BPTC_Format: RGBA_BPTC_Format,
    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
    RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,
    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
    RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
    RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,
    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
    RGBDEncoding: RGBDEncoding,
    RGBEEncoding: RGBEEncoding,
    RGBEFormat: RGBEFormat,
    RGBFormat: RGBFormat,
    RGBIntegerFormat: RGBIntegerFormat,
    RGBM16Encoding: RGBM16Encoding,
    RGBM7Encoding: RGBM7Encoding,
    RGB_ETC1_Format: RGB_ETC1_Format,
    RGB_ETC2_Format: RGB_ETC2_Format,
    RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,
    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,
    RGFormat: RGFormat,
    RGIntegerFormat: RGIntegerFormat,
    RawShaderMaterial: RawShaderMaterial,
    Ray: Ray,
    Raycaster: Raycaster,
    RectAreaLight: RectAreaLight,
    RedFormat: RedFormat,
    RedIntegerFormat: RedIntegerFormat,
    ReinhardToneMapping: ReinhardToneMapping,
    RepeatWrapping: RepeatWrapping,
    ReplaceStencilOp: ReplaceStencilOp,
    ReverseSubtractEquation: ReverseSubtractEquation,
    RingBufferGeometry: RingBufferGeometry,
    RingGeometry: RingGeometry,
    SRGB8_ALPHA8_ASTC_10x10_Format: SRGB8_ALPHA8_ASTC_10x10_Format,
    SRGB8_ALPHA8_ASTC_10x5_Format: SRGB8_ALPHA8_ASTC_10x5_Format,
    SRGB8_ALPHA8_ASTC_10x6_Format: SRGB8_ALPHA8_ASTC_10x6_Format,
    SRGB8_ALPHA8_ASTC_10x8_Format: SRGB8_ALPHA8_ASTC_10x8_Format,
    SRGB8_ALPHA8_ASTC_12x10_Format: SRGB8_ALPHA8_ASTC_12x10_Format,
    SRGB8_ALPHA8_ASTC_12x12_Format: SRGB8_ALPHA8_ASTC_12x12_Format,
    SRGB8_ALPHA8_ASTC_4x4_Format: SRGB8_ALPHA8_ASTC_4x4_Format,
    SRGB8_ALPHA8_ASTC_5x4_Format: SRGB8_ALPHA8_ASTC_5x4_Format,
    SRGB8_ALPHA8_ASTC_5x5_Format: SRGB8_ALPHA8_ASTC_5x5_Format,
    SRGB8_ALPHA8_ASTC_6x5_Format: SRGB8_ALPHA8_ASTC_6x5_Format,
    SRGB8_ALPHA8_ASTC_6x6_Format: SRGB8_ALPHA8_ASTC_6x6_Format,
    SRGB8_ALPHA8_ASTC_8x5_Format: SRGB8_ALPHA8_ASTC_8x5_Format,
    SRGB8_ALPHA8_ASTC_8x6_Format: SRGB8_ALPHA8_ASTC_8x6_Format,
    SRGB8_ALPHA8_ASTC_8x8_Format: SRGB8_ALPHA8_ASTC_8x8_Format,
    Scene: Scene,
    SceneUtils: SceneUtils,
    ShaderChunk: ShaderChunk,
    ShaderLib: ShaderLib,
    ShaderMaterial: ShaderMaterial,
    ShadowMaterial: ShadowMaterial,
    Shape: Shape,
    ShapeBufferGeometry: ShapeBufferGeometry,
    ShapeGeometry: ShapeGeometry,
    ShapePath: ShapePath,
    ShapeUtils: ShapeUtils,
    ShortType: ShortType,
    Skeleton: Skeleton,
    SkeletonHelper: SkeletonHelper,
    SkinnedMesh: SkinnedMesh,
    SmoothShading: SmoothShading,
    Sphere: Sphere,
    SphereBufferGeometry: SphereBufferGeometry,
    SphereGeometry: SphereGeometry,
    Spherical: Spherical,
    SphericalHarmonics3: SphericalHarmonics3,
    Spline: Spline,
    SplineCurve: SplineCurve,
    SplineCurve3: SplineCurve3,
    SpotLight: SpotLight,
    SpotLightHelper: SpotLightHelper,
    SpotLightShadow: SpotLightShadow,
    Sprite: Sprite,
    SpriteMaterial: SpriteMaterial,
    SrcAlphaFactor: SrcAlphaFactor,
    SrcAlphaSaturateFactor: SrcAlphaSaturateFactor,
    SrcColorFactor: SrcColorFactor,
    StaticCopyUsage: StaticCopyUsage,
    StaticDrawUsage: StaticDrawUsage,
    StaticReadUsage: StaticReadUsage,
    StereoCamera: StereoCamera,
    StreamCopyUsage: StreamCopyUsage,
    StreamDrawUsage: StreamDrawUsage,
    StreamReadUsage: StreamReadUsage,
    StringKeyframeTrack: StringKeyframeTrack,
    SubtractEquation: SubtractEquation,
    SubtractiveBlending: SubtractiveBlending,
    TOUCH: TOUCH,
    TangentSpaceNormalMap: TangentSpaceNormalMap,
    TetrahedronBufferGeometry: TetrahedronBufferGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TextBufferGeometry: TextBufferGeometry,
    TextGeometry: TextGeometry,
    Texture: Texture,
    TextureLoader: TextureLoader,
    TorusBufferGeometry: TorusBufferGeometry,
    TorusGeometry: TorusGeometry,
    TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    Triangle: Triangle,
    TriangleFanDrawMode: TriangleFanDrawMode,
    TriangleStripDrawMode: TriangleStripDrawMode,
    TrianglesDrawMode: TrianglesDrawMode,
    TubeBufferGeometry: TubeBufferGeometry,
    TubeGeometry: TubeGeometry,
    UVMapping: UVMapping,
    Uint16Attribute: Uint16Attribute,
    Uint16BufferAttribute: Uint16BufferAttribute,
    Uint32Attribute: Uint32Attribute,
    Uint32BufferAttribute: Uint32BufferAttribute,
    Uint8Attribute: Uint8Attribute,
    Uint8BufferAttribute: Uint8BufferAttribute,
    Uint8ClampedAttribute: Uint8ClampedAttribute,
    Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute,
    Uniform: Uniform,
    UniformsLib: UniformsLib,
    UniformsUtils: UniformsUtils,
    UnsignedByteType: UnsignedByteType,
    UnsignedInt248Type: UnsignedInt248Type,
    UnsignedIntType: UnsignedIntType,
    UnsignedShort4444Type: UnsignedShort4444Type,
    UnsignedShort5551Type: UnsignedShort5551Type,
    UnsignedShort565Type: UnsignedShort565Type,
    UnsignedShortType: UnsignedShortType,
    VSMShadowMap: VSMShadowMap,
    Vector2: Vector2,
    Vector3: Vector3,
    Vector4: Vector4,
    VectorKeyframeTrack: VectorKeyframeTrack,
    Vertex: Vertex,
    VertexColors: VertexColors,
    VideoTexture: VideoTexture,
    WebGL1Renderer: WebGL1Renderer,
    WebGLCubeRenderTarget: WebGLCubeRenderTarget,
    WebGLMultisampleRenderTarget: WebGLMultisampleRenderTarget,
    WebGLRenderTarget: WebGLRenderTarget,
    WebGLRenderTargetCube: WebGLRenderTargetCube,
    WebGLRenderer: WebGLRenderer,
    WebGLUtils: WebGLUtils,
    WireframeGeometry: WireframeGeometry,
    WireframeHelper: WireframeHelper,
    WrapAroundEnding: WrapAroundEnding,
    XHRLoader: XHRLoader,
    ZeroCurvatureEnding: ZeroCurvatureEnding,
    ZeroFactor: ZeroFactor,
    ZeroSlopeEnding: ZeroSlopeEnding,
    ZeroStencilOp: ZeroStencilOp,
    sRGBEncoding: sRGBEncoding
  });

  var COLINEAR = intersectResult('colinear');
  var PARALLEL = intersectResult('parallel');
  var NONE = intersectResult('none');
  /**
  * Check how two line segments intersect eachother. Line segments are represented
  * as (x1, y1)-(x2, y2) and (x3, y3)-(x4, y4).
  *
  * @param {number} x1
  * @param {number} y1
  * @param {number} x2
  * @param {number} y2
  * @param {number} x3
  * @param {number} y3
  * @param {number} x4
  * @param {number} y4
  * @return {object} Object describing intersection that looks like
  *    {
  *      type: none|parallel|colinear|intersecting,
  *      point: {x, y} - only defined when type == intersecting
  *    }
  */

  function checkIntersection$1(x1, y1, x2, y2, x3, y3, x4, y4) {
    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

    if (denom == 0) {
      if (numeA == 0 && numeB == 0) {
        return COLINEAR;
      }

      return PARALLEL;
    }

    var uA = numeA / denom;
    var uB = numeB / denom;

    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
      return intersecting({
        x: x1 + uA * (x2 - x1),
        y: y1 + uA * (y2 - y1)
      });
    }

    return NONE;
  }

  function intersecting(point) {
    var result = intersectResult('intersecting');
    result.point = point;
    return result;
  }

  function intersectResult(type) {
    return {
      type: type
    };
  }

  var Utils = function () {
  	function Utils() {
  		classCallCheck(this, Utils);
  	}

  	createClass(Utils, null, [{
  		key: 'pointDistanceFromLine',

  		/** Determines the distance of a point from a line.
     * @param point The Point coordinates as THREE.Vector2
     * @param start The starting coordinates of the line as THREE.Vector2
     * @param end The ending coordinates of the line as THREE.Vector2
     * @returns The distance value (number).
     */
  		value: function pointDistanceFromLine(point, start, end) {
  			var tPoint = Utils.closestPointOnLine(point, start, end);
  			var tDx = point.x - tPoint.x;
  			var tDy = point.y - tPoint.y;
  			return Math.sqrt(tDx * tDx + tDy * tDy);
  		}

  		/** Gets the projection of a point onto a line.
     * @param point the point
     * @param start the starting coordinates of the line as THREE.Vector2
     * @param end the ending coordinates of the line as THREE.Vector2
     * @returns The point as THREE.Vector2.
     */

  	}, {
  		key: 'closestPointOnLine',
  		value: function closestPointOnLine(point, start, end) {
  			// Inspired by: http://stackoverflow.com/a/6853926
  			var tA = point.x - start.x;
  			var tB = point.y - start.y;
  			var tC = end.x - start.x;
  			var tD = end.y - start.y;

  			var tDot = tA * tC + tB * tD;
  			var tLenSq = tC * tC + tD * tD;
  			var tParam = tDot / tLenSq;

  			var tXx, tYy;

  			if (tParam < 0 || start.x == end.x && start.y == end.y) {
  				tXx = start.x;
  				tYy = start.y;
  			} else if (tParam > 1) {
  				tXx = end.x;
  				tYy = end.y;
  			} else {
  				tXx = start.x + tParam * tC;
  				tYy = start.y + tParam * tD;
  			}

  			return new Vector2(tXx, tYy);
  		}

  		/** Gets the distance of two points.
     * @param start the starting coordinate of the line as Vector2
     * @param end the ending coordinate of the line as Vector2
     * @returns The distance.
     */

  	}, {
  		key: 'distance',
  		value: function distance(start, end) {
  			return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
  		}

  		/**  Gets the angle between point1 -> start and 0,0 -> point2 (-pi to pi)
     * @returns The angle.
     */

  	}, {
  		key: 'angle',
  		value: function angle(start, end) {
  			var tDot = start.x * end.x + start.y * end.y;
  			var tDet = start.x * end.y - start.y * end.x;
  			var tAngle = -Math.atan2(tDet, tDot);
  			return tAngle;
  		}

  		/** shifts angle to be 0 to 2pi */

  	}, {
  		key: 'angle2pi',
  		value: function angle2pi(start, end) {
  			var tTheta = Utils.angle(start, end);
  			if (tTheta < 0) {
  				tTheta += 2.0 * Math.PI;
  			}
  			return tTheta;
  		}

  		/** shifts angle to be 0 to 2pi */

  	}, {
  		key: 'getCyclicOrder',
  		value: function getCyclicOrder(points) {
  			var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  			if (!start) {
  				start = new Vector2(0, 0);
  			}
  			var angles = [];
  			for (var i = 0; i < points.length; i++) {
  				var point = points[i];
  				var vect = point.clone().sub(start);
  				var radians = Math.atan2(vect.y, vect.x);
  				var degrees = MathUtils.radToDeg(radians);
  				degrees = degrees > 0 ? degrees : (degrees + 360) % 360;
  				angles.push(degrees);
  			}
  			var indices = Utils.argsort(angles);
  			var sortedAngles = [];
  			var sortedPoints = [];
  			for (i = 0; i < indices.length; i++) {
  				sortedAngles.push(angles[indices[i]]);
  				sortedPoints.push(points[indices[i]]);
  			}
  			return { indices: indices, angles: sortedAngles, points: sortedPoints };
  		}
  	}, {
  		key: 'argsort',
  		value: function argsort(numericalValues) {
  			var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  			var indices = Array.from(new Array(numericalValues.length), function (val, index) {
  				return index;
  			});
  			return indices.map(function (item, index) {
  				return [numericalValues[index], item];
  			}) // add the clickCount to sort by
  			.sort(function (_ref, _ref2) {
  				var _ref4 = slicedToArray(_ref, 1),
  				    count1 = _ref4[0];

  				var _ref3 = slicedToArray(_ref2, 1),
  				    count2 = _ref3[0];

  				return (count1 - count2) * direction;
  			}) // sort by the clickCount data
  			.map(function (_ref5) {
  				var _ref6 = slicedToArray(_ref5, 2),
  				    item = _ref6[1];

  				return item;
  			}); // extract the sorted items
  		}

  		/** Checks if an array of points is clockwise.
     * @param points Is array of points with x,y attributes
     * @returns True if clockwise.
     */

  	}, {
  		key: 'isClockwise',
  		value: function isClockwise(points) {
  			// make positive
  			var tSubX = Math.min(0, Math.min.apply(null, Utils.map(points, function (p) {
  				return p.x;
  			})));
  			var tSubY = Math.min(0, Math.min.apply(null, Utils.map(points, function (p) {
  				return p.x;
  			})));

  			var tNewPoints = Utils.map(points, function (p) {
  				return {
  					x: p.x - tSubX,
  					y: p.y - tSubY
  				};
  			});

  			// determine CW/CCW, based on:
  			// http://stackoverflow.com/questions/1165647
  			var tSum = 0;
  			for (var tI = 0; tI < tNewPoints.length; tI++) {
  				var tC1 = tNewPoints[tI];
  				var tC2;
  				if (tI == tNewPoints.length - 1) {
  					tC2 = tNewPoints[0];
  				} else {
  					tC2 = tNewPoints[tI + 1];
  				}
  				tSum += (tC2.x - tC1.x) * (tC2.y + tC1.y);
  			}
  			return tSum >= 0;
  		}

  		/** Creates a Guide.
     * @returns A new Guide.
     */

  	}, {
  		key: 'guide',
  		value: function guide() {
  			var tS4 = function tS4() {
  				return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  			};
  			return tS4() + tS4() + '-' + tS4() + '-' + tS4() + '-' + tS4() + '-' + tS4() + tS4() + tS4();
  		}

  		/** both arguments are arrays of corners with x,y attributes */

  	}, {
  		key: 'polygonPolygonIntersect',
  		value: function polygonPolygonIntersect(firstCorners, secondCorners) {
  			for (var tI = 0; tI < firstCorners.length; tI++) {
  				var tFirstCorner = firstCorners[tI],
  				    tSecondCorner;
  				if (tI == firstCorners.length - 1) {
  					tSecondCorner = firstCorners[0];
  				} else {
  					tSecondCorner = firstCorners[tI + 1];
  				}
  				if (Utils.linePolygonIntersect(tFirstCorner.x, tFirstCorner.y, tSecondCorner.x, tSecondCorner.y, secondCorners)) {
  					return true;
  				}
  			}
  			return false;
  		}

  		/** Corners is an array of points with x,y attributes */

  	}, {
  		key: 'linePolygonIntersect',
  		value: function linePolygonIntersect(point, point2, corners) {
  			for (var tI = 0; tI < corners.length; tI++) {
  				var tFirstCorner = corners[tI],
  				    tSecondCorner;
  				if (tI == corners.length - 1) {
  					tSecondCorner = corners[0];
  				} else {
  					tSecondCorner = corners[tI + 1];
  				}
  				if (Utils.lineLineIntersect(point, point2, { x: tFirstCorner.x, y: tFirstCorner.y }, { x: tSecondCorner.x, y: tSecondCorner.y })) {
  					return true;
  				}
  			}
  			return false;
  		}

  		/** */

  	}, {
  		key: 'lineLineIntersectPoint',
  		value: function lineLineIntersectPoint(aStart, aEnd, bStart, bEnd) {
  			var result = checkIntersection$1(aStart.x, aStart.y, aEnd.x, aEnd.y, bStart.x, bStart.y, bEnd.x, bEnd.y);
  			if (result.point) {
  				return new Vector2(result.point.x, result.point.y);
  			}
  			return undefined;
  		}

  		/** */

  	}, {
  		key: 'lineLineIntersect',
  		value: function lineLineIntersect(lineAStart, lineAEnd, lineBStart, lineBEnd) {
  			function tCCW(p1, p2, p3) {
  				var tA = p1.x,
  				    tB = p1.y,
  				    tC = p2.x,
  				    tD = p2.y,
  				    tE = p3.x,
  				    tF = p3.y;
  				return (tF - tB) * (tC - tA) > (tD - tB) * (tE - tA);
  			}
  			var tP1 = lineAStart,
  			    tP2 = lineAEnd,
  			    tP3 = lineBStart,
  			    tP4 = lineBEnd;
  			return tCCW(tP1, tP3, tP4) != tCCW(tP2, tP3, tP4) && tCCW(tP1, tP2, tP3) != tCCW(tP1, tP2, tP4);
  		}

  		/**
        @param corners Is an array of points with x,y attributes
         @param startX X start coord for raycast
         @param startY Y start coord for raycast
     */

  	}, {
  		key: 'pointInPolygon2',
  		value: function pointInPolygon2(point, polygon) {
  			var x = point.x,
  			    y = point.y;
  			var inside = false;
  			for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
  				var intersect = (polygon[i].y <= y && y < polygon[j].y || polygon[j].y <= y && y < polygon[i].y) && x < (polygon[j].x - polygon[i].x) * (y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x;
  				if (intersect) {
  					inside = !inside;
  				}
  			}
  			return inside;
  		}

  		/**
        @param corners Is an array of points with x,y attributes
         @param startX X start coord for raycast
         @param startY Y start coord for raycast
     */

  	}, {
  		key: 'pointInPolygon',
  		value: function pointInPolygon(point, corners, start) {
  			start = start || new Vector2(0, 0);
  			var startX = start.x || 0;
  			var startY = start.y || 0;

  			//ensure that point(startX, startY) is outside the polygon consists of corners
  			var tMinX = 0,
  			    tMinY = 0;
  			var tI = 0;

  			if (startX === undefined || startY === undefined) {
  				for (tI = 0; tI < corners.length; tI++) {
  					tMinX = Math.min(tMinX, corners[tI].x);
  					tMinY = Math.min(tMinX, corners[tI].y);
  				}
  				startX = tMinX - 10;
  				startY = tMinY - 10;
  			}

  			var tIntersects = 0;
  			for (tI = 0; tI < corners.length; tI++) {
  				var tFirstCorner = corners[tI],
  				    tSecondCorner;
  				if (tI == corners.length - 1) {
  					tSecondCorner = corners[0];
  				} else {
  					tSecondCorner = corners[tI + 1];
  				}

  				if (Utils.lineLineIntersect(start, point, tFirstCorner.x, tFirstCorner.y, tSecondCorner.x, tSecondCorner.y)) {
  					tIntersects++;
  				}
  			}
  			// odd intersections means the point is in the polygon
  			return tIntersects % 2 == 1;
  		}

  		/** Checks if all corners of insideCorners are inside the polygon described by outsideCorners */

  	}, {
  		key: 'polygonInsidePolygon',
  		value: function polygonInsidePolygon(insideCorners, outsideCorners, start) {
  			start.x = start.x || 0;
  			start.y = start.y || 0;

  			for (var tI = 0; tI < insideCorners.length; tI++) {
  				if (!Utils.pointInPolygon(insideCorners[tI].x, insideCorners[tI].y, outsideCorners, start)) {
  					return false;
  				}
  			}
  			return true;
  		}

  		/** Checks if any corners of firstCorners is inside the polygon described by secondCorners */

  	}, {
  		key: 'polygonOutsidePolygon',
  		value: function polygonOutsidePolygon(insideCorners, outsideCorners, start) {
  			start.x = start.x || 0;
  			start.y = start.y || 0;

  			for (var tI = 0; tI < insideCorners.length; tI++) {
  				if (Utils.pointInPolygon(insideCorners[tI].x, insideCorners[tI].y, outsideCorners, start)) {
  					return false;
  				}
  			}
  			return true;
  		}

  		// arrays

  	}, {
  		key: 'forEach',
  		value: function forEach(array, action) {
  			for (var tI = 0; tI < array.length; tI++) {
  				action(array[tI]);
  			}
  		}
  	}, {
  		key: 'forEachIndexed',
  		value: function forEachIndexed(array, action) {
  			for (var tI = 0; tI < array.length; tI++) {
  				action(tI, array[tI]);
  			}
  		}
  	}, {
  		key: 'map',
  		value: function map(array, func) {
  			var tResult = [];
  			array.forEach(function (element) {
  				tResult.push(func(element));
  			});
  			return tResult;
  		}

  		/** Remove elements in array if func(element) returns true */

  	}, {
  		key: 'removeIf',
  		value: function removeIf(array, func) {
  			var tResult = [];
  			array.forEach(function (element) {
  				if (!func(element)) {
  					tResult.push(element);
  				}
  			});
  			return tResult;
  		}

  		/** Shift the items in an array by shift (positive integer) */

  	}, {
  		key: 'cycle',
  		value: function cycle(arr, shift) {
  			var tReturn = arr.slice(0);
  			for (var tI = 0; tI < shift; tI++) {
  				var tmp = tReturn.shift();
  				tReturn.push(tmp);
  			}
  			return tReturn;
  		}

  		/** Returns in the unique elemnts in arr */

  	}, {
  		key: 'unique',
  		value: function unique(arr, hashFunc) {
  			var tResults = [];
  			var tMap = {};
  			for (var tI = 0; tI < arr.length; tI++) {
  				if (!tMap.hasOwnProperty(arr[tI])) {
  					tResults.push(arr[tI]);
  					tMap[hashFunc(arr[tI])] = true;
  				}
  			}
  			return tResults;
  		}

  		/** Remove value from array, if it is present */

  	}, {
  		key: 'removeValue',
  		value: function removeValue(array, value) {
  			for (var tI = array.length - 1; tI >= 0; tI--) {
  				if (array[tI] === value) {
  					array.splice(tI, 1);
  				}
  			}
  		}

  		/** Checks if value is in array */

  	}, {
  		key: 'hasValue',
  		value: function hasValue(array, value) {
  			for (var tI = 0; tI < array.length; tI++) {
  				if (array[tI] === value) {
  					return true;
  				}
  			}
  			return false;
  		}

  		/** Subtracts the elements in subArray from array */

  	}, {
  		key: 'subtract',
  		value: function subtract(array, subArray) {
  			return Utils.removeIf(array, function (el) {
  				return Utils.hasValue(subArray, el);
  			});
  		}
  	}]);
  	return Utils;
  }();

  var Region = function () {
  	function Region(points) {
  		classCallCheck(this, Region);

  		this.points = points || [];
  		this.length = points.length;
  	}

  	createClass(Region, [{
  		key: 'area',
  		value: function area() {
  			var area = 0,
  			    i,
  			    j,
  			    point1,
  			    point2;

  			for (i = 0, j = this.length - 1; i < this.length; j = i, i += 1) {
  				point1 = this.points[i];
  				point2 = this.points[j];
  				area += point1.x * point2.y;
  				area -= point1.y * point2.x;
  			}
  			area *= 0.5;

  			return area;
  		}
  	}, {
  		key: 'centroid',
  		value: function centroid() {
  			var x = 0,
  			    y = 0,
  			    i,
  			    j,
  			    f,
  			    point1,
  			    point2;

  			for (i = 0, j = this.length - 1; i < this.length; j = i, i += 1) {
  				point1 = this.points[i];
  				point2 = this.points[j];
  				f = point1.x * point2.y - point2.x * point1.y;
  				x += (point1.x + point2.x) * f;
  				y += (point1.y + point2.y) * f;
  			}

  			f = this.area() * 6;

  			return new Vector2(x / f, y / f);
  		}
  	}]);
  	return Region;
  }();

  function Enum() {
    var _this = this;

    if (!(this instanceof Enum)) return new (Function.prototype.bind.apply(Enum, [null].concat(Array.prototype.slice.call(arguments))))();
    Array.from(arguments).forEach(function (arg) {
      _this[arg] = Symbol(arg);
    });
  }

  var _enum = Enum;

  var ELogContext = _enum('None', 'All', 'Interaction2d', 'Item', 'Wall', 'Room');
  var ELogLevel = _enum('Information', 'Warning', 'Error', 'Fatal', 'Debug');
  /** The current log context. To be set when initializing the Application. */
  var logContext = ELogContext.None;

  /** Pre-check if logging for specified context and/or level is enabled.
   * This may be used to avoid compilation of complex logs.
   * @param context The log context to be verified.
   * @param level The log level to be verified.
   * @returns If this context/levels is currently logged.
   */
  function isLogging(context, level) {
  	return logContext === ELogContext.All || logContext == context || level === ELogLevel.Warning || level === ELogLevel.Error || level === ELogLevel.Fatal;
  }

  /** Log the passed message in the context and with given level.
   * @param context The context in which the message should be logged.
   * @param level The level of the message.
   * @param message The messages to be logged. 
   */
  function log(context, level, message) {
  	if (isLogging(context, level) === false) {
  		return;
  	}
  	var tPrefix = '';
  	switch (level) {
  		case ELogLevel.Information:
  			tPrefix = '[INFO_] ';
  			break;
  		case ELogLevel.Warning:
  			tPrefix = '[WARNG] ';
  			break;
  		case ELogLevel.Error:
  			tPrefix = '[ERROR] ';
  			break;
  		case ELogLevel.Fatal:
  			tPrefix = '[FATAL] ';
  			break;
  		case ELogLevel.Debug:
  			tPrefix = '[DEBUG] ';
  			break;
  	}
  	console.log(tPrefix + message);
  }

  /** Dimensioning in Inch. */
  var dimInch = 'inch';

  /** Dimensioning in Inch. */
  var dimFeetAndInch = 'feetAndInch';

  /** Dimensioning in Meter. */
  var dimMeter = 'm';

  /** Dimensioning in Centi Meter. */
  var dimCentiMeter = 'cm';

  /** Dimensioning in Milli Meter. */
  var dimMilliMeter = 'mm';

  var VIEW_TOP = 'topview';
  var VIEW_FRONT = 'frontview';
  var VIEW_RIGHT = 'rightview';
  var VIEW_LEFT = 'leftview';
  var VIEW_ISOMETRY = 'isometryview';

  var WallTypes = _enum('STRAIGHT', 'CURVED');

  // GENERAL:
  /** The dimensioning unit for 2D floorplan measurements. */
  var configDimUnit = 'dimUnit';
  // WALL:
  /** The initial wall height in cm. */
  var configWallHeight = 'wallHeight';
  /** The initial wall thickness in cm. */
  var configWallThickness = 'wallThickness';

  var configSystemUI = 'systemUI';

  var scale = 'scale';

  var gridSpacing = 'gridSpacing';
  var snapToGrid = 'snapToGrid';
  var directionalDrag = 'directionalDrag';
  var dragOnlyX = 'dragOnlyX';
  var dragOnlyY = 'dragOnlyY';
  var snapTolerance = 'snapTolerance'; //In CMS
  var boundsX = 'boundsX'; //In CMS
  var boundsY = 'boundsY'; //In CMS


  var config = { dimUnit: dimCentiMeter, wallHeight: 250, wallThickness: 20, systemUI: false, scale: 1, snapToGrid: false, dragOnlyX: false, dragOnlyY: false, snapTolerance: 100, gridSpacing: 100, directionalDrag: false, boundsX: 500, boundsY: 500 };

  var wallInformation = { exterior: false, interior: false, midline: true, labels: true, exteriorlabel: 'e:', interiorlabel: 'i:', midlinelabel: 'm:' };

  /** 
   * The tolerance in cms between corners, otherwise below this tolerance they will snap together as one corner*/
  var cornerTolerance = 20;

  /** Global configuration to customize the whole system.  
   * This is a singleton instance;
   */
  var Configuration = function (_EventDispatcher) {
      inherits(Configuration, _EventDispatcher);

      function Configuration() {
          classCallCheck(this, Configuration);

          /** Configuration data loaded from/stored to extern. */
          //		this.data = {dimUnit: dimCentiMeter, wallHeight: 250, wallThickness: 10};
          return possibleConstructorReturn(this, (Configuration.__proto__ || Object.getPrototypeOf(Configuration)).call(this));
      }

      createClass(Configuration, null, [{
          key: 'getInstance',
          value: function getInstance() {
              if (this.__instance === undefined) {
                  this.__instance = new Configuration();
              }
              return this.__instance;
          }
      }, {
          key: 'getData',
          value: function getData() {
              //		return {dimUnit: dimCentiMeter,wallHeight: 250, wallThickness: 10};
              return config;
          }

          /** Set a configuration parameter. */

      }, {
          key: 'setValue',
          value: function setValue(key, value) {
              //		this.data[key] = value;
              config[key] = value;
              Configuration.getInstance().dispatchEvent({ type: EVENT_CHANGED, item: Configuration.getInstance(), 'key': key, 'value': value });
          }

          /** Get a string configuration parameter. */

      }, {
          key: 'getStringValue',
          value: function getStringValue(key) {
              switch (key) {
                  case configDimUnit:
                      //			return String(this.data[key]);
                      return String(Configuration.getData()[key]);
                  default:
                      throw new Error('Invalid string configuration parameter: ' + key);
              }
          }

          /** Get a numeric configuration parameter. */

      }, {
          key: 'getNumericValue',
          value: function getNumericValue(key) {
              switch (key) {
                  case configSystemUI:
                  case configWallHeight:
                  case configWallThickness:
                  case scale:
                  case snapToGrid:
                  case directionalDrag:
                  case dragOnlyX:
                  case dragOnlyY:
                  case boundsX:
                  case boundsY:
                  case snapTolerance:
                  case gridSpacing:
                      //			return Number(this.data[key]);
                      return Number(Configuration.getData()[key]);
                  default:
                      throw new Error('Invalid numeric configuration parameter: ' + key);
              }
          }
      }]);
      return Configuration;
  }(EventDispatcher);

  var decimals = 1000;

  var cmPerFoot = 30.48;
  var pixelsPerFoot = 15.0;
  var cmPerPixel = cmPerFoot * (1.0 / pixelsPerFoot);
  var pixelsPerCm = 1.0 / cmPerPixel;

  var dimensioningOptions = [dimInch, dimFeetAndInch, dimMeter, dimCentiMeter, dimMilliMeter];

  /** Dimensioning functions. */
  var Dimensioning = function () {
      function Dimensioning() {
          classCallCheck(this, Dimensioning);
      }

      createClass(Dimensioning, null, [{
          key: 'cmToPixel',
          value: function cmToPixel(cm) {
              var apply_scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

              if (apply_scale) {
                  return cm * pixelsPerCm * Configuration.getNumericValue('scale');
              }
              return cm * pixelsPerCm;
          }
      }, {
          key: 'pixelToCm',
          value: function pixelToCm(pixel) {
              var apply_scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

              if (apply_scale) {
                  return pixel * cmPerPixel * (1.0 / Configuration.getNumericValue('scale'));
              }
              return pixel * cmPerPixel;
          }
      }, {
          key: 'roundOff',
          value: function roundOff(value, decimals) {
              return Math.round(decimals * value) / decimals;
          }
          /** Converts cm to dimensioning number.
           * @param cm Centi meter value to be converted.
           * @returns Number representation.
           */

      }, {
          key: 'cmFromMeasureRaw',
          value: function cmFromMeasureRaw(measure) {
              switch (Configuration.getStringValue(configDimUnit)) {
                  case dimFeetAndInch:
                      return Math.round(decimals * (measure * 30.480016459203095991)) / decimals;
                  case dimInch:
                      return Math.round(decimals * (measure * 2.5400013716002578512)) / decimals;
                  case dimMilliMeter:
                      return Math.round(decimals * (measure * 0.10000005400001014955)) / decimals;
                  case dimCentiMeter:
                      return measure;
                  case dimMeter:
                  default:
                      return Math.round(decimals * 100 * measure) / decimals;
              }
          }

          /** Converts cm to dimensioning string.
           * @param cm Centi meter value to be converted.
           * @returns String representation.
           */

      }, {
          key: 'cmFromMeasure',
          value: function cmFromMeasure(measure) {
              switch (Configuration.getStringValue(configDimUnit)) {
                  case dimFeetAndInch:
                      return Math.round(decimals * (measure * 30.480016459203095991)) / decimals + 'cm';
                  case dimInch:
                      return Math.round(decimals * (measure * 2.5400013716002578512)) / decimals + 'cm';
                  case dimMilliMeter:
                      return Math.round(decimals * (measure * 0.10000005400001014955)) / decimals + 'cm';
                  case dimCentiMeter:
                      return measure;
                  case dimMeter:
                  default:
                      return Math.round(decimals * 100 * measure) / decimals + 'cm';
              }
          }

          /** Converts cm to dimensioning string.
           * @param cm Centi meter value to be converted.
           * @returns String representation.
           */

      }, {
          key: 'cmToMeasureRaw',
          value: function cmToMeasureRaw(cm) {
              var power = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

              switch (Configuration.getStringValue(configDimUnit)) {
                  case dimFeetAndInch:
                      // dimFeetAndInch returns only the feet
                      var allInFeet = cm * Math.pow(0.032808416666669996953, power);
                      return allInFeet;
                  case dimInch:
                      var inches = Math.round(decimals * (cm * Math.pow(0.393700, power))) / decimals;
                      return inches;
                  case dimMilliMeter:
                      var mm = Math.round(decimals * (cm * Math.pow(10, power))) / decimals;
                      return mm;
                  case dimCentiMeter:
                      return Math.round(decimals * cm) / decimals;
                  case dimMeter:
                  default:
                      var m = Math.round(decimals * (cm * Math.pow(0.01, power))) / decimals;
                      return m;
              }
          }

          /** Converts cm to dimensioning string.
           * @param cm Centi meter value to be converted.
           * @returns String representation.
           */

      }, {
          key: 'cmToMeasure',
          value: function cmToMeasure(cm) {
              var power = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

              switch (Configuration.getStringValue(configDimUnit)) {
                  case dimFeetAndInch:
                      var allInFeet = cm * Math.pow(0.032808416666669996953, power);
                      var floorFeet = Math.floor(allInFeet);
                      var remainingFeet = allInFeet - floorFeet;
                      var remainingInches = Math.round(remainingFeet * 12);
                      return floorFeet + '\'' + remainingInches + '"';
                  case dimInch:
                      var inches = Math.round(decimals * (cm * Math.pow(0.393700, power))) / decimals;
                      return inches + '\'';
                  case dimMilliMeter:
                      var mm = Math.round(decimals * (cm * Math.pow(10, power))) / decimals;
                      return '' + mm + 'mm';
                  case dimCentiMeter:
                      return '' + Math.round(decimals * cm) / decimals + 'cm';
                  case dimMeter:
                  default:
                      var m = Math.round(decimals * (cm * Math.pow(0.01, power))) / decimals;
                      return '' + m + 'm';
              }
          }
      }]);
      return Dimensioning;
  }();

  /**
   * Half Edges are created by Room.
   *
   * Once rooms have been identified, Half Edges are created for each interior wall.
   *
   * A wall can have two half edges if it is visible from both sides.
   */
  var HalfEdge = function (_EventDispatcher) {
      inherits(HalfEdge, _EventDispatcher);

      /**
       * Constructs a half edge.
       * @param {Room} room The associated room. Instance of Room
       * @param {Wall} wall The corresponding wall. Instance of Wall
       * @param {boolean} front True if front side. Boolean value
       */
      function HalfEdge(room, wall, front) {
          classCallCheck(this, HalfEdge);

          /**  The minimum point in space calculated from the bounds
           * @property {Vector3} min  The minimum point in space calculated from the bounds
           * @type {Vector3}
           * @see https://threejs.org/docs/#api/en/math/Vector3
           **/
          var _this = possibleConstructorReturn(this, (HalfEdge.__proto__ || Object.getPrototypeOf(HalfEdge)).call(this));

          _this.min = null;

          /**
           * The maximum point in space calculated from the bounds
           * @property {Vector3} max	 The maximum point in space calculated from the bounds
           * @type {Vector3}
           * @see https://threejs.org/docs/#api/en/math/Vector3
           **/
          _this.max = null;

          /**
           * The center of this half edge
           * @property {Vector3} center The center of this half edge
           * @type {Vector3}
           * @see https://threejs.org/docs/#api/en/math/Vector3
           **/
          _this.center = null;

          /**
           * Reference to a Room instance
           * @property {Room} room Reference to a Room instance
           * @type {Room}
           **/
          _this.room = room;

          /** 
           *  Reference to a Wall instance
           * @property {Wall} room Reference to a Wall instance
           * @type {Wall}
           **/
          _this.wall = wall;

          _this.name = Utils.guide('Edge');

          /**
           * Reference to the next halfedge instance connected to this
           * @property {HalfEdge} next Reference to the next halfedge instance connected to this
           * @type {HalfEdge}
           **/
          _this.next = null;

          /**
           * Reference to the previous halfedge instance connected to this
           * @property {HalfEdge} prev Reference to the previous halfedge instance connected to this
           * @type {HalfEdge}
           **/
          _this.prev = null;

          /** 
           * The offset to maintain for the front and back walls from the midline of a wall
           * @property {Number} offset The offset to maintain for the front and back walls from the midline of a wall
           * @type {Number}
           **/
          _this.offset = 0.0;

          /**
           *  The height of a wall
           * @property {Number} height The height of a wall
           * @type {Number}
           **/
          _this.height = 0.0;

          /**
           * The plane mesh that will be used for checking intersections of wall items
           * @property {Mesh} plane The plane mesh that will be used for checking intersections of wall items
           * @type {Mesh}
           * @see https://threejs.org/docs/#api/en/objects/Mesh
           */
          _this.plane = null;

          /**
           * The interior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @property {Matrix4} interiorTransform The interior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @type {Matrix4} 
           * @see https://threejs.org/docs/#api/en/math/Matrix4
           */
          _this.interiorTransform = new Matrix4();

          /**
           * The inverse of the interior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @property {Matrix4} invInteriorTransform The inverse of the interior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @type {Matrix4}
           * @see https://threejs.org/docs/#api/en/math/Matrix4
           */
          _this.invInteriorTransform = new Matrix4();

          /**
           * The exterior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @property {Matrix4} exteriorTransform The exterior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @type {Matrix4} 
           * @see https://threejs.org/docs/#api/en/math/Matrix4
           */
          _this.exteriorTransform = new Matrix4();

          /**
           * The inverse of the exterior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @property {Matrix4} invExteriorTransform The inverse of the exterior transformation matrix that contains the homogeneous transformation of the plane based on the two corner positions of the wall
           * @type {Matrix4}
           * @see https://threejs.org/docs/#api/en/math/Matrix4
           */
          _this.invExteriorTransform = new Matrix4();

          /**
           * This is an array of callbacks to be call when redraw happens
           * @depreceated 
           */
          _this.redrawCallbacks = null;

          /**
           * Is this is the front edge or the back edge
           * @property {boolean} front Is this is the front edge or the back edge
           * @type {boolean}
           */
          _this.front = front || false;

          _this.offset = wall.thickness / 2.0;
          _this.height = wall.height;

          if (_this.front) {
              _this.wall.frontEdge = _this;
          } else {
              _this.wall.backEdge = _this;
          }
          var scope = _this;

          _this.wall.addEventListener(EVENT_MOVED, function () {
              scope.computeTransforms(scope.interiorTransform, scope.invInteriorTransform, scope.interiorStart(), scope.interiorEnd());
              scope.computeTransforms(scope.exteriorTransform, scope.invExteriorTransform, scope.exteriorStart(), scope.exteriorEnd());
              scope.dispatchEvent({ type: EVENT_REDRAW, item: scope });
          });

          _this.wall.addEventListener(EVENT_UPDATED, function () {
              scope.offset = scope.wall.thickness * 0.5;
              scope.computeTransforms(scope.interiorTransform, scope.invInteriorTransform, scope.interiorStart(), scope.interiorEnd());
              scope.computeTransforms(scope.exteriorTransform, scope.invExteriorTransform, scope.exteriorStart(), scope.exteriorEnd());
              scope.dispatchEvent({ type: EVENT_REDRAW, item: scope });
          });
          return _this;
      }

      /**
       * Two separate textures are used for the walls. Based on which side of the wall this {HalfEdge} refers the texture is returned
       * @return {Object} front/back Two separate textures are used for the walls. Based on which side of the wall this {@link HalfEdge} refers the texture is returned
       */


      createClass(HalfEdge, [{
          key: 'getTexture',
          value: function getTexture() {
              if (this.front) {
                  return this.wall.frontTexture;
              } else {
                  return this.wall.backTexture;
              }
          }

          /**
           * Set a Texture to the wall. Based on the edge side as front or back the texture is applied appropriately to the wall
           * @param {String} textureUrl The path to the texture image
           * @param {boolean} textureStretch Can the texture stretch? If not it will be repeated
           * @param {Number} textureScale The scale value using which the number of repetitions of the texture image is calculated
           * @emits {EVENT_REDRAW}
           */

      }, {
          key: 'setTexture',
          value: function setTexture(textureUrl, textureStretch, textureScale) {
              var texture = { url: textureUrl, stretch: textureStretch, scale: textureScale };
              if (this.front) {
                  this.wall.frontTexture = texture;
              } else {
                  this.wall.backTexture = texture;
              }

              //this.redrawCallbacks.fire();
              this.dispatchEvent({ type: EVENT_REDRAW, item: this });
          }

          /**
           * Emit the redraw event
           * @emits {EVENT_REDRAW}
           */

      }, {
          key: 'dispatchRedrawEvent',
          value: function dispatchRedrawEvent() {
              this.dispatchEvent({ type: EVENT_REDRAW, item: this });
          }

          /**
           * Transform the {@link Corner} instance to a Vector3 instance using the x and y position returned as x and z
           * @param {Corner} corner
           * @return {Vector3}
           * @see https://threejs.org/docs/#api/en/math/Vector3
           */

      }, {
          key: 'transformCorner',
          value: function transformCorner(corner) {
              return new Vector3(corner.x, 0, corner.y);
          }

          /**
           * This generates the invisible planes in the scene that are used for interesection testing for the wall items
           */

      }, {
          key: 'generatePlane',
          value: function generatePlane() {
              var geometry = new Geometry();
              var v1 = this.transformCorner(this.interiorStart());
              var v2 = this.transformCorner(this.interiorEnd());
              var v3 = v2.clone();
              var v4 = v1.clone();

              // v3.y = this.wall.height;
              // v4.y = this.wall.height;

              v3.y = this.wall.startElevation;
              v4.y = this.wall.endElevation;

              geometry.vertices = [v1, v2, v3, v4];
              geometry.faces.push(new Face3(0, 1, 2));
              geometry.faces.push(new Face3(0, 2, 3));
              geometry.computeFaceNormals();
              geometry.computeBoundingBox();

              this.plane = new Mesh(geometry, new MeshBasicMaterial({ visible: true }));
              //The below line was originally setting the plane visibility to false
              //Now its setting visibility to true. This is necessary to be detected
              //with the raycaster objects to click walls and floors.
              this.plane.visible = true;
              this.plane.edge = this; // js monkey patch


              this.computeTransforms(this.interiorTransform, this.invInteriorTransform, this.interiorStart(), this.interiorEnd());
              this.computeTransforms(this.exteriorTransform, this.invExteriorTransform, this.exteriorStart(), this.exteriorEnd());

              var b3 = new Box3();
              b3.setFromObject(this.plane);
              this.min = b3.min.clone();
              this.max = b3.max.clone();
              this.center = this.max.clone().sub(this.min).multiplyScalar(0.5).add(this.min);
          }

          /**
           * Calculate the transformation matrix for the edge (front/back) baesd on the parameters. 
           * @param {Matrix4} transform The matrix reference in which the transformation is stored
           * @param {Matrix4} invTransform The inverse of the transform that is stored in the invTransform
           * @param {Vector2} start The starting point location
           * @param {Vector2} end The ending point location
           * @see https://threejs.org/docs/#api/en/math/Matrix4
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */

      }, {
          key: 'computeTransforms',
          value: function computeTransforms(transform, invTransform, start, end) {
              var v1 = start;
              var v2 = end;

              var angle = Utils.angle(new Vector2(1, 0), new Vector2(v2.x - v1.x, v2.y - v1.y));

              var tt = new Matrix4();
              var tr = new Matrix4();

              tt.makeTranslation(-v1.x, 0, -v1.y);
              tr.makeRotationY(-angle);
              transform.multiplyMatrices(tr, tt);
              invTransform.getInverse(transform);
          }

          /** Gets the distance from specified point.
           * @param {Number} x X coordinate of the point.
           * @param {Number} y Y coordinate of the point.
           * @returns {Number} The distance.
           */

      }, {
          key: 'distanceTo',
          value: function distanceTo(x, y) {
              if (this.wall.wallType === WallTypes.STRAIGHT) {
                  // x, y, x1, y1, x2, y2
                  return Utils.pointDistanceFromLine(new Vector2(x, y), this.interiorStart(), this.interiorEnd());
              } else if (this.wall.wallType === WallTypes.CURVED) {
                  var p = this._bezier.project({ x: x, y: y });
                  var projected = new Vector2(p.x, p.y);
                  return projected.distanceTo(new Vector2(x, y));
              }
              return -1;
          }

          /**
           * Get the starting corner of the wall this instance represents
           * @return {Corner} The starting corner
           */

      }, {
          key: 'getStart',
          value: function getStart() {
              if (this.front) {
                  return this.wall.getStart();
              } else {
                  return this.wall.getEnd();
              }
          }

          /**
           * Get the ending corner of the wall this instance represents
           * @return {Corner} The ending corner
           */

      }, {
          key: 'getEnd',
          value: function getEnd() {
              if (this.front) {
                  return this.wall.getEnd();
              } else {
                  return this.wall.getStart();
              }
          }

          /**
           * If this is the front edge then return the back edge. 
           * For example in a wall there are two halfedges, i.e one for front and one back. Based on which side this halfedge lies return the opposite {@link HalfEdge}
           * @return {HalfEdge} The other HalfEdge
           */

      }, {
          key: 'getOppositeEdge',
          value: function getOppositeEdge() {
              if (this.front) {
                  return this.wall.backEdge;
              } else {
                  return this.wall.frontEdge;
              }
          }

          /**
           * Return the 2D interior location that is at the center/middle. 
           * @return {Vector2} Return an object with attributes x, y
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */

      }, {
          key: 'interiorCenter',
          value: function interiorCenter() {
              if (this.wall.wallType === WallTypes.STRAIGHT) {
                  // x, y, x1, y1, x2, y2
                  return new Vector2((this.interiorStart().x + this.interiorEnd().x) / 2.0, (this.interiorStart().y + this.interiorEnd().y) / 2.0);
              } else if (this.wall.wallType === WallTypes.CURVED) {
                  var c = this.wall.bezier.get(0.5);
                  return new Vector2(c.x, c.y);
              }
              return new Vector2((this.interiorStart().x + this.interiorEnd().x) / 2.0, (this.interiorStart().y + this.interiorEnd().y) / 2.0);
          }

          /**
           * Return the interior distance of the interior wall 
           * @return {Number} The distance
           */

      }, {
          key: 'interiorDistance',
          value: function interiorDistance() {
              var start = this.interiorStart();
              var end = this.interiorEnd();
              if (this.wall.wallType === WallTypes.STRAIGHT) {
                  return Utils.distance(start, end);
              } else if (this.wall.wallType === WallTypes.CURVED) {
                  return this.wall.bezier.length();
              }
              return Utils.distance(start, end);
          }

          /**
           * Return the 2D interior location that is at the start. 
           * @return {Vector2} Return an object with attributes x, y
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */

      }, {
          key: 'interiorStart',
          value: function interiorStart() {
              var vec = this.halfAngleVector(this.prev, this);
              return new Vector2(this.getStart().x + vec.x, this.getStart().y + vec.y);
              // return {x:this.getStart().x + vec.x, y:this.getStart().y + vec.y};
          }

          /**
           * Return the 2D interior location that is at the end. 
           * @return {Vector2} Return an object with attributes x, y
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */
          // 

      }, {
          key: 'interiorEnd',
          value: function interiorEnd() {
              var vec = this.halfAngleVector(this, this.next);
              return new Vector2(this.getEnd().x + vec.x, this.getEnd().y + vec.y);
              // return {x:this.getEnd().x + vec.x, y:this.getEnd().y + vec.y};
          }

          /**
           * Return the 2D exterior location that is at the end. 
           * @return {Vector2} Return an object with attributes x, y
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */

      }, {
          key: 'exteriorEnd',
          value: function exteriorEnd() {
              var vec = this.halfAngleVector(this, this.next);
              return new Vector2(this.getEnd().x - vec.x, this.getEnd().y - vec.y);
          }

          /**
           * Return the 2D exterior location that is at the start. 
           * @return {Vector2} Return an object with attributes x, y
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */

      }, {
          key: 'exteriorStart',
          value: function exteriorStart() {
              var vec = this.halfAngleVector(this.prev, this);
              return new Vector2(this.getStart().x - vec.x, this.getStart().y - vec.y);
          }

          /**
           * Return the 2D exterior location that is at the center/middle. 
           * @return {Vector2} Return an object with attributes x, y
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */

      }, {
          key: 'exteriorCenter',
          value: function exteriorCenter() {
              if (this.wall.wallType === WallTypes.STRAIGHT) {
                  // x, y, x1, y1, x2, y2
                  return new Vector2((this.exteriorStart().x + this.exteriorEnd().x) / 2.0, (this.exteriorStart().y + this.exteriorEnd().y) / 2.0);
              } else if (this.wall.wallType === WallTypes.CURVED) {
                  var c = this.wall.bezier.get(0.5);
                  return new Vector2(c.x, c.y);
              }
              return new Vector2((this.exteriorStart().x + this.exteriorEnd().x) / 2.0, (this.exteriorStart().y + this.exteriorEnd().y) / 2.0);
          }

          /**
           * Return the exterior distance of the exterior wall 
           * @return {Number} The distance
           */

      }, {
          key: 'exteriorDistance',
          value: function exteriorDistance() {
              var start = this.exteriorStart();
              var end = this.exteriorEnd();
              if (this.wall.wallType === WallTypes.STRAIGHT) {
                  return Utils.distance(start, end);
              } else if (this.wall.wallType === WallTypes.CURVED) {
                  return this.wall.bezier.length();
              }
              return Utils.distance(start, end);
          }

          /** Get the corners of the half edge.
           * @returns {Corner[]} An array of x,y pairs.
           */

      }, {
          key: 'corners',
          value: function corners() {
              return [this.interiorStart(), this.interiorEnd(), this.exteriorEnd(), this.exteriorStart()];
          }

          //	curvedCorners()
          //	{
          //		if(this.wall)
          //		{
          //			var curves = [];
          //			var o = new Vector2(0, 0);
          //			var s = this.wall.start.location;
          //			var e = this.wall.end.location;
          //			
          ////			var avect = this.wall.a.clone().sub(this.wall.start);
          ////			var bvect = this.wall.b.clone().sub(this.wall.start);
          //			
          //			var sevect = s.clone().sub(e).normalize();
          //			var se90plus = sevect.clone().rotateAround(o, 3.14*0.5).multiplyScalar(this.wall.thickness*0.5);
          //			var se90minus = sevect.clone().rotateAround(o, -3.14*0.5).multiplyScalar(this.wall.thickness*0.5);
          //			
          //			var s1 = se90plus.clone().add(s);
          //			var e1 = se90plus.clone().add(e);
          //			var e2 = se90minus.clone().add(e);
          //			var s2 = se90minus.clone().add(s);
          //			
          //			curves.push([s1]);
          //			curves.push([this.wall.a.clone().add(se90plus), this.wall.b.clone().add(se90plus), e1]);
          //			curves.push([e2]);
          //			curves.push([this.wall.b.clone().add(se90minus), this.wall.a.clone().add(se90minus), s2]);
          ////			curves.push([s2]);
          //			
          //			
          //			return curves;			
          //		}
          //		return [];
          //	}

          /**
           * Gets CCW angle from v1 to v2
           * @param {Vector2} v1 The point a
           * @param {Vector2} v1 The point b
           * @return {Object} contains keys x and y with number representing the halfAngles
           */

      }, {
          key: 'halfAngleVector',
          value: function halfAngleVector(v1, v2) {
              var v1startX = 0.0,
                  v1startY = 0.0,
                  v1endX = 0.0,
                  v1endY = 0.0;
              var v2startX = 0.0,
                  v2startY = 0.0,
                  v2endX = 0.0,
                  v2endY = 0.0;

              // make the best of things if we dont have prev or next
              if (!v1) {
                  v1startX = v2.getStart().x - (v2.getEnd().x - v2.getStart().x);
                  v1startY = v2.getStart().y - (v2.getEnd().y - v2.getStart().y);

                  v1endX = v2.getStart().x;
                  v1endY = v2.getStart().y;
              } else {
                  v1startX = v1.getStart().x;
                  v1startY = v1.getStart().y;
                  v1endX = v1.getEnd().x;
                  v1endY = v1.getEnd().y;
              }

              if (!v2) {
                  v2startX = v1.getEnd().x;
                  v2startY = v1.getEnd().y;
                  v2endX = v1.getEnd().x + (v1.getEnd().x - v1.getStart().x);
                  v2endY = v1.getEnd().y + (v1.getEnd().y - v1.getStart().y);
              } else {
                  v2startX = v2.getStart().x;
                  v2startY = v2.getStart().y;
                  v2endX = v2.getEnd().x;
                  v2endY = v2.getEnd().y;
              }

              // CCW angle between edges
              var theta = Utils.angle2pi(new Vector2(v1startX - v1endX, v1startY - v1endY), new Vector2(v2endX - v1endX, v2endY - v1endY));

              // cosine and sine of half angle
              var cs = Math.cos(theta / 2.0);
              var sn = Math.sin(theta / 2.0);

              // rotate v2
              var v2dx = v2endX - v2startX;
              var v2dy = v2endY - v2startY;

              var vx = v2dx * cs - v2dy * sn;
              var vy = v2dx * sn + v2dy * cs;

              // normalize
              var mag = Utils.distance(new Vector2(0, 0), new Vector2(vx, vy));
              var desiredMag = this.offset / sn;
              var scalar = desiredMag / mag;

              var halfAngleVector = { x: vx * scalar, y: vy * scalar }; //new Vector2(vx * scalar, vy * scalar);
              return halfAngleVector;
          }
      }]);
      return HalfEdge;
  }(EventDispatcher);

  /**
   * Corners are used to define Walls.
   */
  var Corner = function (_EventDispatcher) {
      inherits(Corner, _EventDispatcher);

      /** Constructs a corner.
       * @param {Floorplan} floorplan The associated model floorplan.
       * @param {Number} x X coordinate.
       * @param {Number} y Y coordinate.
       * @param {String} id An optional unique id. If not set, created internally.
       */
      function Corner(floorplan, x, y, id) {
          classCallCheck(this, Corner);

          /** @property {Array} wallStarts Array of walls that are start walls
           * @type {Array}
           **/
          var _this = possibleConstructorReturn(this, (Corner.__proto__ || Object.getPrototypeOf(Corner)).call(this));

          _this.wallStarts = [];
          /** @property {Array} wallEnds Array of walls that are end walls
           * @type {Array}
           **/
          _this.wallEnds = [];
          /**
           * @deprecated Not in use. The EventDispatcher from threejs is used for emit and listen events
           **/
          _this.moved_callbacks = null;
          /**
           * @deprecated Not in use. The EventDispatcher from threejs is used for emit and listen events
           **/
          _this.deleted_callbacks = null;
          /**
           * @deprecated Not in use. The EventDispatcher from threejs is used for emit and listen events
           **/
          _this.action_callbacks = null;
          /**
           * @property {Floorplan} floorplan Reference to the model floorplan
           * @type {Floorplan}
           **/
          _this.floorplan = floorplan;
          /**
           * @property {Number} x The position in x dimension
           * @type {Number}
           **/
          _this._x = x;
          /**
           * @property {Number} y The position in y dimension
           * @type {Number}
           **/
          _this._y = y;

          /**
           * @property {Vector2} co The position as Vector2
           * @type {Vector2}
           * @see https://threejs.org/docs/#api/en/math/Vector2
           **/
          _this._co = new Vector2(_this._x, _this._y);

          /**
           * @property {Number} _elevation The elevation at this corner
           * @type {Number}
           **/
          _this._elevation = Configuration.getNumericValue(configWallHeight);
          /**
           * @property {String} id The id of this corner. Autogenerated the first time
           * @type {String}
           **/
          _this.id = id || Utils.guide();
          /**
           * @property {Array} attachedRooms Array of rooms that have walls using this corner
           * @type {Array}
           **/
          _this.attachedRooms = [];

          _this._angles = [];
          _this._angleDirections = [];
          _this._startAngles = [];
          _this._endAngles = [];
          _this._cyclicNeighbors = [];
          /**
           * @property {Boolean} _hasChanged A flag to indicate if something has changed about this corner
           * @type {Boolean}
           **/
          _this._hasChanged = false;
          return _this;
      }

      createClass(Corner, [{
          key: 'attachRoom',


          /**
           * @param {Room} room - The room that should be attached to this corner
           * @return {void}
           */
          value: function attachRoom(room) {
              if (room) {
                  this.attachedRooms.push(room);
              }
          }

          /**
           * @return {Room[]} Array of rooms attached to this corner
           */

      }, {
          key: 'getAttachedRooms',
          value: function getAttachedRooms() {
              return this.attachedRooms;
          }

          /**
           * @return {void} Clear all the rooms attached to this corner
           */

      }, {
          key: 'clearAttachedRooms',
          value: function clearAttachedRooms() {
              this.attachedRooms = [];
          }

          /** Add function to moved callbacks.
           * @param func The function to be added.
           */

      }, {
          key: 'fireOnMove',
          value: function fireOnMove(func) {
              this.moved_callbacks.add(func);
          }

          /** Add function to deleted callbacks.
           * @param func The function to be added.
           */

      }, {
          key: 'fireOnDelete',
          value: function fireOnDelete(func) {
              this.deleted_callbacks.add(func);
          }

          /** Add function to action callbacks.
           * @param func The function to be added.
           */

      }, {
          key: 'fireOnAction',
          value: function fireOnAction(func) {
              this.action_callbacks.add(func);
          }
      }, {
          key: 'fireAction',
          value: function fireAction(action) {
              this.dispatchEvent({ type: EVENT_ACTION, item: this, action: action });
              //      this.action_callbacks.fire(action)
          }

          /**
           * @returns
           * @deprecated
           */

      }, {
          key: 'getX',
          value: function getX() {
              return this.x;
          }

          /**
           * @returns
           * @deprecated
           */

      }, {
          key: 'getY',
          value: function getY() {
              return this.y;
          }

          /**
           *	@param {Number} tolerance - The tolerance value within which it will snap to adjacent corners
           *  @return {Object} snapped Contains keys x and y with true/false values
           *  @description The object with x and y that are boolean values to indicate if the snap happens in x and y
           */

      }, {
          key: 'snapToAxis',
          value: function snapToAxis(tolerance) {
              // try to snap this corner to an axis
              var snapped = { x: false, y: false };
              var scope = this;

              this.adjacentCorners().forEach(function (corner) {
                  if (Math.abs(corner.x - scope.x) < tolerance) {
                      scope.x = corner.x;
                      snapped.x = true;
                  }
                  if (Math.abs(corner.y - scope.y) < tolerance) {
                      scope.y = corner.y;
                      snapped.y = true;
                  }
              });
              return snapped;
          }

          /** Moves corner to new position.
           * @param {Number} newX The new x position.
           * @param {Number} newY The new y position.
           */

      }, {
          key: 'move',
          value: function move(newX, newY) {
              var mergeWithIntersections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              //		this.x = newX;
              //		this.y = newY;
              this._x = newX;
              this._y = newY;
              this._co.x = newX;
              this._co.y = newY;

              if (mergeWithIntersections) {
                  //The below line is crashing after makign the changes for curved walls
                  //While release v1.0.0 is stable even with this line enabled
                  this.mergeWithIntersected();
                  if (this.floorplan.rooms.length < 10) {
                      this.updateAttachedRooms(true);
                  }
              }

              this.dispatchEvent({ type: EVENT_MOVED, item: this, position: new Vector2(newX, newY) });
              //      this.moved_callbacks.fire(this.x, this.y);

              this.wallStarts.forEach(function (wall) {
                  wall.fireMoved();
              });

              this.wallEnds.forEach(function (wall) {
                  wall.fireMoved();
              });
          }

          /** Moves corner relatively to new position.
           * @param {Number} dx The delta x.
           * @param {Number} dy The delta y.
           */

      }, {
          key: 'relativeMove',
          value: function relativeMove(dx, dy) {
              this.move(this.x + dx, this.y + dy);
          }

          /**
           * Dispatches an event when removed from the floorplan({@link Floorplan}) instance. The event object contains reference to this {@link Corner} instance as item.
           * @example
           * let corner = new Corner(floorplan, 0, 0);
           * function cornerRemoved(e) { console.log('I WAS REMOVED FROM LOCATION ', e.item.x, e.item.y) };
           * corner.remove();
           * @emits {EVENT_DELETED}
           **/

      }, {
          key: 'remove',
          value: function remove() {
              this.dispatchEvent({ type: EVENT_DELETED, item: this });
              //      this.deleted_callbacks.fire(this);
          }

          /**
           * Removes all the connected corners and itself. This in essence removes all the walls({@link Wall}) this corner is connected to.
           * @example
           * let corner1 = new Corner(floorplan, 0, 0);
           * let corner2 = new Corner(floorplan, 10, 0);
           * function cornerRemoved(e) { console.log('I WAS REMOVED FROM LOCATION ', e.item.x, e.item.y) } //Will log twice for two corners;
           * corner.removeAll();
           **/

      }, {
          key: 'removeAll',
          value: function removeAll() {
              var i = 0;
              for (i = 0; i < this.wallStarts.length; i++) {
                  this.wallStarts[i].remove();
              }
              for (i = 0; i < this.wallEnds.length; i++) {
                  this.wallEnds[i].remove();
              }
              this.remove();
          }

          //Angle is in degrees 0 - 360

      }, {
          key: 'closestAngle',
          value: function closestAngle(angle) {
              var neighbors = this.adjacentCorners();
              var delta = 999999;
              var closestAngle = 0;
              var point = new Vector2();
              for (var i = 0; i < neighbors.length; i++) {
                  var wall = this.wallToOrFrom(neighbors[i]);
                  if (wall.wallType === WallTypes.CURVED) {
                      continue;
                  }
                  var neighbourAngle = neighbors[i].location.clone().sub(this.location).angle();
                  neighbourAngle = neighbourAngle * 180 / Math.PI;
                  var diff = Math.abs(angle - neighbourAngle);
                  if (diff < delta) {
                      delta = diff;
                      point.x = neighbors[i].location.x;
                      point.y = neighbors[i].location.y;
                      closestAngle = neighbourAngle;
                  }
              }
              return { angle: closestAngle, point: point };
          }
      }, {
          key: 'updateAngles',
          value: function updateAngles() {
              var neighbors = this.adjacentCorners();
              this._angles = [];
              this._angleDirections = [];
              this._startAngles = [];
              this._endAngles = [];
              this._cyclicNeighbors = [];
              if (neighbors.length < 2) {
                  return;
              }

              var start = this.location.clone();
              var points = [];
              for (var i = 0; i < neighbors.length; i++) {
                  points.push(neighbors[i].location);
              }
              var indicesAndAngles = Utils.getCyclicOrder(points, start);
              var indices = indicesAndAngles['indices'];
              var angles = indicesAndAngles['angles'];
              //		var N = (indices.length%2 === 0)? (indices.length < 3) ? indices.length - 1 : indices.length : indices.length - 1;
              var N = indices.length < 3 ? 1 : indices.length;
              for (var _i = 0; _i < N; _i++) {
                  var next = (_i + 1) % indices.length;
                  var cindex = indices[_i];
                  var nindex = indices[next];

                  var cwall = this.wallToOrFrom(neighbors[cindex]);
                  var nwall = this.wallToOrFrom(neighbors[nindex]);
                  if (cwall != null && nwall != null) {
                      if (cwall.wallType === WallTypes.CURVED || nwall.wallType === WallTypes.CURVED) {
                          //					No use in showing angle between two curved or two walls with intermixed types of straight and curved
                          //					Set everything to zero
                          this._startAngles.push(0);
                          this._endAngles.push(0);
                          this._angles.push(0);
                          this._angleDirections.push(new Vector2(0, 0));
                          this._cyclicNeighbors.push(neighbors[indices[_i]]);
                          continue;
                      }
                  }

                  var vectorA = points[cindex].clone().sub(start).normalize();
                  var vectorB = points[nindex].clone().sub(start).normalize();
                  var midVector = vectorA.add(vectorB).multiplyScalar(20.0);

                  var diffAngle = Math.abs(angles[next] - angles[_i]);
                  diffAngle = diffAngle > 180 ? 360 - diffAngle : diffAngle;
                  diffAngle = Math.round(diffAngle * 10) / 10;
                  this._startAngles.push(angles[_i]);
                  this._endAngles.push(angles[next]);
                  this._angles.push(diffAngle);
                  this._angleDirections.push(midVector);
                  this._cyclicNeighbors.push(neighbors[indices[_i]]);
              }
          }

          /**
           * When a corner is moved from its location it will impact the connected rooms ({@link Room}) shape, thus their areas. This will update the rooms
           * @example
           * let corner = new Corner(floorplan, 0, 0);
           * corner.move(10, 0);
           **/

      }, {
          key: 'updateAttachedRooms',
          value: function updateAttachedRooms() {
              var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (!this._hasChanged && !explicit) {
                  return;
              }
              //		console.log('UPDATE ALL ATTACHED ROOMS :: ');
              this.attachedRooms.forEach(function (room) {
                  room.updateArea();
              });
              this._hasChanged = false;
          }

          /** Gets the adjacent corners that are connected to this corner by walls ({@link Wall}).
           * @returns {Corner[]} Array of corners.
           */

      }, {
          key: 'adjacentCorners',
          value: function adjacentCorners() {
              var retArray = [];
              var i = 0;
              for (i = 0; i < this.wallStarts.length; i++) {
                  retArray.push(this.wallStarts[i].getEnd());
              }
              for (i = 0; i < this.wallEnds.length; i++) {
                  retArray.push(this.wallEnds[i].getStart());
              }
              return retArray;
          }

          /** Checks if a wall is connected.
           * @param {Wall} wall A wall.
           * @returns {boolean} in case of connection.
           */

      }, {
          key: 'isWallConnected',
          value: function isWallConnected(wall) {
              var i = 0;
              for (i = 0; i < this.wallStarts.length; i++) {
                  if (this.wallStarts[i] === wall) {
                      return true;
                  }
              }
              for (i = 0; i < this.wallEnds.length; i++) {
                  if (this.wallEnds[i] === wall) {
                      return true;
                  }
              }
              return false;
          }

          /**
           * Returns the distance between this corner and a point in 2d space
           * @param {Vector2} point
           * @see https://threejs.org/docs/#api/en/math/Vector2
           * @return {Number} distance The distance
           **/

      }, {
          key: 'distanceFrom',
          value: function distanceFrom(point) {
              var distance = Utils.distance(point, new Vector2(this.x, this.y));
              //console.log('x,y ' + x + ',' + y + ' to ' + this.getX() + ',' + this.getY() + ' is ' + distance);
              return distance;
          }

          /** Gets the distance from a wall.
           * @param {Wall} wall A wall.
           * @returns {Number} distance The distance.
           */

      }, {
          key: 'distanceFromWall',
          value: function distanceFromWall(wall) {
              var cPoint = new Vector2(this.x, this.y);
              if (wall.wallType === WallTypes.STRAIGHT) {
                  return wall.distanceFrom(cPoint);
              } else if (wall.wallType === WallTypes.CURVED) {
                  var p = wall.bezier.project(cPoint);
                  var projected = new Vector2(p.x, p.y);
                  return projected.distanceTo(cPoint);
              }
          }

          /** Gets the distance from a corner.
           * @param {Corner} corner A corner.
           * @returns {Number} The distance.
           */

      }, {
          key: 'distanceFromCorner',
          value: function distanceFromCorner(corner) {
              return this.distanceFrom(new Vector2(corner.x, corner.y));
          }

          /** Detaches a wall.
           * @param {Wall} wall A wall.
           */

      }, {
          key: 'detachWall',
          value: function detachWall(wall) {
              Utils.removeValue(this.wallStarts, wall);
              Utils.removeValue(this.wallEnds, wall);

              if (this.wallStarts.length === 0 && this.wallEnds.length === 0) {
                  this.remove();
              }
          }

          /** Attaches a start wall.
           * @param {Wall} wall A wall.
           */

      }, {
          key: 'attachStart',
          value: function attachStart(wall) {
              this.wallStarts.push(wall);
          }

          /** Attaches an end wall.
           * @param {Wall} wall A wall.
           */

      }, {
          key: 'attachEnd',
          value: function attachEnd(wall) {
              this.wallEnds.push(wall);
          }

          /** Get wall to corner.
           * @param {Corner} corner A corner.
           * @return {Wall} The associated wall or null.
           */

      }, {
          key: 'wallTo',
          value: function wallTo(corner) {
              for (var i = 0; i < this.wallStarts.length; i++) {
                  if (this.wallStarts[i].getEnd() === corner) {
                      return this.wallStarts[i];
                  }
              }
              return null;
          }

          /** Get wall from corner.
           * @param {Corner}  corner A corner.
           * @return {Wall} The associated wall or null.
           */

      }, {
          key: 'wallFrom',
          value: function wallFrom(corner) {
              for (var i = 0; i < this.wallEnds.length; i++) {
                  if (this.wallEnds[i].getStart() === corner) {
                      return this.wallEnds[i];
                  }
              }
              return null;
          }

          /** Get wall to or from corner.
           * @param {Corner} corner A corner.
           * @return {Wall} The associated wall or null.
           */

      }, {
          key: 'wallToOrFrom',
          value: function wallToOrFrom(corner) {
              return this.wallTo(corner) || this.wallFrom(corner);
          }

          /** Get wall from corner.
           * @param {Corner}  corner A corner.
           */

      }, {
          key: 'combineWithCorner',
          value: function combineWithCorner(corner) {
              var i = 0;
              // update position to other corner's
              //		this.x = corner.x;
              //		this.y = corner.y;
              this.move(corner.x, corner.y, false);
              // absorb the other corner's wallStarts and wallEnds
              for (i = corner.wallStarts.length - 1; i >= 0; i--) {
                  corner.wallStarts[i].setStart(this);
              }
              for (i = corner.wallEnds.length - 1; i >= 0; i--) {
                  corner.wallEnds[i].setEnd(this);
              }

              var rooms = corner.getAttachedRooms();
              for (i = 0; i < rooms.length; i++) {
                  var room = rooms[i];
                  //Below returns the roomname object
                  var roomname = this.floorplan.metaroomsdata[room.roomByCornersId];
                  if (roomname) {
                      var oldId = room.roomByCornersId;
                      var newId = oldId.replace(corner.id, this.id);
                      this.floorplan.metaroomsdata[newId] = {};
                      this.floorplan.metaroomsdata[newId]['name'] = roomname['name'];
                      delete this.floorplan.metaroomsdata[oldId];
                  }
              }

              // delete the other corner
              corner.removeAll();
              this.removeDuplicateWalls();
              this.floorplan.update();
          }
      }, {
          key: 'mergeWithIntersected',
          value: function mergeWithIntersected() {
              var updateFloorPlan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              var i = 0;
              //console.log('mergeWithIntersected for object: ' + this.type);
              // check corners
              for (i = 0; i < this.floorplan.getCorners().length; i++) {
                  var corner = this.floorplan.getCorners()[i];
                  if (this.distanceFromCorner(corner) < cornerTolerance && corner !== this) {
                      this.combineWithCorner(corner);
                      return true;
                  }
              }
              // check walls
              for (i = 0; i < this.floorplan.getWalls().length; i++) {
                  var wall = this.floorplan.getWalls()[i];
                  if (this.distanceFromWall(wall) < cornerTolerance && !this.isWallConnected(wall)) {
                      // update position to be on wall
                      var intersection = void 0;
                      if (wall.wallType === WallTypes.STRAIGHT) {
                          intersection = Utils.closestPointOnLine(new Vector2(this.x, this.y), wall.getStart(), wall.getEnd());
                      } else if (wall.wallType === WallTypes.CURVED) {
                          intersection = wall.bezier.project(new Vector2(this.x, this.y));
                      }

                      if (wall.wallType === WallTypes.STRAIGHT) {
                          // merge this corner into wall by breaking wall into two parts
                          this.floorplan.newWall(this, wall.getEnd());
                          wall.setEnd(this);
                      } else if (wall.wallType === WallTypes.CURVED) {
                          // merge this corner into wall by breaking wall into two parts				
                          this.floorplan.newWall(this, wall.getEnd());
                          wall.setEnd(this);
                      }

                      //The below line is crashing because of recursive. This function mergeWithIntersected is called 
                      //From move(newX, newY) method. Now if we call move(newX, newY) from inside this method
                      //It will lead to recursion. So ensure in the move(newX, newY) method mergeWithIntersected is not called
                      //Hence added a third parameter to move(newX, newY, mergeWithIntersections) that is a boolean value
                      //Send this boolean value as false to avoid recursion crashing of the application
                      this.move(intersection.x, intersection.y, false, updateFloorPlan); //Causes Recursion if third parameter is true

                      this.floorplan.update();
                      return true;
                  }
              }
              return false;
          }

          /** Ensure we do not have duplicate walls (i.e. same start and end points) */

      }, {
          key: 'removeDuplicateWalls',
          value: function removeDuplicateWalls() {
              var i = 0;
              // delete the wall between these corners, if it exists
              var wallEndpoints = {};
              var wallStartpoints = {};
              for (i = this.wallStarts.length - 1; i >= 0; i--) {
                  if (this.wallStarts[i].getEnd() === this) {
                      // remove zero length wall
                      this.wallStarts[i].remove();
                  } else if (this.wallStarts[i].getEnd().id in wallEndpoints) {
                      // remove duplicated wall
                      this.wallStarts[i].remove();
                  } else {
                      wallEndpoints[this.wallStarts[i].getEnd().id] = true;
                  }
              }
              for (i = this.wallEnds.length - 1; i >= 0; i--) {
                  if (this.wallEnds[i].getStart() === this) {
                      // removed zero length wall
                      this.wallEnds[i].remove();
                  } else if (this.wallEnds[i].getStart().id in wallStartpoints) {
                      // removed duplicated wall
                      this.wallEnds[i].remove();
                  } else {
                      wallStartpoints[this.wallEnds[i].getStart().id] = true;
                  }
              }
          }
      }, {
          key: 'uuid',
          get: function get() {
              return this.id;
          }
      }, {
          key: 'startAngles',
          get: function get() {
              return this._startAngles;
          }
      }, {
          key: 'endAngles',
          get: function get() {
              return this._endAngles;
          }
      }, {
          key: 'angles',
          get: function get() {
              return this._angles;
          }
      }, {
          key: 'angleDirections',
          get: function get() {
              return this._angleDirections;
          }
      }, {
          key: 'location',
          get: function get() {
              return this._co;
          },
          set: function set(xy) {
              this._co.x = xy.x;
              this._co.y = xy.y;
              this.x = xy.x;
              this.y = xy.y;
          }
      }, {
          key: 'x',
          get: function get() {
              return this._x;
          },
          set: function set(value) {
              var oldvalue = this._x;
              if (Math.abs(value - this._x) > 1e-6) {
                  this._hasChanged = true;
              }
              this._x = value;
              if (this._hasChanged) {
                  this._co.x = this._x;
                  this.updateAttachedRooms();
                  //			this.floorplan.update(false);
                  this.dispatchEvent({ type: EVENT_CORNER_ATTRIBUTES_CHANGED, item: this, info: { from: oldvalue, to: this._x } });
              }
          }
      }, {
          key: 'y',
          get: function get() {
              return this._y;
          },
          set: function set(value) {
              var oldvalue = this._y;
              if (Math.abs(value - this._y) > 1e-6) {
                  this._hasChanged = true;
              }
              this._y = value;
              if (this._hasChanged) {
                  this._co.y = this._y;
                  this.updateAttachedRooms();
                  //			this.floorplan.update(false);
                  this.dispatchEvent({ type: EVENT_CORNER_ATTRIBUTES_CHANGED, item: this, info: { from: oldvalue, to: this._y } });
              }
          }

          /** @type {Number} elevation The elevation value at this corner*/

      }, {
          key: 'elevation',
          set: function set(value) {
              var oldvalue = this._elevation;
              if (value - this._elevation < 1e-6) {
                  this._hasChanged = true;
              }
              this._elevation = Number(value); //Dimensioning.cmFromMeasureRaw(Number(value));
              if (this._hasChanged) {
                  this.dispatchEvent({ type: EVENT_CORNER_ATTRIBUTES_CHANGED, item: this, info: { from: oldvalue, to: this._elevation } });
              }
          }

          /** @type {Number} elevation The elevation value at this corner*/
          ,
          get: function get() {
              return this._elevation;
          }
      }]);
      return Corner;
  }(EventDispatcher);

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var utils = createCommonjsModule(function (module) {
  (function() {

    // math-inlining.
    var abs = Math.abs,
      cos = Math.cos,
      sin = Math.sin,
      acos = Math.acos,
      atan2 = Math.atan2,
      sqrt = Math.sqrt,
      pow = Math.pow,
      // cube root function yielding real roots
      crt = function(v) {
        return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
      },
      // trig constants
      pi = Math.PI,
      tau = 2 * pi,
      quart = pi / 2,
      // float precision significant decimal
      epsilon = 0.000001,
      // extremas used in bbox calculation and similar algorithms
      nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,
      nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,
      // a zero coordinate, which is surprisingly useful
      ZERO = { x: 0, y: 0, z: 0 };

    // Bezier utility functions
    var utils = {
      // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
      Tvalues: [
        -0.0640568928626056260850430826247450385909,
        0.0640568928626056260850430826247450385909,
        -0.1911188674736163091586398207570696318404,
        0.1911188674736163091586398207570696318404,
        -0.3150426796961633743867932913198102407864,
        0.3150426796961633743867932913198102407864,
        -0.4337935076260451384870842319133497124524,
        0.4337935076260451384870842319133497124524,
        -0.5454214713888395356583756172183723700107,
        0.5454214713888395356583756172183723700107,
        -0.6480936519369755692524957869107476266696,
        0.6480936519369755692524957869107476266696,
        -0.7401241915785543642438281030999784255232,
        0.7401241915785543642438281030999784255232,
        -0.8200019859739029219539498726697452080761,
        0.8200019859739029219539498726697452080761,
        -0.8864155270044010342131543419821967550873,
        0.8864155270044010342131543419821967550873,
        -0.9382745520027327585236490017087214496548,
        0.9382745520027327585236490017087214496548,
        -0.9747285559713094981983919930081690617411,
        0.9747285559713094981983919930081690617411,
        -0.9951872199970213601799974097007368118745,
        0.9951872199970213601799974097007368118745
      ],

      // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
      Cvalues: [
        0.1279381953467521569740561652246953718517,
        0.1279381953467521569740561652246953718517,
        0.1258374563468282961213753825111836887264,
        0.1258374563468282961213753825111836887264,
        0.121670472927803391204463153476262425607,
        0.121670472927803391204463153476262425607,
        0.1155056680537256013533444839067835598622,
        0.1155056680537256013533444839067835598622,
        0.1074442701159656347825773424466062227946,
        0.1074442701159656347825773424466062227946,
        0.0976186521041138882698806644642471544279,
        0.0976186521041138882698806644642471544279,
        0.086190161531953275917185202983742667185,
        0.086190161531953275917185202983742667185,
        0.0733464814110803057340336152531165181193,
        0.0733464814110803057340336152531165181193,
        0.0592985849154367807463677585001085845412,
        0.0592985849154367807463677585001085845412,
        0.0442774388174198061686027482113382288593,
        0.0442774388174198061686027482113382288593,
        0.0285313886289336631813078159518782864491,
        0.0285313886289336631813078159518782864491,
        0.0123412297999871995468056670700372915759,
        0.0123412297999871995468056670700372915759
      ],

      arcfn: function(t, derivativeFn) {
        var d = derivativeFn(t);
        var l = d.x * d.x + d.y * d.y;
        if (typeof d.z !== "undefined") {
          l += d.z * d.z;
        }
        return sqrt(l);
      },

      compute: function(t, points, _3d) {
        // shortcuts
        if (t === 0) {
          return points[0];
        }

        var order = points.length-1;

        if (t === 1) {
          return points[order];
        }

        var p = points;
        var mt = 1 - t;

        // constant?
        if (order === 0) {
          return points[0];
        }

        // linear?
        if (order === 1) {
          ret = {
            x: mt * p[0].x + t * p[1].x,
            y: mt * p[0].y + t * p[1].y
          };
          if (_3d) {
            ret.z = mt * p[0].z + t * p[1].z;
          }
          return ret;
        }

        // quadratic/cubic curve?
        if (order < 4) {
          var mt2 = mt * mt,
            t2 = t * t,
            a,
            b,
            c,
            d = 0;
          if (order === 2) {
            p = [p[0], p[1], p[2], ZERO];
            a = mt2;
            b = mt * t * 2;
            c = t2;
          } else if (order === 3) {
            a = mt2 * mt;
            b = mt2 * t * 3;
            c = mt * t2 * 3;
            d = t * t2;
          }
          var ret = {
            x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
            y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
          };
          if (_3d) {
            ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
          }
          return ret;
        }

        // higher order curves: use de Casteljau's computation
        var dCpts = JSON.parse(JSON.stringify(points));
        while (dCpts.length > 1) {
          for (var i = 0; i < dCpts.length - 1; i++) {
            dCpts[i] = {
              x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,
              y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t
            };
            if (typeof dCpts[i].z !== "undefined") {
              dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;
            }
          }
          dCpts.splice(dCpts.length - 1, 1);
        }
        return dCpts[0];
      },

      computeWithRatios: function (t, points, ratios, _3d) {
        var mt = 1 - t, r = ratios, p = points, d;
        var f1 = r[0], f2 = r[1], f3 = r[2], f4 = r[3];

        // spec for linear
        f1 *= mt;
        f2 *= t;

        if (p.length === 2) {
          d = f1 + f2;
          return {
            x: (f1 * p[0].x + f2 * p[1].x)/d,
            y: (f1 * p[0].y + f2 * p[1].y)/d,
            z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z)/d
          };
        }

        // upgrade to quadratic
        f1 *= mt;
        f2 *= 2 * mt;
        f3 *= t * t;

        if (p.length === 3) {
          d = f1 + f2 + f3;
          return {
            x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x)/d,
            y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y)/d,
            z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z)/d
          };
        }

        // upgrade to cubic
        f1 *= mt;
        f2 *= 1.5 * mt;
        f3 *= 3 * mt;
        f4 *= t * t * t;

        if (p.length === 4) {
          d = f1 + f2 + f3 + f4;
          return {
            x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x)/d,
            y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y)/d,
            z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z)/d
          };
        }
      },

      derive: function (points, _3d) {
        var dpoints = [];
        for (var p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
          var list = [];
          for (var j = 0, dpt; j < c; j++) {
            dpt = {
              x: c * (p[j + 1].x - p[j].x),
              y: c * (p[j + 1].y - p[j].y)
            };
            if (_3d) {
              dpt.z = c * (p[j + 1].z - p[j].z);
            }
            list.push(dpt);
          }
          dpoints.push(list);
          p = list;
        }
        return dpoints;
      },

      between: function(v, m, M) {
        return (
          (m <= v && v <= M) ||
          utils.approximately(v, m) ||
          utils.approximately(v, M)
        );
      },

      approximately: function(a, b, precision) {
        return abs(a - b) <= (precision || epsilon);
      },

      length: function(derivativeFn) {
        var z = 0.5,
          sum = 0,
          len = utils.Tvalues.length,
          i,
          t;
        for (i = 0; i < len; i++) {
          t = z * utils.Tvalues[i] + z;
          sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);
        }
        return z * sum;
      },

      map: function(v, ds, de, ts, te) {
        var d1 = de - ds,
          d2 = te - ts,
          v2 = v - ds,
          r = v2 / d1;
        return ts + d2 * r;
      },

      lerp: function(r, v1, v2) {
        var ret = {
          x: v1.x + r * (v2.x - v1.x),
          y: v1.y + r * (v2.y - v1.y)
        };
        if (!!v1.z && !!v2.z) {
          ret.z = v1.z + r * (v2.z - v1.z);
        }
        return ret;
      },

      pointToString: function(p) {
        var s = p.x + "/" + p.y;
        if (typeof p.z !== "undefined") {
          s += "/" + p.z;
        }
        return s;
      },

      pointsToString: function(points) {
        return "[" + points.map(utils.pointToString).join(", ") + "]";
      },

      copy: function(obj) {
        return JSON.parse(JSON.stringify(obj));
      },

      angle: function(o, v1, v2) {
        var dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1 * dy2 - dy1 * dx2,
          dot = dx1 * dx2 + dy1 * dy2;
        return atan2(cross, dot);
      },

      // round as string, to avoid rounding errors
      round: function(v, d) {
        var s = "" + v;
        var pos = s.indexOf(".");
        return parseFloat(s.substring(0, pos + 1 + d));
      },

      dist: function(p1, p2) {
        var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
        return sqrt(dx * dx + dy * dy);
      },

      closest: function(LUT, point) {
        var mdist = pow(2, 63),
          mpos,
          d;
        LUT.forEach(function(p, idx) {
          d = utils.dist(point, p);
          if (d < mdist) {
            mdist = d;
            mpos = idx;
          }
        });
        return { mdist: mdist, mpos: mpos };
      },

      abcratio: function(t, n) {
        // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
        if (n !== 2 && n !== 3) {
          return false;
        }
        if (typeof t === "undefined") {
          t = 0.5;
        } else if (t === 0 || t === 1) {
          return t;
        }
        var bottom = pow(t, n) + pow(1 - t, n),
          top = bottom - 1;
        return abs(top / bottom);
      },

      projectionratio: function(t, n) {
        // see u(t) note on http://pomax.github.io/bezierinfo/#abc
        if (n !== 2 && n !== 3) {
          return false;
        }
        if (typeof t === "undefined") {
          t = 0.5;
        } else if (t === 0 || t === 1) {
          return t;
        }
        var top = pow(1 - t, n),
          bottom = pow(t, n) + top;
        return top / bottom;
      },

      lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
        var nx =
            (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
          ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
          d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (d == 0) {
          return false;
        }
        return { x: nx / d, y: ny / d };
      },

      lli4: function(p1, p2, p3, p4) {
        var x1 = p1.x,
          y1 = p1.y,
          x2 = p2.x,
          y2 = p2.y,
          x3 = p3.x,
          y3 = p3.y,
          x4 = p4.x,
          y4 = p4.y;
        return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
      },

      lli: function(v1, v2) {
        return utils.lli4(v1, v1.c, v2, v2.c);
      },

      makeline: function(p1, p2) {
        var Bezier = bezier;
        var x1 = p1.x,
          y1 = p1.y,
          x2 = p2.x,
          y2 = p2.y,
          dx = (x2 - x1) / 3,
          dy = (y2 - y1) / 3;
        return new Bezier(
          x1,
          y1,
          x1 + dx,
          y1 + dy,
          x1 + 2 * dx,
          y1 + 2 * dy,
          x2,
          y2
        );
      },

      findbbox: function(sections) {
        var mx = nMax,
          my = nMax,
          MX = nMin,
          MY = nMin;
        sections.forEach(function(s) {
          var bbox = s.bbox();
          if (mx > bbox.x.min) mx = bbox.x.min;
          if (my > bbox.y.min) my = bbox.y.min;
          if (MX < bbox.x.max) MX = bbox.x.max;
          if (MY < bbox.y.max) MY = bbox.y.max;
        });
        return {
          x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
          y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
        };
      },

      shapeintersections: function(
        s1,
        bbox1,
        s2,
        bbox2,
        curveIntersectionThreshold
      ) {
        if (!utils.bboxoverlap(bbox1, bbox2)) return [];
        var intersections = [];
        var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
        var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
        a1.forEach(function(l1) {
          if (l1.virtual) return;
          a2.forEach(function(l2) {
            if (l2.virtual) return;
            var iss = l1.intersects(l2, curveIntersectionThreshold);
            if (iss.length > 0) {
              iss.c1 = l1;
              iss.c2 = l2;
              iss.s1 = s1;
              iss.s2 = s2;
              intersections.push(iss);
            }
          });
        });
        return intersections;
      },

      makeshape: function(forward, back, curveIntersectionThreshold) {
        var bpl = back.points.length;
        var fpl = forward.points.length;
        var start = utils.makeline(back.points[bpl - 1], forward.points[0]);
        var end = utils.makeline(forward.points[fpl - 1], back.points[0]);
        var shape = {
          startcap: start,
          forward: forward,
          back: back,
          endcap: end,
          bbox: utils.findbbox([start, forward, back, end])
        };
        var self = utils;
        shape.intersections = function(s2) {
          return self.shapeintersections(
            shape,
            shape.bbox,
            s2,
            s2.bbox,
            curveIntersectionThreshold
          );
        };
        return shape;
      },

      getminmax: function(curve, d, list) {
        if (!list) return { min: 0, max: 0 };
        var min = nMax,
          max = nMin,
          t,
          c;
        if (list.indexOf(0) === -1) {
          list = [0].concat(list);
        }
        if (list.indexOf(1) === -1) {
          list.push(1);
        }
        for (var i = 0, len = list.length; i < len; i++) {
          t = list[i];
          c = curve.get(t);
          if (c[d] < min) {
            min = c[d];
          }
          if (c[d] > max) {
            max = c[d];
          }
        }
        return { min: min, mid: (min + max) / 2, max: max, size: max - min };
      },

      align: function(points, line) {
        var tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y - ty, line.p2.x - tx),
          d = function(v) {
            return {
              x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),
              y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)
            };
          };
        return points.map(d);
      },

      roots: function(points, line) {
        line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
        var order = points.length - 1;
        var p = utils.align(points, line);
        var reduce = function(t) {
          return 0 <= t && t <= 1;
        };

        if (order === 2) {
          var a = p[0].y,
            b = p[1].y,
            c = p[2].y,
            d = a - 2 * b + c;
          if (d !== 0) {
            var m1 = -sqrt(b * b - a * c),
              m2 = -a + b,
              v1 = -(m1 + m2) / d,
              v2 = -(-m1 + m2) / d;
            return [v1, v2].filter(reduce);
          } else if (b !== c && d === 0) {
            return [(2*b - c)/(2*b - 2*c)].filter(reduce);
          }
          return [];
        }

        // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
        var pa = p[0].y,
          pb = p[1].y,
          pc = p[2].y,
          pd = p[3].y,
          d = -pa + 3 * pb - 3 * pc + pd,
          a = 3 * pa - 6 * pb + 3 * pc,
          b = -3 * pa + 3 * pb,
          c = pa;

        if (utils.approximately(d, 0)) {
          // this is not a cubic curve.
          if (utils.approximately(a, 0)) {
            // in fact, this is not a quadratic curve either.
            if (utils.approximately(b, 0)) {
              // in fact in fact, there are no solutions.
              return [];
            }
            // linear solution:
            return [-c / b].filter(reduce);
          }
          // quadratic solution:
          var q = sqrt(b * b - 4 * a * c),
            a2 = 2 * a;
          return [(q - b) / a2, (-b - q) / a2].filter(reduce);
        }

        // at this point, we know we need a cubic solution:

        a /= d;
        b /= d;
        c /= d;

        var p = (3 * b - a * a) / 3,
          p3 = p / 3,
          q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,
          q2 = q / 2,
          discriminant = q2 * q2 + p3 * p3 * p3,
          u1,
          v1,
          x1,
          x2,
          x3;
        if (discriminant < 0) {
          var mp3 = -p / 3,
            mp33 = mp3 * mp3 * mp3,
            r = sqrt(mp33),
            t = -q / (2 * r),
            cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
            phi = acos(cosphi),
            crtr = crt(r),
            t1 = 2 * crtr;
          x1 = t1 * cos(phi / 3) - a / 3;
          x2 = t1 * cos((phi + tau) / 3) - a / 3;
          x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;
          return [x1, x2, x3].filter(reduce);
        } else if (discriminant === 0) {
          u1 = q2 < 0 ? crt(-q2) : -crt(q2);
          x1 = 2 * u1 - a / 3;
          x2 = -u1 - a / 3;
          return [x1, x2].filter(reduce);
        } else {
          var sd = sqrt(discriminant);
          u1 = crt(-q2 + sd);
          v1 = crt(q2 + sd);
          return [u1 - v1 - a / 3].filter(reduce);
        }
      },

      droots: function(p) {
        // quadratic roots are easy
        if (p.length === 3) {
          var a = p[0],
            b = p[1],
            c = p[2],
            d = a - 2 * b + c;
          if (d !== 0) {
            var m1 = -sqrt(b * b - a * c),
              m2 = -a + b,
              v1 = -(m1 + m2) / d,
              v2 = -(-m1 + m2) / d;
            return [v1, v2];
          } else if (b !== c && d === 0) {
            return [(2 * b - c) / (2 * (b - c))];
          }
          return [];
        }

        // linear roots are even easier
        if (p.length === 2) {
          var a = p[0],
            b = p[1];
          if (a !== b) {
            return [a / (a - b)];
          }
          return [];
        }
      },

      curvature: function(t, points, _3d, kOnly) {
        var dpoints = utils.derive(points);
        var d1 = dpoints[0];
        var d2 = dpoints[1];
        var num, dnm, adk, dk, k=0, r=0;

        //
        // We're using the following formula for curvature:
        //
        //              x'y" - y'x"
        //   k(t) = ------------------
        //           (x'² + y'²)^(3/2)
        //
        // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition
        //
        // With it corresponding 3D counterpart:
        //
        //          sqrt( (y'z" - y"z')² + (z'x" - z"x')² + (x'y" - x"y')²)
        //   k(t) = -------------------------------------------------------
        //                     (x'² + y'² + z'²)^(3/2)
        //

        var d = utils.compute(t, d1);
        var dd = utils.compute(t, d2);
        var qdsum = d.x*d.x + d.y*d.y;
        if (_3d) {
          num = sqrt(
            pow(d.y*dd.z - dd.y*d.z, 2) +
            pow(d.z*dd.x - dd.z*d.x, 2) +
            pow(d.x*dd.y - dd.x*d.y, 2)
          );
          dnm = pow(qdsum + d.z*d.z, 3/2);
        } else {
          num = d.x*dd.y - d.y*dd.x;
          dnm = pow(qdsum, 3/2);
        }

        if (num === 0 || dnm === 0) {
          return { k:0, r:0 };
        }

        k = num/dnm;
        r = dnm/num;

        // We're also computing the derivative of kappa, because
        // there is value in knowing the rate of change for the
        // curvature along the curve. And we're just going to
        // ballpark it based on an epsilon.
        if (!kOnly) {
          // compute k'(t) based on the interval before, and after it,
          // to at least try to not introduce forward/backward pass bias.
          var pk = utils.curvature(t-0.001, points, _3d, true).k;
          var nk = utils.curvature(t+0.001, points, _3d, true).k;
          dk = ((nk-k) + (k-pk))/2;
          adk = (abs(nk-k) + abs(k-pk))/2;
        }

        return { k: k, r: r, dk: dk, adk:adk, };
      },

      inflections: function(points) {
        if (points.length < 4) return [];

        // FIXME: TODO: add in inflection abstraction for quartic+ curves?

        var p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
          a = p[2].x * p[1].y,
          b = p[3].x * p[1].y,
          c = p[1].x * p[2].y,
          d = p[3].x * p[2].y,
          v1 = 18 * (-3 * a + 2 * b + 3 * c - d),
          v2 = 18 * (3 * a - b - 3 * c),
          v3 = 18 * (c - a);

        if (utils.approximately(v1, 0)) {
          if (!utils.approximately(v2, 0)) {
            var t = -v3 / v2;
            if (0 <= t && t <= 1) return [t];
          }
          return [];
        }

        var trm = v2 * v2 - 4 * v1 * v3,
          sq = Math.sqrt(trm),
          d = 2 * v1;

        if (utils.approximately(d, 0)) return [];

        return [(sq - v2) / d, -(v2 + sq) / d].filter(function(r) {
          return 0 <= r && r <= 1;
        });
      },

      bboxoverlap: function(b1, b2) {
        var dims = ["x", "y"],
          len = dims.length,
          i,
          dim,
          l,
          t,
          d;
        for (i = 0; i < len; i++) {
          dim = dims[i];
          l = b1[dim].mid;
          t = b2[dim].mid;
          d = (b1[dim].size + b2[dim].size) / 2;
          if (abs(l - t) >= d) return false;
        }
        return true;
      },

      expandbox: function(bbox, _bbox) {
        if (_bbox.x.min < bbox.x.min) {
          bbox.x.min = _bbox.x.min;
        }
        if (_bbox.y.min < bbox.y.min) {
          bbox.y.min = _bbox.y.min;
        }
        if (_bbox.z && _bbox.z.min < bbox.z.min) {
          bbox.z.min = _bbox.z.min;
        }
        if (_bbox.x.max > bbox.x.max) {
          bbox.x.max = _bbox.x.max;
        }
        if (_bbox.y.max > bbox.y.max) {
          bbox.y.max = _bbox.y.max;
        }
        if (_bbox.z && _bbox.z.max > bbox.z.max) {
          bbox.z.max = _bbox.z.max;
        }
        bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
        bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
        if (bbox.z) {
          bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
        }
        bbox.x.size = bbox.x.max - bbox.x.min;
        bbox.y.size = bbox.y.max - bbox.y.min;
        if (bbox.z) {
          bbox.z.size = bbox.z.max - bbox.z.min;
        }
      },

      pairiteration: function(c1, c2, curveIntersectionThreshold) {
        var c1b = c1.bbox(),
          c2b = c2.bbox(),
          r = 100000,
          threshold = curveIntersectionThreshold || 0.5;
        if (
          c1b.x.size + c1b.y.size < threshold &&
          c2b.x.size + c2b.y.size < threshold
        ) {
          return [
            ((r * (c1._t1 + c1._t2) / 2) | 0) / r +
              "/" +
              ((r * (c2._t1 + c2._t2) / 2) | 0) / r
          ];
        }
        var cc1 = c1.split(0.5),
          cc2 = c2.split(0.5),
          pairs = [
            { left: cc1.left, right: cc2.left },
            { left: cc1.left, right: cc2.right },
            { left: cc1.right, right: cc2.right },
            { left: cc1.right, right: cc2.left }
          ];
        pairs = pairs.filter(function(pair) {
          return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
        });
        var results = [];
        if (pairs.length === 0) return results;
        pairs.forEach(function(pair) {
          results = results.concat(
            utils.pairiteration(pair.left, pair.right, threshold)
          );
        });
        results = results.filter(function(v, i) {
          return results.indexOf(v) === i;
        });
        return results;
      },

      getccenter: function(p1, p2, p3) {
        var dx1 = p2.x - p1.x,
          dy1 = p2.y - p1.y,
          dx2 = p3.x - p2.x,
          dy2 = p3.y - p2.y;
        var dx1p = dx1 * cos(quart) - dy1 * sin(quart),
          dy1p = dx1 * sin(quart) + dy1 * cos(quart),
          dx2p = dx2 * cos(quart) - dy2 * sin(quart),
          dy2p = dx2 * sin(quart) + dy2 * cos(quart);
        // chord midpoints
        var mx1 = (p1.x + p2.x) / 2,
          my1 = (p1.y + p2.y) / 2,
          mx2 = (p2.x + p3.x) / 2,
          my2 = (p2.y + p3.y) / 2;
        // midpoint offsets
        var mx1n = mx1 + dx1p,
          my1n = my1 + dy1p,
          mx2n = mx2 + dx2p,
          my2n = my2 + dy2p;
        // intersection of these lines:
        var arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),
          r = utils.dist(arc, p1),
          // arc start/end values, over mid point:
          s = atan2(p1.y - arc.y, p1.x - arc.x),
          m = atan2(p2.y - arc.y, p2.x - arc.x),
          e = atan2(p3.y - arc.y, p3.x - arc.x),
          _;
        // determine arc direction (cw/ccw correction)
        if (s < e) {
          // if s<m<e, arc(s, e)
          // if m<s<e, arc(e, s + tau)
          // if s<e<m, arc(e, s + tau)
          if (s > m || m > e) {
            s += tau;
          }
          if (s > e) {
            _ = e;
            e = s;
            s = _;
          }
        } else {
          // if e<m<s, arc(e, s)
          // if m<e<s, arc(s, e + tau)
          // if e<s<m, arc(s, e + tau)
          if (e < m && m < s) {
            _ = e;
            e = s;
            s = _;
          } else {
            e += tau;
          }
        }
        // assign and done.
        arc.s = s;
        arc.e = e;
        arc.r = r;
        return arc;
      },

      numberSort: function(a, b) {
        return a - b;
      }
    };

    module.exports = utils;
  })();
  });

  var polyBezier = createCommonjsModule(function (module) {
  (function() {

    var utils$1 = utils;

    /**
     * Poly Bezier
     * @param {[type]} curves [description]
     */
    var PolyBezier = function(curves) {
      this.curves = [];
      this._3d = false;
      if (!!curves) {
        this.curves = curves;
        this._3d = this.curves[0]._3d;
      }
    };

    PolyBezier.prototype = {
      valueOf: function() {
        return this.toString();
      },
      toString: function() {
        return (
          "[" +
          this.curves
            .map(function(curve) {
              return utils$1.pointsToString(curve.points);
            })
            .join(", ") +
          "]"
        );
      },
      addCurve: function(curve) {
        this.curves.push(curve);
        this._3d = this._3d || curve._3d;
      },
      length: function() {
        return this.curves
          .map(function(v) {
            return v.length();
          })
          .reduce(function(a, b) {
            return a + b;
          });
      },
      curve: function(idx) {
        return this.curves[idx];
      },
      bbox: function() {
        var c = this.curves;
        var bbox = c[0].bbox();
        for (var i = 1; i < c.length; i++) {
          utils$1.expandbox(bbox, c[i].bbox());
        }
        return bbox;
      },
      offset: function(d) {
        var offset = [];
        this.curves.forEach(function(v) {
          offset = offset.concat(v.offset(d));
        });
        return new PolyBezier(offset);
      }
    };

    module.exports = PolyBezier;
  })();
  });

  /**
   * Normalise an SVG path to absolute coordinates
   * and full commands, rather than relative coordinates
   * and/or shortcut commands.
   */
  function normalizePath(d) {
    // preprocess "d" so that we have spaces between values
    d = d
      .replace(/,/g, " ") // replace commas with spaces
      .replace(/-/g, " - ") // add spacing around minus signs
      .replace(/-\s+/g, "-") // remove spacing to the right of minus signs.
      .replace(/([a-zA-Z])/g, " $1 ");

    // set up the variables used in this function
    var instructions = d.replace(/([a-zA-Z])\s?/g, "|$1").split("|"),
      instructionLength = instructions.length,
      i,
      instruction,
      op,
      lop,
      args = [],
      alen,
      a,
      sx = 0,
      sy = 0,
      x = 0,
      y = 0,
      cx = 0,
      cy = 0,
      cx2 = 0,
      cy2 = 0,
      normalized = "";

    // we run through the instruction list starting at 1, not 0,
    // because we split up "|M x y ...." so the first element will
    // always be an empty string. By design.
    for (i = 1; i < instructionLength; i++) {
      // which instruction is this?
      instruction = instructions[i];
      op = instruction.substring(0, 1);
      lop = op.toLowerCase();

      // what are the arguments? note that we need to convert
      // all strings into numbers, or + will do silly things.
      args = instruction
        .replace(op, "")
        .trim()
        .split(" ");
      args = args
        .filter(function(v) {
          return v !== "";
        })
        .map(parseFloat);
      alen = args.length;

      // we could use a switch, but elaborate code in a "case" with
      // fallthrough is just horrid to read. So let's use ifthen
      // statements instead.

      // moveto command (plus possible lineto)
      if (lop === "m") {
        normalized += "M ";
        if (op === "m") {
          x += args[0];
          y += args[1];
        } else {
          x = args[0];
          y = args[1];
        }
        // records start position, for dealing
        // with the shape close operator ('Z')
        sx = x;
        sy = y;
        normalized += x + " " + y + " ";
        if (alen > 2) {
          for (a = 0; a < alen; a += 2) {
            if (op === "m") {
              x += args[a];
              y += args[a + 1];
            } else {
              x = args[a];
              y = args[a + 1];
            }
            normalized += ["L",x,y,''].join(" ");
          }
        }
      } else if (lop === "l") {
        // lineto commands
        for (a = 0; a < alen; a += 2) {
          if (op === "l") {
            x += args[a];
            y += args[a + 1];
          } else {
            x = args[a];
            y = args[a + 1];
          }
          normalized += ["L",x,y,''].join(" ");
        }
      } else if (lop === "h") {
        for (a = 0; a < alen; a++) {
          if (op === "h") {
            x += args[a];
          } else {
            x = args[a];
          }
          normalized += ["L",x,y,''].join(" ");
        }
      } else if (lop === "v") {
        for (a = 0; a < alen; a++) {
          if (op === "v") {
            y += args[a];
          } else {
            y = args[a];
          }
          normalized += ["L",x,y,''].join(" ");
        }
      } else if (lop === "q") {
        // quadratic curveto commands
        for (a = 0; a < alen; a += 4) {
          if (op === "q") {
            cx = x + args[a];
            cy = y + args[a + 1];
            x += args[a + 2];
            y += args[a + 3];
          } else {
            cx = args[a];
            cy = args[a + 1];
            x = args[a + 2];
            y = args[a + 3];
          }
          normalized += ["Q",cx,cy,x,y,''].join(" ");
        }
      } else if (lop === "t") {
        for (a = 0; a < alen; a += 2) {
          // reflect previous cx/cy over x/y
          cx = x + (x - cx);
          cy = y + (y - cy);
          // then get real end point
          if (op === "t") {
            x += args[a];
            y += args[a + 1];
          } else {
            x = args[a];
            y = args[a + 1];
          }
          normalized += ["Q",cx,cy,x,y,''].join(" ");
        }
      } else if (lop === "c") {
        // cubic curveto commands
        for (a = 0; a < alen; a += 6) {
          if (op === "c") {
            cx = x + args[a];
            cy = y + args[a + 1];
            cx2 = x + args[a + 2];
            cy2 = y + args[a + 3];
            x += args[a + 4];
            y += args[a + 5];
          } else {
            cx = args[a];
            cy = args[a + 1];
            cx2 = args[a + 2];
            cy2 = args[a + 3];
            x = args[a + 4];
            y = args[a + 5];
          }
          normalized += ["C",cx,cy,cx2,cy2,x,y,''].join(" ");
        }
      } else if (lop === "s") {
        for (a = 0; a < alen; a += 4) {
          // reflect previous cx2/cy2 over x/y
          cx = x + (x - cx2);
          cy = y + (y - cy2);
          // then get real control and end point
          if (op === "s") {
            cx2 = x + args[a];
            cy2 = y + args[a + 1];
            x += args[a + 2];
            y += args[a + 3];
          } else {
            cx2 = args[a];
            cy2 = args[a + 1];
            x = args[a + 2];
            y = args[a + 3];
          }
          normalized +=["C",cx,cy,cx2,cy2,x,y,''].join(" ");
        }
      } else if (lop === "z") {
        normalized += "Z ";
        // not unimportant: path closing changes the current x/y coordinate
        x = sx;
        y = sy;
      }
    }
    return normalized.trim();
  }

  var normaliseSvg = normalizePath;

  var M = { x: false, y: false };

  function makeBezier(Bezier, term, values) {
    if (term === 'Z') return;
    if (term === 'M') {
      M = {x: values[0], y: values[1]};
      return;
    }
    // ES7: new Bezier(M.x, M.y, ...values)
    var cvalues = [false, M.x, M.y].concat(values);
    var PreboundConstructor = Bezier.bind.apply(Bezier, cvalues);
    var curve = new PreboundConstructor();
    var last = values.slice(-2);
    M = { x : last[0], y: last[1] };
    return curve;
  }

  function convertPath(Bezier, d) {
    var terms = normaliseSvg(d).split(" "),
      term,
      matcher = new RegExp("[MLCQZ]", ""),
      segment,
      values,
      segments = [],
      ARGS = { "C": 6, "Q": 4, "L": 2, "M": 2};

    while (terms.length) {
      term = terms.splice(0,1)[0];
      if (matcher.test(term)) {
        values = terms.splice(0, ARGS[term]).map(parseFloat);
        segment = makeBezier(Bezier, term, values);
        if (segment) segments.push(segment);
      }
    }

    return new Bezier.PolyBezier(segments);
  }

  var svgToBeziers = convertPath;

  var bezier = createCommonjsModule(function (module) {
  /**
    A javascript Bezier curve library by Pomax.

    Based on http://pomax.github.io/bezierinfo

    This code is MIT licensed.
  **/
  (function() {

    // math-inlining.
    var abs = Math.abs,
      min = Math.min,
      max = Math.max,
      cos = Math.cos,
      sin = Math.sin,
      acos = Math.acos,
      sqrt = Math.sqrt,
      pi = Math.PI,
      // a zero coordinate, which is surprisingly useful
      ZERO = { x: 0, y: 0, z: 0 };

    // quite needed
    var utils$1 = utils;

    // only used for outlines atm.
    var PolyBezier = polyBezier;

    /**
     * Bezier curve constructor. The constructor argument can be one of three things:
     *
     * 1. array/4 of {x:..., y:..., z:...}, z optional
     * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
     * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
     *
     */
    var Bezier = function(coords) {
      var args = coords && coords.forEach ? coords : [].slice.call(arguments);
      var coordlen = false;
      if (typeof args[0] === "object") {
        coordlen = args.length;
        var newargs = [];
        args.forEach(function(point) {
          ["x", "y", "z"].forEach(function(d) {
            if (typeof point[d] !== "undefined") {
              newargs.push(point[d]);
            }
          });
        });
        args = newargs;
      }
      var higher = false;
      var len = args.length;
      if (coordlen) {
        if (coordlen > 4) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
          higher = true;
        }
      } else {
        if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
        }
      }
      var _3d =
        (!higher && (len === 9 || len === 12)) ||
        (coords && coords[0] && typeof coords[0].z !== "undefined");
      this._3d = _3d;
      var points = [];
      for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
        var point = {
          x: args[idx],
          y: args[idx + 1]
        };
        if (_3d) {
          point.z = args[idx + 2];
        }
        points.push(point);
      }
      this.order = points.length - 1;
      this.points = points;
      var dims = ["x", "y"];
      if (_3d) dims.push("z");
      this.dims = dims;
      this.dimlen = dims.length;

      (function(curve) {
        var order = curve.order;
        var points = curve.points;
        var a = utils$1.align(points, { p1: points[0], p2: points[order] });
        for (var i = 0; i < a.length; i++) {
          if (abs(a[i].y) > 0.0001) {
            curve._linear = false;
            return;
          }
        }
        curve._linear = true;
      })(this);

      this._t1 = 0;
      this._t2 = 1;
      this.update();
    };

    var svgToBeziers$1 = svgToBeziers;

    /**
     * turn an svg <path> d attribute into a sequence of Bezier segments.
     */
    Bezier.SVGtoBeziers = function(d) {
      return svgToBeziers$1(Bezier, d);
    };

    function getABC(n, S, B, E, t) {
      if (typeof t === "undefined") {
        t = 0.5;
      }
      var u = utils$1.projectionratio(t, n),
        um = 1 - u,
        C = {
          x: u * S.x + um * E.x,
          y: u * S.y + um * E.y
        },
        s = utils$1.abcratio(t, n),
        A = {
          x: B.x + (B.x - C.x) / s,
          y: B.y + (B.y - C.y) / s
        };
      return { A: A, B: B, C: C };
    }

    Bezier.quadraticFromPoints = function(p1, p2, p3, t) {
      if (typeof t === "undefined") {
        t = 0.5;
      }
      // shortcuts, although they're really dumb
      if (t === 0) {
        return new Bezier(p2, p2, p3);
      }
      if (t === 1) {
        return new Bezier(p1, p2, p2);
      }
      // real fitting.
      var abc = getABC(2, p1, p2, p3, t);
      return new Bezier(p1, abc.A, p3);
    };

    Bezier.cubicFromPoints = function(S, B, E, t, d1) {
      if (typeof t === "undefined") {
        t = 0.5;
      }
      var abc = getABC(3, S, B, E, t);
      if (typeof d1 === "undefined") {
        d1 = utils$1.dist(B, abc.C);
      }
      var d2 = d1 * (1 - t) / t;

      var selen = utils$1.dist(S, E),
        lx = (E.x - S.x) / selen,
        ly = (E.y - S.y) / selen,
        bx1 = d1 * lx,
        by1 = d1 * ly,
        bx2 = d2 * lx,
        by2 = d2 * ly;
      // derivation of new hull coordinates
      var e1 = { x: B.x - bx1, y: B.y - by1 },
        e2 = { x: B.x + bx2, y: B.y + by2 },
        A = abc.A,
        v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },
        v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },
        nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },
        nc2 = {
          x: E.x + (v2.x - E.x) / (1 - t),
          y: E.y + (v2.y - E.y) / (1 - t)
        };
      // ...done
      return new Bezier(S, nc1, nc2, E);
    };

    var getUtils = function() {
      return utils$1;
    };

    Bezier.getUtils = getUtils;

    Bezier.PolyBezier = PolyBezier;

    Bezier.prototype = {
      getUtils: getUtils,
      valueOf: function() {
        return this.toString();
      },
      toString: function() {
        return utils$1.pointsToString(this.points);
      },
      toSVG: function(relative) {
        if (this._3d) return false;
        var p = this.points,
          x = p[0].x,
          y = p[0].y,
          s = ["M", x, y, this.order === 2 ? "Q" : "C"];
        for (var i = 1, last = p.length; i < last; i++) {
          s.push(p[i].x);
          s.push(p[i].y);
        }
        return s.join(" ");
      },
      setRatios: function(ratios) {
        if (ratios.length !== this.points.length) {
          throw new Error("incorrect number of ratio values");
        }
        this.ratios = ratios;
        this._lut = []; //  invalidate any precomputed LUT
      },
      verify: function() {
        var print = this.coordDigest();
        if (print !== this._print) {
          this._print = print;
          this.update();
        }
      },
      coordDigest: function() {
        return this.points.map(function(c,pos) {
          return '' + pos + c.x + c.y + (c.z?c.z:0);
        }).join('');
      },
      update: function(newprint) {
        // invalidate any precomputed LUT
        this._lut = [];
        this.dpoints = utils$1.derive(this.points, this._3d);
        this.computedirection();
      },
      computedirection: function() {
        var points = this.points;
        var angle = utils$1.angle(points[0], points[this.order], points[1]);
        this.clockwise = angle > 0;
      },
      length: function() {
        return utils$1.length(this.derivative.bind(this));
      },
      _lut: [],
      getLUT: function(steps) {
        this.verify();
        steps = steps || 100;
        if (this._lut.length === steps) {
          return this._lut;
        }
        this._lut = [];
        // We want a range from 0 to 1 inclusive, so
        // we decrement and then use <= rather than <:
        steps--;
        for (var t = 0; t <= steps; t++) {
          this._lut.push(this.compute(t / steps));
        }
        return this._lut;
      },
      on: function(point, error) {
        error = error || 5;
        var lut = this.getLUT(),
          hits = [],
          c,
          t = 0;
        for (var i = 0; i < lut.length; i++) {
          c = lut[i];
          if (utils$1.dist(c, point) < error) {
            hits.push(c);
            t += i / lut.length;
          }
        }
        if (!hits.length) return false;
        return (t /= hits.length);
      },
      project: function(point) {
        // step 1: coarse check
        var LUT = this.getLUT(),
          l = LUT.length - 1,
          closest = utils$1.closest(LUT, point),
          mdist = closest.mdist,
          mpos = closest.mpos;

        // step 2: fine check
        var ft,
          t,
          p,
          d,
          t1 = (mpos - 1) / l,
          t2 = (mpos + 1) / l,
          step = 0.1 / l;
        mdist += 1;
        for (t = t1, ft = t; t < t2 + step; t += step) {
          p = this.compute(t);
          d = utils$1.dist(point, p);
          if (d < mdist) {
            mdist = d;
            ft = t;
          }
        }
        p = this.compute(ft);
        p.t = ft;
        p.d = mdist;
        return p;
      },
      get: function(t) {
        return this.compute(t);
      },
      point: function(idx) {
        return this.points[idx];
      },
      compute: function(t) {
        if (this.ratios) return utils$1.computeWithRatios(t, this.points, this.ratios, this._3d);
        return utils$1.compute(t, this.points, this._3d, this.ratios);
      },
      raise: function() {
        var p = this.points,
          np = [p[0]],
          i,
          k = p.length,
          pi,
          pim;
        for (var i = 1; i < k; i++) {
          pi = p[i];
          pim = p[i - 1];
          np[i] = {
            x: (k - i) / k * pi.x + i / k * pim.x,
            y: (k - i) / k * pi.y + i / k * pim.y
          };
        }
        np[k] = p[k - 1];
        return new Bezier(np);
      },
      derivative: function(t) {
        var mt = 1 - t,
          a,
          b,
          c = 0,
          p = this.dpoints[0];
        if (this.order === 2) {
          p = [p[0], p[1], ZERO];
          a = mt;
          b = t;
        }
        if (this.order === 3) {
          a = mt * mt;
          b = mt * t * 2;
          c = t * t;
        }
        var ret = {
          x: a * p[0].x + b * p[1].x + c * p[2].x,
          y: a * p[0].y + b * p[1].y + c * p[2].y
        };
        if (this._3d) {
          ret.z = a * p[0].z + b * p[1].z + c * p[2].z;
        }
        return ret;
      },
      curvature: function(t) {
        return utils$1.curvature(t, this.points, this._3d);
      },
      inflections: function() {
        return utils$1.inflections(this.points);
      },
      normal: function(t) {
        return this._3d ? this.__normal3(t) : this.__normal2(t);
      },
      __normal2: function(t) {
        var d = this.derivative(t);
        var q = sqrt(d.x * d.x + d.y * d.y);
        return { x: -d.y / q, y: d.x / q };
      },
      __normal3: function(t) {
        // see http://stackoverflow.com/questions/25453159
        var r1 = this.derivative(t),
          r2 = this.derivative(t + 0.01),
          q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),
          q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
        r1.x /= q1;
        r1.y /= q1;
        r1.z /= q1;
        r2.x /= q2;
        r2.y /= q2;
        r2.z /= q2;
        // cross product
        var c = {
          x: r2.y * r1.z - r2.z * r1.y,
          y: r2.z * r1.x - r2.x * r1.z,
          z: r2.x * r1.y - r2.y * r1.x
        };
        var m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
        c.x /= m;
        c.y /= m;
        c.z /= m;
        // rotation matrix
        var R = [
          c.x * c.x,
          c.x * c.y - c.z,
          c.x * c.z + c.y,
          c.x * c.y + c.z,
          c.y * c.y,
          c.y * c.z - c.x,
          c.x * c.z - c.y,
          c.y * c.z + c.x,
          c.z * c.z
        ];
        // normal vector:
        var n = {
          x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
          y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
          z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
        };
        return n;
      },
      hull: function(t) {
        var p = this.points,
          _p = [],
          pt,
          q = [],
          idx = 0,
          i = 0,
          l = 0;
        q[idx++] = p[0];
        q[idx++] = p[1];
        q[idx++] = p[2];
        if (this.order === 3) {
          q[idx++] = p[3];
        }
        // we lerp between all points at each iteration, until we have 1 point left.
        while (p.length > 1) {
          _p = [];
          for (i = 0, l = p.length - 1; i < l; i++) {
            pt = utils$1.lerp(t, p[i], p[i + 1]);
            q[idx++] = pt;
            _p.push(pt);
          }
          p = _p;
        }
        return q;
      },
      split: function(t1, t2) {
        // shortcuts
        if (t1 === 0 && !!t2) {
          return this.split(t2).left;
        }
        if (t2 === 1) {
          return this.split(t1).right;
        }

        // no shortcut: use "de Casteljau" iteration.
        var q = this.hull(t1);
        var result = {
          left:
            this.order === 2
              ? new Bezier([q[0], q[3], q[5]])
              : new Bezier([q[0], q[4], q[7], q[9]]),
          right:
            this.order === 2
              ? new Bezier([q[5], q[4], q[2]])
              : new Bezier([q[9], q[8], q[6], q[3]]),
          span: q
        };

        // make sure we bind _t1/_t2 information!
        result.left._t1 = utils$1.map(0, 0, 1, this._t1, this._t2);
        result.left._t2 = utils$1.map(t1, 0, 1, this._t1, this._t2);
        result.right._t1 = utils$1.map(t1, 0, 1, this._t1, this._t2);
        result.right._t2 = utils$1.map(1, 0, 1, this._t1, this._t2);

        // if we have no t2, we're done
        if (!t2) {
          return result;
        }

        // if we have a t2, split again:
        t2 = utils$1.map(t2, t1, 1, 0, 1);
        var subsplit = result.right.split(t2);
        return subsplit.left;
      },
      extrema: function() {
        var dims = this.dims,
          result = {},
          roots = [],
          p,
          mfn;
        dims.forEach(
          function(dim) {
            mfn = function(v) {
              return v[dim];
            };
            p = this.dpoints[0].map(mfn);
            result[dim] = utils$1.droots(p);
            if (this.order === 3) {
              p = this.dpoints[1].map(mfn);
              result[dim] = result[dim].concat(utils$1.droots(p));
            }
            result[dim] = result[dim].filter(function(t) {
              return t >= 0 && t <= 1;
            });
            roots = roots.concat(result[dim].sort(utils$1.numberSort));
          }.bind(this)
        );
        roots = roots.sort(utils$1.numberSort).filter(function(v, idx) {
          return roots.indexOf(v) === idx;
        });
        result.values = roots;
        return result;
      },
      bbox: function() {
        var extrema = this.extrema(),
          result = {};
        this.dims.forEach(
          function(d) {
            result[d] = utils$1.getminmax(this, d, extrema[d]);
          }.bind(this)
        );
        return result;
      },
      overlaps: function(curve) {
        var lbbox = this.bbox(),
          tbbox = curve.bbox();
        return utils$1.bboxoverlap(lbbox, tbbox);
      },
      offset: function(t, d) {
        if (typeof d !== "undefined") {
          var c = this.get(t);
          var n = this.normal(t);
          var ret = {
            c: c,
            n: n,
            x: c.x + n.x * d,
            y: c.y + n.y * d
          };
          if (this._3d) {
            ret.z = c.z + n.z * d;
          }
          return ret;
        }
        if (this._linear) {
          var nv = this.normal(0);
          var coords = this.points.map(function(p) {
            var ret = {
              x: p.x + t * nv.x,
              y: p.y + t * nv.y
            };
            if (p.z && n.z) {
              ret.z = p.z + t * nv.z;
            }
            return ret;
          });
          return [new Bezier(coords)];
        }
        var reduced = this.reduce();
        return reduced.map(function(s) {
          if (s._linear) {
            return s.offset(t)[0];
          }
          return s.scale(t);
        });
      },
      simple: function() {
        if (this.order === 3) {
          var a1 = utils$1.angle(this.points[0], this.points[3], this.points[1]);
          var a2 = utils$1.angle(this.points[0], this.points[3], this.points[2]);
          if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;
        }
        var n1 = this.normal(0);
        var n2 = this.normal(1);
        var s = n1.x * n2.x + n1.y * n2.y;
        if (this._3d) {
          s += n1.z * n2.z;
        }
        var angle = abs(acos(s));
        return angle < pi / 3;
      },
      reduce: function() {
        var i,
          t1 = 0,
          t2 = 0,
          step = 0.01,
          segment,
          pass1 = [],
          pass2 = [];
        // first pass: split on extrema
        var extrema = this.extrema().values;
        if (extrema.indexOf(0) === -1) {
          extrema = [0].concat(extrema);
        }
        if (extrema.indexOf(1) === -1) {
          extrema.push(1);
        }

        for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
          t2 = extrema[i];
          segment = this.split(t1, t2);
          segment._t1 = t1;
          segment._t2 = t2;
          pass1.push(segment);
          t1 = t2;
        }

        // second pass: further reduce these segments to simple segments
        pass1.forEach(function(p1) {
          t1 = 0;
          t2 = 0;
          while (t2 <= 1) {
            for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
              segment = p1.split(t1, t2);
              if (!segment.simple()) {
                t2 -= step;
                if (abs(t1 - t2) < step) {
                  // we can never form a reduction
                  return [];
                }
                segment = p1.split(t1, t2);
                segment._t1 = utils$1.map(t1, 0, 1, p1._t1, p1._t2);
                segment._t2 = utils$1.map(t2, 0, 1, p1._t1, p1._t2);
                pass2.push(segment);
                t1 = t2;
                break;
              }
            }
          }
          if (t1 < 1) {
            segment = p1.split(t1, 1);
            segment._t1 = utils$1.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = p1._t2;
            pass2.push(segment);
          }
        });
        return pass2;
      },
      scale: function(d) {
        var order = this.order;
        var distanceFn = false;
        if (typeof d === "function") {
          distanceFn = d;
        }
        if (distanceFn && order === 2) {
          return this.raise().scale(distanceFn);
        }

        // TODO: add special handling for degenerate (=linear) curves.
        var clockwise = this.clockwise;
        var r1 = distanceFn ? distanceFn(0) : d;
        var r2 = distanceFn ? distanceFn(1) : d;
        var v = [this.offset(0, 10), this.offset(1, 10)];
        var o = utils$1.lli4(v[0], v[0].c, v[1], v[1].c);
        if (!o) {
          throw new Error("cannot scale this curve. Try reducing it first.");
        }
        // move all points by distance 'd' wrt the origin 'o'
        var points = this.points,
          np = [];

        // move end points by fixed distance along normal.
        [0, 1].forEach(
          function(t) {
            var p = (np[t * order] = utils$1.copy(points[t * order]));
            p.x += (t ? r2 : r1) * v[t].n.x;
            p.y += (t ? r2 : r1) * v[t].n.y;
          }.bind(this)
        );

        if (!distanceFn) {
          // move control points to lie on the intersection of the offset
          // derivative vector, and the origin-through-control vector
          [0, 1].forEach(
            function(t) {
              if (this.order === 2 && !!t) return;
              var p = np[t * order];
              var d = this.derivative(t);
              var p2 = { x: p.x + d.x, y: p.y + d.y };
              np[t + 1] = utils$1.lli4(p, p2, o, points[t + 1]);
            }.bind(this)
          );
          return new Bezier(np);
        }

        // move control points by "however much necessary to
        // ensure the correct tangent to endpoint".
        [0, 1].forEach(
          function(t) {
            if (this.order === 2 && !!t) return;
            var p = points[t + 1];
            var ov = {
              x: p.x - o.x,
              y: p.y - o.y
            };
            var rc = distanceFn ? distanceFn((t + 1) / order) : d;
            if (distanceFn && !clockwise) rc = -rc;
            var m = sqrt(ov.x * ov.x + ov.y * ov.y);
            ov.x /= m;
            ov.y /= m;
            np[t + 1] = {
              x: p.x + rc * ov.x,
              y: p.y + rc * ov.y
            };
          }.bind(this)
        );
        return new Bezier(np);
      },
      outline: function(d1, d2, d3, d4) {
        d2 = typeof d2 === "undefined" ? d1 : d2;
        var reduced = this.reduce(),
          len = reduced.length,
          fcurves = [],
          bcurves = [],
          p,
          alen = 0,
          tlen = this.length();

        var graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";

        function linearDistanceFunction(s, e, tlen, alen, slen) {
          return function(v) {
            var f1 = alen / tlen,
              f2 = (alen + slen) / tlen,
              d = e - s;
            return utils$1.map(v, 0, 1, s + f1 * d, s + f2 * d);
          };
        }

        // form curve oulines
        reduced.forEach(function(segment) {
          slen = segment.length();
          if (graduated) {
            fcurves.push(
              segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
            );
            bcurves.push(
              segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
            );
          } else {
            fcurves.push(segment.scale(d1));
            bcurves.push(segment.scale(-d2));
          }
          alen += slen;
        });

        // reverse the "return" outline
        bcurves = bcurves
          .map(function(s) {
            p = s.points;
            if (p[3]) {
              s.points = [p[3], p[2], p[1], p[0]];
            } else {
              s.points = [p[2], p[1], p[0]];
            }
            return s;
          })
          .reverse();

        // form the endcaps as lines
        var fs = fcurves[0].points[0],
          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],
          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],
          be = bcurves[0].points[0],
          ls = utils$1.makeline(bs, fs),
          le = utils$1.makeline(fe, be),
          segments = [ls]
            .concat(fcurves)
            .concat([le])
            .concat(bcurves),
          slen = segments.length;

        return new PolyBezier(segments);
      },
      outlineshapes: function(d1, d2, curveIntersectionThreshold) {
        d2 = d2 || d1;
        var outline = this.outline(d1, d2).curves;
        var shapes = [];
        for (var i = 1, len = outline.length; i < len / 2; i++) {
          var shape = utils$1.makeshape(
            outline[i],
            outline[len - i],
            curveIntersectionThreshold
          );
          shape.startcap.virtual = i > 1;
          shape.endcap.virtual = i < len / 2 - 1;
          shapes.push(shape);
        }
        return shapes;
      },
      intersects: function(curve, curveIntersectionThreshold) {
        if (!curve) return this.selfintersects(curveIntersectionThreshold);
        if (curve.p1 && curve.p2) {
          return this.lineIntersects(curve);
        }
        if (curve instanceof Bezier) {
          curve = curve.reduce();
        }
        return this.curveintersects(
          this.reduce(),
          curve,
          curveIntersectionThreshold
        );
      },
      lineIntersects: function(line) {
        var mx = min(line.p1.x, line.p2.x),
          my = min(line.p1.y, line.p2.y),
          MX = max(line.p1.x, line.p2.x),
          MY = max(line.p1.y, line.p2.y),
          self = this;
        return utils$1.roots(this.points, line).filter(function(t) {
          var p = self.get(t);
          return utils$1.between(p.x, mx, MX) && utils$1.between(p.y, my, MY);
        });
      },
      selfintersects: function(curveIntersectionThreshold) {
        var reduced = this.reduce();
        // "simple" curves cannot intersect with their direct
        // neighbour, so for each segment X we check whether
        // it intersects [0:x-2][x+2:last].
        var i,
          len = reduced.length - 2,
          results = [],
          result,
          left,
          right;
        for (i = 0; i < len; i++) {
          left = reduced.slice(i, i + 1);
          right = reduced.slice(i + 2);
          result = this.curveintersects(left, right, curveIntersectionThreshold);
          results = results.concat(result);
        }
        return results;
      },
      curveintersects: function(c1, c2, curveIntersectionThreshold) {
        var pairs = [];
        // step 1: pair off any overlapping segments
        c1.forEach(function(l) {
          c2.forEach(function(r) {
            if (l.overlaps(r)) {
              pairs.push({ left: l, right: r });
            }
          });
        });
        // step 2: for each pairing, run through the convergence algorithm.
        var intersections = [];
        pairs.forEach(function(pair) {
          var result = utils$1.pairiteration(
            pair.left,
            pair.right,
            curveIntersectionThreshold
          );
          if (result.length > 0) {
            intersections = intersections.concat(result);
          }
        });
        return intersections;
      },
      arcs: function(errorThreshold) {
        errorThreshold = errorThreshold || 0.5;
        var circles = [];
        return this._iterate(errorThreshold, circles);
      },
      _error: function(pc, np1, s, e) {
        var q = (e - s) / 4,
          c1 = this.get(s + q),
          c2 = this.get(e - q),
          ref = utils$1.dist(pc, np1),
          d1 = utils$1.dist(pc, c1),
          d2 = utils$1.dist(pc, c2);
        return abs(d1 - ref) + abs(d2 - ref);
      },
      _iterate: function(errorThreshold, circles) {
        var t_s = 0,
          t_e = 1,
          safety;
        // we do a binary search to find the "good `t` closest to no-longer-good"
        do {
          safety = 0;

          // step 1: start with the maximum possible arc
          t_e = 1;

          // points:
          var np1 = this.get(t_s),
            np2,
            np3,
            arc,
            prev_arc;

          // booleans:
          var curr_good = false,
            prev_good = false,
            done;

          // numbers:
          var t_m = t_e,
            prev_e = 1;

          // step 2: find the best possible arc
          do {
            prev_good = curr_good;
            prev_arc = arc;
            t_m = (t_s + t_e) / 2;

            np2 = this.get(t_m);
            np3 = this.get(t_e);

            arc = utils$1.getccenter(np1, np2, np3);

            //also save the t values
            arc.interval = {
              start: t_s,
              end: t_e
            };

            var error = this._error(arc, np1, t_s, t_e);
            curr_good = error <= errorThreshold;

            done = prev_good && !curr_good;
            if (!done) prev_e = t_e;

            // this arc is fine: we can move 'e' up to see if we can find a wider arc
            if (curr_good) {
              // if e is already at max, then we're done for this arc.
              if (t_e >= 1) {
                // make sure we cap at t=1
                arc.interval.end = prev_e = 1;
                prev_arc = arc;
                // if we capped the arc segment to t=1 we also need to make sure that
                // the arc's end angle is correct with respect to the bezier end point.
                if (t_e > 1) {
                  var d = {
                    x: arc.x + arc.r * cos(arc.e),
                    y: arc.y + arc.r * sin(arc.e)
                  };
                  arc.e += utils$1.angle({ x: arc.x, y: arc.y }, d, this.get(1));
                }
                break;
              }
              // if not, move it up by half the iteration distance
              t_e = t_e + (t_e - t_s) / 2;
            } else {
              // this is a bad arc: we need to move 'e' down to find a good arc
              t_e = t_m;
            }
          } while (!done && safety++ < 100);

          if (safety >= 100) {
            break;
          }

          // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

          prev_arc = prev_arc ? prev_arc : arc;
          circles.push(prev_arc);
          t_s = prev_e;
        } while (t_e < 1);
        return circles;
      }
    };

    module.exports = Bezier;
  })();
  });

  var bezierJs = bezier;

  /** The default wall texture. */
  var defaultWallTexture = { url: 'rooms/textures/wallmap.png', stretch: true, scale: 0 };

  /**
   * A Wall is the basic element to create Rooms.
   *
   * Walls consists of two half edges.
   */
  var Wall = function (_EventDispatcher) {
      inherits(Wall, _EventDispatcher);

      /**
       * Constructs a new wall.
       * @param start Start corner.
       * @param end End corner.
       */
      function Wall(start, end, aa, bb) {
          classCallCheck(this, Wall);

          var _this = possibleConstructorReturn(this, (Wall.__proto__ || Object.getPrototypeOf(Wall)).call(this));

          _this.start = start;
          _this.end = end;
          _this.name = 'wall';
          if (!aa && !bb) {
              _this._walltype = WallTypes.STRAIGHT;
          } else {
              _this._walltype = WallTypes.CURVED;
          }
          var o = new Vector2(0, 0);
          var abvector = end.location.clone().sub(start.location).multiplyScalar(0.5);

          var ab135plus = abvector.clone().rotateAround(o, Math.PI * 0.75);
          var ab45plus = abvector.clone().rotateAround(o, Math.PI * 0.25);

          if (aa) {
              _this._a = new Vector2(0, 0);
              _this._a.x = aa.x;
              _this._a.y = aa.y;
          } else {
              _this._a = start.location.clone().add(ab45plus);
          }

          if (bb) {
              _this._b = new Vector2(0, 0);
              _this._b.x = bb.x;
              _this._b.y = bb.y;
          } else {
              _this._b = end.location.clone().add(ab135plus);
          }
          _this._a_vector = _this._a.clone().sub(start.location);
          _this._b_vector = _this._b.clone().sub(start.location);

          _this._bezier = new bezierJs(start.location.x, start.location.y, _this._a.x, _this._a.y, _this._b.x, _this._b.y, end.location.x, end.location.y);

          _this.id = _this.getUuid();

          _this.start.attachStart(_this);
          _this.end.attachEnd(_this);

          /** Front is the plane from start to end. */
          _this.frontEdge = null;

          /** Back is the plane from end to start. */
          _this.backEdge = null;

          /** */
          _this.orphan = false;

          /** Items attached to this wall */
          _this.items = [];

          /** */
          _this.onItems = [];

          /** The front-side texture. */
          _this.frontTexture = defaultWallTexture;

          /** The back-side texture. */
          _this.backTexture = defaultWallTexture;

          /** Wall thickness. */
          _this._thickness = Configuration.getNumericValue(configWallThickness);

          /** Wall height. */
          _this.height = Configuration.getNumericValue(configWallHeight);

          /** Actions to be applied after movement. */
          _this.moved_callbacks = null;

          /** Actions to be applied on removal. */
          _this.deleted_callbacks = null;

          /** Actions to be applied explicitly. */
          _this.action_callbacks = null;

          //		this.start.addEventListener(EVENT_MOVED, ()=>{
          //			scope.updateControlVectors();
          //		});
          //		this.end.addEventListener(EVENT_MOVED, ()=>{
          //			scope.updateControlVectors();
          //		});
          _this.addCornerMoveListener(_this.start);
          _this.addCornerMoveListener(_this.end);
          return _this;
      }

      createClass(Wall, [{
          key: 'addCornerMoveListener',
          value: function addCornerMoveListener(corner) {
              var remove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              var scope = this;

              function moved() {
                  scope.updateControlVectors();
              }

              function cornerAttributesChanged() {
                  scope.dispatchEvent({ type: EVENT_MOVED, item: scope, position: null });
              }

              if (remove) {
                  corner.removeEventListener(EVENT_MOVED, moved);
                  corner.removeEventListener(EVENT_CORNER_ATTRIBUTES_CHANGED, cornerAttributesChanged);
                  return;
              }
              corner.addEventListener(EVENT_MOVED, moved);
              corner.addEventListener(EVENT_CORNER_ATTRIBUTES_CHANGED, cornerAttributesChanged);
          }
      }, {
          key: 'updateControlVectors',
          value: function updateControlVectors() {
              this._bezier.points[0].x = this.start.location.x;
              this._bezier.points[0].y = this.start.location.y;

              this._bezier.points[1].x = this.a.x;
              this._bezier.points[1].y = this.a.y;

              this._bezier.points[2].x = this.b.x;
              this._bezier.points[2].y = this.b.y;

              this._bezier.points[3].x = this.end.location.x;
              this._bezier.points[3].y = this.end.location.y;
              this._bezier.update();
              if (this.getStart() || this.getEnd()) {
                  var _ = this.getStart() != null ? this.getStart().floorplan.update(false) : this.getEnd() != null ? this.getEnd().floorplan.update(false) : false;
              }
              //		this._a_vector = this._a.clone().sub(this.start.location);
              //		this._b_vector = this._b.clone().sub(this.start.location);
          }
      }, {
          key: 'getUuid',
          value: function getUuid() {
              return [this.start.id, this.end.id].join();
          }
      }, {
          key: 'resetFrontBack',
          value: function resetFrontBack() {
              this.frontEdge = null;
              this.backEdge = null;
              this.orphan = false;
          }
      }, {
          key: 'snapToAxis',
          value: function snapToAxis(tolerance) {
              // order here is important, but unfortunately arbitrary
              this.start.snapToAxis(tolerance);
              this.end.snapToAxis(tolerance);
          }
      }, {
          key: 'fireOnMove',
          value: function fireOnMove(func) {
              this.moved_callbacks.add(func);
          }
      }, {
          key: 'fireOnDelete',
          value: function fireOnDelete(func) {
              this.deleted_callbacks.add(func);
          }
      }, {
          key: 'dontFireOnDelete',
          value: function dontFireOnDelete(func) {
              this.deleted_callbacks.remove(func);
          }
      }, {
          key: 'fireOnAction',
          value: function fireOnAction(func) {
              this.action_callbacks.add(func);
          }
      }, {
          key: 'fireAction',
          value: function fireAction(action) {
              this.dispatchEvent({ type: EVENT_ACTION, action: action });
              //this.action_callbacks.fire(action);
          }
      }, {
          key: 'move',
          value: function move(newX, newY) {
              var dx = newX - (this.start.location.x + this.end.location.x) * 0.5;
              var dy = newY - (this.start.location.y + this.end.location.y) * 0.5;
              this.relativeMove(dx, dy);
          }
      }, {
          key: 'relativeMove',
          value: function relativeMove(dx, dy, corner) {
              if (!corner) {
                  this.start.relativeMove(dx, dy);
                  this.end.relativeMove(dx, dy);
              } else {
                  corner.relativeMove(dx, dy);
              }
              this.updateControlVectors();
          }
      }, {
          key: 'fireMoved',
          value: function fireMoved() {
              this.dispatchEvent({ type: EVENT_MOVED, item: this, position: null });
          }
      }, {
          key: 'fireRedraw',
          value: function fireRedraw() {
              if (this.frontEdge) {
                  //			this.frontEdge.dispatchEvent({type: EVENT_REDRAW});
                  this.frontEdge.dispatchRedrawEvent();
                  //this.frontEdge.redrawCallbacks.fire();
              }
              if (this.backEdge) {
                  //			this.backEdge.dispatchEvent({type: EVENT_REDRAW});
                  this.backEdge.dispatchRedrawEvent();
                  //this.backEdge.redrawCallbacks.fire();
              }
          }
      }, {
          key: 'getStart',
          value: function getStart() {
              return this.start;
          }
      }, {
          key: 'getEnd',
          value: function getEnd() {
              return this.end;
          }
      }, {
          key: 'getStartX',
          value: function getStartX() {
              return this.start.getX();
          }
      }, {
          key: 'getEndX',
          value: function getEndX() {
              return this.end.getX();
          }
      }, {
          key: 'getStartY',
          value: function getStartY() {
              return this.start.getY();
          }
      }, {
          key: 'getEndY',
          value: function getEndY() {
              return this.end.getY();
          }
      }, {
          key: 'wallLength',
          value: function wallLength() {
              if (this.wallType === WallTypes.STRAIGHT) {
                  var start = this.getStart();
                  var end = this.getEnd();
                  return Utils.distance(start, end);
              } else if (this.wallType === WallTypes.CURVED) {
                  return this._bezier.length();
              }
              return -1;
          }
      }, {
          key: 'wallCenter',
          value: function wallCenter() {
              if (this.wallType === WallTypes.STRAIGHT) {
                  return new Vector2((this.getStart().x + this.getEnd().x) / 2.0, (this.getStart().y + this.getEnd().y) / 2.0);
              } else if (this.wallType === WallTypes.CURVED) {
                  var p = this._bezier.get(0.5);
                  return new Vector2(p.x, p.y);
              }
              return new Vector2(0, 0);
          }
      }, {
          key: 'remove',
          value: function remove() {
              this.start.detachWall(this);
              this.end.detachWall(this);
              this.dispatchEvent({ type: EVENT_DELETED, item: this });
              //this.deleted_callbacks.fire(this);
          }
      }, {
          key: 'setStart',
          value: function setStart(corner) {
              this.start.detachWall(this);
              this.addCornerMoveListener(this.start, true);

              corner.attachStart(this);
              this.start = corner;
              this.addCornerMoveListener(this.start);
              this.fireMoved();
          }
      }, {
          key: 'setEnd',
          value: function setEnd(corner) {

              this.end.detachWall(this);
              this.addCornerMoveListener(this.end);

              corner.attachEnd(this);
              this.end = corner;
              this.addCornerMoveListener(this.end, true);
              this.fireMoved();
          }
      }, {
          key: 'distanceFrom',
          value: function distanceFrom(point) {
              if (this.wallType === WallTypes.STRAIGHT) {
                  return Utils.pointDistanceFromLine(point, new Vector2(this.getStartX(), this.getStartY()), new Vector2(this.getEndX(), this.getEndY()));
              } else if (this.wallType === WallTypes.CURVED) {
                  var p = this._bezier.project(point);
                  var projected = new Vector2(p.x, p.y);
                  return projected.distanceTo(point);
              }
              return -1;
          }

          /** Return the corner opposite of the one provided.
           * @param corner The given corner.
           * @returns The opposite corner.
           */

      }, {
          key: 'oppositeCorner',
          value: function oppositeCorner(corner) {
              if (this.start === corner) {
                  return this.end;
              } else if (this.end === corner) {
                  return this.start;
              } else {
                  console.log('Wall does not connect to corner');
                  return null;
              }
          }
      }, {
          key: 'getClosestCorner',
          value: function getClosestCorner(point) {
              var startVector = new Vector2(this.start.x, this.start.y);
              var endVector = new Vector2(this.end.x, this.end.y);
              var startDistance = point.distanceTo(startVector);
              var endDistance = point.distanceTo(endVector);
              if (startDistance <= this.thickness * 2) {
                  return this.start;
              } else if (endDistance <= this.thickness * 2) {
                  return this.end;
              }
              return null;
          }
      }, {
          key: 'updateAttachedRooms',
          value: function updateAttachedRooms() {
              var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (this.start != null) {
                  this.start.updateAttachedRooms(explicit);
              }
              if (this.end) {
                  this.end.updateAttachedRooms(explicit);
              }
          }
      }, {
          key: 'wallSize',
          set: function set(value) {
              if (this.wallType === WallTypes.STRAIGHT) {
                  var vector = this.getEnd().location.clone().sub(this.getStart().location);
                  var currentLength = this.wallLength();
                  var changeInLength = value / currentLength;

                  var neighboursCountStart = this.getStart().adjacentCorners().length === 1;
                  var neighboursCountEnd = this.getEnd().adjacentCorners().length === 1;

                  var changeInLengthOffset = void 0,
                      movementVector = void 0,
                      startPoint = void 0,
                      endPoint = void 0;

                  changeInLengthOffset = changeInLength - 1;

                  if (!neighboursCountStart && !neighboursCountEnd || neighboursCountStart && neighboursCountEnd) {
                      changeInLengthOffset *= 0.5;
                      movementVector = vector.clone().multiplyScalar(changeInLengthOffset);
                      startPoint = movementVector.clone().multiplyScalar(-1).add(this.getStart().location);
                      endPoint = movementVector.clone().add(this.getEnd().location);
                  } else if (neighboursCountStart) {
                      movementVector = vector.clone().multiplyScalar(changeInLengthOffset);
                      startPoint = movementVector.clone().multiplyScalar(-1).add(this.getStart().location);
                      endPoint = this.getEnd().location;
                  } else if (neighboursCountEnd) {
                      movementVector = vector.clone().multiplyScalar(changeInLengthOffset);
                      endPoint = movementVector.clone().add(this.getEnd().location);
                      startPoint = this.getStart().location;
                  }
                  this.getStart().move(startPoint.x, startPoint.y);
                  this.getEnd().move(endPoint.x, endPoint.y);

                  this.updateAttachedRooms();

                  //			vector = vector.multiplyScalar(changeInLength).add(this.getStart().location);
                  //			this.getEnd().move(vector.x, vector.y);
              }
              /**
               * No need for the below statement. Because the corners moved will trigger the event to this instance
               * Then this instance will also trigger the move event 
               */
              // this.dispatchEvent({ type: EVENT_UPDATED, item: this });
          },
          get: function get() {
              return this.wallLength();
          }
      }, {
          key: 'thickness',
          get: function get() {
              return this._thickness;
          },
          set: function set(thick) {
              this._thickness = thick;
              this.dispatchEvent({ type: EVENT_UPDATED, item: this }); //This is stupid. You need to say what event exactly happened
          }
      }, {
          key: 'uuid',
          get: function get() {
              return this.getUuid();
          }
      }, {
          key: 'a',
          get: function get() {
              return this._a;
          },
          set: function set(location) {
              this._a.x = location.x;
              this._a.y = location.y;
              this._a_vector = this._a.clone().sub(this.start.location);
              this.updateControlVectors();
          }
      }, {
          key: 'b',
          get: function get() {
              return this._b;
          },
          set: function set(location) {
              this._b.x = location.x;
              this._b.y = location.y;
              this._b_vector = this._b.clone().sub(this.start.location);
              this.updateControlVectors();
          }
      }, {
          key: 'aVector',
          get: function get() {
              return this._a_vector.clone();
          }
      }, {
          key: 'bVector',
          get: function get() {
              return this._b_vector.clone();
          }
      }, {
          key: 'bezier',
          get: function get() {
              return this._bezier;
          }
      }, {
          key: 'wallType',
          get: function get() {
              return this._walltype;
          },
          set: function set(value) {
              if (value === WallTypes.STRAIGHT || value === WallTypes.CURVED) {
                  this._walltype = value;
              }
              this.updateControlVectors();
              this.updateAttachedRooms(true);
          }
      }, {
          key: 'startElevation',
          get: function get() {
              if (this.start && this.start != null) {
                  return this.start.elevation;
              }
              return 0.0;
          }
      }, {
          key: 'endElevation',
          get: function get() {
              if (this.end && this.end != null) {
                  return this.end.elevation;
              }
              return 0.0;
          }
      }]);
      return Wall;
  }(EventDispatcher);

  /** Default texture to be used if nothing is provided. */
  var defaultRoomTexture = { url: 'rooms/textures/hardwood.png', scale: 400 };

  /**
   * A Room is the combination of a Floorplan with a floor plane.
   */
  var Room = function (_EventDispatcher) {
      inherits(Room, _EventDispatcher);

      /**
       *  ordered CCW
       */
      function Room(floorplan, corners) {
          classCallCheck(this, Room);

          var _this = possibleConstructorReturn(this, (Room.__proto__ || Object.getPrototypeOf(Room)).call(this));

          _this._name = 'A New Room';
          _this.min = null;
          _this.max = null;
          _this.center = null;
          _this.area = 0.0;
          _this.areaCenter = null;
          _this._polygonPoints = [];
          _this.__walls = [];

          _this.floorplan = floorplan;
          _this._corners = corners;
          _this.interiorCorners = [];
          _this.interiorCorners3D = [];
          _this.floorRectangleSize = new Vector2();
          _this.edgePointer = null;
          _this.floorPlane = null;
          _this.roofPlane = null;
          _this.customTexture = false;
          _this.floorChangeCallbacks = null;

          _this.updateWalls();
          _this.updateInteriorCorners();
          _this.generatePlane();
          _this.generateRoofPlane();

          var cornerids = [];
          var i = 0;
          for (; i < _this.corners.length; i++) {
              var c = _this.corners[i];
              c.attachRoom(_this);
              cornerids.push(c.id);
              c.addEventListener(EVENT_MOVED, function () {
                  return _this._roomUpdated();
              });
          }
          var scope = _this;
          for (i = 0; i < _this.__walls.length; i++) {
              var wall = _this.__walls[i];
              wall.addEventListener(EVENT_UPDATED, function () {
                  scope.updateInteriorCorners();
                  scope.dispatchEvent({ type: EVENT_CHANGED, item: scope });
              });
          }
          _this._roomByCornersId = cornerids.join(',');
          return _this;
      }

      createClass(Room, [{
          key: '_roomUpdated',
          value: function _roomUpdated() {
              this.updateInteriorCorners();
              this.updateArea();
          }
      }, {
          key: '__getOrderedCorners',
          value: function __getOrderedCorners(wall) {
              var i = this.corners.indexOf(wall.start);
              var j = this.corners.indexOf(wall.end);
              if (i === -1 || j === -1) {
                  return null;
              }
              var start = this.corners[Math.max(i, j)].location.clone();
              var end = this.corners[Math.min(i, j)].location.clone();
              if (i === 0 && j === this.corners.length - 1 || j === 0 && i === this.corners.length - 1) {
                  end = this.corners[this.corners.length - 1].location.clone();
                  start = this.corners[0].location.clone();
              }
              return { 'start': start, 'end': end };
          }
      }, {
          key: 'getWallDirection',
          value: function getWallDirection(wall) {
              var orderedCorners = this.__getOrderedCorners(wall);
              if (orderedCorners === null) {
                  return null;
              }
              var start = orderedCorners['start'];
              var end = orderedCorners['end'];
              var vect = end.sub(start);
              var vect3 = new Vector3(vect.x, vect.y, 0);
              return vect3.normalize().clone();
          }
      }, {
          key: 'getWallOutDirection',
          value: function getWallOutDirection(wall) {
              var vect3 = this.getWallDirection(wall); //new Vector3(vect.x, vect.y, 0);
              if (vect3 === null) {
                  return null;
              }
              // console.log('WALL DIRECTION : ', vect3);
              vect3 = vect3.applyAxisAngle(new Vector3(0, 0, 1), Math.PI * 0.5);
              // console.log('WALL NORMAL DIRECTION : ', vect3);
              return vect3.normalize();
          }
      }, {
          key: 'getWallStart',
          value: function getWallStart(wall) {
              var orderedCorners = this.__getOrderedCorners(wall);
              if (orderedCorners === null) {
                  return null;
              }
              return orderedCorners['start'];
          }
      }, {
          key: 'getWallEnd',
          value: function getWallEnd(wall) {
              var orderedCorners = this.__getOrderedCorners(wall);
              if (orderedCorners === null) {
                  return null;
              }
              return orderedCorners['end'];
          }
      }, {
          key: 'getWallPlane',
          value: function getWallPlane(wall) {
              var orderedCorners = this.__getOrderedCorners(wall);
              if (orderedCorners === null) {
                  return null;
              }
              var planeLocation = wall.start.location.clone().add(wall.end.location).multiplyScalar(0.5);
              var normal = this.getWallOutDirection(wall);
              var plane = new Plane(normal, 0);
              var m = new Matrix4();
              m.makeTranslation(planeLocation.x, planeLocation.y, 0);
              // plane = plane.applyMatrix4(m);
              plane.setFromNormalAndCoplanarPoint(normal, new Vector3(planeLocation.x, planeLocation.y, 0));
              return plane;
          }
      }, {
          key: 'roomIdentifier',
          value: function roomIdentifier() {
              var cornerids = [];
              this.corners.forEach(function (corner) {
                  cornerids.push(corner.id);
              });
              var ids = cornerids.join(',');
              return ids;
          }
      }, {
          key: 'getUuid',
          value: function getUuid() {
              var cornerUuids = Utils.map(this.corners, function (c) {
                  return c.id;
              });
              cornerUuids.sort();
              return cornerUuids.join();
          }
      }, {
          key: 'fireOnFloorChange',
          value: function fireOnFloorChange(callback) {
              this.floorChangeCallbacks.add(callback);
          }
      }, {
          key: 'getTexture',
          value: function getTexture() {
              var uuid = this.getUuid();
              var tex = this.floorplan.getFloorTexture(uuid);
              return tex || defaultRoomTexture;
          }
      }, {
          key: 'setRoomWallsTexture',
          value: function setRoomWallsTexture(textureUrl, textureStretch, textureScale) {
              var edge = this.edgePointer;
              var iterateWhile = true;
              edge.setTexture(textureUrl, textureStretch, textureScale);
              while (iterateWhile) {
                  if (edge.next === this.edgePointer) {
                      break;
                  } else {
                      edge = edge.next;
                  }
                  edge.setTexture(textureUrl, textureStretch, textureScale);
              }
          }

          /**
           * textureStretch always true, just an argument for consistency with walls
           */

      }, {
          key: 'setTexture',
          value: function setTexture(textureUrl, textureStretch, textureScale) {
              var uuid = this.getUuid();
              this.floorplan.setFloorTexture(uuid, textureUrl, textureScale);
              this.dispatchEvent({ type: EVENT_CHANGED, item: this });
              //		this.floorChangeCallbacks.fire();
          }
      }, {
          key: 'generateRoofPlane',
          value: function generateRoofPlane() {
              if (this.roofPlane && this.roofPlane != null) {
                  if (this.roofPlane.parent != null) {
                      this.roofPlane.parent.remove(this.roofPlane);
                  }
              }
              // setup texture
              var geometry = new Geometry();

              this.corners.forEach(function (corner) {
                  var vertex = new Vector3(corner.x, corner.elevation, corner.y);
                  geometry.vertices.push(vertex);
              });
              for (var _i = 2; _i < geometry.vertices.length; _i++) {
                  var face = new Face3(0, _i - 1, _i);
                  geometry.faces.push(face);
              }
              this.roofPlane = new Mesh(geometry, new MeshBasicMaterial({ side: DoubleSide, visible: false }));
              this.roofPlane.room = this;
          }
      }, {
          key: 'generatePlane',
          value: function generatePlane() {
              var points = [];
              this.interiorCorners.forEach(function (corner) {
                  points.push(new Vector2(corner.x, corner.y));
              });
              var shape = new Shape(points);
              var geometry = new ShapeGeometry(shape);
              this.floorPlane = new Mesh(geometry, new MeshBasicMaterial({ side: DoubleSide, visible: false }));
              //The below line was originally setting the plane visibility to false
              //Now its setting visibility to true. This is necessary to be detected
              //with the raycaster objects to click walls and floors.
              this.floorPlane.visible = true;
              this.floorPlane.rotation.set(Math.PI / 2, 0, 0);
              this.floorPlane.room = this; // js monkey patch

              var b3 = new Box3();
              b3.setFromObject(this.floorPlane);
              this.min = b3.min.clone();
              this.max = b3.max.clone();
              this.center = this.max.clone().sub(this.min).multiplyScalar(0.5).add(this.min);
          }
      }, {
          key: 'cycleIndex',
          value: function cycleIndex(index) {
              if (index < 0) {
                  return index += this.corners.length;
              } else {
                  return index % this.corners.length;
              }
          }
      }, {
          key: 'pointInRoom',
          value: function pointInRoom(pt) {
              var polygon = [];
              this.corners.forEach(function (corner) {
                  var co = new Vector2(corner.x, corner.y);
                  polygon.push(co);
              });
              return Utils.pointInPolygon2(pt, polygon);
          }
      }, {
          key: 'updateInteriorCorners',
          value: function updateInteriorCorners() {
              var minB = new Vector2(Number.MAX_VALUE, Number.MAX_VALUE);
              var maxB = new Vector2(Number.MIN_VALUE, Number.MIN_VALUE);
              var edge = this.edgePointer;
              var iterateWhile = true;
              this.interiorCorners = [];
              this.interiorCorners3D = [];
              while (iterateWhile) {
                  var iStart = edge.interiorStart();
                  var cStart = edge.getStart();
                  minB.x = Math.min(iStart.x, minB.x);
                  minB.y = Math.min(iStart.y, minB.y);
                  maxB.x = Math.max(maxB.x, iStart.x);
                  maxB.y = Math.max(maxB.y, iStart.y);
                  this.interiorCorners.push(iStart);
                  this.interiorCorners3D.push(new Vector3(iStart.x, cStart.elevation, iStart.y));
                  edge.generatePlane();
                  if (edge.next === this.edgePointer) {
                      break;
                  } else {
                      edge = edge.next;
                  }
              }
              this.floorRectangleSize = maxB.clone().sub(minB);
          }
      }, {
          key: 'updateArea',
          value: function updateArea() {
              var oldarea = this.area;
              var points = [];
              var allpoints = [];
              this.areaCenter = new Vector2();
              this._polygonPoints = [];

              var firstCorner = void 0,
                  secondCorner = void 0,
                  wall = void 0,
                  i = void 0,
                  corner = void 0,
                  region = void 0;

              for (i = 0; i < this.corners.length; i++) {
                  corner = this.corners[i];
                  firstCorner = this.corners[i];
                  secondCorner = this.corners[(i + 1) % this.corners.length];
                  wall = firstCorner.wallToOrFrom(secondCorner);

                  if (wall != null) {
                      if (wall.wallType === WallTypes.CURVED) {
                          var begin = corner.location.clone().sub(wall.bezier.get(0)).length();
                          var p = void 0;
                          var stepIndex = void 0;
                          allpoints.push(corner.location.clone());

                          if (begin < 1e-6) {
                              for (stepIndex = 1; stepIndex < 20; stepIndex++) {
                                  p = wall.bezier.get(stepIndex / 20);
                                  allpoints.push(new Vector2(p.x, p.y));
                              }
                          } else {
                              for (stepIndex = 19; stepIndex > 0; stepIndex--) {
                                  p = wall.bezier.get(stepIndex / 20);
                                  allpoints.push(new Vector2(p.x, p.y));
                              }
                          }
                      } else {
                          allpoints.push(corner.location.clone());
                      }
                  } else {
                      allpoints.push(corner.location.clone());
                  }
              }

              points = allpoints;
              region = new Region(points);
              this.area = Math.abs(region.area());
              this.areaCenter = region.centroid();
              this._polygonPoints = points;
              this.dispatchEvent({ type: EVENT_ROOM_ATTRIBUTES_CHANGED, item: this, info: { from: oldarea, to: this.area } });
          }
      }, {
          key: 'updateArea2',
          value: function updateArea2() {
              var scope = this;
              var isComplexRoom = false;
              var oldarea = this.area;
              var points = [];
              var N = 0;
              var area = 0;
              this.areaCenter = new Vector2();
              this._polygonPoints = [];

              //The below makes this routine too slow
              //		this.updateWalls();
              //		this.updateInteriorCorners();
              //		this.generatePlane();
              //		this.generateRoofPlane();


              for (var _i2 = 0; _i2 < this.corners.length; _i2++) {
                  var firstCorner = this.corners[_i2];
                  var secondCorner = this.corners[(_i2 + 1) % this.corners.length];
                  var wall = firstCorner.wallToOrFrom(secondCorner);
                  isComplexRoom |= wall.wallType === WallTypes.CURVED;
              }

              var inext = void 0,
                  a = void 0,
                  b = void 0,
                  ax_by = void 0,
                  ay_bx = void 0,
                  delta = void 0;
              if (!isComplexRoom) {
                  this.corners.forEach(function (corner) {
                      var co = new Vector2(corner.x, corner.y);
                      scope.areaCenter.add(co);
                      points.push(co);
                  });
                  this.areaCenter.multiplyScalar(1.0 / points.length);
                  for (var _i3 = 0; _i3 < points.length; _i3++) {
                      inext = (_i3 + 1) % points.length;
                      a = points[_i3];
                      b = points[inext];
                      ax_by = a.x * b.y;
                      ay_bx = a.y * b.x;
                      delta = ax_by - ay_bx;
                      area += delta;
                  }
                  this.area = Math.abs(area) * 0.5;
                  this._polygonPoints = points;
                  this.dispatchEvent({ type: EVENT_ROOM_ATTRIBUTES_CHANGED, item: this, info: { from: oldarea, to: this.area } });
                  return;
              }

              //		this.corners.forEach((corner) => {
              //			var co = new Vector2(corner.x,corner.y);
              //			this.areaCenter.add(co);
              //			points.push(co);
              //		});

              N = this.corners.length;

              for (var _i4 = 0; _i4 < this.corners.length; _i4++) {
                  var _firstCorner = this.corners[_i4];
                  var _secondCorner = this.corners[(_i4 + 1) % this.corners.length];
                  var _wall = _firstCorner.wallToOrFrom(_secondCorner);
                  this.areaCenter.add(_firstCorner.location);

                  if (_wall != null) {
                      if (_wall.wallType === WallTypes.CURVED) {
                          points.push(_firstCorner.location);
                          var LUT = _wall.bezier.getLUT(20);
                          for (var j = 1; j < LUT.length - 1; j++) {
                              var p = LUT[j];
                              p = new Vector2(p.x, p.y);
                              points.push(p);
                          }
                      } else {
                          points.push(_firstCorner.location);
                      }
                  } else {
                      points.push(_firstCorner.location);
                  }
              }

              this.areaCenter.multiplyScalar(1.0 / N);

              var indicesAndAngles = Utils.getCyclicOrder(points, this.areaCenter);
              points = indicesAndAngles['points'];

              for (var _i5 = 0; _i5 < points.length; _i5++) {
                  inext = (_i5 + 1) % points.length;
                  a = points[_i5];
                  b = points[inext];
                  //Another irregular polygon method based on the url below
                  //https://www.mathsisfun.com/geometry/area-irregular-polygons.html
                  //			var width = a.x - b.x;
                  //			var height = (a.y + b.y) * 0.5;
                  //			var delta = Math.abs(width * height);
                  ax_by = a.x * b.y;
                  ay_bx = a.y * b.x;
                  delta = ax_by - ay_bx;
                  area += delta;
              }
              this._polygonPoints = points;
              this.area = Math.abs(area) * 0.5;
              //		if we are using the method in url https://www.mathsisfun.com/geometry/area-irregular-polygons.html 
              //		then we dont have to multiply the area by 0.5;
              //		this.area = Math.abs(area);
              this.dispatchEvent({ type: EVENT_ROOM_ATTRIBUTES_CHANGED, item: this, info: { from: oldarea, to: this.area } });
          }
      }, {
          key: 'hasAllCornersById',
          value: function hasAllCornersById(ids) {
              var sum = 0;
              for (var _i6 = 0; _i6 < ids.length; _i6++) {
                  sum += this.hasACornerById(ids[_i6]);
              }
              return sum === this.corners.length;
          }
      }, {
          key: 'hasACornerById',
          value: function hasACornerById(id) {
              for (var _i7 = 0; _i7 < this.corners.length; _i7++) {
                  var corner = this.corners[_i7];
                  if (corner.id === id) {
                      return 1;
                  }
              }
              return 0;
          }

          /**
           * Populates each wall's half edge relating to this room
           * this creates a fancy doubly connected edge list (DCEL)
           */

      }, {
          key: 'updateWalls',
          value: function updateWalls() {

              var prevEdge = null;
              var firstEdge = null;
              this.__walls = [];

              for (var _i8 = 0; _i8 < this.corners.length; _i8++) {

                  var firstCorner = this.corners[_i8];
                  var secondCorner = this.corners[(_i8 + 1) % this.corners.length];

                  // find if wall is heading in that direction
                  var wallTo = firstCorner.wallTo(secondCorner);
                  var wallFrom = firstCorner.wallFrom(secondCorner);
                  var edge = null;
                  if (wallTo) {
                      edge = new HalfEdge(this, wallTo, true);
                  } else if (wallFrom) {
                      edge = new HalfEdge(this, wallFrom, false);
                  } else {
                      // something horrible has happened
                      console.log('corners arent connected by a wall, uh oh');
                  }

                  /**
                   * Ensure the room contains the list of wall pointers
                   */
                  if (!this.__walls.includes(wallTo) && wallTo) {
                      this.__walls.push(wallTo);
                  }
                  if (!this.__walls.includes(wallFrom) && wallFrom) {
                      this.__walls.push(wallFrom);
                  }

                  if (_i8 === 0) {
                      firstEdge = edge;
                  } else {
                      edge.prev = prevEdge;
                      prevEdge.next = edge;
                      if (_i8 + 1 === this.corners.length) {
                          firstEdge.prev = edge;
                          edge.next = firstEdge;
                      }
                  }
                  prevEdge = edge;
              }

              // hold on to an edge reference
              this.edgePointer = firstEdge;
          }
      }, {
          key: 'uuid',
          get: function get() {
              return this.getUuid();
          }
      }, {
          key: 'corners',
          get: function get() {
              return this._corners;
          }
      }, {
          key: 'sharedWalls',
          get: function get() {
              return this.__walls;
          }
      }, {
          key: 'roomCornerPoints',
          get: function get() {
              return this._polygonPoints;
          }
      }, {
          key: 'roomByCornersId',
          get: function get() {
              return this._roomByCornersId;
          }
      }, {
          key: 'name',
          set: function set(value) {
              var oldname = this._name;
              this._name = value;
              this.dispatchEvent({ type: EVENT_ROOM_ATTRIBUTES_CHANGED, item: this, info: { from: oldname, to: this._name } });
          },
          get: function get() {
              return this._name;
          }
      }]);
      return Room;
  }(EventDispatcher);

  /** */
  var defaultFloorPlanTolerance = 10.0;

  /**
   * A Floorplan represents a number of Walls, Corners and Rooms. This is an
   * abstract that keeps the 2d and 3d in sync
   */
  var Floorplan = function (_EventDispatcher) {
      inherits(Floorplan, _EventDispatcher);

      /** Constructs a floorplan. */
      function Floorplan() {
          classCallCheck(this, Floorplan);

          /**
           * List of elements of Wall instance
           * 
           * @property {Wall[]} walls Array of walls
           * @type {Wall[]}
           */
          var _this = possibleConstructorReturn(this, (Floorplan.__proto__ || Object.getPrototypeOf(Floorplan)).call(this));

          _this.walls = [];
          /**
           * List of elements of Corner instance
           * 
           * @property {Corner[]} corners array of corners
           * @type {Corner[]}
           */
          _this.corners = [];

          /**
           * List of elements of Room instance
           * 
           * @property {Room[]} walls Array of walls
           * @type {Room[]}
           */
          _this.rooms = [];

          /**
           * An {@link Object} that stores the metadata of rooms like name
           * 
           * @property {Object} metaroomsdata stores the metadata of rooms like
           *           name
           * @type {Object}
           */
          _this.metaroomsdata = {};
          // List with reference to callback on a new wall insert event
          /**
           * @deprecated
           */
          _this.new_wall_callbacks = [];
          // List with reference to callbacks on a new corner insert event
          /**
           * @deprecated
           */
          _this.new_corner_callbacks = [];
          // List with reference to callbacks on redraw event
          /**
           * @deprecated
           */
          _this.redraw_callbacks = [];
          // List with reference to callbacks for updated_rooms event
          /**
           * @deprecated
           */
          _this.updated_rooms = [];
          // List with reference to callbacks for roomLoaded event
          /**
           * @deprecated
           */
          _this.roomLoadedCallbacks = [];

          _this.floorTextures = {};
          /**
           * The {@link CarbonSheet} that handles the background image to show in
           * the 2D view
           * 
           * @property {CarbonSheet} _carbonSheet The carbonsheet instance
           * @type {Object}
           */
          _this._carbonSheet = null;
          return _this;
      }

      /**
       * @param {CarbonSheet}
       *            val
       */


      createClass(Floorplan, [{
          key: 'wallEdges',


          /**
           * @return {HalfEdge[]} edges The array of {@link HalfEdge}
           */
          value: function wallEdges() {
              var edges = [];
              this.walls.forEach(function (wall) {
                  if (wall.frontEdge) {
                      edges.push(wall.frontEdge);
                  }
                  if (wall.backEdge) {
                      edges.push(wall.backEdge);
                  }
              });
              return edges;
          }

          /**
           * Returns the roof planes in the floorplan for intersection testing
           * 
           * @return {Mesh[]} planes
           * @see <https://threejs.org/docs/#api/en/objects/Mesh>
           */

      }, {
          key: 'roofPlanes',
          value: function roofPlanes() {
              var planes = [];
              this.rooms.forEach(function (room) {
                  planes.push(room.roofPlane);
              });
              return planes;
          }

          /**
           * Returns all the planes for intersection for the walls
           * 
           * @return {Mesh[]} planes
           * @see <https://threejs.org/docs/#api/en/objects/Mesh>
           */

      }, {
          key: 'wallEdgePlanes',
          value: function wallEdgePlanes() {
              var planes = [];
              this.walls.forEach(function (wall) {
                  if (wall.frontEdge) {
                      planes.push(wall.frontEdge.plane);
                  }
                  if (wall.backEdge) {
                      planes.push(wall.backEdge.plane);
                  }
              });
              return planes;
          }

          /**
           * Returns all the planes for intersection of the floors in all room
           * 
           * @return {Mesh[]} planes
           * @see <https://threejs.org/docs/#api/en/objects/Mesh>
           */

      }, {
          key: 'floorPlanes',
          value: function floorPlanes() {
              return Utils.map(this.rooms, function (room) {
                  return room.floorPlane;
              });
          }
      }, {
          key: 'fireOnNewWall',
          value: function fireOnNewWall(callback) {
              this.new_wall_callbacks.add(callback);
          }
      }, {
          key: 'fireOnNewCorner',
          value: function fireOnNewCorner(callback) {
              this.new_corner_callbacks.add(callback);
          }
      }, {
          key: 'fireOnRedraw',
          value: function fireOnRedraw(callback) {
              this.redraw_callbacks.add(callback);
          }
      }, {
          key: 'fireOnUpdatedRooms',
          value: function fireOnUpdatedRooms(callback) {
              this.updated_rooms.add(callback);
          }

          // This method needs to be called from the 2d floorplan whenever
          // the other method newWall is called.
          // This is to ensure that there are no floating walls going across
          // other walls. If two walls are intersecting then the intersection point
          // has to create a new wall.
          /**
           * Checks existing walls for any intersections they would make. If there are
           * intersections then introduce new corners and new walls as required at
           * places
           * 
           * @param {Corner}
           *            start
           * @param {Corner}
           *            end
           * @return {boolean} intersects
           */

      }, {
          key: 'newWallsForIntersections',
          value: function newWallsForIntersections(start, end) {
              var intersections = false;
              // This is a bug in the logic
              // When creating a new wall with a start and end
              // it needs to be checked if it is cutting other walls
              // If it cuts then all those walls have to removed and introduced as
              // new walls along with this new wall
              var cStart = new Vector2(start.getX(), start.getY());
              var cEnd = new Vector2(end.getX(), end.getY());
              var line = { p1: cStart, p2: cEnd };

              for (var i = 0; i < this.walls.length; i++) {
                  var twall = this.walls[i];
                  var bstart = { x: twall.getStartX(), y: twall.getStartY() };
                  var bend = { x: twall.getEndX(), y: twall.getEndY() };
                  var iPoint = void 0;
                  if (twall.wallType === WallTypes.CURVED) {
                      iPoint = twall.bezier.intersects(line);
                      if (iPoint.length) {
                          iPoint = twall.bezier.get(iPoint[0]);
                      }
                  } else {
                      iPoint = Utils.lineLineIntersectPoint(cStart, cEnd, bstart, bend);
                  }
                  if (iPoint) {
                      var nCorner = this.newCorner(iPoint.x, iPoint.y);
                      nCorner.mergeWithIntersected(false);
                      intersections = true;
                  }
              }
              //		for( i=0;i<this.corners.length;i++)
              //		{
              //			var aCorner = this.corners[i];
              //			if(aCorner)
              //			{
              //				aCorner.relativeMove(0, 0);
              //				aCorner.snapToAxis(25);
              //			}
              //		}
              //		this.update();
              //		for( i=0;i<this.corners.length;i++)
              //		{
              //			aCorner = this.corners[i];
              //			if(aCorner)
              //			{
              //				aCorner.relativeMove(0, 0);
              //				aCorner.snapToAxis(25);
              //			}
              //		}
              this.update();

              return intersections;
          }

          /**
           * Creates a new wall.
           * 
           * @param {Corner}
           *            start The start corner.
           * @param {Corner}
           *            end The end corner.
           * @returns {Wall} The new wall.
           */

      }, {
          key: 'newWall',
          value: function newWall(start, end, a, b) {
              var scope = this;
              var wall = new Wall(start, end, a, b);
              this.walls.push(wall);
              wall.addEventListener(EVENT_DELETED, function (o) {
                  scope.removeWall(o.item);
              });
              wall.addEventListener(EVENT_WALL_ATTRIBUTES_CHANGED, function (o) {
                  scope.dispatchEvent(o);
              });

              this.dispatchEvent({ type: EVENT_NEW, item: this, newItem: wall });
              this.update();
              return wall;
          }

          /**
           * Creates a new corner.
           * 
           * @param {Number}
           *            x The x coordinate.
           * @param {Number}
           *            y The y coordinate.
           * @param {String}
           *            id An optional id. If unspecified, the id will be created
           *            internally.
           * @returns {Corner} The new corner.
           */

      }, {
          key: 'newCorner',
          value: function newCorner(x, y, id) {
              var scope = this;
              var corner = new Corner(this, x, y, id);

              for (var i = 0; i < this.corners.length; i++) {
                  var existingCorner = this.corners[i];
                  if (existingCorner.distanceFromCorner(corner) < cornerTolerance) {
                      return existingCorner;
                  }
              }

              this.corners.push(corner);
              corner.addEventListener(EVENT_DELETED, function (o) {
                  scope.removeCorner(o.item);
                  scope.update();
                  scope.dispatchEvent({ type: EVENT_DELETED, item: scope });
              });
              corner.addEventListener(EVENT_CORNER_ATTRIBUTES_CHANGED, function (o) {
                  scope.dispatchEvent(o);
                  var updatecorners = o.item.adjacentCorners();
                  updatecorners.push(o.item);
                  scope.update(false, updatecorners);
                  //			scope.update(false);//For debug reasons
              });
              corner.addEventListener(EVENT_MOVED, function (o) {
                  scope.dispatchEvent(o);
                  var updatecorners = o.item.adjacentCorners();
                  updatecorners.push(o.item);
                  scope.update(false, updatecorners);
                  //			scope.update(false);//For debug reasons
              });

              this.dispatchEvent({ type: EVENT_NEW, item: this, newItem: corner });

              // This code has been added by #0K. There should be an update whenever a
              // new corner is inserted
              this.update();

              return corner;
          }

          /**
           * Removes a wall.
           * 
           * @param {Wall}
           *            wall The wall to be removed.
           */

      }, {
          key: 'removeWall',
          value: function removeWall(wall) {
              this.dispatchEvent({ type: EVENT_DELETED, item: this, deleted: wall, item_type: 'wall' });
              Utils.removeValue(this.walls, wall);
              this.update();
          }

          /**
           * Removes a corner.
           * 
           * @param {Corner}
           *            corner The corner to be removed.
           */

      }, {
          key: 'removeCorner',
          value: function removeCorner(corner) {
              this.dispatchEvent({ type: EVENT_DELETED, item: this, deleted: corner, item_type: 'corner' });
              Utils.removeValue(this.corners, corner);
          }

          /**
           * Gets the walls.
           * 
           * @return {Wall[]}
           */

      }, {
          key: 'getWalls',
          value: function getWalls() {
              return this.walls;
          }

          /**
           * Gets the corners.
           * 
           * @return {Corner[]}
           */

      }, {
          key: 'getCorners',
          value: function getCorners() {
              return this.corners;
          }

          /**
           * Gets the rooms.
           * 
           * @return {Room[]}
           */

      }, {
          key: 'getRooms',
          value: function getRooms() {
              return this.rooms;
          }

          /**
           * Gets the room overlapping the location x, y.
           * 
           * @param {Number}
           *            mx
           * @param {Number}
           *            my
           * @return {Room}
           */

      }, {
          key: 'overlappedRoom',
          value: function overlappedRoom(mx, my) {
              for (var i = 0; i < this.rooms.length; i++) {
                  var room = this.rooms[i];
                  var flag = room.pointInRoom(new Vector2(mx, my));
                  if (flag) {
                      return room;
                  }
              }

              return null;
          }

          /**
           * Gets the Control of a Curved Wall overlapping the location x, y at a
           * tolerance.
           * 
           * @param {Number}
           *            x
           * @param {Number}
           *            y
           * @param {Number}
           *            tolerance
           * @return {Corner}
           */

      }, {
          key: 'overlappedControlPoint',
          value: function overlappedControlPoint(wall, x, y, tolerance) {
              tolerance = tolerance || defaultFloorPlanTolerance * 5;
              if (wall.a.distanceTo(new Vector2(x, y)) < tolerance && wall.wallType === WallTypes.CURVED) {
                  return wall.a;
              } else if (wall.b.distanceTo(new Vector2(x, y)) < tolerance && wall.wallType === WallTypes.CURVED) {
                  return wall.b;
              }

              return null;
          }

          /**
           * Gets the Corner overlapping the location x, y at a tolerance.
           * 
           * @param {Number}
           *            x
           * @param {Number}
           *            y
           * @param {Number}
           *            tolerance
           * @return {Corner}
           */

      }, {
          key: 'overlappedCorner',
          value: function overlappedCorner(x, y, tolerance) {
              tolerance = tolerance || defaultFloorPlanTolerance;
              for (var i = 0; i < this.corners.length; i++) {
                  if (this.corners[i].distanceFrom(new Vector2(x, y)) < tolerance) {
                      return this.corners[i];
                  }
              }
              return null;
          }

          /**
           * Gets the Wall overlapping the location x, y at a tolerance.
           * 
           * @param {Number}
           *            x
           * @param {Number}
           *            y
           * @param {Number}
           *            tolerance
           * @return {Wall}
           */

      }, {
          key: 'overlappedWall',
          value: function overlappedWall(x, y, tolerance) {
              tolerance = tolerance || defaultFloorPlanTolerance;
              for (var i = 0; i < this.walls.length; i++) {
                  var newtolerance = tolerance; // (tolerance+
                  // ((this.walls[i].wallType ==
                  // WallTypes.CURVED)*tolerance*10));
                  if (this.walls[i].distanceFrom(new Vector2(x, y)) < newtolerance) {
                      return this.walls[i];
                  }
              }
              return null;
          }

          /**
           * The metadata object with information about the rooms.
           * 
           * @return {Object} metaroomdata an object with room corner ids as key and
           *         names as values
           */

      }, {
          key: 'getMetaRoomData',
          value: function getMetaRoomData() {
              var metaRoomData = {};
              this.rooms.forEach(function (room) {
                  var metaroom = {};
                  // var cornerids = [];
                  // room.corners.forEach((corner)=>{
                  // cornerids.push(corner.id);
                  // });
                  // var ids = cornerids.join(',');
                  var ids = room.roomByCornersId;
                  metaroom['name'] = room.name;
                  metaRoomData[ids] = metaroom;
              });
              return metaRoomData;
          }

          // Save the floorplan as a json object file
          /**
           * @return {void}
           */

      }, {
          key: 'saveFloorplan',
          value: function saveFloorplan() {
              var floorplans = { version: Version.getTechnicalVersion(), corners: {}, walls: [], rooms: {}, wallTextures: [], floorTextures: {}, newFloorTextures: {}, carbonSheet: {} };
              var cornerIds = [];
              // writing all the corners based on the corners array
              // is having a bug. This is because some walls have corners
              // that aren't part of the corners array anymore. This is a quick fix
              // by adding the corners to the json file based on the corners in the walls
              // this.corners.forEach((corner) => {
              // floorplans.corners[corner.id] = {'x': corner.x,'y': corner.y};
              // });

              this.walls.forEach(function (wall) {
                  if (wall.getStart() && wall.getEnd()) {
                      floorplans.walls.push({
                          'corner1': wall.getStart().id,
                          'corner2': wall.getEnd().id,
                          'frontTexture': wall.frontTexture,
                          'backTexture': wall.backTexture,
                          'wallType': wall.wallType.description,
                          'a': { x: wall.a.x, y: wall.a.y },
                          'b': { x: wall.b.x, y: wall.b.y }
                      });
                      cornerIds.push(wall.getStart());
                      cornerIds.push(wall.getEnd());
                  }
              });

              cornerIds.forEach(function (corner) {
                  floorplans.corners[corner.id] = { 'x': Dimensioning.cmToMeasureRaw(corner.x), 'y': Dimensioning.cmToMeasureRaw(corner.y), 'elevation': Dimensioning.cmToMeasureRaw(corner.elevation) };
              });

              // this.rooms.forEach((room)=>{
              // var metaroom = {};
              // var cornerids = [];
              // room.corners.forEach((corner)=>{
              // cornerids.push(corner.id);
              // });
              // var ids = cornerids.join(',');
              // metaroom['name'] = room.name;
              // floorplans.rooms[ids] = metaroom;
              // });
              floorplans.rooms = this.metaroomsdata;

              if (this.carbonSheet) {
                  floorplans.carbonSheet['url'] = this.carbonSheet.url;
                  floorplans.carbonSheet['transparency'] = this.carbonSheet.transparency;
                  floorplans.carbonSheet['x'] = this.carbonSheet.x;
                  floorplans.carbonSheet['y'] = this.carbonSheet.y;
                  floorplans.carbonSheet['anchorX'] = this.carbonSheet.anchorX;
                  floorplans.carbonSheet['anchorY'] = this.carbonSheet.anchorY;
                  floorplans.carbonSheet['width'] = this.carbonSheet.width;
                  floorplans.carbonSheet['height'] = this.carbonSheet.height;
              }

              floorplans.newFloorTextures = this.floorTextures;
              return floorplans;
          }

          // Load the floorplan from a previously saved json object file
          /**
           * @param {JSON}
           *            floorplan
           * @return {void}
           * @emits {EVENT_LOADED}
           */

      }, {
          key: 'loadFloorplan',
          value: function loadFloorplan(floorplan) {
              this.reset();
              var corners = {};
              if (floorplan == null || !('corners' in floorplan) || !('walls' in floorplan)) {
                  return;
              }
              var currentUnit = Configuration.getStringValue(configDimUnit);
              if (floorplan.units) {
                  switch (floorplan.units) {
                      case dimInch:
                          Configuration.setValue(configDimUnit, dimInch);
                          break;
                      case dimFeetAndInch:
                          Configuration.setValue(configDimUnit, dimFeetAndInch);
                          break;
                      case dimMeter:
                          Configuration.setValue(configDimUnit, dimMeter);
                          break;
                      case dimCentiMeter:
                          Configuration.setValue(configDimUnit, dimCentiMeter);
                          break;
                      case dimMilliMeter:
                      default:
                          Configuration.setValue(configDimUnit, dimMilliMeter);
                          break;
                  }
              }

              for (var id in floorplan.corners) {
                  var corner = floorplan.corners[id];
                  corners[id] = this.newCorner(Dimensioning.cmFromMeasureRaw(corner.x), Dimensioning.cmFromMeasureRaw(corner.y), id);
                  if (corner.elevation) {
                      corners[id].elevation = Dimensioning.cmFromMeasureRaw(corner.elevation);
                  }
              }
              var scope = this;
              floorplan.walls.forEach(function (wall) {
                  var newWall = scope.newWall(corners[wall.corner1], corners[wall.corner2]);

                  if (wall.frontTexture) {
                      newWall.frontTexture = wall.frontTexture;
                  }
                  if (wall.backTexture) {
                      newWall.backTexture = wall.backTexture;
                  }
                  // Adding of a, b, wallType (straight, curved) for walls happened
                  // with introduction of 0.0.2a
                  if (Version.isVersionHigherThan(floorplan.version, '0.0.2a')) {
                      newWall.a = wall.a;
                      newWall.b = wall.b;
                      if (wall.wallType === 'CURVED') {
                          newWall.wallType = WallTypes.CURVED;
                      } else {
                          newWall.wallType = WallTypes.STRAIGHT;
                      }
                  }
              });

              if ('newFloorTextures' in floorplan) {
                  this.floorTextures = floorplan.newFloorTextures;
              }
              this.metaroomsdata = floorplan.rooms;
              this.update();
              this.dispatchEvent({ type: EVENT_LOADED, item: this });
              Configuration.setValue(configDimUnit, currentUnit);
              // this.roomLoadedCallbacks.fire();
          }

          /**
           * @deprecated
           */

      }, {
          key: 'getFloorTexture',
          value: function getFloorTexture(uuid) {
              if (uuid in this.floorTextures) {
                  return this.floorTextures[uuid];
              }
              return null;
          }

          /**
           * @deprecated
           */

      }, {
          key: 'setFloorTexture',
          value: function setFloorTexture(uuid, url, scale) {
              this.floorTextures[uuid] = { url: url, scale: scale };
          }

          /** clear out obsolete floor textures */
          /**
           * @deprecated
           */

      }, {
          key: 'updateFloorTextures',
          value: function updateFloorTextures() {
              var uuids = Utils.map(this.rooms, function (room) {
                  return room.getUuid();
              });
              for (var uuid in this.floorTextures) {
                  if (!Utils.hasValue(uuids, uuid)) {
                      delete this.floorTextures[uuid];
                  }
              }
          }

          /**
           * Resets the floorplan data to empty
           * 
           * @return {void}
           */

      }, {
          key: 'reset',
          value: function reset() {
              var tmpCorners = this.corners.slice(0);
              var tmpWalls = this.walls.slice(0);

              tmpWalls.forEach(function (wall) {
                  wall.remove();
                  wall = null;
              });

              tmpCorners.forEach(function (corner) {
                  corner.remove();
                  corner = null;
              });

              this.corners = [];
              this.walls = [];
          }

          /**
           * @param {Object}
           *            event
           * @listens {EVENT_ROOM_NAME_CHANGED} When a room name is changed and
           *          updates to metaroomdata
           */

      }, {
          key: 'roomNameChanged',
          value: function roomNameChanged(e) {
              if (this.metaroomsdata) {
                  this.metaroomsdata[e.item.roomByCornersId] = e.newname;
              }
          }

          /**
           * Update the floorplan with new rooms, remove old rooms etc.
           */

      }, {
          key: 'update',
          value: function update() //Should include for , updatewalls=null, updaterooms=null
          {
              var updateroomconfiguration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              var updatecorners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

              if (updatecorners != null) {
                  //			console.log('UPDATE CORNER ANGLES ::: ', updatecorners.length);
                  updatecorners.forEach(function (corner) {
                      corner.updateAngles();
                  });
              }

              if (!updateroomconfiguration) {
                  this.dispatchEvent({ type: EVENT_UPDATED, item: this });
                  return;
              }

              //		console.log('UPDATE ROOM WITH NEW ENTRIES ::: ');

              var scope = this;
              this.walls.forEach(function (wall) {
                  wall.resetFrontBack();
              });

              // this.rooms.forEach((room)=>{room.removeEventListener(EVENT_ROOM_NAME_CHANGED,
              // scope.roomNameChanged)});

              var roomCorners = this.findRooms(this.corners);
              this.rooms = [];

              this.corners.forEach(function (corner) {
                  corner.clearAttachedRooms();
                  //			corner.updateAngles();
              });

              roomCorners.forEach(function (corners) {
                  var room = new Room(scope, corners);
                  room.updateArea();
                  scope.rooms.push(room);

                  room.addEventListener(EVENT_ROOM_NAME_CHANGED, function (e) {
                      scope.roomNameChanged(e);
                  });
                  room.addEventListener(EVENT_ROOM_ATTRIBUTES_CHANGED, function (o) {
                      var room = o.item;
                      scope.dispatchEvent(o);
                      if (scope.metaroomsdata[room.roomByCornersId]) {
                          scope.metaroomsdata[room.roomByCornersId]['name'] = room.name;
                      } else {
                          scope.metaroomsdata[room.roomByCornersId] = {};
                          scope.metaroomsdata[room.roomByCornersId]['name'] = room.name;
                      }
                  });

                  if (scope.metaroomsdata) {
                      if (scope.metaroomsdata[room.roomByCornersId]) {
                          room.name = scope.metaroomsdata[room.roomByCornersId]['name'];
                      }
                  }
              });
              this.assignOrphanEdges();
              this.updateFloorTextures();
              this.dispatchEvent({ type: EVENT_UPDATED, item: this });
              this.dispatchEvent({ type: EVENT_NEW_ROOMS_ADDED, item: this });

              // console.log('TOTAL WALLS ::: ', this.walls.length);
          }

          /**
           * Returns the center of the floorplan in the y plane
           * 
           * @return {Vector2} center
           * @see https://threejs.org/docs/#api/en/math/Vector2
           */

      }, {
          key: 'getCenter',
          value: function getCenter() {
              return this.getDimensions(true);
          }

          /**
           * Returns the bounding volume of the full floorplan
           * 
           * @return {Vector3} size
           * @see https://threejs.org/docs/#api/en/math/Vector3
           */

      }, {
          key: 'getSize',
          value: function getSize() {
              return this.getDimensions(false);
          }
      }, {
          key: 'getSize3',
          value: function getSize3() {
              var size2D = this.getDimensions();
              var size3D = new Vector3(size2D.x, size2D.z, Number.MIN_VALUE);
              for (var i = 0; i < this.corners.length; i++) {
                  var corner = this.corners[i];
                  size3D.z = Math.max(size3D.z, corner.elevation);
              }
              return size3D;
          }
      }, {
          key: 'setSize',
          value: function setSize(newSize) {
              var i = 0;
              var m = new Matrix4();
              var currentSize = this.getSize3();
              var scale = newSize.clone().divide(currentSize);
              m.scale(scale);
              for (; i < this.corners.length; i++) {
                  var corner = this.corners[i];
                  var vector = new Vector3(corner.location.x, corner.location.y, corner.elevation);
                  vector = vector.applyMatrix4(m);
                  corner.elevation = vector.z;
                  corner.move(vector.x, vector.y);
              }
          }

          /**
           * Returns the bounding size or the center location of the full floorplan
           * 
           * @param {boolean}
           *            center If true return the center else the size
           * @return {Vector3} size
           * @see https://threejs.org/docs/#api/en/math/Vector3
           */

      }, {
          key: 'getDimensions',
          value: function getDimensions(center) {
              center = center || false; // otherwise, get size

              var xMin = Infinity;
              var xMax = -Infinity;
              var zMin = Infinity;
              var zMax = -Infinity;
              this.corners.forEach(function (corner) {
                  if (corner.x < xMin) xMin = corner.x;
                  if (corner.x > xMax) xMax = corner.x;
                  if (corner.y < zMin) zMin = corner.y;
                  if (corner.y > zMax) zMax = corner.y;
              });
              var ret = void 0;
              if (xMin === Infinity || xMax === -Infinity || zMin === Infinity || zMax === -Infinity) {
                  ret = new Vector3();
              } else {
                  if (center) {
                      // center
                      ret = new Vector3((xMin + xMax) * 0.5, 0, (zMin + zMax) * 0.5);
                  } else {
                      // size
                      ret = new Vector3(xMax - xMin, 0, zMax - zMin);
                  }
              }
              return ret;
          }

          /**
           * An internal cleanup method
           */

      }, {
          key: 'assignOrphanEdges',
          value: function assignOrphanEdges() {
              this.walls.forEach(function (wall) {
                  if (!wall.backEdge && !wall.frontEdge) {
                      wall.orphan = true;
                      var back = new HalfEdge(null, wall, false);
                      var front = new HalfEdge(null, wall, true);
                      back.generatePlane();
                      front.generatePlane();
                  }
              });
          }

          /**
           * Find the 'rooms' in our planar straight-line graph. Rooms are set of the
           * smallest (by area) possible cycles in this graph.
           * 
           * @param corners
           *            The corners of the floorplan.
           * @returns The rooms, each room as an array of corners.
           * @param {Corners[]}
           *            corners
           * @return {Corners[][]} loops
           */

      }, {
          key: 'findRooms',
          value: function findRooms(corners) {

              function _calculateTheta(previousCorner, currentCorner, nextCorner) {
                  var theta = Utils.angle2pi(new Vector2(previousCorner.x - currentCorner.x, previousCorner.y - currentCorner.y), new Vector2(nextCorner.x - currentCorner.x, nextCorner.y - currentCorner.y));
                  return theta;
              }

              function _removeDuplicateRooms(roomArray) {
                  var results = [];
                  var lookup = {};
                  var hashFunc = function hashFunc(corner) {
                      return corner.id;
                  };
                  var sep = '-';
                  for (var i = 0; i < roomArray.length; i++) {
                      // rooms are cycles, shift it around to check uniqueness
                      var add = true;
                      var room = roomArray[i];
                      var str = void 0;
                      for (var j = 0; j < room.length; j++) {
                          var roomShift = Utils.cycle(room, j);
                          str = Utils.map(roomShift, hashFunc).join(sep);
                          if (lookup.hasOwnProperty(str)) {
                              add = false;
                          }
                      }
                      if (add) {
                          results.push(roomArray[i]);
                          lookup[str] = true;
                      }
                  }
                  return results;
              }

              /**
               * An internal method to find rooms based on corners and their
               * connectivities
               */
              function _findTightestCycle(firstCorner, secondCorner) {
                  var stack = [];
                  var next = { corner: secondCorner, previousCorners: [firstCorner] };
                  var visited = {};
                  visited[firstCorner.id] = true;

                  var _loop = function _loop() {
                      // update previous corners, current corner, and visited corners
                      var currentCorner = next.corner;
                      visited[currentCorner.id] = true;

                      // did we make it back to the startCorner?
                      if (next.corner === firstCorner && currentCorner !== secondCorner) {
                          return {
                              v: next.previousCorners
                          };
                      }

                      var addToStack = [];
                      var adjacentCorners = next.corner.adjacentCorners();
                      for (var i = 0; i < adjacentCorners.length; i++) {
                          var nextCorner = adjacentCorners[i];

                          // is this where we came from?
                          // give an exception if its the first corner and we aren't
                          // at the second corner
                          if (nextCorner.id in visited && !(nextCorner === firstCorner && currentCorner !== secondCorner)) {
                              continue;
                          }

                          // nope, throw it on the queue
                          addToStack.push(nextCorner);
                      }

                      var previousCorners = next.previousCorners.slice(0);
                      previousCorners.push(currentCorner);
                      if (addToStack.length > 1) {
                          // visit the ones with smallest theta first
                          var previousCorner = next.previousCorners[next.previousCorners.length - 1];
                          addToStack.sort(function (a, b) {
                              return _calculateTheta(previousCorner, currentCorner, b) - _calculateTheta(previousCorner, currentCorner, a);
                          });
                      }

                      if (addToStack.length > 0) {
                          // add to the stack
                          addToStack.forEach(function (corner) {
                              stack.push({ corner: corner, previousCorners: previousCorners });
                          });
                      }

                      // pop off the next one
                      next = stack.pop();
                  };

                  while (next) {
                      var _ret = _loop();

                      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                  }
                  return [];
              }

              // find tightest loops, for each corner, for each adjacent
              // TODO: optimize this, only check corners with > 2 adjacents, or
              // isolated cycles
              var loops = [];

              corners.forEach(function (firstCorner) {
                  firstCorner.adjacentCorners().forEach(function (secondCorner) {
                      loops.push(_findTightestCycle(firstCorner, secondCorner));
                  });
              });

              // remove duplicates
              var uniqueLoops = _removeDuplicateRooms(loops);
              // remove CW loops
              var uniqueCCWLoops = Utils.removeIf(uniqueLoops, Utils.isClockwise);
              return uniqueCCWLoops;
          }
      }, {
          key: 'carbonSheet',
          set: function set(val) {
              this._carbonSheet = val;
          }

          /**
           * @return {CarbonSheet} _carbonSheet reference to the instance of
           *         {@link CarbonSheet}
           */
          ,
          get: function get() {
              return this._carbonSheet;
          }
      }]);
      return Floorplan;
  }(EventDispatcher);

  /**
   * @author Rich Tibbett / https://github.com/richtr
   * @author mrdoob / http://mrdoob.com/
   * @author Tony Parisi / http://www.tonyparisi.com/
   * @author Takahiro / https://github.com/takahirox
   * @author Don McCurdy / https://www.donmccurdy.com
   */

  var GLTFLoader = ( function () {

  	function GLTFLoader( manager ) {

  		Loader.call( this, manager );

  		this.dracoLoader = null;
  		this.ddsLoader = null;

  		this.pluginCallbacks = [];
  		this.register( function ( parser ) {

  			return new GLTFMaterialsClearcoatExtension( parser );

  		} );

  	}

  	GLTFLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

  		constructor: GLTFLoader,

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var resourcePath;

  			if ( this.resourcePath !== '' ) {

  				resourcePath = this.resourcePath;

  			} else if ( this.path !== '' ) {

  				resourcePath = this.path;

  			} else {

  				resourcePath = LoaderUtils.extractUrlBase( url );

  			}

  			// Tells the LoadingManager to track an extra item, which resolves after
  			// the model is fully loaded. This means the count of items loaded will
  			// be incorrect, but ensures manager.onLoad() does not fire early.
  			scope.manager.itemStart( url );

  			var _onError = function ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			};

  			var loader = new FileLoader( scope.manager );

  			loader.setPath( this.path );
  			loader.setResponseType( 'arraybuffer' );
  			loader.setRequestHeader( this.requestHeader );

  			if ( scope.crossOrigin === 'use-credentials' ) {

  				loader.setWithCredentials( true );

  			}

  			loader.load( url, function ( data ) {

  				try {

  					scope.parse( data, resourcePath, function ( gltf ) {

  						onLoad( gltf );

  						scope.manager.itemEnd( url );

  					}, _onError );

  				} catch ( e ) {

  					_onError( e );

  				}

  			}, onProgress, _onError );

  		},

  		setDRACOLoader: function ( dracoLoader ) {

  			this.dracoLoader = dracoLoader;
  			return this;

  		},

  		setDDSLoader: function ( ddsLoader ) {

  			this.ddsLoader = ddsLoader;
  			return this;

  		},

  		register: function ( callback ) {

  			if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

  				this.pluginCallbacks.push( callback );

  			}

  			return this;

  		},

  		unregister: function ( callback ) {

  			if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

  				this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

  			}

  			return this;

  		},

  		parse: function ( data, path, onLoad, onError ) {

  			var content;
  			var extensions = {};
  			var plugins = {};

  			if ( typeof data === 'string' ) {

  				content = data;

  			} else {

  				var magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

  				if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

  					try {

  						extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

  					} catch ( error ) {

  						if ( onError ) onError( error );
  						return;

  					}

  					content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

  				} else {

  					content = LoaderUtils.decodeText( new Uint8Array( data ) );

  				}

  			}

  			var json = JSON.parse( content );

  			if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

  				if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
  				return;

  			}

  			var parser = new GLTFParser( json, {

  				path: path || this.resourcePath || '',
  				crossOrigin: this.crossOrigin,
  				manager: this.manager

  			} );

  			parser.fileLoader.setRequestHeader( this.requestHeader );

  			for ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {

  				var plugin = this.pluginCallbacks[ i ]( parser );
  				plugins[ plugin.name ] = plugin;

  				// Workaround to avoid determining as unknown extension
  				// in addUnknownExtensionsToUserData().
  				// Remove this workaround if we move all the existing
  				// extension handlers to plugin system
  				extensions[ plugin.name ] = true;

  			}

  			if ( json.extensionsUsed ) {

  				for ( var i = 0; i < json.extensionsUsed.length; ++ i ) {

  					var extensionName = json.extensionsUsed[ i ];
  					var extensionsRequired = json.extensionsRequired || [];

  					switch ( extensionName ) {

  						case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
  							extensions[ extensionName ] = new GLTFLightsExtension( json );
  							break;

  						case EXTENSIONS.KHR_MATERIALS_UNLIT:
  							extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
  							break;

  						case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
  							extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
  							break;

  						case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
  							extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
  							break;

  						case EXTENSIONS.MSFT_TEXTURE_DDS:
  							extensions[ extensionName ] = new GLTFTextureDDSExtension( this.ddsLoader );
  							break;

  						case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
  							extensions[ extensionName ] = new GLTFTextureTransformExtension();
  							break;

  						case EXTENSIONS.KHR_MESH_QUANTIZATION:
  							extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
  							break;

  						default:

  							if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

  								console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

  							}

  					}

  				}

  			}

  			parser.setExtensions( extensions );
  			parser.setPlugins( plugins );
  			parser.parse( onLoad, onError );

  		}

  	} );

  	/* GLTFREGISTRY */

  	function GLTFRegistry() {

  		var objects = {};

  		return	{

  			get: function ( key ) {

  				return objects[ key ];

  			},

  			add: function ( key, object ) {

  				objects[ key ] = object;

  			},

  			remove: function ( key ) {

  				delete objects[ key ];

  			},

  			removeAll: function () {

  				objects = {};

  			}

  		};

  	}

  	/*********************************/
  	/********** EXTENSIONS ***********/
  	/*********************************/

  	var EXTENSIONS = {
  		KHR_BINARY_GLTF: 'KHR_binary_glTF',
  		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  		KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  		KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
  		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  		KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  		KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  		MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
  	};

  	/**
  	 * DDS Texture Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
  	 *
  	 */
  	function GLTFTextureDDSExtension( ddsLoader ) {

  		if ( ! ddsLoader ) {

  			throw new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader' );

  		}

  		this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
  		this.ddsLoader = ddsLoader;

  	}

  	/**
  	 * Punctual Lights Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
  	 */
  	function GLTFLightsExtension( json ) {

  		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

  		var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};
  		this.lightDefs = extension.lights || [];

  	}

  	GLTFLightsExtension.prototype.loadLight = function ( lightIndex ) {

  		var lightDef = this.lightDefs[ lightIndex ];
  		var lightNode;

  		var color = new Color( 0xffffff );
  		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

  		var range = lightDef.range !== undefined ? lightDef.range : 0;

  		switch ( lightDef.type ) {

  			case 'directional':
  				lightNode = new DirectionalLight( color );
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			case 'point':
  				lightNode = new PointLight( color );
  				lightNode.distance = range;
  				break;

  			case 'spot':
  				lightNode = new SpotLight( color );
  				lightNode.distance = range;
  				// Handle spotlight properties.
  				lightDef.spot = lightDef.spot || {};
  				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
  				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
  				lightNode.angle = lightDef.spot.outerConeAngle;
  				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			default:
  				throw new Error( 'THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".' );

  		}

  		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
  		// here, because node-level parsing will only override position if explicitly specified.
  		lightNode.position.set( 0, 0, 0 );

  		lightNode.decay = 2;

  		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

  		lightNode.name = lightDef.name || ( 'light_' + lightIndex );

  		return Promise.resolve( lightNode );

  	};

  	/**
  	 * Unlit Materials Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
  	 */
  	function GLTFMaterialsUnlitExtension() {

  		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

  	}

  	GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {

  		return MeshBasicMaterial;

  	};

  	GLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {

  		var pending = [];

  		materialParams.color = new Color( 1.0, 1.0, 1.0 );
  		materialParams.opacity = 1.0;

  		var metallicRoughness = materialDef.pbrMetallicRoughness;

  		if ( metallicRoughness ) {

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				var array = metallicRoughness.baseColorFactor;

  				materialParams.color.fromArray( array );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

  			}

  		}

  		return Promise.all( pending );

  	};

  	/**
  	 * Clearcoat Materials Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
  	 */
  	function GLTFMaterialsClearcoatExtension( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

  	}

  	GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( /* materialIndex */ ) {

  		return MeshPhysicalMaterial;

  	};

  	GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {

  		var parser = this.parser;
  		var materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		var pending = [];

  		var extension = materialDef.extensions[ this.name ];

  		if ( extension.clearcoatFactor !== undefined ) {

  			materialParams.clearcoat = extension.clearcoatFactor;

  		}

  		if ( extension.clearcoatTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

  		}

  		if ( extension.clearcoatRoughnessFactor !== undefined ) {

  			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

  		}

  		if ( extension.clearcoatRoughnessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

  		}

  		if ( extension.clearcoatNormalTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

  			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

  				var scale = extension.clearcoatNormalTexture.scale;

  				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

  			}

  		}

  		return Promise.all( pending );

  	};

  	/* BINARY EXTENSION */
  	var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  	var BINARY_EXTENSION_HEADER_LENGTH = 12;
  	var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

  	function GLTFBinaryExtension( data ) {

  		this.name = EXTENSIONS.KHR_BINARY_GLTF;
  		this.content = null;
  		this.body = null;

  		var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

  		this.header = {
  			magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
  			version: headerView.getUint32( 4, true ),
  			length: headerView.getUint32( 8, true )
  		};

  		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

  			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

  		} else if ( this.header.version < 2.0 ) {

  			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

  		}

  		var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
  		var chunkIndex = 0;

  		while ( chunkIndex < chunkView.byteLength ) {

  			var chunkLength = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			var chunkType = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

  				var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
  				this.content = LoaderUtils.decodeText( contentArray );

  			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

  				var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
  				this.body = data.slice( byteOffset, byteOffset + chunkLength );

  			}

  			// Clients must ignore chunks with unknown types.

  			chunkIndex += chunkLength;

  		}

  		if ( this.content === null ) {

  			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

  		}

  	}

  	/**
  	 * DRACO Mesh Compression Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
  	 */
  	function GLTFDracoMeshCompressionExtension( json, dracoLoader ) {

  		if ( ! dracoLoader ) {

  			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

  		}

  		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
  		this.json = json;
  		this.dracoLoader = dracoLoader;
  		this.dracoLoader.preload();

  	}

  	GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {

  		var json = this.json;
  		var dracoLoader = this.dracoLoader;
  		var bufferViewIndex = primitive.extensions[ this.name ].bufferView;
  		var gltfAttributeMap = primitive.extensions[ this.name ].attributes;
  		var threeAttributeMap = {};
  		var attributeNormalizedMap = {};
  		var attributeTypeMap = {};

  		for ( var attributeName in gltfAttributeMap ) {

  			var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

  			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

  		}

  		for ( attributeName in primitive.attributes ) {

  			var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

  			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

  				var accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
  				var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  				attributeTypeMap[ threeAttributeName ] = componentType;
  				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

  			}

  		}

  		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

  			return new Promise( function ( resolve ) {

  				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

  					for ( var attributeName in geometry.attributes ) {

  						var attribute = geometry.attributes[ attributeName ];
  						var normalized = attributeNormalizedMap[ attributeName ];

  						if ( normalized !== undefined ) attribute.normalized = normalized;

  					}

  					resolve( geometry );

  				}, threeAttributeMap, attributeTypeMap );

  			} );

  		} );

  	};

  	/**
  	 * Texture Transform Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
  	 */
  	function GLTFTextureTransformExtension() {

  		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

  	}

  	GLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {

  		texture = texture.clone();

  		if ( transform.offset !== undefined ) {

  			texture.offset.fromArray( transform.offset );

  		}

  		if ( transform.rotation !== undefined ) {

  			texture.rotation = transform.rotation;

  		}

  		if ( transform.scale !== undefined ) {

  			texture.repeat.fromArray( transform.scale );

  		}

  		if ( transform.texCoord !== undefined ) {

  			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

  		}

  		texture.needsUpdate = true;

  		return texture;

  	};

  	/**
  	 * Specular-Glossiness Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
  	 */

  	/**
  	 * A sub class of StandardMaterial with some of the functionality
  	 * changed via the `onBeforeCompile` callback
  	 * @pailhead
  	 */

  	function GLTFMeshStandardSGMaterial( params ) {

  		MeshStandardMaterial.call( this );

  		this.isGLTFSpecularGlossinessMaterial = true;

  		//various chunks that need replacing
  		var specularMapParsFragmentChunk = [
  			'#ifdef USE_SPECULARMAP',
  			'	uniform sampler2D specularMap;',
  			'#endif'
  		].join( '\n' );

  		var glossinessMapParsFragmentChunk = [
  			'#ifdef USE_GLOSSINESSMAP',
  			'	uniform sampler2D glossinessMap;',
  			'#endif'
  		].join( '\n' );

  		var specularMapFragmentChunk = [
  			'vec3 specularFactor = specular;',
  			'#ifdef USE_SPECULARMAP',
  			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
  			'	texelSpecular = sRGBToLinear( texelSpecular );',
  			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
  			'	specularFactor *= texelSpecular.rgb;',
  			'#endif'
  		].join( '\n' );

  		var glossinessMapFragmentChunk = [
  			'float glossinessFactor = glossiness;',
  			'#ifdef USE_GLOSSINESSMAP',
  			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
  			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
  			'	glossinessFactor *= texelGlossiness.a;',
  			'#endif'
  		].join( '\n' );

  		var lightPhysicalFragmentChunk = [
  			'PhysicalMaterial material;',
  			'material.diffuseColor = diffuseColor.rgb;',
  			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
  			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
  			'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.',
  			'material.specularRoughness += geometryRoughness;',
  			'material.specularRoughness = min( material.specularRoughness, 1.0 );',
  			'material.specularColor = specularFactor.rgb;',
  		].join( '\n' );

  		var uniforms = {
  			specular: { value: new Color().setHex( 0xffffff ) },
  			glossiness: { value: 1 },
  			specularMap: { value: null },
  			glossinessMap: { value: null }
  		};

  		this._extraUniforms = uniforms;

  		// please see #14031 or #13198 for an alternate approach
  		this.onBeforeCompile = function ( shader ) {

  			for ( var uniformName in uniforms ) {

  				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

  			}

  			shader.fragmentShader = shader.fragmentShader.replace( 'uniform float roughness;', 'uniform vec3 specular;' );
  			shader.fragmentShader = shader.fragmentShader.replace( 'uniform float metalness;', 'uniform float glossiness;' );
  			shader.fragmentShader = shader.fragmentShader.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk );
  			shader.fragmentShader = shader.fragmentShader.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk );
  			shader.fragmentShader = shader.fragmentShader.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk );
  			shader.fragmentShader = shader.fragmentShader.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk );
  			shader.fragmentShader = shader.fragmentShader.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

  		};

  		/*eslint-disable*/
  		Object.defineProperties(
  			this,
  			{
  				specular: {
  					get: function () { return uniforms.specular.value; },
  					set: function ( v ) { uniforms.specular.value = v; }
  				},
  				specularMap: {
  					get: function () { return uniforms.specularMap.value; },
  					set: function ( v ) { uniforms.specularMap.value = v; }
  				},
  				glossiness: {
  					get: function () { return uniforms.glossiness.value; },
  					set: function ( v ) { uniforms.glossiness.value = v; }
  				},
  				glossinessMap: {
  					get: function () { return uniforms.glossinessMap.value; },
  					set: function ( v ) {

  						uniforms.glossinessMap.value = v;
  						//how about something like this - @pailhead
  						if ( v ) {

  							this.defines.USE_GLOSSINESSMAP = '';
  							// set USE_ROUGHNESSMAP to enable vUv
  							this.defines.USE_ROUGHNESSMAP = '';

  						} else {

  							delete this.defines.USE_ROUGHNESSMAP;
  							delete this.defines.USE_GLOSSINESSMAP;

  						}

  					}
  				}
  			}
  		);

  		/*eslint-enable*/
  		delete this.metalness;
  		delete this.roughness;
  		delete this.metalnessMap;
  		delete this.roughnessMap;

  		this.setValues( params );

  	}

  	GLTFMeshStandardSGMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
  	GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

  	GLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {

  		MeshStandardMaterial.prototype.copy.call( this, source );
  		this.specularMap = source.specularMap;
  		this.specular.copy( source.specular );
  		this.glossinessMap = source.glossinessMap;
  		this.glossiness = source.glossiness;
  		delete this.metalness;
  		delete this.roughness;
  		delete this.metalnessMap;
  		delete this.roughnessMap;
  		return this;

  	};

  	function GLTFMaterialsPbrSpecularGlossinessExtension() {

  		return {

  			name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

  			specularGlossinessParams: [
  				'color',
  				'map',
  				'lightMap',
  				'lightMapIntensity',
  				'aoMap',
  				'aoMapIntensity',
  				'emissive',
  				'emissiveIntensity',
  				'emissiveMap',
  				'bumpMap',
  				'bumpScale',
  				'normalMap',
  				'normalMapType',
  				'displacementMap',
  				'displacementScale',
  				'displacementBias',
  				'specularMap',
  				'specular',
  				'glossinessMap',
  				'glossiness',
  				'alphaMap',
  				'envMap',
  				'envMapIntensity',
  				'refractionRatio',
  			],

  			getMaterialType: function () {

  				return GLTFMeshStandardSGMaterial;

  			},

  			extendParams: function ( materialParams, materialDef, parser ) {

  				var pbrSpecularGlossiness = materialDef.extensions[ this.name ];

  				materialParams.color = new Color( 1.0, 1.0, 1.0 );
  				materialParams.opacity = 1.0;

  				var pending = [];

  				if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

  					var array = pbrSpecularGlossiness.diffuseFactor;

  					materialParams.color.fromArray( array );
  					materialParams.opacity = array[ 3 ];

  				}

  				if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

  					pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

  				}

  				materialParams.emissive = new Color( 0.0, 0.0, 0.0 );
  				materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
  				materialParams.specular = new Color( 1.0, 1.0, 1.0 );

  				if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

  					materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

  				}

  				if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

  					var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
  					pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
  					pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

  				}

  				return Promise.all( pending );

  			},

  			createMaterial: function ( materialParams ) {

  				var material = new GLTFMeshStandardSGMaterial( materialParams );
  				material.fog = true;

  				material.color = materialParams.color;

  				material.map = materialParams.map === undefined ? null : materialParams.map;

  				material.lightMap = null;
  				material.lightMapIntensity = 1.0;

  				material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
  				material.aoMapIntensity = 1.0;

  				material.emissive = materialParams.emissive;
  				material.emissiveIntensity = 1.0;
  				material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

  				material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
  				material.bumpScale = 1;

  				material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
  				material.normalMapType = TangentSpaceNormalMap;

  				if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

  				material.displacementMap = null;
  				material.displacementScale = 1;
  				material.displacementBias = 0;

  				material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
  				material.specular = materialParams.specular;

  				material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
  				material.glossiness = materialParams.glossiness;

  				material.alphaMap = null;

  				material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
  				material.envMapIntensity = 1.0;

  				material.refractionRatio = 0.98;

  				return material;

  			},

  		};

  	}

  	/**
  	 * Mesh Quantization Extension
  	 *
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
  	 */
  	function GLTFMeshQuantizationExtension() {

  		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

  	}

  	/*********************************/
  	/********** INTERPOLATION ********/
  	/*********************************/

  	// Spline Interpolation
  	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
  	function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	GLTFCubicSplineInterpolant.prototype = Object.create( Interpolant.prototype );
  	GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

  	GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {

  		// Copies a sample value to the result buffer. See description of glTF
  		// CUBICSPLINE values layout in interpolate_() function below.

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			valueSize = this.valueSize,
  			offset = index * valueSize * 3 + valueSize;

  		for ( var i = 0; i !== valueSize; i ++ ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	};

  	GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

  	GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

  	GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer;
  		var values = this.sampleValues;
  		var stride = this.valueSize;

  		var stride2 = stride * 2;
  		var stride3 = stride * 3;

  		var td = t1 - t0;

  		var p = ( t - t0 ) / td;
  		var pp = p * p;
  		var ppp = pp * p;

  		var offset1 = i1 * stride3;
  		var offset0 = offset1 - stride3;

  		var s2 = - 2 * ppp + 3 * pp;
  		var s3 = ppp - pp;
  		var s0 = 1 - s2;
  		var s1 = s3 - pp + p;

  		// Layout of keyframe output values for CUBICSPLINE animations:
  		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
  		for ( var i = 0; i !== stride; i ++ ) {

  			var p0 = values[ offset0 + i + stride ]; // splineVertex_k
  			var m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
  			var p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
  			var m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

  			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

  		}

  		return result;

  	};

  	/*********************************/
  	/********** INTERNALS ************/
  	/*********************************/

  	/* CONSTANTS */

  	var WEBGL_CONSTANTS = {
  		FLOAT: 5126,
  		//FLOAT_MAT2: 35674,
  		FLOAT_MAT3: 35675,
  		FLOAT_MAT4: 35676,
  		FLOAT_VEC2: 35664,
  		FLOAT_VEC3: 35665,
  		FLOAT_VEC4: 35666,
  		LINEAR: 9729,
  		REPEAT: 10497,
  		SAMPLER_2D: 35678,
  		POINTS: 0,
  		LINES: 1,
  		LINE_LOOP: 2,
  		LINE_STRIP: 3,
  		TRIANGLES: 4,
  		TRIANGLE_STRIP: 5,
  		TRIANGLE_FAN: 6,
  		UNSIGNED_BYTE: 5121,
  		UNSIGNED_SHORT: 5123
  	};

  	var WEBGL_COMPONENT_TYPES = {
  		5120: Int8Array,
  		5121: Uint8Array,
  		5122: Int16Array,
  		5123: Uint16Array,
  		5125: Uint32Array,
  		5126: Float32Array
  	};

  	var WEBGL_FILTERS = {
  		9728: NearestFilter,
  		9729: LinearFilter,
  		9984: NearestMipmapNearestFilter,
  		9985: LinearMipmapNearestFilter,
  		9986: NearestMipmapLinearFilter,
  		9987: LinearMipmapLinearFilter
  	};

  	var WEBGL_WRAPPINGS = {
  		33071: ClampToEdgeWrapping,
  		33648: MirroredRepeatWrapping,
  		10497: RepeatWrapping
  	};

  	var WEBGL_TYPE_SIZES = {
  		'SCALAR': 1,
  		'VEC2': 2,
  		'VEC3': 3,
  		'VEC4': 4,
  		'MAT2': 4,
  		'MAT3': 9,
  		'MAT4': 16
  	};

  	var ATTRIBUTES = {
  		POSITION: 'position',
  		NORMAL: 'normal',
  		TANGENT: 'tangent',
  		TEXCOORD_0: 'uv',
  		TEXCOORD_1: 'uv2',
  		COLOR_0: 'color',
  		WEIGHTS_0: 'skinWeight',
  		JOINTS_0: 'skinIndex',
  	};

  	var PATH_PROPERTIES = {
  		scale: 'scale',
  		translation: 'position',
  		rotation: 'quaternion',
  		weights: 'morphTargetInfluences'
  	};

  	var INTERPOLATION = {
  		CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  		                        // keyframe track will be initialized with a default interpolation type, then modified.
  		LINEAR: InterpolateLinear,
  		STEP: InterpolateDiscrete
  	};

  	var ALPHA_MODES = {
  		OPAQUE: 'OPAQUE',
  		MASK: 'MASK',
  		BLEND: 'BLEND'
  	};

  	var MIME_TYPE_FORMATS = {
  		'image/png': RGBAFormat,
  		'image/jpeg': RGBFormat
  	};

  	/* UTILITY FUNCTIONS */

  	function resolveURL( url, path ) {

  		// Invalid URL
  		if ( typeof url !== 'string' || url === '' ) return '';

  		// Host Relative URL
  		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

  			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

  		}

  		// Absolute URL http://,https://,//
  		if ( /^(https?:)?\/\//i.test( url ) ) return url;

  		// Data URI
  		if ( /^data:.*,.*$/i.test( url ) ) return url;

  		// Blob URL
  		if ( /^blob:.*$/i.test( url ) ) return url;

  		// Relative URL
  		return path + url;

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
  	 */
  	function createDefaultMaterial( cache ) {

  		if ( cache[ 'DefaultMaterial' ] === undefined ) {

  			cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
  				color: 0xFFFFFF,
  				emissive: 0x000000,
  				metalness: 1,
  				roughness: 1,
  				transparent: false,
  				depthTest: true,
  				side: FrontSide
  			} );

  		}

  		return cache[ 'DefaultMaterial' ];

  	}

  	function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

  		// Add unknown glTF extensions to an object's userData.

  		for ( var name in objectDef.extensions ) {

  			if ( knownExtensions[ name ] === undefined ) {

  				object.userData.gltfExtensions = object.userData.gltfExtensions || {};
  				object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

  			}

  		}

  	}

  	/**
  	 * @param {Object3D|Material|BufferGeometry} object
  	 * @param {GLTF.definition} gltfDef
  	 */
  	function assignExtrasToUserData( object, gltfDef ) {

  		if ( gltfDef.extras !== undefined ) {

  			if ( typeof gltfDef.extras === 'object' ) {

  				Object.assign( object.userData, gltfDef.extras );

  			} else {

  				console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

  			}

  		}

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
  	 *
  	 * @param {BufferGeometry} geometry
  	 * @param {Array<GLTF.Target>} targets
  	 * @param {GLTFParser} parser
  	 * @return {Promise<BufferGeometry>}
  	 */
  	function addMorphTargets( geometry, targets, parser ) {

  		var hasMorphPosition = false;
  		var hasMorphNormal = false;

  		for ( var i = 0, il = targets.length; i < il; i ++ ) {

  			var target = targets[ i ];

  			if ( target.POSITION !== undefined ) hasMorphPosition = true;
  			if ( target.NORMAL !== undefined ) hasMorphNormal = true;

  			if ( hasMorphPosition && hasMorphNormal ) break;

  		}

  		if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );

  		var pendingPositionAccessors = [];
  		var pendingNormalAccessors = [];

  		for ( var i = 0, il = targets.length; i < il; i ++ ) {

  			var target = targets[ i ];

  			if ( hasMorphPosition ) {

  				var pendingAccessor = target.POSITION !== undefined
  					? parser.getDependency( 'accessor', target.POSITION )
  					: geometry.attributes.position;

  				pendingPositionAccessors.push( pendingAccessor );

  			}

  			if ( hasMorphNormal ) {

  				var pendingAccessor = target.NORMAL !== undefined
  					? parser.getDependency( 'accessor', target.NORMAL )
  					: geometry.attributes.normal;

  				pendingNormalAccessors.push( pendingAccessor );

  			}

  		}

  		return Promise.all( [
  			Promise.all( pendingPositionAccessors ),
  			Promise.all( pendingNormalAccessors )
  		] ).then( function ( accessors ) {

  			var morphPositions = accessors[ 0 ];
  			var morphNormals = accessors[ 1 ];

  			if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
  			if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
  			geometry.morphTargetsRelative = true;

  			return geometry;

  		} );

  	}

  	/**
  	 * @param {Mesh} mesh
  	 * @param {GLTF.Mesh} meshDef
  	 */
  	function updateMorphTargets( mesh, meshDef ) {

  		mesh.updateMorphTargets();

  		if ( meshDef.weights !== undefined ) {

  			for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {

  				mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

  			}

  		}

  		// .extras has user-defined data, so check that .extras.targetNames is an array.
  		if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

  			var targetNames = meshDef.extras.targetNames;

  			if ( mesh.morphTargetInfluences.length === targetNames.length ) {

  				mesh.morphTargetDictionary = {};

  				for ( var i = 0, il = targetNames.length; i < il; i ++ ) {

  					mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

  				}

  			} else {

  				console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

  			}

  		}

  	}

  	function createPrimitiveKey( primitiveDef ) {

  		var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
  		var geometryKey;

  		if ( dracoExtension ) {

  			geometryKey = 'draco:' + dracoExtension.bufferView
  				+ ':' + dracoExtension.indices
  				+ ':' + createAttributesKey( dracoExtension.attributes );

  		} else {

  			geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

  		}

  		return geometryKey;

  	}

  	function createAttributesKey( attributes ) {

  		var attributesKey = '';

  		var keys = Object.keys( attributes ).sort();

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

  		}

  		return attributesKey;

  	}

  	/* GLTF PARSER */

  	function GLTFParser( json, options ) {

  		this.json = json || {};
  		this.extensions = {};
  		this.plugins = {};
  		this.options = options || {};

  		// loader object cache
  		this.cache = new GLTFRegistry();

  		// associations between Three.js objects and glTF elements
  		this.associations = new Map();

  		// BufferGeometry caching
  		this.primitiveCache = {};

  		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
  		// expensive work of uploading a texture to the GPU off the main thread.
  		if ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {

  			this.textureLoader = new ImageBitmapLoader( this.options.manager );

  		} else {

  			this.textureLoader = new TextureLoader( this.options.manager );

  		}

  		this.textureLoader.setCrossOrigin( this.options.crossOrigin );

  		this.fileLoader = new FileLoader( this.options.manager );
  		this.fileLoader.setResponseType( 'arraybuffer' );

  		if ( this.options.crossOrigin === 'use-credentials' ) {

  			this.fileLoader.setWithCredentials( true );

  		}

  	}

  	GLTFParser.prototype.setExtensions = function ( extensions ) {

  		this.extensions = extensions;

  	};

  	GLTFParser.prototype.setPlugins = function ( plugins ) {

  		this.plugins = plugins;

  	};

  	GLTFParser.prototype.parse = function ( onLoad, onError ) {

  		var parser = this;
  		var json = this.json;
  		var extensions = this.extensions;

  		// Clear the loader cache
  		this.cache.removeAll();

  		// Mark the special nodes/meshes in json for efficient parse
  		this.markDefs();

  		Promise.all( [

  			this.getDependencies( 'scene' ),
  			this.getDependencies( 'animation' ),
  			this.getDependencies( 'camera' ),

  		] ).then( function ( dependencies ) {

  			var result = {
  				scene: dependencies[ 0 ][ json.scene || 0 ],
  				scenes: dependencies[ 0 ],
  				animations: dependencies[ 1 ],
  				cameras: dependencies[ 2 ],
  				asset: json.asset,
  				parser: parser,
  				userData: {}
  			};

  			addUnknownExtensionsToUserData( extensions, result, json );

  			assignExtrasToUserData( result, json );

  			onLoad( result );

  		} ).catch( onError );

  	};

  	/**
  	 * Marks the special nodes/meshes in json for efficient parse.
  	 */
  	GLTFParser.prototype.markDefs = function () {

  		var nodeDefs = this.json.nodes || [];
  		var skinDefs = this.json.skins || [];
  		var meshDefs = this.json.meshes || [];

  		var meshReferences = {};
  		var meshUses = {};

  		// Nothing in the node definition indicates whether it is a Bone or an
  		// Object3D. Use the skins' joint references to mark bones.
  		for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

  			var joints = skinDefs[ skinIndex ].joints;

  			for ( var i = 0, il = joints.length; i < il; i ++ ) {

  				nodeDefs[ joints[ i ] ].isBone = true;

  			}

  		}

  		// Meshes can (and should) be reused by multiple nodes in a glTF asset. To
  		// avoid having more than one Mesh with the same name, count
  		// references and rename instances below.
  		//
  		// Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
  		for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

  			var nodeDef = nodeDefs[ nodeIndex ];

  			if ( nodeDef.mesh !== undefined ) {

  				if ( meshReferences[ nodeDef.mesh ] === undefined ) {

  					meshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;

  				}

  				meshReferences[ nodeDef.mesh ] ++;

  				// Nothing in the mesh definition indicates whether it is
  				// a SkinnedMesh or Mesh. Use the node's mesh reference
  				// to mark SkinnedMesh if node has skin.
  				if ( nodeDef.skin !== undefined ) {

  					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

  				}

  			}

  		}

  		this.json.meshReferences = meshReferences;
  		this.json.meshUses = meshUses;

  	};

  	GLTFParser.prototype._invokeOne = function ( func ) {

  		var extensions = Object.values( this.plugins );
  		extensions.push( this );

  		for ( var i = 0; i < extensions.length; i ++ ) {

  			var result = func( extensions[ i ] );

  			if ( result ) return result;

  		}

  	};

  	GLTFParser.prototype._invokeAll = function ( func ) {

  		var extensions = Object.values( this.plugins );
  		extensions.unshift( this );

  		var pending = [];

  		for ( var i = 0; i < extensions.length; i ++ ) {

  			pending.push( func( extensions[ i ] ) );

  		}

  		return Promise.all( pending );

  	};

  	/**
  	 * Requests the specified dependency asynchronously, with caching.
  	 * @param {string} type
  	 * @param {number} index
  	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
  	 */
  	GLTFParser.prototype.getDependency = function ( type, index ) {

  		var cacheKey = type + ':' + index;
  		var dependency = this.cache.get( cacheKey );

  		if ( ! dependency ) {

  			switch ( type ) {

  				case 'scene':
  					dependency = this.loadScene( index );
  					break;

  				case 'node':
  					dependency = this.loadNode( index );
  					break;

  				case 'mesh':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadMesh && ext.loadMesh( index );

  					} );
  					break;

  				case 'accessor':
  					dependency = this.loadAccessor( index );
  					break;

  				case 'bufferView':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadBufferView && ext.loadBufferView( index );

  					} );
  					break;

  				case 'buffer':
  					dependency = this.loadBuffer( index );
  					break;

  				case 'material':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadMaterial && ext.loadMaterial( index );

  					} );
  					break;

  				case 'texture':
  					dependency = this.loadTexture( index );
  					break;

  				case 'skin':
  					dependency = this.loadSkin( index );
  					break;

  				case 'animation':
  					dependency = this.loadAnimation( index );
  					break;

  				case 'camera':
  					dependency = this.loadCamera( index );
  					break;

  				case 'light':
  					dependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index );
  					break;

  				default:
  					throw new Error( 'Unknown type: ' + type );

  			}

  			this.cache.add( cacheKey, dependency );

  		}

  		return dependency;

  	};

  	/**
  	 * Requests all dependencies of the specified type asynchronously, with caching.
  	 * @param {string} type
  	 * @return {Promise<Array<Object>>}
  	 */
  	GLTFParser.prototype.getDependencies = function ( type ) {

  		var dependencies = this.cache.get( type );

  		if ( ! dependencies ) {

  			var parser = this;
  			var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

  			dependencies = Promise.all( defs.map( function ( def, index ) {

  				return parser.getDependency( type, index );

  			} ) );

  			this.cache.add( type, dependencies );

  		}

  		return dependencies;

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  	 * @param {number} bufferIndex
  	 * @return {Promise<ArrayBuffer>}
  	 */
  	GLTFParser.prototype.loadBuffer = function ( bufferIndex ) {

  		var bufferDef = this.json.buffers[ bufferIndex ];
  		var loader = this.fileLoader;

  		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

  			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

  		}

  		// If present, GLB container is required to be the first buffer.
  		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

  			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

  		}

  		var options = this.options;

  		return new Promise( function ( resolve, reject ) {

  			loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

  				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

  			} );

  		} );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  	 * @param {number} bufferViewIndex
  	 * @return {Promise<ArrayBuffer>}
  	 */
  	GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {

  		var bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

  		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

  			var byteLength = bufferViewDef.byteLength || 0;
  			var byteOffset = bufferViewDef.byteOffset || 0;
  			return buffer.slice( byteOffset, byteOffset + byteLength );

  		} );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
  	 * @param {number} accessorIndex
  	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
  	 */
  	GLTFParser.prototype.loadAccessor = function ( accessorIndex ) {

  		var parser = this;
  		var json = this.json;

  		var accessorDef = this.json.accessors[ accessorIndex ];

  		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

  			// Ignore empty accessors, which may be used to declare runtime
  			// information about attributes coming from another source (e.g. Draco
  			// compression extension).
  			return Promise.resolve( null );

  		}

  		var pendingBufferViews = [];

  		if ( accessorDef.bufferView !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

  		} else {

  			pendingBufferViews.push( null );

  		}

  		if ( accessorDef.sparse !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

  		}

  		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

  			var bufferView = bufferViews[ 0 ];

  			var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
  			var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
  			var elementBytes = TypedArray.BYTES_PER_ELEMENT;
  			var itemBytes = elementBytes * itemSize;
  			var byteOffset = accessorDef.byteOffset || 0;
  			var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
  			var normalized = accessorDef.normalized === true;
  			var array, bufferAttribute;

  			// The buffer is not interleaved if the stride is the item size in bytes.
  			if ( byteStride && byteStride !== itemBytes ) {

  				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
  				// This makes sure that IBA.count reflects accessor.count properly
  				var ibSlice = Math.floor( byteOffset / byteStride );
  				var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
  				var ib = parser.cache.get( ibCacheKey );

  				if ( ! ib ) {

  					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

  					// Integer parameters to IB/IBA are in array elements, not bytes.
  					ib = new InterleavedBuffer( array, byteStride / elementBytes );

  					parser.cache.add( ibCacheKey, ib );

  				}

  				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

  			} else {

  				if ( bufferView === null ) {

  					array = new TypedArray( accessorDef.count * itemSize );

  				} else {

  					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

  				}

  				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

  			}

  			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
  			if ( accessorDef.sparse !== undefined ) {

  				var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
  				var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

  				var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
  				var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

  				var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
  				var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

  				if ( bufferView !== null ) {

  					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
  					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

  				}

  				for ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {

  					var index = sparseIndices[ i ];

  					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
  					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
  					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
  					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
  					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

  				}

  			}

  			return bufferAttribute;

  		} );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
  	 * @param {number} textureIndex
  	 * @return {Promise<THREE.Texture>}
  	 */
  	GLTFParser.prototype.loadTexture = function ( textureIndex ) {

  		var parser = this;
  		var json = this.json;
  		var options = this.options;
  		var textureLoader = this.textureLoader;

  		var URL = self.URL || self.webkitURL;

  		var textureDef = json.textures[ textureIndex ];

  		var textureExtensions = textureDef.extensions || {};

  		var source;

  		if ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {

  			source = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];

  		} else {

  			source = json.images[ textureDef.source ];

  		}

  		var sourceURI = source.uri;
  		var isObjectURL = false;

  		if ( source.bufferView !== undefined ) {

  			// Load binary image data from bufferView, if provided.

  			sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

  				isObjectURL = true;
  				var blob = new Blob( [ bufferView ], { type: source.mimeType } );
  				sourceURI = URL.createObjectURL( blob );
  				return sourceURI;

  			} );

  		}

  		return Promise.resolve( sourceURI ).then( function ( sourceURI ) {

  			// Load Texture resource.

  			var loader = options.manager.getHandler( sourceURI );

  			if ( ! loader ) {

  				loader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]
  					? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader
  					: textureLoader;

  			}

  			return new Promise( function ( resolve, reject ) {

  				var onLoad = resolve;

  				if ( loader.isImageBitmapLoader === true ) {

  					onLoad = function ( imageBitmap ) {

  						resolve( new CanvasTexture( imageBitmap ) );

  					};

  				}

  				loader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

  			} );

  		} ).then( function ( texture ) {

  			// Clean up resources and configure Texture.

  			if ( isObjectURL === true ) {

  				URL.revokeObjectURL( sourceURI );

  			}

  			texture.flipY = false;

  			if ( textureDef.name ) texture.name = textureDef.name;

  			// Ignore unknown mime types, like DDS files.
  			if ( source.mimeType in MIME_TYPE_FORMATS ) {

  				texture.format = MIME_TYPE_FORMATS[ source.mimeType ];

  			}

  			var samplers = json.samplers || {};
  			var sampler = samplers[ textureDef.sampler ] || {};

  			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
  			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
  			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
  			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

  			parser.associations.set( texture, {
  				type: 'textures',
  				index: textureIndex
  			} );

  			return texture;

  		} );

  	};

  	/**
  	 * Asynchronously assigns a texture to the given material parameters.
  	 * @param {Object} materialParams
  	 * @param {string} mapName
  	 * @param {Object} mapDef
  	 * @return {Promise}
  	 */
  	GLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {

  		var parser = this;

  		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

  			if ( ! texture.isCompressedTexture ) {

  				switch ( mapName ) {

  					case 'aoMap':
  					case 'emissiveMap':
  					case 'metalnessMap':
  					case 'normalMap':
  					case 'roughnessMap':
  						texture.format = RGBFormat;
  						break;

  				}

  			}

  			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
  			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
  			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

  				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

  			}

  			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

  				var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

  				if ( transform ) {

  					var gltfReference = parser.associations.get( texture );
  					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
  					parser.associations.set( texture, gltfReference );

  				}

  			}

  			materialParams[ mapName ] = texture;

  		} );

  	};

  	/**
  	 * Assigns final material to a Mesh, Line, or Points instance. The instance
  	 * already has a material (generated from the glTF material options alone)
  	 * but reuse of the same glTF material may require multiple threejs materials
  	 * to accomodate different primitive types, defines, etc. New materials will
  	 * be created if necessary, and reused from a cache.
  	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
  	 */
  	GLTFParser.prototype.assignFinalMaterial = function ( mesh ) {

  		var geometry = mesh.geometry;
  		var material = mesh.material;

  		var useVertexTangents = geometry.attributes.tangent !== undefined;
  		var useVertexColors = geometry.attributes.color !== undefined;
  		var useFlatShading = geometry.attributes.normal === undefined;
  		var useSkinning = mesh.isSkinnedMesh === true;
  		var useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
  		var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

  		if ( mesh.isPoints ) {

  			var cacheKey = 'PointsMaterial:' + material.uuid;

  			var pointsMaterial = this.cache.get( cacheKey );

  			if ( ! pointsMaterial ) {

  				pointsMaterial = new PointsMaterial();
  				Material.prototype.copy.call( pointsMaterial, material );
  				pointsMaterial.color.copy( material.color );
  				pointsMaterial.map = material.map;
  				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

  				this.cache.add( cacheKey, pointsMaterial );

  			}

  			material = pointsMaterial;

  		} else if ( mesh.isLine ) {

  			var cacheKey = 'LineBasicMaterial:' + material.uuid;

  			var lineMaterial = this.cache.get( cacheKey );

  			if ( ! lineMaterial ) {

  				lineMaterial = new LineBasicMaterial();
  				Material.prototype.copy.call( lineMaterial, material );
  				lineMaterial.color.copy( material.color );

  				this.cache.add( cacheKey, lineMaterial );

  			}

  			material = lineMaterial;

  		}

  		// Clone the material if it will be modified
  		if ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {

  			var cacheKey = 'ClonedMaterial:' + material.uuid + ':';

  			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
  			if ( useSkinning ) cacheKey += 'skinning:';
  			if ( useVertexTangents ) cacheKey += 'vertex-tangents:';
  			if ( useVertexColors ) cacheKey += 'vertex-colors:';
  			if ( useFlatShading ) cacheKey += 'flat-shading:';
  			if ( useMorphTargets ) cacheKey += 'morph-targets:';
  			if ( useMorphNormals ) cacheKey += 'morph-normals:';

  			var cachedMaterial = this.cache.get( cacheKey );

  			if ( ! cachedMaterial ) {

  				cachedMaterial = material.clone();

  				if ( useSkinning ) cachedMaterial.skinning = true;
  				if ( useVertexTangents ) cachedMaterial.vertexTangents = true;
  				if ( useVertexColors ) cachedMaterial.vertexColors = true;
  				if ( useFlatShading ) cachedMaterial.flatShading = true;
  				if ( useMorphTargets ) cachedMaterial.morphTargets = true;
  				if ( useMorphNormals ) cachedMaterial.morphNormals = true;

  				this.cache.add( cacheKey, cachedMaterial );

  				this.associations.set( cachedMaterial, this.associations.get( material ) );

  			}

  			material = cachedMaterial;

  		}

  		// workarounds for mesh and geometry

  		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

  			geometry.setAttribute( 'uv2', geometry.attributes.uv );

  		}

  		// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
  		if ( material.normalScale && ! useVertexTangents ) {

  			material.normalScale.y = - material.normalScale.y;

  		}

  		if ( material.clearcoatNormalScale && ! useVertexTangents ) {

  			material.clearcoatNormalScale.y = - material.clearcoatNormalScale.y;

  		}

  		mesh.material = material;

  	};

  	GLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {

  		return MeshStandardMaterial;

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
  	 * @param {number} materialIndex
  	 * @return {Promise<Material>}
  	 */
  	GLTFParser.prototype.loadMaterial = function ( materialIndex ) {

  		var parser = this;
  		var json = this.json;
  		var extensions = this.extensions;
  		var materialDef = json.materials[ materialIndex ];

  		var materialType;
  		var materialParams = {};
  		var materialExtensions = materialDef.extensions || {};

  		var pending = [];

  		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

  			var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
  			materialType = sgExtension.getMaterialType();
  			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

  		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

  			var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
  			materialType = kmuExtension.getMaterialType();
  			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

  		} else {

  			// Specification:
  			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

  			var metallicRoughness = materialDef.pbrMetallicRoughness || {};

  			materialParams.color = new Color( 1.0, 1.0, 1.0 );
  			materialParams.opacity = 1.0;

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				var array = metallicRoughness.baseColorFactor;

  				materialParams.color.fromArray( array );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

  			}

  			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
  			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

  			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
  				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

  			}

  			materialType = this._invokeOne( function ( ext ) {

  				return ext.getMaterialType && ext.getMaterialType( materialIndex );

  			} );

  			pending.push( this._invokeAll( function ( ext ) {

  				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

  			} ) );

  		}

  		if ( materialDef.doubleSided === true ) {

  			materialParams.side = DoubleSide;

  		}

  		var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

  		if ( alphaMode === ALPHA_MODES.BLEND ) {

  			materialParams.transparent = true;

  			// See: https://github.com/mrdoob/three.js/issues/17706
  			materialParams.depthWrite = false;

  		} else {

  			materialParams.transparent = false;

  			if ( alphaMode === ALPHA_MODES.MASK ) {

  				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

  			}

  		}

  		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

  			materialParams.normalScale = new Vector2( 1, 1 );

  			if ( materialDef.normalTexture.scale !== undefined ) {

  				materialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );

  			}

  		}

  		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

  			if ( materialDef.occlusionTexture.strength !== undefined ) {

  				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

  			}

  		}

  		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

  			materialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );

  		}

  		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

  		}

  		return Promise.all( pending ).then( function () {

  			var material;

  			if ( materialType === GLTFMeshStandardSGMaterial ) {

  				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

  			} else {

  				material = new materialType( materialParams );

  			}

  			if ( materialDef.name ) material.name = materialDef.name;

  			// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
  			if ( material.map ) material.map.encoding = sRGBEncoding;
  			if ( material.emissiveMap ) material.emissiveMap.encoding = sRGBEncoding;

  			assignExtrasToUserData( material, materialDef );

  			parser.associations.set( material, { type: 'materials', index: materialIndex } );

  			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

  			return material;

  		} );

  	};

  	/**
  	 * @param {BufferGeometry} geometry
  	 * @param {GLTF.Primitive} primitiveDef
  	 * @param {GLTFParser} parser
  	 */
  	function computeBounds( geometry, primitiveDef, parser ) {

  		var attributes = primitiveDef.attributes;

  		var box = new Box3();

  		if ( attributes.POSITION !== undefined ) {

  			var accessor = parser.json.accessors[ attributes.POSITION ];

  			var min = accessor.min;
  			var max = accessor.max;

  			// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

  			if ( min !== undefined && max !== undefined ) {

  				box.set(
  					new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
  					new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );

  			} else {

  				console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

  				return;

  			}

  		} else {

  			return;

  		}

  		var targets = primitiveDef.targets;

  		if ( targets !== undefined ) {

  			var maxDisplacement = new Vector3();
  			var vector = new Vector3();

  			for ( var i = 0, il = targets.length; i < il; i ++ ) {

  				var target = targets[ i ];

  				if ( target.POSITION !== undefined ) {

  					var accessor = parser.json.accessors[ target.POSITION ];
  					var min = accessor.min;
  					var max = accessor.max;

  					// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

  					if ( min !== undefined && max !== undefined ) {

  						// we need to get max of absolute components because target weight is [-1,1]
  						vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
  						vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
  						vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );

  						// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
  						// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
  						// are used to implement key-frame animations and as such only two are active at a time - this results in very large
  						// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
  						maxDisplacement.max( vector );

  					} else {

  						console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

  					}

  				}

  			}

  			// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
  			box.expandByVector( maxDisplacement );

  		}

  		geometry.boundingBox = box;

  		var sphere = new Sphere();

  		box.getCenter( sphere.center );
  		sphere.radius = box.min.distanceTo( box.max ) / 2;

  		geometry.boundingSphere = sphere;

  	}

  	/**
  	 * @param {BufferGeometry} geometry
  	 * @param {GLTF.Primitive} primitiveDef
  	 * @param {GLTFParser} parser
  	 * @return {Promise<BufferGeometry>}
  	 */
  	function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

  		var attributes = primitiveDef.attributes;

  		var pending = [];

  		function assignAttributeAccessor( accessorIndex, attributeName ) {

  			return parser.getDependency( 'accessor', accessorIndex )
  				.then( function ( accessor ) {

  					geometry.setAttribute( attributeName, accessor );

  				} );

  		}

  		for ( var gltfAttributeName in attributes ) {

  			var threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

  			// Skip attributes already provided by e.g. Draco extension.
  			if ( threeAttributeName in geometry.attributes ) continue;

  			pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

  		}

  		if ( primitiveDef.indices !== undefined && ! geometry.index ) {

  			var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

  				geometry.setIndex( accessor );

  			} );

  			pending.push( accessor );

  		}

  		assignExtrasToUserData( geometry, primitiveDef );

  		computeBounds( geometry, primitiveDef, parser );

  		return Promise.all( pending ).then( function () {

  			return primitiveDef.targets !== undefined
  				? addMorphTargets( geometry, primitiveDef.targets, parser )
  				: geometry;

  		} );

  	}

  	/**
  	 * @param {BufferGeometry} geometry
  	 * @param {Number} drawMode
  	 * @return {BufferGeometry}
  	 */
  	function toTrianglesDrawMode( geometry, drawMode ) {

  		var index = geometry.getIndex();

  		// generate index if not present

  		if ( index === null ) {

  			var indices = [];

  			var position = geometry.getAttribute( 'position' );

  			if ( position !== undefined ) {

  				for ( var i = 0; i < position.count; i ++ ) {

  					indices.push( i );

  				}

  				geometry.setIndex( indices );
  				index = geometry.getIndex();

  			} else {

  				console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
  				return geometry;

  			}

  		}

  		//

  		var numberOfTriangles = index.count - 2;
  		var newIndices = [];

  		if ( drawMode === TriangleFanDrawMode ) {

  			// gl.TRIANGLE_FAN

  			for ( var i = 1; i <= numberOfTriangles; i ++ ) {

  				newIndices.push( index.getX( 0 ) );
  				newIndices.push( index.getX( i ) );
  				newIndices.push( index.getX( i + 1 ) );

  			}

  		} else {

  			// gl.TRIANGLE_STRIP

  			for ( var i = 0; i < numberOfTriangles; i ++ ) {

  				if ( i % 2 === 0 ) {

  					newIndices.push( index.getX( i ) );
  					newIndices.push( index.getX( i + 1 ) );
  					newIndices.push( index.getX( i + 2 ) );


  				} else {

  					newIndices.push( index.getX( i + 2 ) );
  					newIndices.push( index.getX( i + 1 ) );
  					newIndices.push( index.getX( i ) );

  				}

  			}

  		}

  		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

  			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

  		}

  		// build final geometry

  		var newGeometry = geometry.clone();
  		newGeometry.setIndex( newIndices );

  		return newGeometry;

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
  	 *
  	 * Creates BufferGeometries from primitives.
  	 *
  	 * @param {Array<GLTF.Primitive>} primitives
  	 * @return {Promise<Array<BufferGeometry>>}
  	 */
  	GLTFParser.prototype.loadGeometries = function ( primitives ) {

  		var parser = this;
  		var extensions = this.extensions;
  		var cache = this.primitiveCache;

  		function createDracoPrimitive( primitive ) {

  			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
  				.decodePrimitive( primitive, parser )
  				.then( function ( geometry ) {

  					return addPrimitiveAttributes( geometry, primitive, parser );

  				} );

  		}

  		var pending = [];

  		for ( var i = 0, il = primitives.length; i < il; i ++ ) {

  			var primitive = primitives[ i ];
  			var cacheKey = createPrimitiveKey( primitive );

  			// See if we've already created this geometry
  			var cached = cache[ cacheKey ];

  			if ( cached ) {

  				// Use the cached geometry if it exists
  				pending.push( cached.promise );

  			} else {

  				var geometryPromise;

  				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

  					// Use DRACO geometry if available
  					geometryPromise = createDracoPrimitive( primitive );

  				} else {

  					// Otherwise create a new geometry
  					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

  				}

  				// Cache this geometry
  				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

  				pending.push( geometryPromise );

  			}

  		}

  		return Promise.all( pending );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
  	 * @param {number} meshIndex
  	 * @return {Promise<Group|Mesh|SkinnedMesh>}
  	 */
  	GLTFParser.prototype.loadMesh = function ( meshIndex ) {

  		var parser = this;
  		var json = this.json;

  		var meshDef = json.meshes[ meshIndex ];
  		var primitives = meshDef.primitives;

  		var pending = [];

  		for ( var i = 0, il = primitives.length; i < il; i ++ ) {

  			var material = primitives[ i ].material === undefined
  				? createDefaultMaterial( this.cache )
  				: this.getDependency( 'material', primitives[ i ].material );

  			pending.push( material );

  		}

  		pending.push( parser.loadGeometries( primitives ) );

  		return Promise.all( pending ).then( function ( results ) {

  			var materials = results.slice( 0, results.length - 1 );
  			var geometries = results[ results.length - 1 ];

  			var meshes = [];

  			for ( var i = 0, il = geometries.length; i < il; i ++ ) {

  				var geometry = geometries[ i ];
  				var primitive = primitives[ i ];

  				// 1. create Mesh

  				var mesh;

  				var material = materials[ i ];

  				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
  					primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
  					primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
  					primitive.mode === undefined ) {

  					// .isSkinnedMesh isn't in glTF spec. See .markDefs()
  					mesh = meshDef.isSkinnedMesh === true
  						? new SkinnedMesh( geometry, material )
  						: new Mesh( geometry, material );

  					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

  						// we normalize floating point skin weight array to fix malformed assets (see #15319)
  						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
  						mesh.normalizeSkinWeights();

  					}

  					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

  						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

  					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

  						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

  					}

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

  					mesh = new LineSegments( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

  					mesh = new Line( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

  					mesh = new LineLoop( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

  					mesh = new Points( geometry, material );

  				} else {

  					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

  				}

  				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

  					updateMorphTargets( mesh, meshDef );

  				}

  				mesh.name = meshDef.name || ( 'mesh_' + meshIndex );

  				if ( geometries.length > 1 ) mesh.name += '_' + i;

  				assignExtrasToUserData( mesh, meshDef );

  				parser.assignFinalMaterial( mesh );

  				meshes.push( mesh );

  			}

  			if ( meshes.length === 1 ) {

  				return meshes[ 0 ];

  			}

  			var group = new Group();

  			for ( var i = 0, il = meshes.length; i < il; i ++ ) {

  				group.add( meshes[ i ] );

  			}

  			return group;

  		} );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
  	 * @param {number} cameraIndex
  	 * @return {Promise<THREE.Camera>}
  	 */
  	GLTFParser.prototype.loadCamera = function ( cameraIndex ) {

  		var camera;
  		var cameraDef = this.json.cameras[ cameraIndex ];
  		var params = cameraDef[ cameraDef.type ];

  		if ( ! params ) {

  			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
  			return;

  		}

  		if ( cameraDef.type === 'perspective' ) {

  			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

  		} else if ( cameraDef.type === 'orthographic' ) {

  			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

  		}

  		if ( cameraDef.name ) camera.name = cameraDef.name;

  		assignExtrasToUserData( camera, cameraDef );

  		return Promise.resolve( camera );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
  	 * @param {number} skinIndex
  	 * @return {Promise<Object>}
  	 */
  	GLTFParser.prototype.loadSkin = function ( skinIndex ) {

  		var skinDef = this.json.skins[ skinIndex ];

  		var skinEntry = { joints: skinDef.joints };

  		if ( skinDef.inverseBindMatrices === undefined ) {

  			return Promise.resolve( skinEntry );

  		}

  		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

  			skinEntry.inverseBindMatrices = accessor;

  			return skinEntry;

  		} );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
  	 * @param {number} animationIndex
  	 * @return {Promise<AnimationClip>}
  	 */
  	GLTFParser.prototype.loadAnimation = function ( animationIndex ) {

  		var json = this.json;

  		var animationDef = json.animations[ animationIndex ];

  		var pendingNodes = [];
  		var pendingInputAccessors = [];
  		var pendingOutputAccessors = [];
  		var pendingSamplers = [];
  		var pendingTargets = [];

  		for ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {

  			var channel = animationDef.channels[ i ];
  			var sampler = animationDef.samplers[ channel.sampler ];
  			var target = channel.target;
  			var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
  			var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
  			var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

  			pendingNodes.push( this.getDependency( 'node', name ) );
  			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
  			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
  			pendingSamplers.push( sampler );
  			pendingTargets.push( target );

  		}

  		return Promise.all( [

  			Promise.all( pendingNodes ),
  			Promise.all( pendingInputAccessors ),
  			Promise.all( pendingOutputAccessors ),
  			Promise.all( pendingSamplers ),
  			Promise.all( pendingTargets )

  		] ).then( function ( dependencies ) {

  			var nodes = dependencies[ 0 ];
  			var inputAccessors = dependencies[ 1 ];
  			var outputAccessors = dependencies[ 2 ];
  			var samplers = dependencies[ 3 ];
  			var targets = dependencies[ 4 ];

  			var tracks = [];

  			for ( var i = 0, il = nodes.length; i < il; i ++ ) {

  				var node = nodes[ i ];
  				var inputAccessor = inputAccessors[ i ];
  				var outputAccessor = outputAccessors[ i ];
  				var sampler = samplers[ i ];
  				var target = targets[ i ];

  				if ( node === undefined ) continue;

  				node.updateMatrix();
  				node.matrixAutoUpdate = true;

  				var TypedKeyframeTrack;

  				switch ( PATH_PROPERTIES[ target.path ] ) {

  					case PATH_PROPERTIES.weights:

  						TypedKeyframeTrack = NumberKeyframeTrack;
  						break;

  					case PATH_PROPERTIES.rotation:

  						TypedKeyframeTrack = QuaternionKeyframeTrack;
  						break;

  					case PATH_PROPERTIES.position:
  					case PATH_PROPERTIES.scale:
  					default:

  						TypedKeyframeTrack = VectorKeyframeTrack;
  						break;

  				}

  				var targetName = node.name ? node.name : node.uuid;

  				var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

  				var targetNames = [];

  				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

  					// Node may be a Group (glTF mesh with several primitives) or a Mesh.
  					node.traverse( function ( object ) {

  						if ( object.isMesh === true && object.morphTargetInfluences ) {

  							targetNames.push( object.name ? object.name : object.uuid );

  						}

  					} );

  				} else {

  					targetNames.push( targetName );

  				}

  				var outputArray = outputAccessor.array;

  				if ( outputAccessor.normalized ) {

  					var scale;

  					if ( outputArray.constructor === Int8Array ) {

  						scale = 1 / 127;

  					} else if ( outputArray.constructor === Uint8Array ) {

  						scale = 1 / 255;

  					} else if ( outputArray.constructor == Int16Array ) {

  						scale = 1 / 32767;

  					} else if ( outputArray.constructor === Uint16Array ) {

  						scale = 1 / 65535;

  					} else {

  						throw new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );

  					}

  					var scaled = new Float32Array( outputArray.length );

  					for ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {

  						scaled[ j ] = outputArray[ j ] * scale;

  					}

  					outputArray = scaled;

  				}

  				for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {

  					var track = new TypedKeyframeTrack(
  						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
  						inputAccessor.array,
  						outputArray,
  						interpolation
  					);

  					// Override interpolation with custom factory method.
  					if ( sampler.interpolation === 'CUBICSPLINE' ) {

  						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

  							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
  							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
  							// must be divided by three to get the interpolant's sampleSize argument.

  							return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

  						};

  						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
  						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

  					}

  					tracks.push( track );

  				}

  			}

  			var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

  			return new AnimationClip( name, undefined, tracks );

  		} );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
  	 * @param {number} nodeIndex
  	 * @return {Promise<Object3D>}
  	 */
  	GLTFParser.prototype.loadNode = function ( nodeIndex ) {

  		var json = this.json;
  		var extensions = this.extensions;
  		var parser = this;

  		var meshReferences = json.meshReferences;
  		var meshUses = json.meshUses;

  		var nodeDef = json.nodes[ nodeIndex ];

  		return ( function () {

  			var pending = [];

  			if ( nodeDef.mesh !== undefined ) {

  				pending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

  					var node;

  					if ( meshReferences[ nodeDef.mesh ] > 1 ) {

  						var instanceNum = meshUses[ nodeDef.mesh ] ++;

  						node = mesh.clone();
  						node.name += '_instance_' + instanceNum;

  					} else {

  						node = mesh;

  					}

  					// if weights are provided on the node, override weights on the mesh.
  					if ( nodeDef.weights !== undefined ) {

  						node.traverse( function ( o ) {

  							if ( ! o.isMesh ) return;

  							for ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

  								o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

  							}

  						} );

  					}

  					return node;

  				} ) );

  			}

  			if ( nodeDef.camera !== undefined ) {

  				pending.push( parser.getDependency( 'camera', nodeDef.camera ) );

  			}

  			if ( nodeDef.extensions
  				&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]
  				&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {

  				pending.push( parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ) );

  			}

  			return Promise.all( pending );

  		}() ).then( function ( objects ) {

  			var node;

  			// .isBone isn't in glTF spec. See .markDefs
  			if ( nodeDef.isBone === true ) {

  				node = new Bone();

  			} else if ( objects.length > 1 ) {

  				node = new Group();

  			} else if ( objects.length === 1 ) {

  				node = objects[ 0 ];

  			} else {

  				node = new Object3D();

  			}

  			if ( node !== objects[ 0 ] ) {

  				for ( var i = 0, il = objects.length; i < il; i ++ ) {

  					node.add( objects[ i ] );

  				}

  			}

  			if ( nodeDef.name ) {

  				node.userData.name = nodeDef.name;
  				node.name = PropertyBinding.sanitizeNodeName( nodeDef.name );

  			}

  			assignExtrasToUserData( node, nodeDef );

  			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

  			if ( nodeDef.matrix !== undefined ) {

  				var matrix = new Matrix4();
  				matrix.fromArray( nodeDef.matrix );
  				node.applyMatrix4( matrix );

  			} else {

  				if ( nodeDef.translation !== undefined ) {

  					node.position.fromArray( nodeDef.translation );

  				}

  				if ( nodeDef.rotation !== undefined ) {

  					node.quaternion.fromArray( nodeDef.rotation );

  				}

  				if ( nodeDef.scale !== undefined ) {

  					node.scale.fromArray( nodeDef.scale );

  				}

  			}

  			parser.associations.set( node, { type: 'nodes', index: nodeIndex } );

  			return node;

  		} );

  	};

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
  	 * @param {number} sceneIndex
  	 * @return {Promise<Group>}
  	 */
  	GLTFParser.prototype.loadScene = function () {

  		// scene node hierachy builder

  		function buildNodeHierachy( nodeId, parentObject, json, parser ) {

  			var nodeDef = json.nodes[ nodeId ];

  			return parser.getDependency( 'node', nodeId ).then( function ( node ) {

  				if ( nodeDef.skin === undefined ) return node;

  				// build skeleton here as well

  				var skinEntry;

  				return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

  					skinEntry = skin;

  					var pendingJoints = [];

  					for ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

  						pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

  					}

  					return Promise.all( pendingJoints );

  				} ).then( function ( jointNodes ) {

  					node.traverse( function ( mesh ) {

  						if ( ! mesh.isMesh ) return;

  						var bones = [];
  						var boneInverses = [];

  						for ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {

  							var jointNode = jointNodes[ j ];

  							if ( jointNode ) {

  								bones.push( jointNode );

  								var mat = new Matrix4();

  								if ( skinEntry.inverseBindMatrices !== undefined ) {

  									mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

  								}

  								boneInverses.push( mat );

  							} else {

  								console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

  							}

  						}

  						mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

  					} );

  					return node;

  				} );

  			} ).then( function ( node ) {

  				// build node hierachy

  				parentObject.add( node );

  				var pending = [];

  				if ( nodeDef.children ) {

  					var children = nodeDef.children;

  					for ( var i = 0, il = children.length; i < il; i ++ ) {

  						var child = children[ i ];
  						pending.push( buildNodeHierachy( child, node, json, parser ) );

  					}

  				}

  				return Promise.all( pending );

  			} );

  		}

  		return function loadScene( sceneIndex ) {

  			var json = this.json;
  			var extensions = this.extensions;
  			var sceneDef = this.json.scenes[ sceneIndex ];
  			var parser = this;

  			// Loader returns Group, not Scene.
  			// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
  			var scene = new Group();
  			if ( sceneDef.name ) scene.name = sceneDef.name;

  			assignExtrasToUserData( scene, sceneDef );

  			if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

  			var nodeIds = sceneDef.nodes || [];

  			var pending = [];

  			for ( var i = 0, il = nodeIds.length; i < il; i ++ ) {

  				pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

  			}

  			return Promise.all( pending ).then( function () {

  				return scene;

  			} );

  		};

  	}();

  	return GLTFLoader;

  } )();

  /**
   * An Item is an abstract entity for all things placed in the scene, e.g. at
   * walls or on the floor.
   */
  var Item = function (_Mesh) {
      inherits(Item, _Mesh);

      /**
       * Constructs an item.
       *
       * @param model
       *            TODO
       * @param metadata
       *            TODO
       * @param geometry
       *            TODO
       * @param material
       *            TODO
       * @param position
       *            TODO
       * @param rotation
       *            TODO
       * @param scale
       *            TODO
       */
      function Item(model, metadata, geometry, material, position, rotation, scale, loaded_gltf_entity) {
          classCallCheck(this, Item);

          var _this = possibleConstructorReturn(this, (Item.__proto__ || Object.getPrototypeOf(Item)).call(this));

          _this.model = model;
          _this.metadata = metadata;

          /** */
          _this.errorGlow = new Mesh();
          /** */
          _this.hover = false;
          /** */
          _this.selected = false;
          /** */
          _this.highlighted = false;
          /** */
          _this.error = false;
          /** */
          _this.emissiveColor = 0x444444;
          /** Does this object affect other floor items */
          _this.obstructFloorMoves = true;
          /** */
          _this.position_set = false;
          /** Show rotate option in context menu */
          _this.allowRotate = true;
          /** */
          _this.fixed = false;
          /** dragging */
          _this.dragOffset = new Vector3();
          /** */
          _this.halfSize = new Vector3(0, 0, 0);
          _this.bhelper = null;

          _this.scene = _this.model.scene;
          _this._freePosition = true;

          _this.geometry = geometry;
          _this.material = material;
          // center in its boundingbox
          _this.geometry.computeBoundingBox();
          _this.geometry.applyMatrix(new Matrix4().makeTranslation(-0.5 * (_this.geometry.boundingBox.max.x + _this.geometry.boundingBox.min.x), -0.5 * (_this.geometry.boundingBox.max.y + _this.geometry.boundingBox.min.y), -0.5 * (_this.geometry.boundingBox.max.z + _this.geometry.boundingBox.min.z)));
          _this.geometry.computeBoundingBox();

          /**\
           * How to create keyframe states for S6Viewer using Blender?
           * Store each animation into the Blender's action editor with a name
           * Give the appropriate name in the floorplan json in the 'frame' for each item
           * 
           */

          var mixer = new AnimationMixer(_this._loadedgltfobject.scene);
          var clips = loaded_gltf_entity.animations;
          if (clips != undefined) {
              if (clips.length) {
                  // clips.forEach((clip) => {
                  //     console.log(clip);
                  //     console.log(clip.name, clip.duration);
                  //     // mixer.clipAction(clip).play();
                  // });
                  var frame = _this.metadata.frame;
                  var clip = AnimationClip.findByName(clips, frame);
                  if (clip != undefined && clip != null) {
                      mixer.clipAction(clip).play();
                      mixer.update(0.0);
                  }
              }
          }
          _this.add(_this._loadedgltfobject.scene);

          if (!_this.material.color) {
              _this.material.color = new Color('#FFFFFF');
          }
          _this.wirematerial = new MeshBasicMaterial({ color: 0x000000, wireframe: true });

          _this.errorColor = 0xff0000;

          _this.resizable = metadata.resizable;

          _this.castShadow = true;
          _this.receiveShadow = false;

          _this.originalmaterial = material;
          _this.texture = _this.material.texture;

          _this.position_set = false;
          if (position) {
              _this.position.copy(position);
              _this.position_set = true;
          }

          _this.halfSize = _this.objectHalfSize();
          _this.canvasWH = document.createElement('canvas');
          _this.canvasWH.width = _this.getWidth() + 1.0;
          _this.canvasWH.height = _this.getHeight() + 1.0;

          _this.canvascontextWH = _this.canvasWH.getContext('2d');
          _this.canvasTextureWH = new CanvasTexture(_this.canvasWH);
          _this.canvasMaterialWH = new MeshBasicMaterial({ map: _this.canvasTextureWH, side: DoubleSide, transparent: true });
          _this.canvasPlaneWH = new Mesh(new PlaneGeometry(_this.getWidth(), _this.getHeight(), 1, 1), _this.canvasMaterialWH);
          _this.canvasPlaneWH.scale.set(1, 1, 1);
          _this.canvasPlaneWH.position.set(0, 0, _this.getDepth() * 0.5 + 0.3);

          _this.canvasWD = document.createElement('canvas');
          _this.canvasWD.width = _this.getWidth() + 1.0;
          _this.canvasWD.height = _this.getDepth() + 1.0;

          _this.canvascontextWD = _this.canvasWD.getContext('2d');
          _this.canvasTextureWD = new CanvasTexture(_this.canvasWD);
          _this.canvasMaterialWD = new MeshBasicMaterial({ map: _this.canvasTextureWD, side: DoubleSide, transparent: true });
          _this.canvasPlaneWD = new Mesh(new PlaneGeometry(_this.getWidth(), _this.getDepth(), 1, 1), _this.canvasMaterialWD);
          _this.canvasPlaneWD.rotateX(-Math.PI * 0.5);
          _this.canvasPlaneWD.scale.set(1, 1, 1);
          _this.canvasPlaneWD.position.set(0, _this.getHeight() * 0.5 + 0.3, 0);
          _this.canvasPlaneWH.visible = _this.canvasPlaneWD.visible = false;

          _this.add(_this.canvasPlaneWH);
          _this.add(_this.canvasPlaneWD);
          _this.resizeProportionally = true;

          if (rotation) {
              _this.rotation.y = rotation;
          }

          if (scale != null) {
              _this.setScale(scale.x, scale.y, scale.z);
          }

          if (_this.metadata.materialColors) {
              if (_this.metadata.materialColors.length) {
                  if (_this.material.length) {
                      for (var i = 0; i < _this.metadata.materialColors.length; i++) {
                          _this.material[i].color = new Color(_this.metadata.materialColors[i]);
                      }
                  } else {
                      _this.material.color = new Color(_this.metadata.materialColors[0]);
                  }
              }
          }
          return _this;
      }

      createClass(Item, [{
          key: 'updateCanvasTexture',
          value: function updateCanvasTexture(canvas, context, material, w, h, wPrefix, hPrefix) {
              if (w < 1 || h < 1) {
                  return;
              }

              wPrefix = wPrefix ? wPrefix : 'w:';
              hPrefix = hPrefix ? hPrefix : 'h:';

              w *= 3;
              h *= 3;

              canvas.width = w;
              canvas.height = h;
              canvas.style.letterSpacing = '-22.5px';

              context.font = 'bold 45pt Courier';
              context.fillStyle = '#DADADA99';
              context.fillRect(0, 0, w, h);
              context.textAlign = 'center';
              context.textBaseline = 'middle';

              context.lineWidth = 3;
              context.setLineDash([1, 2]);
              context.strokeStyle = '#000000';

              context.beginPath();
              context.moveTo(0, h * 0.5);
              context.lineTo(w, h * 0.5);
              context.closePath();
              context.stroke();

              context.beginPath();
              context.moveTo(w * 0.125, 0);
              context.lineTo(w * 0.125, h);
              context.closePath();
              context.stroke();

              context.lineWidth = 1;
              context.setLineDash([0]);
              context.strokeStyle = '#0000FF';
              context.strokeText(wPrefix + Dimensioning.cmToMeasure(w / 3), w * 0.5, h * 0.5);

              context.fillStyle = '#FF0000';
              context.fillText(wPrefix + Dimensioning.cmToMeasure(w / 3), w * 0.5, h * 0.5);

              context.translate(w * 0.125, 0);
              context.rotate(Math.PI * 0.5);
              context.strokeStyle = '#0000FF';
              context.strokeText(hPrefix + Dimensioning.cmToMeasure(h / 3), h * 0.5, 0);

              context.fillStyle = '#FF0000';
              context.fillText(hPrefix + Dimensioning.cmToMeasure(h / 3), h * 0.5, 0);
              context.restore();
              material.map.needsUpdate = true;
          }
      }, {
          key: 'switchWireframe',
          value: function switchWireframe(flag) {
              this.material = flag ? this.wirematerial : this.originalmaterial;
          }

          /** */

      }, {
          key: 'remove',
          value: function remove() {
              this.scene.removeItem(this);
          }

          /** */

      }, {
          key: 'resize',
          value: function resize(height, width, depth) {
              var x = width / this.getWidth();
              var y = height / this.getHeight();
              var z = depth / this.getDepth();

              if (this.resizeProportionally) {
                  if (Math.abs(width - this.getWidth()) > 0.1) {
                      this.setScale(x, x, x);
                  } else if (Math.abs(height - this.getHeight()) > 0.1) {
                      this.setScale(y, y, y);
                  } else {
                      this.setScale(z, z, z);
                  }
                  return;
              }
              this.setScale(x, y, z);
          }
      }, {
          key: 'getMaterial',
          value: function getMaterial() {
              return this.material;
          }
      }, {
          key: 'getMaterialColor',
          value: function getMaterialColor(index) {
              index = index ? index : 0;
              if (this.material.length) {
                  return '#' + this.material[index].color.getHexString();
              }
              return '#' + this.material.color.getHexString();
          }

          // Always send an hexadecimal string value for color - ex. '#FFFFFF'

      }, {
          key: 'setMaterialColor',
          value: function setMaterialColor(color, index) {
              var c = new Color(color);
              if (this.material.length) {
                  index = index ? index : 0;
                  this.material[index].color = c;
                  return;
              }
              this.material.color = c;
          }

          /** */

      }, {
          key: 'setScale',
          value: function setScale(x, y, z) {
              var scaleVec = new Vector3(x, y, z);
              this.halfSize.multiply(scaleVec);
              scaleVec.multiply(this.scale);
              this.scale.set(scaleVec.x, scaleVec.y, scaleVec.z);
              this.resized();
              if (this.bhelper) {
                  this.bhelper.update();
              }

              //		this.updateCanvasTexture(canvas, context, material, w, h);
              this.updateCanvasTexture(this.canvasWH, this.canvascontextWH, this.canvasMaterialWH, this.getWidth(), this.getHeight(), 'w:', 'h:');
              this.updateCanvasTexture(this.canvasWD, this.canvascontextWD, this.canvasMaterialWD, this.getWidth(), this.getDepth(), 'w:', 'd:');

              this.scene.needsUpdate = true;
          }
      }, {
          key: 'getProportionalResize',
          value: function getProportionalResize() {
              return this.resizeProportionally;
          }
      }, {
          key: 'setProportionalResize',
          value: function setProportionalResize(flag) {
              this.resizeProportionally = flag;
          }

          /** */

      }, {
          key: 'setFixed',
          value: function setFixed(fixed) {
              this.fixed = fixed;
          }

          /** Subclass can define to take action after a resize. */

      }, {
          key: 'resized',
          value: function resized() {}

          /** */

      }, {
          key: 'getHeight',
          value: function getHeight() {
              return this.halfSize.y * 2.0;
          }

          /** */

      }, {
          key: 'getWidth',
          value: function getWidth() {
              return this.halfSize.x * 2.0;
          }

          /** */

      }, {
          key: 'getDepth',
          value: function getDepth() {
              return this.halfSize.z * 2.0;
          }

          /** */

      }, {
          key: 'placeInRoom',
          value: function placeInRoom() {}

          /** */

      }, {
          key: 'initObject',
          value: function initObject() {
              this.placeInRoom();
              // An ugly hack to increase the size of gltf models
              if (this.halfSize.x < 1.0) {
                  this.resize(this.getHeight() * 300, this.getWidth() * 300, this.getDepth() * 300);
              }
              this.bhelper = new BoxHelper(this);
              this.scene.add(this.bhelper);
              this.bhelper.visible = false;
              // select and stuff
              this.scene.needsUpdate = true;
          }

          /** */

      }, {
          key: 'removed',
          value: function removed() {}

          /** on is a bool */

      }, {
          key: 'updateHighlight',
          value: function updateHighlight() {
              var _this2 = this;

              var on = this.hover || this.selected;
              this.highlighted = on;
              var hex = on ? this.emissiveColor : 0x000000;
              if (this.material) {
                  if (this.material.length) {
                      this.material.forEach(function (material) {
                          // TODO_Ekki emissive doesn't exist anymore?
                          material.emissive.setHex(hex);
                          _this2.material.emissive = new Color(hex);
                      });
                  } else {
                      this.material.emissive.setHex(hex);
                      this.material.emissive = new Color(hex);
                  }
              }
          }

          /** */

      }, {
          key: 'mouseOver',
          value: function mouseOver() {
              this.hover = true;
              this.updateHighlight();
          }

          /** */

      }, {
          key: 'mouseOff',
          value: function mouseOff() {
              this.hover = false;
              this.updateHighlight();
          }

          /** */

      }, {
          key: 'setSelected',
          value: function setSelected() {
              this.setScale(1, 1, 1);
              this.selected = true;
              this.bhelper.visible = true;
              this.canvasPlaneWH.visible = this.canvasPlaneWD.visible = true;
              this.updateHighlight();
          }

          /** */

      }, {
          key: 'setUnselected',
          value: function setUnselected() {
              this.selected = false;
              this.bhelper.visible = false;
              this.canvasPlaneWH.visible = this.canvasPlaneWD.visible = false;
              this.updateHighlight();
          }

          /** intersection has attributes point (vec3) and object (THREE.Mesh) */

      }, {
          key: 'clickPressed',
          value: function clickPressed(intersection) {
              this.dragOffset.copy(intersection.point).sub(this.position);
          }

          /** */

      }, {
          key: 'clickDragged',
          value: function clickDragged(intersection) {
              if (intersection) {
                  this.moveToPosition(intersection.point.sub(this.dragOffset), intersection);
              }
          }

          /** */

      }, {
          key: 'rotate',
          value: function rotate(intersection) {
              if (intersection) {
                  var angle = Utils.angle(new Vector2(0, 1), new Vector2(intersection.point.x - this.position.x, intersection.point.z - this.position.z));
                  var snapTolerance = Math.PI / 16.0;
                  // snap to intervals near Math.PI/2
                  for (var i = -4; i <= 4; i++) {
                      if (Math.abs(angle - i * (Math.PI / 2)) < snapTolerance) {
                          angle = i * (Math.PI / 2);
                          break;
                      }
                  }
                  this.rotation.y = angle;
              }
          }

          /** */

      }, {
          key: 'moveToPosition',
          value: function moveToPosition(vec3) {
              this.position.copy(vec3);
              if (this.bhelper) {
                  this.bhelper.update();
              }
          }

          /** */

      }, {
          key: 'clickReleased',
          value: function clickReleased() {
              if (this.error) {
                  this.hideError();
              }
          }

          /**
           * Returns an array of planes to use other than the ground plane for passing
           * intersection to clickPressed and clickDragged
           */

      }, {
          key: 'customIntersectionPlanes',
          value: function customIntersectionPlanes() {
              return [];
          }

          /**
           * returns the 2d corners of the bounding polygon
           *
           * offset is Vector3 (used for getting corners of object at a new position)
           *
           * TODO: handle rotated objects better!
           */

      }, {
          key: 'getCorners',
          value: function getCorners(xDim, yDim, position) {
              position = position || this.position;
              var halfSize = this.halfSize.clone();
              var c1 = new Vector3(-halfSize.x, 0, -halfSize.z);
              var c2 = new Vector3(halfSize.x, 0, -halfSize.z);
              var c3 = new Vector3(halfSize.x, 0, halfSize.z);
              var c4 = new Vector3(-halfSize.x, 0, halfSize.z);

              var transform = new Matrix4();
              // console.log(this.rotation.y);
              transform.makeRotationY(this.rotation.y); // + Math.PI/2)

              c1.applyMatrix4(transform);
              c2.applyMatrix4(transform);
              c3.applyMatrix4(transform);
              c4.applyMatrix4(transform);

              c1.add(position);
              c2.add(position);
              c3.add(position);
              c4.add(position);

              // halfSize.applyMatrix4(transform);

              // var min = position.clone().sub(halfSize);
              // var max = position.clone().add(halfSize);

              var corners = [{ x: c1.x, y: c1.z }, { x: c2.x, y: c2.z }, { x: c3.x, y: c3.z }, { x: c4.x, y: c4.z }];
              return corners;
          }

          /** */

      }, {
          key: 'isValidPosition',
          value: function isValidPosition() {
              return false;
          }

          /** */

      }, {
          key: 'showError',
          value: function showError(vec3) {
              vec3 = vec3 || this.position;
              if (!this.error) {
                  this.error = true;
                  this.errorGlow = this.createGlow(this.errorColor, 0.8, true);
                  this.scene.add(this.errorGlow);
              }
              this.errorGlow.position.copy(vec3);
          }

          /** */

      }, {
          key: 'hideError',
          value: function hideError() {
              if (this.error) {
                  this.error = false;
                  this.scene.remove(this.errorGlow);
              }
          }

          /** */

      }, {
          key: 'objectHalfSize',
          value: function objectHalfSize() {
              // var objectBox = new Box3();
              // objectBox.setFromObject(this);
              this.geometry.computeBoundingBox();
              var objectBox = this.geometry.boundingBox.clone();
              return objectBox.max.clone().sub(objectBox.min).divideScalar(2);
          }

          /** */

      }, {
          key: 'createGlow',
          value: function createGlow(color, opacity, ignoreDepth) {
              ignoreDepth = ignoreDepth || false;
              var glowMaterial = new MeshBasicMaterial({ color: color, blending: AdditiveBlending, opacity: 0.2, transparent: true, depthTest: !ignoreDepth });
              var glow = new Mesh(this.geometry.clone(), glowMaterial);
              glow.position.copy(this.position);
              glow.rotation.copy(this.rotation);
              glow.scale.copy(this.scale);
              return glow;
          }
      }, {
          key: 'getMetaData',
          value: function getMetaData() {
              var matattribs = [];
              if (this.material.length) {
                  this.material.forEach(function (mat) {
                      matattribs.push('#' + mat.color.getHexString());
                  });
              } else {
                  matattribs.push('#' + this.material.color.getHexString());
              }
              return {
                  item_name: this.metadata.itemName,
                  item_type: this.metadata.itemType,
                  format: this.metadata.format,
                  model_url: this.metadata.modelUrl,
                  xpos: this.position.x,
                  ypos: this.position.y,
                  zpos: this.position.z,
                  rotation: this.rotation.y,
                  scale_x: this.scale.x,
                  scale_y: this.scale.y,
                  scale_z: this.scale.z,
                  fixed: this.fixed,
                  material_colors: matattribs
              };
          }
      }, {
          key: 'freePosition',
          get: function get() {
              return this._freePosition;
          }
      }]);
      return Item;
  }(Mesh);

  /**
   * A Floor Item is an entity to be placed related to a floor.
   */
  var FloorItem = function (_Item) {
  	inherits(FloorItem, _Item);

  	function FloorItem(model, metadata, geometry, material, position, rotation, scale) {
  		var isgltf = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  		classCallCheck(this, FloorItem);

  		var _this = possibleConstructorReturn(this, (FloorItem.__proto__ || Object.getPrototypeOf(FloorItem)).call(this, model, metadata, geometry, material, position, rotation, scale, isgltf));

  		_this._freePosition = false;
  		return _this;
  	}

  	/** */


  	createClass(FloorItem, [{
  		key: 'placeInRoom',
  		value: function placeInRoom() {
  			if (!this.position_set) {
  				var center = this.model.floorplan.getCenter();
  				this.position.x = center.x;
  				this.position.z = center.z;
  				this.position.y = 0.5 * (this.geometry.boundingBox.max.y - this.geometry.boundingBox.min.y);
  			}
  		}

  		/** Take action after a resize */

  	}, {
  		key: 'resized',
  		value: function resized() {
  			this.position.y = this.halfSize.y;
  		}

  		/** */

  	}, {
  		key: 'moveToPosition',
  		value: function moveToPosition(vec3) {
  			// keeps the position in the room and on the floor
  			if (!this.isValidPosition(vec3)) {
  				this.showError(vec3);
  				return;
  			} else {
  				this.hideError();
  				vec3.y = this.position.y; // keep it on the floor!
  				//			this.position.copy(vec3);
  				get(FloorItem.prototype.__proto__ || Object.getPrototypeOf(FloorItem.prototype), 'moveToPosition', this).call(this, vec3);
  			}
  		}

  		/** */

  	}, {
  		key: 'isValidPosition',
  		value: function isValidPosition(vec3) {
  			var corners = this.getCorners('x', 'z', vec3);
  			// check if we are in a room
  			var rooms = this.model.floorplan.getRooms();
  			var isInARoom = false;
  			for (var i = 0; i < rooms.length; i++) {
  				if (Utils.pointInPolygon(new Vector2(vec3.x, vec3.z), rooms[i].interiorCorners) && !Utils.polygonPolygonIntersect(corners, rooms[i].interiorCorners)) {
  					isInARoom = true;
  				}
  			}
  			if (!isInARoom) {
  				//We do not want to check if the object is in room or not
  				//It is upto the user to place it anywhere he/she wants however
  				//			return false;
  				return true;
  			}

  			// check if we are outside all other objects
  			/*
         if (this.obstructFloorMoves) {
             var objects = this.model.items.getItems();
             for (var i = 0; i < objects.length; i++) {
                 if (objects[i] === this || !objects[i].obstructFloorMoves) {
                     continue;
                 }
                 if (!utils.polygonOutsidePolygon(corners, objects[i].getCorners('x', 'z')) ||
                     utils.polygonPolygonIntersect(corners, objects[i].getCorners('x', 'z'))) {
                     //console.log('object not outside other objects');
                     return false;
                 }
             }
         }*/
  			return true;
  		}
  	}]);
  	return FloorItem;
  }(Item);

  /**
   * A Wall Item is an entity to be placed related to a wall.
   */
  var WallItem = function (_Item) {
  	inherits(WallItem, _Item);

  	function WallItem(model, metadata, geometry, material, position, rotation, scale) {
  		var isgltf = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  		classCallCheck(this, WallItem);

  		/** The currently applied wall edge. */
  		var _this = possibleConstructorReturn(this, (WallItem.__proto__ || Object.getPrototypeOf(WallItem)).call(this, model, metadata, geometry, material, position, rotation, scale, isgltf));

  		_this.currentWallEdge = null;
  		/* TODO:
           This caused a huge headache.
           HalfEdges get destroyed/created every time floorplan is edited.
           This item should store a reference to a wall and front/back,
           and grab its edge reference dynamically whenever it needs it.
     */

  		/** used for finding rotations */
  		_this.refVec = new Vector2(0, 1.0);
  		/** */
  		_this.wallOffsetScalar = 0;
  		/** */
  		_this.sizeX = 0;
  		/** */
  		_this.sizeY = 0;
  		/** */
  		_this.addToWall = false;
  		/** */
  		_this.boundToFloor = false;
  		/** */
  		_this.frontVisible = false;
  		/** */
  		_this.backVisible = false;
  		_this.allowRotate = false;
  		_this._freePosition = false;
  		return _this;
  	}

  	/** Get the closet wall edge.
    * @returns The wall edge.
    */


  	createClass(WallItem, [{
  		key: 'closestWallEdge',
  		value: function closestWallEdge() {
  			var wallEdges = this.model.floorplan.wallEdges();
  			var wallEdge = null;
  			var minDistance = null;
  			var itemX = this.position.x;
  			var itemZ = this.position.z;
  			wallEdges.forEach(function (edge) {
  				var distance = edge.distanceTo(itemX, itemZ);
  				if (minDistance === null || distance < minDistance) {
  					minDistance = distance;
  					wallEdge = edge;
  				}
  			});
  			return wallEdge;
  		}

  		/** */

  	}, {
  		key: 'removed',
  		value: function removed() {
  			if (this.currentWallEdge != null && this.addToWall) {
  				Utils.removeValue(this.currentWallEdge.wall.items, this);
  				this.redrawWall();
  			}
  		}

  		/** */

  	}, {
  		key: 'redrawWall',
  		value: function redrawWall() {
  			if (this.addToWall) {
  				this.currentWallEdge.wall.fireRedraw();
  			}
  		}

  		/** */

  	}, {
  		key: 'updateEdgeVisibility',
  		value: function updateEdgeVisibility(visible, front) {
  			if (front) {
  				this.frontVisible = visible;
  			} else {
  				this.backVisible = visible;
  			}
  			this.visible = this.frontVisible || this.backVisible;
  		}

  		/** */

  	}, {
  		key: 'updateSize',
  		value: function updateSize() {
  			this.wallOffsetScalar = (this.geometry.boundingBox.max.z - this.geometry.boundingBox.min.z) * this.scale.z / 2.0;
  			this.sizeX = (this.geometry.boundingBox.max.x - this.geometry.boundingBox.min.x) * this.scale.x;
  			this.sizeY = (this.geometry.boundingBox.max.y - this.geometry.boundingBox.min.y) * this.scale.y;
  		}

  		/** */

  	}, {
  		key: 'resized',
  		value: function resized() {
  			if (this.boundToFloor) {
  				this.position.y = 0.5 * (this.geometry.boundingBox.max.y - this.geometry.boundingBox.min.y) * this.scale.y + 0.01;
  			}
  			this.updateSize();
  			this.redrawWall();
  		}

  		/** */

  	}, {
  		key: 'placeInRoom',
  		value: function placeInRoom() {
  			var closestWallEdge = this.closestWallEdge();
  			this.changeWallEdge(closestWallEdge);
  			this.updateSize();

  			if (!this.position_set) {
  				// position not set
  				var center = closestWallEdge.interiorCenter();
  				var newPos = new Vector3(center.x, closestWallEdge.wall.height / 2.0, center.y);
  				this.boundMove(newPos);
  				this.position.copy(newPos);
  				this.redrawWall();
  			}
  		}

  		/** */

  	}, {
  		key: 'moveToPosition',
  		value: function moveToPosition(vec3, intersection) {
  			var intersectionEdge = intersection ? intersection.object ? intersection.object.edge : intersection : this.closestWallEdge();
  			this.changeWallEdge(intersectionEdge);
  			this.boundMove(vec3);

  			//		this.position.copy(vec3);
  			get(WallItem.prototype.__proto__ || Object.getPrototypeOf(WallItem.prototype), 'moveToPosition', this).call(this, vec3);
  			this.redrawWall();
  		}

  		/** */

  	}, {
  		key: 'getWallOffset',
  		value: function getWallOffset() {
  			return this.wallOffsetScalar;
  		}

  		/** */

  	}, {
  		key: 'changeWallEdge',
  		value: function changeWallEdge(wallEdge) {
  			if (this.currentWallEdge != null) {
  				if (this.addToWall) {
  					Utils.removeValue(this.currentWallEdge.wall.items, this);
  					this.redrawWall();
  				} else {
  					Utils.removeValue(this.currentWallEdge.wall.onItems, this);
  				}
  			}

  			var scope = this;

  			function __remove(event) {
  				scope.remove(event.item);
  			}

  			// handle subscription to wall being removed
  			if (this.currentWallEdge != null) {
  				//			this.currentWallEdge.wall.dontFireOnDelete(this.remove.bind(this));
  				this.currentWallEdge.wall.removeEventListener(EVENT_DELETED, __remove);
  			}
  			//		wallEdge.wall.fireOnDelete(this.remove.bind(this));
  			wallEdge.wall.addEventListener(EVENT_DELETED, __remove);

  			// find angle between wall normals
  			var normal2 = new Vector2();
  			var normal3 = wallEdge.plane.geometry.faces[0].normal;
  			normal2.x = normal3.x;
  			normal2.y = normal3.z;

  			var angle = Utils.angle(new Vector2(this.refVec.x, this.refVec.y), new Vector2(normal2.x, normal2.y));
  			this.rotation.y = angle;
  			// update currentWall
  			this.currentWallEdge = wallEdge;
  			if (this.addToWall) {
  				wallEdge.wall.items.push(this);
  				this.redrawWall();
  			} else {
  				wallEdge.wall.onItems.push(this);
  			}
  		}

  		/** Returns an array of planes to use other than the ground plane
     * for passing intersection to clickPressed and clickDragged */

  	}, {
  		key: 'customIntersectionPlanes',
  		value: function customIntersectionPlanes() {
  			return this.model.floorplan.wallEdgePlanes();
  		}

  		/** takes the move vec3, and makes sure object stays bounded on plane */

  	}, {
  		key: 'boundMove',
  		value: function boundMove(vec3) {
  			var tolerance = 1;
  			var edge = this.currentWallEdge;
  			vec3.applyMatrix4(edge.interiorTransform);
  			if (vec3.x < this.sizeX / 2.0 + tolerance) {
  				vec3.x = this.sizeX / 2.0 + tolerance;
  			} else if (vec3.x > edge.interiorDistance() - this.sizeX / 2.0 - tolerance) {
  				vec3.x = edge.interiorDistance() - this.sizeX / 2.0 - tolerance;
  			}

  			if (this.boundToFloor) {
  				vec3.y = 0.5 * (this.geometry.boundingBox.max.y - this.geometry.boundingBox.min.y) * this.scale.y + 0.01;
  			} else {
  				if (vec3.y < this.sizeY / 2.0 + tolerance) {
  					vec3.y = this.sizeY / 2.0 + tolerance;
  				}
  				//Commenting the below condition where it will restrict the movement of the item to an uniform height
  				//			else if (vec3.y > edge.height - this.sizeY / 2.0 - tolerance)
  				//			{
  				//				vec3.y = edge.height - this.sizeY / 2.0 - tolerance;
  				//			}
  			}
  			vec3.z = this.getWallOffset();
  			vec3.applyMatrix4(edge.invInteriorTransform);
  		}
  	}]);
  	return WallItem;
  }(Item);

  /// <reference path="../../lib/three.d.ts" />
  /** */
  var InWallItem = function (_WallItem) {
  	inherits(InWallItem, _WallItem);

  	function InWallItem(model, metadata, geometry, material, position, rotation, scale) {
  		var isgltf = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  		classCallCheck(this, InWallItem);

  		var _this = possibleConstructorReturn(this, (InWallItem.__proto__ || Object.getPrototypeOf(InWallItem)).call(this, model, metadata, geometry, material, position, rotation, scale, isgltf));

  		_this.addToWall = true;
  		return _this;
  	}

  	/** */


  	createClass(InWallItem, [{
  		key: 'getWallOffset',
  		value: function getWallOffset() {
  			// fudge factor so it saves to the right wall
  			return -this.currentWallEdge.offset + 0.5;
  		}
  	}]);
  	return InWallItem;
  }(WallItem);

  /// <reference path="../../lib/three.d.ts" />

  /** */
  var InWallFloorItem = function (_InWallItem) {
  	inherits(InWallFloorItem, _InWallItem);

  	function InWallFloorItem(model, metadata, geometry, material, position, rotation, scale) {
  		var isgltf = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  		classCallCheck(this, InWallFloorItem);

  		var _this = possibleConstructorReturn(this, (InWallFloorItem.__proto__ || Object.getPrototypeOf(InWallFloorItem)).call(this, model, metadata, geometry, material, position, rotation, scale, isgltf));

  		_this.boundToFloor = true;
  		return _this;
  	}

  	return InWallFloorItem;
  }(InWallItem);

  /// <reference path="../../lib/three.d.ts" />
  /// <reference path="../model/model.ts" />
  /// <reference path="floor_item.ts" />
  /// <reference path="metadata.ts" />

  /** */
  var OnFloorItem = function (_FloorItem) {
  	inherits(OnFloorItem, _FloorItem);

  	function OnFloorItem(model, metadata, geometry, material, position, rotation, scale) {
  		var isgltf = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  		classCallCheck(this, OnFloorItem);

  		var _this = possibleConstructorReturn(this, (OnFloorItem.__proto__ || Object.getPrototypeOf(OnFloorItem)).call(this, model, metadata, geometry, material, position, rotation, scale, isgltf));

  		_this.obstructFloorMoves = false;
  		_this.receiveShadow = true;
  		return _this;
  	}

  	return OnFloorItem;
  }(FloorItem);

  /// <reference path="../../lib/three.d.ts" />
  /// <reference path="../model/model.ts" />
  /// <reference path="wall_item.ts" />
  /// <reference path="metadata.ts" />
  /** */
  var WallFloorItem = function (_WallItem) {
  	inherits(WallFloorItem, _WallItem);

  	function WallFloorItem(model, metadata, geometry, material, position, rotation, scale) {
  		var isgltf = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  		classCallCheck(this, WallFloorItem);

  		var _this = possibleConstructorReturn(this, (WallFloorItem.__proto__ || Object.getPrototypeOf(WallFloorItem)).call(this, model, metadata, geometry, material, position, rotation, scale, isgltf));

  		_this.boundToFloor = true;
  		return _this;
  	}

  	return WallFloorItem;
  }(WallItem);

  /**
   * A Floor Item is an entity to be placed related to a floor.
   */
  var RoofItem = function (_Item) {
  	inherits(RoofItem, _Item);

  	function RoofItem(model, metadata, geometry, material, position, rotation, scale) {
  		var isgltf = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  		classCallCheck(this, RoofItem);

  		var _this = possibleConstructorReturn(this, (RoofItem.__proto__ || Object.getPrototypeOf(RoofItem)).call(this, model, metadata, geometry, material, position, rotation, scale, isgltf));

  		_this.allowRotate = false;
  		_this.boundToFloor = false;
  		_this._freePosition = false;
  		if (_this.geometry) {
  			_this.geometry.applyMatrix(new Matrix4().makeTranslation(-0.5 * (_this.geometry.boundingBox.max.x + _this.geometry.boundingBox.min.x), -0.5 * (_this.geometry.boundingBox.max.y - _this.geometry.boundingBox.min.y), -0.5 * (_this.geometry.boundingBox.max.z + _this.geometry.boundingBox.min.z)));
  			_this.geometry.computeBoundingBox();
  		}
  		_this.halfSize = _this.objectHalfSize();
  		_this.canvasPlaneWH.position.set(0, _this.getHeight() * -0.5, _this.getDepth() * 0.5);
  		_this.canvasPlaneWD.position.set(0, -_this.getHeight(), 0);

  		var co = _this.closestCeilingPoint();
  		_this.moveToPosition(co);
  		return _this;
  	}

  	/** Returns an array of planes to use other than the ground plane
    * for passing intersection to clickPressed and clickDragged */


  	createClass(RoofItem, [{
  		key: 'customIntersectionPlanes',
  		value: function customIntersectionPlanes() {
  			return this.model.floorplan.roofPlanes();
  		}
  	}, {
  		key: 'roofContainsPoint',
  		value: function roofContainsPoint(roof, forpoint) {
  			var g = roof.geometry;
  			var result = { distance: Number.MAX_VALUE, contains: false, point: null, closestPoint: null };
  			var closestPoint = null;
  			for (var i = 0; i < g.faces.length; i++) {
  				var f = g.faces[i];
  				var plane = new Plane();
  				var triangle = new Triangle(g.vertices[f.a], g.vertices[f.b], g.vertices[f.c]);
  				var ipoint = new Vector3();
  				var cpoint = new Vector3();
  				var contains = false;
  				var distance = 0.0;
  				closestPoint = triangle.closestPointToPoint(forpoint, cpoint);
  				triangle.getPlane(plane);
  				plane.projectPoint(forpoint, ipoint);
  				contains = triangle.containsPoint(ipoint);
  				distance = plane.distanceToPoint(forpoint);
  				if (distance < result.distance && contains) {
  					result.distance = distance;
  					result.contains = contains;
  					result.point = ipoint;
  					result.closestPoint = closestPoint.clone();
  				}
  			}
  			//No good result so return the closest point of the last triangle in this roof mesh
  			if (result.point == null) {
  				result.closestPoint = closestPoint.clone();
  			}

  			return result;
  		}
  	}, {
  		key: 'closestCeilingPoint',
  		value: function closestCeilingPoint() {
  			var roofs = this.model.floorplan.roofPlanes();
  			var roof = null;
  			var globalResult = { distance: Number.MAX_VALUE, point: null };
  			var result = null;
  			for (var i = 0; i < roofs.length; i++) {
  				roof = roofs[i];
  				result = this.roofContainsPoint(roof, this.position);
  				if (result.point != null && result.distance < globalResult.distance && result.contains) {
  					globalResult.distance = result.distance;
  					globalResult.point = result.point.clone();
  				}
  			}
  			//No good results so assign the closestPoint of the last roof in the above iteration
  			if (globalResult.point == null) {
  				return result.closestPoint.clone();
  			}
  			return globalResult.point.clone();
  		}

  		/** */

  	}, {
  		key: 'placeInRoom',
  		value: function placeInRoom() {
  			if (!this.position_set) {
  				var co = this.closestCeilingPoint();
  				this.moveToPosition(co);
  			}
  		}
  	}]);
  	return RoofItem;
  }(Item);

  var item_types = { 1: FloorItem, 2: WallItem, 3: InWallItem, 7: InWallFloorItem, 8: OnFloorItem, 9: WallFloorItem, 0: Item, 4: RoofItem };

  /** Factory class to create items. */
  var Factory = function () {
  	function Factory() {
  		classCallCheck(this, Factory);
  	}

  	createClass(Factory, null, [{
  		key: 'getClass',

  		/** Gets the class for the specified item. */
  		value: function getClass(itemType) {
  			return item_types[itemType];
  		}
  	}]);
  	return Factory;
  }();

  /**
   * The Scene is a manager of Items and also links to a ThreeJS scene.
   */
  var Scene$1 = function (_EventDispatcher) {
      inherits(Scene$1, _EventDispatcher);

      /**
       * Constructs a scene.
       * @param model The associated model.
       * @param textureDir The directory from which to load the textures.
       */
      function Scene$1(model, textureDir) {
          classCallCheck(this, Scene$1);

          var _this = possibleConstructorReturn(this, (Scene$1.__proto__ || Object.getPrototypeOf(Scene$1)).call(this));

          _this.model = model;
          _this.textureDir = textureDir;

          //		var grid = new GridHelper(4000, 200);

          _this.scene = new Scene();
          _this.scene.background = new Color(0xffffff);
          //		this.scene.fog = new Fog(0xFAFAFA, 0.001, 6000);
          _this.items = [];
          _this.needsUpdate = false;
          // init item loader
          // this.loader = new JSONLoader();
          // this.loader.setCrossOrigin('');

          _this.gltfloader = new GLTFLoader();
          // this.gltfloader.setCrossOrigin('');
          //		this.add(grid);

          return _this;
      }

      /** Adds a non-item, basically a mesh, to the scene.
       * @param mesh The mesh to be added.
       */


      createClass(Scene$1, [{
          key: 'add',
          value: function add(mesh) {
              this.scene.add(mesh);
          }

          /** Removes a non-item, basically a mesh, from the scene.
           * @param mesh The mesh to be removed.
           */

      }, {
          key: 'remove',
          value: function remove(mesh) {
              this.scene.remove(mesh);
              Utils.removeValue(this.items, mesh);
          }

          /** Gets the scene.
           * @returns The scene.
           */

      }, {
          key: 'getScene',
          value: function getScene() {
              return this.scene;
          }

          /** Gets the items.
           * @returns The items.
           */

      }, {
          key: 'getItems',
          value: function getItems() {
              return this.items;
          }

          /** Gets the count of items.
           * @returns The count.
           */

      }, {
          key: 'itemCount',
          value: function itemCount() {
              return this.items.length;
          }

          /** Removes all items. */

      }, {
          key: 'clearItems',
          value: function clearItems() {
              // var items_copy = this.items ;
              var scope = this;
              this.items.forEach(function (item) {
                  scope.removeItem(item, true);
              });
              this.items = [];
          }

          /**
           * Removes an item.
           * @param item The item to be removed.
           * @param dontRemove If not set, also remove the item from the items list.
           */

      }, {
          key: 'removeItem',
          value: function removeItem(item, keepInList) {
              keepInList = keepInList || false;
              // use this for item meshes
              this.dispatchEvent({ type: EVENT_ITEM_REMOVED, item: item });
              //this.itemRemovedCallbacks.fire(item);
              item.removed();
              this.scene.remove(item);
              if (!keepInList) {
                  Utils.removeValue(this.items, item);
              }
          }
      }, {
          key: 'switchWireframe',
          value: function switchWireframe(flag) {
              this.items.forEach(function (item) {
                  item.switchWireframe(flag);
              });
          }

          /**
           * Creates an item and adds it to the scene.
           * @param itemType The type of the item given by an enumerator.
           * @param fileName The name of the file to load.
           * @param metadata TODO
           * @param position The initial position.
           * @param rotation The initial rotation around the y axis.
           * @param scale The initial scaling.
           * @param fixed True if fixed.
           * @param newItemDefinitions - Object with position and 'edge' attribute if it is a wall item
           */

      }, {
          key: 'addItem',
          value: function addItem(itemType, fileName, metadata, position, rotation, scale, fixed, newItemDefinitions) {
              if (itemType == undefined) {
                  itemType = 1;
              }

              var scope = this;

              function addToMaterials(materials, newmaterial) {
                  for (var i = 0; i < materials.length; i++) {
                      var mat = materials[i];
                      if (mat.name == newmaterial.name) {
                          return [materials, i];
                      }
                  }
                  materials.push(newmaterial);
                  return [materials, materials.length - 1];
              }

              var loaderCallback = function loaderCallback(geometry, materials, gltf_entity) {
                  //			var item = new (Factory.getClass(itemType))(scope.model, metadata, geometry, new MeshFaceMaterial(materials), position, rotation, scale);
                  var item = new (Factory.getClass(itemType))(scope.model, metadata, geometry, materials, position, rotation, scale, gltf_entity);
                  item.fixed = fixed || false;
                  scope.items.push(item);
                  scope.add(item);
                  item.initObject();
                  scope.dispatchEvent({ type: EVENT_ITEM_LOADED, item: item });
                  if (newItemDefinitions) {
                      item.moveToPosition(newItemDefinitions.position, newItemDefinitions.edge);
                      item.placeInRoom();
                  }
              };
              var gltfCallback = function gltfCallback(gltfModel) {
                  var newmaterials = [];
                  var newGeometry = new Geometry();

                  gltfModel.scene.traverse(function (child) {
                      if (child.type == 'Mesh') {
                          var materialindices = [];
                          if (child.material.length) {
                              for (var k = 0; k < child.material.length; k++) {
                                  var newItems = addToMaterials(newmaterials, child.material[k]);
                                  newmaterials = newItems[0];
                                  materialindices.push(newItems[1]);
                              }
                          } else {
                              newItems = addToMaterials(newmaterials, child.material); //materials.push(child.material);
                              newmaterials = newItems[0];
                              materialindices.push(newItems[1]);
                          }

                          if (child.geometry.isBufferGeometry) {
                              var tGeometry = new Geometry().fromBufferGeometry(child.geometry);
                              tGeometry.faces.forEach(function (face) {
                                  //							face.materialIndex = face.materialIndex + newmaterials.length;
                                  face.materialIndex = materialindices[face.materialIndex];
                              });
                              child.updateMatrix();
                              newGeometry.merge(tGeometry, child.matrix);
                          } else {
                              child.geometry.faces.forEach(function (face) {
                                  //							face.materialIndex = face.materialIndex + newmaterials.length;
                                  face.materialIndex = materialindices[face.materialIndex];
                              });
                              child.updateMatrix();
                              newGeometry.mergeMesh(child);
                          }
                      }
                  });
                  loaderCallback(newGeometry, newmaterials, gltfModel);
                  // loaderCallback(gltfModel.scene, newmaterials, true);
              };
              this.dispatchEvent({ type: EVENT_ITEM_LOADING });
              this.gltfloader.load(fileName, gltfCallback, null, null);
          }
      }]);
      return Scene$1;
  }(EventDispatcher);

  /**
   * @author mrdoob / http://mrdoob.com/
   */
  function OBJExporter() {
  	this.parse = function (object) {
  		var output = '';

  		var indexVertex = 0;
  		var indexVertexUvs = 0;
  		var indexNormals = 0;

  		var vertex = new Vector3();
  		var normal = new Vector3();
  		var uv = new Vector2();

  		var i,
  		    j,
  		    k,
  		    l,
  		    m,
  		    face = [];

  		var parseMesh = function parseMesh(mesh) {

  			var nbVertex = 0;
  			var nbNormals = 0;
  			var nbVertexUvs = 0;

  			var geometry = mesh.geometry;

  			var normalMatrixWorld = new Matrix3();

  			if (geometry instanceof Geometry) {

  				geometry = new BufferGeometry().setFromObject(mesh);
  			}

  			if (geometry instanceof BufferGeometry) {

  				// shortcuts
  				var vertices = geometry.getAttribute('position');
  				var normals = geometry.getAttribute('normal');
  				var uvs = geometry.getAttribute('uv');
  				var indices = geometry.getIndex();

  				// name of the mesh object
  				output += 'o ' + mesh.name + '\n';

  				// name of the mesh material
  				if (mesh.material && mesh.material.name) {

  					output += 'usemtl ' + mesh.material.name + '\n';
  				}

  				// vertices

  				if (vertices !== undefined) {

  					for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {

  						vertex.x = vertices.getX(i);
  						vertex.y = vertices.getY(i);
  						vertex.z = vertices.getZ(i);

  						// transfrom the vertex to world space
  						vertex.applyMatrix4(mesh.matrixWorld);

  						// transform the vertex to export format
  						output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';
  					}
  				}

  				// uvs

  				if (uvs !== undefined) {

  					for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {

  						uv.x = uvs.getX(i);
  						uv.y = uvs.getY(i);

  						// transform the uv to export format
  						output += 'vt ' + uv.x + ' ' + uv.y + '\n';
  					}
  				}

  				// normals

  				if (normals !== undefined) {

  					normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);

  					for (i = 0, l = normals.count; i < l; i++, nbNormals++) {

  						normal.x = normals.getX(i);
  						normal.y = normals.getY(i);
  						normal.z = normals.getZ(i);

  						// transfrom the normal to world space
  						normal.applyMatrix3(normalMatrixWorld);

  						// transform the normal to export format
  						output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\n';
  					}
  				}

  				// faces

  				if (indices !== null) {

  					for (i = 0, l = indices.count; i < l; i += 3) {

  						for (m = 0; m < 3; m++) {

  							j = indices.getX(i + m) + 1;

  							face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');
  						}

  						// transform the face to export format
  						output += 'f ' + face.join(' ') + '\n';
  					}
  				} else {

  					for (i = 0, l = vertices.count; i < l; i += 3) {

  						for (m = 0; m < 3; m++) {

  							j = i + m + 1;

  							face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');
  						}

  						// transform the face to export format
  						output += 'f ' + face.join(' ') + '\n';
  					}
  				}
  			} else {

  				console.warn('THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry);
  			}

  			// update index
  			indexVertex += nbVertex;
  			indexVertexUvs += nbVertexUvs;
  			indexNormals += nbNormals;
  		};

  		var parseLine = function parseLine(line) {

  			var nbVertex = 0;

  			var geometry = line.geometry;
  			var type = line.type;

  			if (geometry instanceof Geometry) {

  				geometry = new BufferGeometry().setFromObject(line);
  			}

  			if (geometry instanceof BufferGeometry) {

  				// shortcuts
  				var vertices = geometry.getAttribute('position');

  				// name of the line object
  				output += 'o ' + line.name + '\n';

  				if (vertices !== undefined) {

  					for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {

  						vertex.x = vertices.getX(i);
  						vertex.y = vertices.getY(i);
  						vertex.z = vertices.getZ(i);

  						// transfrom the vertex to world space
  						vertex.applyMatrix4(line.matrixWorld);

  						// transform the vertex to export format
  						output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';
  					}
  				}

  				if (type === 'Line') {

  					output += 'l ';

  					for (j = 1, l = vertices.count; j <= l; j++) {

  						output += indexVertex + j + ' ';
  					}

  					output += '\n';
  				}

  				if (type === 'LineSegments') {

  					for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {

  						output += 'l ' + (indexVertex + j) + ' ' + (indexVertex + k) + '\n';
  					}
  				}
  			} else {

  				console.warn('THREE.OBJExporter.parseLine(): geometry type unsupported', geometry);
  			}

  			// update index
  			indexVertex += nbVertex;
  		};

  		object.traverse(function (child) {

  			if (child instanceof Mesh) {

  				parseMesh(child);
  			}

  			if (child instanceof Line) {

  				parseLine(child);
  			}
  		});

  		return output;
  	};
  }

  OBJExporter.prototype = Object.create(EventDispatcher.prototype);
  OBJExporter.prototype.constructor = OBJExporter;

  /**
   * @author fernandojsg / http://fernandojsg.com
   * @author Don McCurdy / https://www.donmccurdy.com
   * @author Takahiro / https://github.com/takahirox
   */

  var _GLTFExporter = (function(){
      //------------------------------------------------------------------------------
      //Constants
      //------------------------------------------------------------------------------
      var WEBGL_CONSTANTS = {
              POINTS: 0x0000,
              LINES: 0x0001,
              LINE_LOOP: 0x0002,
              LINE_STRIP: 0x0003,
              TRIANGLES: 0x0004,
              TRIANGLE_STRIP: 0x0005,
              TRIANGLE_FAN: 0x0006,

              UNSIGNED_BYTE: 0x1401,
              UNSIGNED_SHORT: 0x1403,
              FLOAT: 0x1406,
              UNSIGNED_INT: 0x1405,
              ARRAY_BUFFER: 0x8892,
              ELEMENT_ARRAY_BUFFER: 0x8893,

              NEAREST: 0x2600,
              LINEAR: 0x2601,
              NEAREST_MIPMAP_NEAREST: 0x2700,
              LINEAR_MIPMAP_NEAREST: 0x2701,
              NEAREST_MIPMAP_LINEAR: 0x2702,
              LINEAR_MIPMAP_LINEAR: 0x2703
      };

      var THREE_TO_WEBGL = {
              // @TODO Replace with computed property name [THREE.*] when available on
              // es6
              1003: WEBGL_CONSTANTS.NEAREST,
              1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,
              1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,
              1006: WEBGL_CONSTANTS.LINEAR,
              1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,
              1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR
      };

      var PATH_PROPERTIES = {
              scale: 'scale',
              position: 'translation',
              quaternion: 'rotation',
              morphTargetInfluences: 'weights'
      };
  //	------------------------------------------------------------------------------
  //	GLTF Exporter
  //	------------------------------------------------------------------------------
  	function GLTFExporter() {}

  	GLTFExporter.prototype = {

  			constructor: GLTFExporter,

  			/**
  			 * Parse scenes and generate GLTF output
  			 * 
  			 * @param {THREE.Scene
  			 *            or [THREE.Scenes]} input THREE.Scene or Array of
  			 *            THREE.Scenes
  			 * @param {Function}
  			 *            onDone Callback on completed
  			 * @param {Object}
  			 *            options options
  			 */
  			parse: function ( input, onDone, options ) {

  				var DEFAULT_OPTIONS = {
  						binary: false,
  						trs: false,
  						onlyVisible: true,
  						truncateDrawRange: true,
  						embedImages: true,
  						animations: [],
  						forceIndices: false,
  						forcePowerOfTwoTextures: false
  				};

  				options = Object.assign( {}, DEFAULT_OPTIONS, options );

  				if ( options.animations.length > 0 ) {

  					// Only TRS properties, and not matrices, may be targeted by
  					// animation.
  					options.trs = true;

  				}

  				var outputJSON = {

  						asset: {

  							version: "2.0",
  							generator: "THREE.GLTFExporter"

  						}

  				};

  				var byteOffset = 0;
  				var buffers = [];
  				var pending = [];
  				var nodeMap = new Map();
  				var skins = [];
  				var extensionsUsed = {};
  				var cachedData = {

  						attributes: new Map(),
  						materials: new Map(),
  						textures: new Map(),
  						images: new Map()

  				};

  				var cachedCanvas;

  				/**
  				 * Compare two arrays
  				 */
  				/**
  				 * Compare two arrays
  				 * 
  				 * @param {Array}
  				 *            array1 Array 1 to compare
  				 * @param {Array}
  				 *            array2 Array 2 to compare
  				 * @return {Boolean} Returns true if both arrays are equal
  				 */
  				function equalArray( array1, array2 ) {

  					return ( array1.length === array2.length ) && array1.every( function ( element, index ) {

  						return element === array2[ index ];

  					} );

  				}

  				/**
  				 * Converts a string to an ArrayBuffer.
  				 * 
  				 * @param {string}
  				 *            text
  				 * @return {ArrayBuffer}
  				 */
  				function stringToArrayBuffer( text ) {

  					if ( window.TextEncoder !== undefined ) {

  						return new TextEncoder().encode( text ).buffer;

  					}

  					var array = new Uint8Array( new ArrayBuffer( text.length ) );

  					for ( var i = 0, il = text.length; i < il; i ++ ) {

  						var value = text.charCodeAt( i );

  						// Replacing multi-byte character with space(0x20).
  						array[ i ] = value > 0xFF ? 0x20 : value;

  					}

  					return array.buffer;

  				}

  				/**
  				 * Get the min and max vectors from the given attribute
  				 * 
  				 * @param {THREE.BufferAttribute}
  				 *            attribute Attribute to find the min/max in range
  				 *            from start to start + count
  				 * @param {Integer}
  				 *            start
  				 * @param {Integer}
  				 *            count
  				 * @return {Object} Object containing the `min` and `max` values
  				 *         (As an array of attribute.itemSize components)
  				 */
  				function getMinMax( attribute, start, count ) {

  					var output = {

  							min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
  							max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )

  					};

  					for ( var i = start; i < start + count; i ++ ) {

  						for ( var a = 0; a < attribute.itemSize; a ++ ) {

  							var value = attribute.array[ i * attribute.itemSize + a ];
  							output.min[ a ] = Math.min( output.min[ a ], value );
  							output.max[ a ] = Math.max( output.max[ a ], value );

  						}

  					}

  					return output;

  				}

  				/**
  				 * Checks if image size is POT.
  				 * 
  				 * @param {Image}
  				 *            image The image to be checked.
  				 * @returns {Boolean} Returns true if image size is POT.
  				 * 
  				 */
  				function isPowerOfTwo( image ) {

  					return three_module.Math.isPowerOfTwo( image.width ) && three_module.Math.isPowerOfTwo( image.height );

  				}

  				/**
  				 * Checks if normal attribute values are normalized.
  				 * 
  				 * @param {THREE.BufferAttribute}
  				 *            normal
  				 * @returns {Boolean}
  				 * 
  				 */
  				function isNormalizedNormalAttribute( normal ) {

  					if ( cachedData.attributes.has( normal ) ) {

  						return false;

  					}

  					var v = new three_module.Vector3();

  					for ( var i = 0, il = normal.count; i < il; i ++ ) {

  						// 0.0005 is from glTF-validator
  						if ( Math.abs( v.fromArray( normal.array, i * 3 ).length() - 1.0 ) > 0.0005 ) return false;

  					}

  					return true;

  				}

  				/**
  				 * Creates normalized normal buffer attribute.
  				 * 
  				 * @param {THREE.BufferAttribute}
  				 *            normal
  				 * @returns {THREE.BufferAttribute}
  				 * 
  				 */
  				function createNormalizedNormalAttribute( normal ) {

  					if ( cachedData.attributes.has( normal ) ) {

  						return cachedData.attributes.get( normal );

  					}

  					var attribute = normal.clone();

  					var v = new three_module.Vector3();

  					for ( var i = 0, il = attribute.count; i < il; i ++ ) {

  						v.fromArray( attribute.array, i * 3 );

  						if ( v.x === 0 && v.y === 0 && v.z === 0 ) {

  							// if values can't be normalized set (1, 0, 0)
  							v.setX( 1.0 );

  						} else {

  							v.normalize();

  						}

  						v.toArray( attribute.array, i * 3 );

  					}

  					cachedData.attributes.set( normal, attribute );

  					return attribute;

  				}

  				/**
  				 * Get the required size + padding for a buffer, rounded to the
  				 * next 4-byte boundary.
  				 * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
  				 * 
  				 * @param {Integer}
  				 *            bufferSize The size the original buffer.
  				 * @returns {Integer} new buffer size with required padding.
  				 * 
  				 */
  				function getPaddedBufferSize( bufferSize ) {

  					return Math.ceil( bufferSize / 4 ) * 4;

  				}

  				/**
  				 * Returns a buffer aligned to 4-byte boundary.
  				 * 
  				 * @param {ArrayBuffer}
  				 *            arrayBuffer Buffer to pad
  				 * @param {Integer}
  				 *            paddingByte (Optional)
  				 * @returns {ArrayBuffer} The same buffer if it's already
  				 *          aligned to 4-byte boundary or a new buffer
  				 */
  				function getPaddedArrayBuffer( arrayBuffer, paddingByte ) {

  					paddingByte = paddingByte || 0;

  					var paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );

  					if ( paddedLength !== arrayBuffer.byteLength ) {

  						var array = new Uint8Array( paddedLength );
  						array.set( new Uint8Array( arrayBuffer ) );

  						if ( paddingByte !== 0 ) {

  							for ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {

  								array[ i ] = paddingByte;

  							}

  						}

  						return array.buffer;

  					}

  					return arrayBuffer;

  				}

  				/**
  				 * Serializes a userData.
  				 * 
  				 * @param {THREE.Object3D|THREE.Material}
  				 *            object
  				 * @returns {Object}
  				 */
  				function serializeUserData( object ) {

  					try {

  						return JSON.parse( JSON.stringify( object.userData ) );

  					} catch ( error ) {

  						console.warn( 'THREE.GLTFExporter: userData of \'' + object.name + '\' ' +
  								'won\'t be serialized because of JSON.stringify error - ' + error.message );

  						return {};

  					}

  				}

  				/**
  				 * Process a buffer to append to the default one.
  				 * 
  				 * @param {ArrayBuffer}
  				 *            buffer
  				 * @return {Integer}
  				 */
  				function processBuffer( buffer ) {

  					if ( ! outputJSON.buffers ) {

  						outputJSON.buffers = [ { byteLength: 0 } ];

  					}

  					// All buffers are merged before export.
  					buffers.push( buffer );

  					return 0;

  				}

  				/**
  				 * Process and generate a BufferView
  				 * 
  				 * @param {THREE.BufferAttribute}
  				 *            attribute
  				 * @param {number}
  				 *            componentType
  				 * @param {number}
  				 *            start
  				 * @param {number}
  				 *            count
  				 * @param {number}
  				 *            target (Optional) Target usage of the BufferView
  				 * @return {Object}
  				 */
  				function processBufferView( attribute, componentType, start, count, target ) {

  					if ( ! outputJSON.bufferViews ) {

  						outputJSON.bufferViews = [];

  					}

  					// Create a new dataview and dump the attribute's array into
  					// it

  					var componentSize;

  					if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

  						componentSize = 1;

  					} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

  						componentSize = 2;

  					} else {

  						componentSize = 4;

  					}

  					var byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );
  					var dataView = new DataView( new ArrayBuffer( byteLength ) );
  					var offset = 0;

  					for ( var i = start; i < start + count; i ++ ) {

  						for ( var a = 0; a < attribute.itemSize; a ++ ) {

  							// @TODO Fails on InterleavedBufferAttribute, and
  							// could probably be
  							// optimized for normal BufferAttribute.
  							var value = attribute.array[ i * attribute.itemSize + a ];

  							if ( componentType === WEBGL_CONSTANTS.FLOAT ) {

  								dataView.setFloat32( offset, value, true );

  							} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {

  								dataView.setUint32( offset, value, true );

  							} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

  								dataView.setUint16( offset, value, true );

  							} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

  								dataView.setUint8( offset, value );

  							}

  							offset += componentSize;

  						}

  					}

  					var gltfBufferView = {

  							buffer: processBuffer( dataView.buffer ),
  							byteOffset: byteOffset,
  							byteLength: byteLength

  					};

  					if ( target !== undefined ) gltfBufferView.target = target;

  					if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {

  						// Only define byteStride for vertex attributes.
  						gltfBufferView.byteStride = attribute.itemSize * componentSize;

  					}

  					byteOffset += byteLength;

  					outputJSON.bufferViews.push( gltfBufferView );

  					// @TODO Merge bufferViews where possible.
  					var output = {

  							id: outputJSON.bufferViews.length - 1,
  							byteLength: 0

  					};

  					return output;

  				}

  				/**
  				 * Process and generate a BufferView from an image Blob.
  				 * 
  				 * @param {Blob}
  				 *            blob
  				 * @return {Promise<Integer>}
  				 */
  				function processBufferViewImage( blob ) {

  					if ( ! outputJSON.bufferViews ) {

  						outputJSON.bufferViews = [];

  					}

  					return new Promise( function ( resolve ) {

  						var reader = new window.FileReader();
  						reader.readAsArrayBuffer( blob );
  						reader.onloadend = function () {

  							var buffer = getPaddedArrayBuffer( reader.result );

  							var bufferView = {
  									buffer: processBuffer( buffer ),
  									byteOffset: byteOffset,
  									byteLength: buffer.byteLength
  							};

  							byteOffset += buffer.byteLength;

  							outputJSON.bufferViews.push( bufferView );

  							resolve( outputJSON.bufferViews.length - 1 );

  						};

  					} );

  				}

  				/**
  				 * Process attribute to generate an accessor
  				 * 
  				 * @param {THREE.BufferAttribute}
  				 *            attribute Attribute to process
  				 * @param {THREE.BufferGeometry}
  				 *            geometry (Optional) Geometry used for truncated
  				 *            draw range
  				 * @param {Integer}
  				 *            start (Optional)
  				 * @param {Integer}
  				 *            count (Optional)
  				 * @return {Integer} Index of the processed accessor on the
  				 *         "accessors" array
  				 */
  				function processAccessor( attribute, geometry, start, count ) {

  					var types = {

  							1: 'SCALAR',
  							2: 'VEC2',
  							3: 'VEC3',
  							4: 'VEC4',
  							16: 'MAT4'

  					};

  					var componentType;

  					// Detect the component type of the attribute array (float,
  					// uint or ushort)
  					if ( attribute.array.constructor === Float32Array ) {

  						componentType = WEBGL_CONSTANTS.FLOAT;

  					} else if ( attribute.array.constructor === Uint32Array ) {

  						componentType = WEBGL_CONSTANTS.UNSIGNED_INT;

  					} else if ( attribute.array.constructor === Uint16Array ) {

  						componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;

  					} else if ( attribute.array.constructor === Uint8Array ) {

  						componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;

  					} else {

  						throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );

  					}

  					if ( start === undefined ) start = 0;
  					if ( count === undefined ) count = attribute.count;

  					// @TODO Indexed buffer geometry with drawRange not
  					// supported yet
  					if ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {

  						var end = start + count;
  						var end2 = geometry.drawRange.count === Infinity
  						? attribute.count
  								: geometry.drawRange.start + geometry.drawRange.count;

  						start = Math.max( start, geometry.drawRange.start );
  						count = Math.min( end, end2 ) - start;

  						if ( count < 0 ) count = 0;

  					}

  					// Skip creating an accessor if the attribute doesn't have
  					// data to export
  					if ( count === 0 ) {

  						return null;

  					}

  					var minMax = getMinMax( attribute, start, count );

  					var bufferViewTarget;

  					// If geometry isn't provided, don't infer the target usage
  					// of the bufferView. For
  					// animation samplers, target must not be set.
  					if ( geometry !== undefined ) {

  						bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;

  					}

  					var bufferView = processBufferView( attribute, componentType, start, count, bufferViewTarget );

  					var gltfAccessor = {

  							bufferView: bufferView.id,
  							byteOffset: bufferView.byteOffset,
  							componentType: componentType,
  							count: count,
  							max: minMax.max,
  							min: minMax.min,
  							type: types[ attribute.itemSize ]

  					};

  					if ( ! outputJSON.accessors ) {

  						outputJSON.accessors = [];

  					}

  					outputJSON.accessors.push( gltfAccessor );

  					return outputJSON.accessors.length - 1;

  				}

  				/**
  				 * Process image
  				 * 
  				 * @param {Image}
  				 *            image to process
  				 * @param {Integer}
  				 *            format of the image (e.g. THREE.RGBFormat,
  				 *            THREE.RGBAFormat etc)
  				 * @param {Boolean}
  				 *            flipY before writing out the image
  				 * @return {Integer} Index of the processed texture in the
  				 *         "images" array
  				 */
  				function processImage( image, format, flipY ) {

  					if ( ! cachedData.images.has( image ) ) {

  						cachedData.images.set( image, {} );

  					}

  					var cachedImages = cachedData.images.get( image );
  					var mimeType = format === three_module.RGBAFormat ? 'image/png' : 'image/jpeg';
  					var key = mimeType + ":flipY/" + flipY.toString();

  					if ( cachedImages[ key ] !== undefined ) {

  						return cachedImages[ key ];

  					}

  					if ( ! outputJSON.images ) {

  						outputJSON.images = [];

  					}

  					var gltfImage = { mimeType: mimeType };

  					if ( options.embedImages ) {

  						var canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );

  						canvas.width = image.width;
  						canvas.height = image.height;

  						if ( options.forcePowerOfTwoTextures && ! isPowerOfTwo( image ) ) {

  							console.warn( 'GLTFExporter: Resized non-power-of-two image.', image );

  							canvas.width = three_module.Math.floorPowerOfTwo( canvas.width );
  							canvas.height = three_module.Math.floorPowerOfTwo( canvas.height );

  						}

  						var ctx = canvas.getContext( '2d' );

  						if ( flipY === true ) {

  							ctx.translate( 0, canvas.height );
  							ctx.scale( 1, - 1 );

  						}

  						ctx.drawImage( image, 0, 0, canvas.width, canvas.height );

  						if ( options.binary === true ) {

  							pending.push( new Promise( function ( resolve ) {

  								canvas.toBlob( function ( blob ) {

  									processBufferViewImage( blob ).then( function ( bufferViewIndex ) {

  										gltfImage.bufferView = bufferViewIndex;

  										resolve();

  									} );

  								}, mimeType );

  							} ) );

  						} else {

  							gltfImage.uri = canvas.toDataURL( mimeType );

  						}

  					} else {

  						gltfImage.uri = image.src;

  					}

  					outputJSON.images.push( gltfImage );

  					var index = outputJSON.images.length - 1;
  					cachedImages[ key ] = index;

  					return index;

  				}

  				/**
  				 * Process sampler
  				 * 
  				 * @param {Texture}
  				 *            map Texture to process
  				 * @return {Integer} Index of the processed texture in the
  				 *         "samplers" array
  				 */
  				function processSampler( map ) {

  					if ( ! outputJSON.samplers ) {

  						outputJSON.samplers = [];

  					}

  					var gltfSampler = {

  							magFilter: THREE_TO_WEBGL[ map.magFilter ],
  							minFilter: THREE_TO_WEBGL[ map.minFilter ],
  							wrapS: THREE_TO_WEBGL[ map.wrapS ],
  							wrapT: THREE_TO_WEBGL[ map.wrapT ]

  					};

  					outputJSON.samplers.push( gltfSampler );

  					return outputJSON.samplers.length - 1;

  				}

  				/**
  				 * Process texture
  				 * 
  				 * @param {Texture}
  				 *            map Map to process
  				 * @return {Integer} Index of the processed texture in the
  				 *         "textures" array
  				 */
  				function processTexture( map ) {

  					if ( cachedData.textures.has( map ) ) {

  						return cachedData.textures.get( map );

  					}

  					if ( ! outputJSON.textures ) {

  						outputJSON.textures = [];

  					}

  					var gltfTexture = {

  							sampler: processSampler( map ),
  							source: processImage( map.image, map.format, map.flipY )

  					};

  					outputJSON.textures.push( gltfTexture );

  					var index = outputJSON.textures.length - 1;
  					cachedData.textures.set( map, index );

  					return index;

  				}

  				/**
  				 * Process material
  				 * 
  				 * @param {THREE.Material}
  				 *            material Material to process
  				 * @return {Integer} Index of the processed material in the
  				 *         "materials" array
  				 */
  				function processMaterial( material ) {

  					if ( cachedData.materials.has( material ) ) {

  						return cachedData.materials.get( material );

  					}

  					if ( ! outputJSON.materials ) {

  						outputJSON.materials = [];

  					}

  					if ( material.isShaderMaterial ) {

  						console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );
  						return null;

  					}

  					// @QUESTION Should we avoid including any attribute that
  					// has the default value?
  					var gltfMaterial = {

  							pbrMetallicRoughness: {}

  					};

  					if ( material.isMeshBasicMaterial ) {

  						gltfMaterial.extensions = { KHR_materials_unlit: {} };

  						extensionsUsed[ 'KHR_materials_unlit' ] = true;

  					} else if ( ! material.isMeshStandardMaterial ) {

  						console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );

  					}

  					// pbrMetallicRoughness.baseColorFactor
  					var color = material.color.toArray().concat( [ material.opacity ] );

  					if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

  						gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;

  					}

  					if ( material.isMeshStandardMaterial ) {

  						gltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;
  						gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;

  					} else if ( material.isMeshBasicMaterial ) {

  						gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;
  						gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;

  					} else {

  						gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;
  						gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;

  					}

  					// pbrMetallicRoughness.metallicRoughnessTexture
  					if ( material.metalnessMap || material.roughnessMap ) {

  						if ( material.metalnessMap === material.roughnessMap ) {

  							gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = {

  									index: processTexture( material.metalnessMap )

  							};

  						} else {

  							console.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );

  						}

  					}

  					// pbrMetallicRoughness.baseColorTexture
  					if ( material.map ) {

  						gltfMaterial.pbrMetallicRoughness.baseColorTexture = {

  								index: processTexture( material.map )

  						};

  					}

  					if ( material.isMeshBasicMaterial ||
  							material.isLineBasicMaterial ||
  							material.isPointsMaterial ) ; else {

  						// emissiveFactor
  						var emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();

  						if ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {

  							gltfMaterial.emissiveFactor = emissive;

  						}

  						// emissiveTexture
  						if ( material.emissiveMap ) {

  							gltfMaterial.emissiveTexture = {

  									index: processTexture( material.emissiveMap )

  							};

  						}

  					}

  					// normalTexture
  					if ( material.normalMap ) {

  						gltfMaterial.normalTexture = {

  								index: processTexture( material.normalMap )

  						};

  						if ( material.normalScale.x !== - 1 ) {

  							if ( material.normalScale.x !== material.normalScale.y ) {

  								console.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );

  							}

  							gltfMaterial.normalTexture.scale = material.normalScale.x;

  						}

  					}

  					// occlusionTexture
  					if ( material.aoMap ) {

  						gltfMaterial.occlusionTexture = {

  								index: processTexture( material.aoMap )

  						};

  						if ( material.aoMapIntensity !== 1.0 ) {

  							gltfMaterial.occlusionTexture.strength = material.aoMapIntensity;

  						}

  					}

  					// alphaMode
  					if ( material.transparent || material.alphaTest > 0.0 ) {

  						gltfMaterial.alphaMode = material.opacity < 1.0 ? 'BLEND' : 'MASK';

  						// Write alphaCutoff if it's non-zero and different from
  						// the default (0.5).
  						if ( material.alphaTest > 0.0 && material.alphaTest !== 0.5 ) {

  							gltfMaterial.alphaCutoff = material.alphaTest;

  						}

  					}

  					// doubleSided
  					if ( material.side === three_module.DoubleSide ) {

  						gltfMaterial.doubleSided = true;

  					}

  					if ( material.name !== '' ) {

  						gltfMaterial.name = material.name;

  					}

  					if ( Object.keys( material.userData ).length > 0 ) {

  						gltfMaterial.extras = serializeUserData( material );

  					}

  					outputJSON.materials.push( gltfMaterial );

  					var index = outputJSON.materials.length - 1;
  					cachedData.materials.set( material, index );

  					return index;

  				}

  				/**
  				 * Process mesh
  				 * 
  				 * @param {THREE.Mesh}
  				 *            mesh Mesh to process
  				 * @return {Integer} Index of the processed mesh in the "meshes"
  				 *         array
  				 */
  				function processMesh( mesh ) {

  					var geometry = mesh.geometry;

  					var mode;

  					// Use the correct mode
  					if ( mesh.isLineSegments ) {

  						mode = WEBGL_CONSTANTS.LINES;

  					} else if ( mesh.isLineLoop ) {

  						mode = WEBGL_CONSTANTS.LINE_LOOP;

  					} else if ( mesh.isLine ) {

  						mode = WEBGL_CONSTANTS.LINE_STRIP;

  					} else if ( mesh.isPoints ) {

  						mode = WEBGL_CONSTANTS.POINTS;

  					} else {

  						if ( ! geometry.isBufferGeometry ) {

  							var geometryTemp = new three_module.BufferGeometry();
  							geometryTemp.fromGeometry( geometry );
  							geometry = geometryTemp;

  						}

  						if ( mesh.drawMode === three_module.TriangleFanDrawMode ) {

  							console.warn( 'GLTFExporter: TriangleFanDrawMode and wireframe incompatible.' );
  							mode = WEBGL_CONSTANTS.TRIANGLE_FAN;

  						} else if ( mesh.drawMode === three_module.TriangleStripDrawMode ) {

  							mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;

  						} else {

  							mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;

  						}

  					}

  					var gltfMesh = {};

  					var attributes = {};
  					var primitives = [];
  					var targets = [];

  					// Conversion between attributes names in threejs and gltf
  					// spec
  					var nameConversion = {

  							uv: 'TEXCOORD_0',
  							uv2: 'TEXCOORD_1',
  							color: 'COLOR_0',
  							skinWeight: 'WEIGHTS_0',
  							skinIndex: 'JOINTS_0'

  					};

  					var originalNormal = geometry.getAttribute( 'normal' );

  					if ( originalNormal !== undefined && ! isNormalizedNormalAttribute( originalNormal ) ) {

  						console.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );

  						geometry.addAttribute( 'normal', createNormalizedNormalAttribute( originalNormal ) );

  					}

  					// @QUESTION Detect if .vertexColors = THREE.VertexColors?
  					// For every attribute create an accessor
  					for ( var attributeName in geometry.attributes ) {

  						var attribute = geometry.attributes[ attributeName ];
  						attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();

  						// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
  						var array = attribute.array;
  						if ( attributeName === 'JOINTS_0' &&
  								! ( array instanceof Uint16Array ) &&
  								! ( array instanceof Uint8Array ) ) {

  							console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );
  							attribute = new three_module.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );

  						}

  						if ( attributeName.substr( 0, 5 ) !== 'MORPH' ) {

  							var accessor = processAccessor( attribute, geometry );
  							if ( accessor !== null ) {

  								attributes[ attributeName ] = accessor;

  							}

  						}

  					}

  					if ( originalNormal !== undefined ) geometry.addAttribute( 'normal', originalNormal );

  					// Skip if no exportable attributes found
  					if ( Object.keys( attributes ).length === 0 ) {

  						return null;

  					}

  					// Morph targets
  					if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {

  						var weights = [];
  						var targetNames = [];
  						var reverseDictionary = {};

  						if ( mesh.morphTargetDictionary !== undefined ) {

  							for ( var key in mesh.morphTargetDictionary ) {

  								reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;

  							}

  						}

  						for ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {

  							var target = {};

  							var warned = false;

  							for ( var attributeName in geometry.morphAttributes ) {

  								// glTF 2.0 morph supports only
  								// POSITION/NORMAL/TANGENT.
  								// Three.js doesn't support TANGENT yet.

  								if ( attributeName !== 'position' && attributeName !== 'normal' ) {

  									if ( ! warned ) {

  										console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );
  										warned = true;

  									}

  									continue;

  								}

  								var attribute = geometry.morphAttributes[ attributeName ][ i ];

  								// Three.js morph attribute has absolute values
  								// while the one of glTF has relative values.
  								//
  								// glTF 2.0 Specification:
  								// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

  								var baseAttribute = geometry.attributes[ attributeName ];
  								// Clones attribute not to override
  								var relativeAttribute = attribute.clone();

  								for ( var j = 0, jl = attribute.count; j < jl; j ++ ) {

  									relativeAttribute.setXYZ(
  											j,
  											attribute.getX( j ) - baseAttribute.getX( j ),
  											attribute.getY( j ) - baseAttribute.getY( j ),
  											attribute.getZ( j ) - baseAttribute.getZ( j )
  									);

  								}

  								target[ attributeName.toUpperCase() ] = processAccessor( relativeAttribute, geometry );

  							}

  							targets.push( target );

  							weights.push( mesh.morphTargetInfluences[ i ] );
  							if ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );

  						}

  						gltfMesh.weights = weights;

  						if ( targetNames.length > 0 ) {

  							gltfMesh.extras = {};
  							gltfMesh.extras.targetNames = targetNames;

  						}

  					}

  					var extras = ( Object.keys( geometry.userData ).length > 0 ) ? serializeUserData( geometry ) : undefined;

  					var forceIndices = options.forceIndices;
  					var isMultiMaterial = Array.isArray( mesh.material );

  					if ( isMultiMaterial && geometry.groups.length === 0 ) return null;

  					if ( ! forceIndices && geometry.index === null && isMultiMaterial ) {

  						// temporal workaround.
  						console.warn( 'THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.' );
  						forceIndices = true;

  					}

  					var didForceIndices = false;

  					if ( geometry.index === null && forceIndices ) {

  						var indices = [];

  						for ( var i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {

  							indices[ i ] = i;

  						}

  						geometry.setIndex( indices );

  						didForceIndices = true;

  					}

  					var materials = isMultiMaterial ? mesh.material : [ mesh.material ];
  					var groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];

  					for ( var i = 0, il = groups.length; i < il; i ++ ) {

  						var primitive = {
  								mode: mode,
  								attributes: attributes,
  						};

  						if ( extras ) primitive.extras = extras;

  						if ( targets.length > 0 ) primitive.targets = targets;

  						if ( geometry.index !== null ) {

  							primitive.indices = processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );

  						}

  						var material = processMaterial( materials[ groups[ i ].materialIndex ] );

  						if ( material !== null ) {

  							primitive.material = material;

  						}

  						primitives.push( primitive );

  					}

  					if ( didForceIndices ) {

  						geometry.setIndex( null );

  					}

  					gltfMesh.primitives = primitives;

  					if ( ! outputJSON.meshes ) {

  						outputJSON.meshes = [];

  					}

  					outputJSON.meshes.push( gltfMesh );

  					return outputJSON.meshes.length - 1;

  				}

  				/**
  				 * Process camera
  				 * 
  				 * @param {THREE.Camera}
  				 *            camera Camera to process
  				 * @return {Integer} Index of the processed mesh in the "camera"
  				 *         array
  				 */
  				function processCamera( camera ) {

  					if ( ! outputJSON.cameras ) {

  						outputJSON.cameras = [];

  					}

  					var isOrtho = camera.isOrthographicCamera;

  					var gltfCamera = {

  							type: isOrtho ? 'orthographic' : 'perspective'

  					};

  					if ( isOrtho ) {

  						gltfCamera.orthographic = {

  								xmag: camera.right * 2,
  								ymag: camera.top * 2,
  								zfar: camera.far <= 0 ? 0.001 : camera.far,
  										znear: camera.near < 0 ? 0 : camera.near

  						};

  					} else {

  						gltfCamera.perspective = {

  								aspectRatio: camera.aspect,
  								yfov: three_module.Math.degToRad( camera.fov ) / camera.aspect,
  								zfar: camera.far <= 0 ? 0.001 : camera.far,
  										znear: camera.near < 0 ? 0 : camera.near

  						};

  					}

  					if ( camera.name !== '' ) {

  						gltfCamera.name = camera.type;

  					}

  					outputJSON.cameras.push( gltfCamera );

  					return outputJSON.cameras.length - 1;

  				}

  				/**
  				 * Creates glTF animation entry from AnimationClip object.
  				 * 
  				 * Status: - Only properties listed in PATH_PROPERTIES may be
  				 * animated.
  				 * 
  				 * @param {THREE.AnimationClip}
  				 *            clip
  				 * @param {THREE.Object3D}
  				 *            root
  				 * @return {number}
  				 */
  				function processAnimation( clip, root ) {

  					if ( ! outputJSON.animations ) {

  						outputJSON.animations = [];

  					}

  					var channels = [];
  					var samplers = [];

  					for ( var i = 0; i < clip.tracks.length; ++ i ) {

  						var track = clip.tracks[ i ];
  						var trackBinding = three_module.PropertyBinding.parseTrackName( track.name );
  						var trackNode = three_module.PropertyBinding.findNode( root, trackBinding.nodeName );
  						var trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];

  						if ( trackBinding.objectName === 'bones' ) {

  							if ( trackNode.isSkinnedMesh === true ) {

  								trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );

  							} else {

  								trackNode = undefined;

  							}

  						}

  						if ( ! trackNode || ! trackProperty ) {

  							console.warn( 'THREE.GLTFExporter: Could not export animation track "%s".', track.name );
  							return null;

  						}

  						var inputItemSize = 1;
  						var outputItemSize = track.values.length / track.times.length;

  						if ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {

  							if ( trackNode.morphTargetInfluences.length !== 1 &&
  									trackBinding.propertyIndex !== undefined ) {

  								console.warn( 'THREE.GLTFExporter: Skipping animation track "%s". ' +
  										'Morph target keyframe tracks must target all available morph targets ' +
  										'for the given mesh.', track.name );
  								continue;

  							}

  							outputItemSize /= trackNode.morphTargetInfluences.length;

  						}

  						var interpolation;

  						// @TODO export CubicInterpolant(InterpolateSmooth) as
  						// CUBICSPLINE

  						// Detecting glTF cubic spline interpolant by checking
  						// factory method's special property
  						// GLTFCubicSplineInterpolant is a custom interpolant
  						// and track doesn't return
  						// valid value from .getInterpolation().
  						if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {

  							interpolation = 'CUBICSPLINE';

  							// itemSize of CUBICSPLINE keyframe is 9
  							// (VEC3 * 3: inTangent, splineVertex, and
  							// outTangent)
  							// but needs to be stored as VEC3 so dividing by 3
  							// here.
  							outputItemSize /= 3;

  						} else if ( track.getInterpolation() === three_module.InterpolateDiscrete ) {

  							interpolation = 'STEP';

  						} else {

  							interpolation = 'LINEAR';

  						}

  						samplers.push( {

  							input: processAccessor( new three_module.BufferAttribute( track.times, inputItemSize ) ),
  							output: processAccessor( new three_module.BufferAttribute( track.values, outputItemSize ) ),
  							interpolation: interpolation

  						} );

  						channels.push( {

  							sampler: samplers.length - 1,
  							target: {
  								node: nodeMap.get( trackNode ),
  								path: trackProperty
  							}

  						} );

  					}

  					outputJSON.animations.push( {

  						name: clip.name || 'clip_' + outputJSON.animations.length,
  						samplers: samplers,
  						channels: channels

  					} );

  					return outputJSON.animations.length - 1;

  				}

  				function processSkin( object ) {

  					var node = outputJSON.nodes[ nodeMap.get( object ) ];

  					var skeleton = object.skeleton;
  					var rootJoint = object.skeleton.bones[ 0 ];

  					if ( rootJoint === undefined ) return null;

  					var joints = [];
  					var inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );

  					for ( var i = 0; i < skeleton.bones.length; ++ i ) {

  						joints.push( nodeMap.get( skeleton.bones[ i ] ) );

  						skeleton.boneInverses[ i ].toArray( inverseBindMatrices, i * 16 );

  					}

  					if ( outputJSON.skins === undefined ) {

  						outputJSON.skins = [];

  					}

  					outputJSON.skins.push( {

  						inverseBindMatrices: processAccessor( new three_module.BufferAttribute( inverseBindMatrices, 16 ) ),
  						joints: joints,
  						skeleton: nodeMap.get( rootJoint )

  					} );

  					var skinIndex = node.skin = outputJSON.skins.length - 1;

  					return skinIndex;

  				}

  				/**
  				 * Process Object3D node
  				 * 
  				 * @param {THREE.Object3D}
  				 *            node Object3D to processNode
  				 * @return {Integer} Index of the node in the nodes list
  				 */
  				function processNode( object ) {

  					if ( object.isLight ) {

  						console.warn( 'GLTFExporter: Unsupported node type:', object.constructor.name );
  						return null;

  					}

  					if ( ! outputJSON.nodes ) {

  						outputJSON.nodes = [];

  					}

  					var gltfNode = {};

  					if ( options.trs ) {

  						var rotation = object.quaternion.toArray();
  						var position = object.position.toArray();
  						var scale = object.scale.toArray();

  						if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

  							gltfNode.rotation = rotation;

  						}

  						if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

  							gltfNode.translation = position;

  						}

  						if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

  							gltfNode.scale = scale;

  						}

  					} else {

  						object.updateMatrix();
  						if ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {

  							gltfNode.matrix = object.matrix.elements;

  						}

  					}

  					// We don't export empty strings name because it represents
  					// no-name in Three.js.
  					if ( object.name !== '' ) {

  						gltfNode.name = String( object.name );

  					}

  					if ( object.userData && Object.keys( object.userData ).length > 0 ) {

  						gltfNode.extras = serializeUserData( object );

  					}

  					if ( object.isMesh || object.isLine || object.isPoints ) {

  						var mesh = processMesh( object );

  						if ( mesh !== null ) {

  							gltfNode.mesh = mesh;

  						}

  					} else if ( object.isCamera ) {

  						gltfNode.camera = processCamera( object );

  					}

  					if ( object.isSkinnedMesh ) {

  						skins.push( object );

  					}

  					if ( object.children.length > 0 ) {

  						var children = [];

  						for ( var i = 0, l = object.children.length; i < l; i ++ ) {

  							var child = object.children[ i ];

  							if ( child.visible || options.onlyVisible === false ) {

  								var node = processNode( child );

  								if ( node !== null ) {

  									children.push( node );

  								}

  							}

  						}

  						if ( children.length > 0 ) {

  							gltfNode.children = children;

  						}


  					}

  					outputJSON.nodes.push( gltfNode );

  					var nodeIndex = outputJSON.nodes.length - 1;
  					nodeMap.set( object, nodeIndex );

  					return nodeIndex;

  				}

  				/**
  				 * Process Scene
  				 * 
  				 * @param {THREE.Scene}
  				 *            node Scene to process
  				 */
  				function processScene( scene ) {

  					if ( ! outputJSON.scenes ) {

  						outputJSON.scenes = [];
  						outputJSON.scene = 0;

  					}

  					var gltfScene = {

  							nodes: []

  					};

  					if ( scene.name !== '' ) {

  						gltfScene.name = scene.name;

  					}

  					outputJSON.scenes.push( gltfScene );

  					var nodes = [];

  					for ( var i = 0, l = scene.children.length; i < l; i ++ ) {

  						var child = scene.children[ i ];

  						if ( child.visible || options.onlyVisible === false ) {

  							var node = processNode( child );

  							if ( node !== null ) {

  								nodes.push( node );

  							}

  						}

  					}

  					if ( nodes.length > 0 ) {

  						gltfScene.nodes = nodes;

  					}

  				}

  				/**
  				 * Creates a THREE.Scene to hold a list of objects and parse it
  				 * 
  				 * @param {Array}
  				 *            objects List of objects to process
  				 */
  				function processObjects( objects ) {

  					var scene = new three_module.Scene();
  					scene.name = 'AuxScene';

  					for ( var i = 0; i < objects.length; i ++ ) {

  						// We push directly to children instead of calling `add`
  						// to prevent
  						// modify the .parent and break its original scene and
  						// hierarchy
  						scene.children.push( objects[ i ] );

  					}

  					processScene( scene );

  				}

  				function processInput( input ) {

  					input = input instanceof Array ? input : [ input ];

  					var objectsWithoutScene = [];

  					for ( var i = 0; i < input.length; i ++ ) {

  						if ( input[ i ] instanceof three_module.Scene ) {

  							processScene( input[ i ] );

  						} else {

  							objectsWithoutScene.push( input[ i ] );

  						}

  					}

  					if ( objectsWithoutScene.length > 0 ) {

  						processObjects( objectsWithoutScene );

  					}

  					for ( var i = 0; i < skins.length; ++ i ) {

  						processSkin( skins[ i ] );

  					}

  					for ( var i = 0; i < options.animations.length; ++ i ) {

  						processAnimation( options.animations[ i ], input[ 0 ] );

  					}

  				}

  				processInput( input );

  				Promise.all( pending ).then( function () {

  					// Merge buffers.
  					var blob = new Blob( buffers, { type: 'application/octet-stream' } );

  					// Declare extensions.
  					var extensionsUsedList = Object.keys( extensionsUsed );
  					if ( extensionsUsedList.length > 0 ) outputJSON.extensionsUsed = extensionsUsedList;

  					if ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {

  						// Update bytelength of the single buffer.
  						outputJSON.buffers[ 0 ].byteLength = blob.size;

  						var reader = new window.FileReader();

  						if ( options.binary === true ) {

  							// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

  							var GLB_HEADER_BYTES = 12;
  							var GLB_HEADER_MAGIC = 0x46546C67;
  							var GLB_VERSION = 2;

  							var GLB_CHUNK_PREFIX_BYTES = 8;
  							var GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
  							var GLB_CHUNK_TYPE_BIN = 0x004E4942;

  							reader.readAsArrayBuffer( blob );
  							reader.onloadend = function () {

  								// Binary chunk.
  								var binaryChunk = getPaddedArrayBuffer( reader.result );
  								var binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
  								binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );
  								binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );

  								// JSON chunk.
  								var jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( outputJSON ) ), 0x20 );
  								var jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
  								jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );
  								jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );

  								// GLB header.
  								var header = new ArrayBuffer( GLB_HEADER_BYTES );
  								var headerView = new DataView( header );
  								headerView.setUint32( 0, GLB_HEADER_MAGIC, true );
  								headerView.setUint32( 4, GLB_VERSION, true );
  								var totalByteLength = GLB_HEADER_BYTES
  								+ jsonChunkPrefix.byteLength + jsonChunk.byteLength
  								+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;
  								headerView.setUint32( 8, totalByteLength, true );

  								var glbBlob = new Blob( [
  									header,
  									jsonChunkPrefix,
  									jsonChunk,
  									binaryChunkPrefix,
  									binaryChunk
  									], { type: 'application/octet-stream' } );

  								var glbReader = new window.FileReader();
  								glbReader.readAsArrayBuffer( glbBlob );
  								glbReader.onloadend = function () {

  									onDone( glbReader.result );

  								};

  							};

  						} else {

  							reader.readAsDataURL( blob );
  							reader.onloadend = function () {

  								var base64data = reader.result;
  								outputJSON.buffers[ 0 ].uri = base64data;
  								onDone( outputJSON );

  							};

  						}

  					} else {

  						onDone( outputJSON );

  					}

  				} );
  			}
  	};
  	return GLTFExporter;
  })();
  var threeGltfExporter = _GLTFExporter;

  /**
   * A Model is an abstract concept the has the data structuring a floorplan. It connects a {@link Floorplan} and a {@link Scene}
   */
  var Model = function (_EventDispatcher) {
      inherits(Model, _EventDispatcher);

      /** Constructs a new model.
       * @param textureDir The directory containing the textures.
       */
      function Model(textureDir) {
          classCallCheck(this, Model);

          var _this = possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).call(this));

          _this.floorplan = new Floorplan();
          _this.scene = new Scene$1(_this, textureDir);
          _this.roomLoadingCallbacks = null;
          _this.roomLoadedCallbacks = null;
          _this.roomSavedCallbacks = null;
          _this.roomDeletedCallbacks = null;

          return _this;
      }

      createClass(Model, [{
          key: 'switchWireframe',
          value: function switchWireframe(flag) {
              this.scene.switchWireframe(flag);
          }
      }, {
          key: 'loadSerialized',
          value: function loadSerialized(json) {
              // TODO: better documentation on serialization format.
              // TODO: a much better serialization format.
              this.dispatchEvent({ type: EVENT_LOADING, item: this });
              //      this.roomLoadingCallbacks.fire();

              var data = JSON.parse(json);
              this.newRoom(data.floorplan, data.items);

              this.dispatchEvent({ type: EVENT_LOADED, item: this });
              //      this.roomLoadedCallbacks.fire();
          }
      }, {
          key: 'exportMeshAsObj',
          value: function exportMeshAsObj() {
              var exporter = new OBJExporter();
              return exporter.parse(this.scene.getScene());
          }
      }, {
          key: 'exportForBlender',
          value: function exportForBlender() {
              var scope = this;
              var gltfexporter = new threeGltfExporter();
              var meshes = [];
              this.scene.getScene().traverse(function (child) {
                  if (child instanceof Mesh) {
                      if (child.material) {
                          if (child.material.length || child.material.visible) {
                              var op = child.material.transparent ? child.material.opacity : undefined;
                              meshes.push(child);
                              if (op) {
                                  child.material.opacity = op;
                              }
                          }
                      }
                  }
              });

              gltfexporter.parse(meshes, function (result) {
                  var output = JSON.stringify(result, null, 2);
                  scope.dispatchEvent({ type: EVENT_GLTF_READY, item: this, gltf: output });
              });
          }
      }, {
          key: 'exportSerialized',
          value: function exportSerialized() {
              var items_arr = [];
              var objects = this.scene.getItems();
              for (var i = 0; i < objects.length; i++) {
                  var obj = objects[i];
                  //			items_arr[i] = {item_name: obj.metadata.itemName,item_type: obj.metadata.itemType,model_url: obj.metadata.modelUrl,xpos: obj.position.x,ypos: obj.position.y,zpos: obj.position.z,rotation: obj.rotation.y,scale_x: obj.scale.x,scale_y: obj.scale.y,scale_z: obj.scale.z,fixed: obj.fixed};
                  items_arr[i] = obj.getMetaData();
              }

              var room = { floorplan: this.floorplan.saveFloorplan(), items: items_arr };
              return JSON.stringify(room);
          }
      }, {
          key: 'newRoom',
          value: function newRoom(floorplan, items) {
              this.scene.clearItems();
              this.floorplan.loadFloorplan(floorplan);
              // items.forEach((item) => {
              //     var matColors = (item.material_colors) ? item.material_colors : [];
              //     var position = new Vector3(item.xpos, item.ypos, item.zpos);
              //     var metadata = { itemName: item.item_name, resizable: item.resizable, format: item.format, itemType: item.item_type, modelUrl: item.model_url, materialColors: matColors, frame: (item.frame) ? item.frame : '0' };
              //     var scale = new Vector3(item.scale_x, item.scale_y, item.scale_z);
              //     this.scene.addItem(item.item_type, item.model_url, metadata, position, item.rotation, scale, item.fixed);
              // });
          }
      }]);
      return Model;
  }(EventDispatcher);

  /** Meta data for items. */
  var Metadata = function Metadata() {
  	classCallCheck(this, Metadata);

  	this.itemName = '';
  	this.itemType = -1;
  	this.modelUrl = '';
  	this.resizable = false;
  };

  var jquery = createCommonjsModule(function (module) {
  /*!
   * jQuery JavaScript Library v3.5.1
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2020-05-04T22:49Z
   */
  ( function( global, factory ) {

  	{

  		// For CommonJS and CommonJS-like environments where a proper `window`
  		// is present, execute the factory and get jQuery.
  		// For environments that do not have a `window` with a `document`
  		// (such as Node.js), expose a factory as module.exports.
  		// This accentuates the need for the creation of a real `window`.
  		// e.g. var jQuery = require("jquery")(window);
  		// See ticket #14549 for more info.
  		module.exports = global.document ?
  			factory( global, true ) :
  			function( w ) {
  				if ( !w.document ) {
  					throw new Error( "jQuery requires a window with a document" );
  				}
  				return factory( w );
  			};
  	}

  // Pass this if window is not defined yet
  } )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

  var arr = [];

  var getProto = Object.getPrototypeOf;

  var slice = arr.slice;

  var flat = arr.flat ? function( array ) {
  	return arr.flat.call( array );
  } : function( array ) {
  	return arr.concat.apply( [], array );
  };


  var push = arr.push;

  var indexOf = arr.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var fnToString = hasOwn.toString;

  var ObjectFunctionString = fnToString.call( Object );

  var support = {};

  var isFunction = function isFunction( obj ) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };


  var isWindow = function isWindow( obj ) {
  		return obj != null && obj === obj.window;
  	};


  var document = window.document;



  	var preservedScriptAttributes = {
  		type: true,
  		src: true,
  		nonce: true,
  		noModule: true
  	};

  	function DOMEval( code, node, doc ) {
  		doc = doc || document;

  		var i, val,
  			script = doc.createElement( "script" );

  		script.text = code;
  		if ( node ) {
  			for ( i in preservedScriptAttributes ) {

  				// Support: Firefox 64+, Edge 18+
  				// Some browsers don't support the "nonce" property on scripts.
  				// On the other hand, just using `getAttribute` is not enough as
  				// the `nonce` attribute is reset to an empty string whenever it
  				// becomes browsing-context connected.
  				// See https://github.com/whatwg/html/issues/2369
  				// See https://html.spec.whatwg.org/#nonce-attributes
  				// The `node.getAttribute` check was added for the sake of
  				// `jQuery.globalEval` so that it can fake a nonce-containing node
  				// via an object.
  				val = node[ i ] || node.getAttribute && node.getAttribute( i );
  				if ( val ) {
  					script.setAttribute( i, val );
  				}
  			}
  		}
  		doc.head.appendChild( script ).parentNode.removeChild( script );
  	}


  function toType( obj ) {
  	if ( obj == null ) {
  		return obj + "";
  	}

  	// Support: Android <=2.3 only (functionish RegExp)
  	return typeof obj === "object" || typeof obj === "function" ?
  		class2type[ toString.call( obj ) ] || "object" :
  		typeof obj;
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module



  var
  	version = "3.5.1",

  	// Define a local copy of jQuery
  	jQuery = function( selector, context ) {

  		// The jQuery object is actually just the init constructor 'enhanced'
  		// Need init if jQuery is called (just allow error to be thrown if not included)
  		return new jQuery.fn.init( selector, context );
  	};

  jQuery.fn = jQuery.prototype = {

  	// The current version of jQuery being used
  	jquery: version,

  	constructor: jQuery,

  	// The default length of a jQuery object is 0
  	length: 0,

  	toArray: function() {
  		return slice.call( this );
  	},

  	// Get the Nth element in the matched element set OR
  	// Get the whole matched element set as a clean array
  	get: function( num ) {

  		// Return all the elements in a clean array
  		if ( num == null ) {
  			return slice.call( this );
  		}

  		// Return just the one element from the set
  		return num < 0 ? this[ num + this.length ] : this[ num ];
  	},

  	// Take an array of elements and push it onto the stack
  	// (returning the new matched element set)
  	pushStack: function( elems ) {

  		// Build a new jQuery matched element set
  		var ret = jQuery.merge( this.constructor(), elems );

  		// Add the old object onto the stack (as a reference)
  		ret.prevObject = this;

  		// Return the newly-formed element set
  		return ret;
  	},

  	// Execute a callback for every element in the matched set.
  	each: function( callback ) {
  		return jQuery.each( this, callback );
  	},

  	map: function( callback ) {
  		return this.pushStack( jQuery.map( this, function( elem, i ) {
  			return callback.call( elem, i, elem );
  		} ) );
  	},

  	slice: function() {
  		return this.pushStack( slice.apply( this, arguments ) );
  	},

  	first: function() {
  		return this.eq( 0 );
  	},

  	last: function() {
  		return this.eq( -1 );
  	},

  	even: function() {
  		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  			return ( i + 1 ) % 2;
  		} ) );
  	},

  	odd: function() {
  		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  			return i % 2;
  		} ) );
  	},

  	eq: function( i ) {
  		var len = this.length,
  			j = +i + ( i < 0 ? len : 0 );
  		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  	},

  	end: function() {
  		return this.prevObject || this.constructor();
  	},

  	// For internal use only.
  	// Behaves like an Array's method, not like a jQuery method.
  	push: push,
  	sort: arr.sort,
  	splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function() {
  	var options, name, src, copy, copyIsArray, clone,
  		target = arguments[ 0 ] || {},
  		i = 1,
  		length = arguments.length,
  		deep = false;

  	// Handle a deep copy situation
  	if ( typeof target === "boolean" ) {
  		deep = target;

  		// Skip the boolean and the target
  		target = arguments[ i ] || {};
  		i++;
  	}

  	// Handle case when target is a string or something (possible in deep copy)
  	if ( typeof target !== "object" && !isFunction( target ) ) {
  		target = {};
  	}

  	// Extend jQuery itself if only one argument is passed
  	if ( i === length ) {
  		target = this;
  		i--;
  	}

  	for ( ; i < length; i++ ) {

  		// Only deal with non-null/undefined values
  		if ( ( options = arguments[ i ] ) != null ) {

  			// Extend the base object
  			for ( name in options ) {
  				copy = options[ name ];

  				// Prevent Object.prototype pollution
  				// Prevent never-ending loop
  				if ( name === "__proto__" || target === copy ) {
  					continue;
  				}

  				// Recurse if we're merging plain objects or arrays
  				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
  					( copyIsArray = Array.isArray( copy ) ) ) ) {
  					src = target[ name ];

  					// Ensure proper type for the source value
  					if ( copyIsArray && !Array.isArray( src ) ) {
  						clone = [];
  					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
  						clone = {};
  					} else {
  						clone = src;
  					}
  					copyIsArray = false;

  					// Never move original objects, clone them
  					target[ name ] = jQuery.extend( deep, clone, copy );

  				// Don't bring in undefined values
  				} else if ( copy !== undefined ) {
  					target[ name ] = copy;
  				}
  			}
  		}
  	}

  	// Return the modified object
  	return target;
  };

  jQuery.extend( {

  	// Unique for each copy of jQuery on the page
  	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  	// Assume jQuery is ready without the ready module
  	isReady: true,

  	error: function( msg ) {
  		throw new Error( msg );
  	},

  	noop: function() {},

  	isPlainObject: function( obj ) {
  		var proto, Ctor;

  		// Detect obvious negatives
  		// Use toString instead of jQuery.type to catch host objects
  		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
  			return false;
  		}

  		proto = getProto( obj );

  		// Objects with no prototype (e.g., `Object.create( null )`) are plain
  		if ( !proto ) {
  			return true;
  		}

  		// Objects with prototype are plain iff they were constructed by a global Object function
  		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
  		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  	},

  	isEmptyObject: function( obj ) {
  		var name;

  		for ( name in obj ) {
  			return false;
  		}
  		return true;
  	},

  	// Evaluates a script in a provided context; falls back to the global one
  	// if not specified.
  	globalEval: function( code, options, doc ) {
  		DOMEval( code, { nonce: options && options.nonce }, doc );
  	},

  	each: function( obj, callback ) {
  		var length, i = 0;

  		if ( isArrayLike( obj ) ) {
  			length = obj.length;
  			for ( ; i < length; i++ ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		} else {
  			for ( i in obj ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		}

  		return obj;
  	},

  	// results is for internal usage only
  	makeArray: function( arr, results ) {
  		var ret = results || [];

  		if ( arr != null ) {
  			if ( isArrayLike( Object( arr ) ) ) {
  				jQuery.merge( ret,
  					typeof arr === "string" ?
  					[ arr ] : arr
  				);
  			} else {
  				push.call( ret, arr );
  			}
  		}

  		return ret;
  	},

  	inArray: function( elem, arr, i ) {
  		return arr == null ? -1 : indexOf.call( arr, elem, i );
  	},

  	// Support: Android <=4.0 only, PhantomJS 1 only
  	// push.apply(_, arraylike) throws on ancient WebKit
  	merge: function( first, second ) {
  		var len = +second.length,
  			j = 0,
  			i = first.length;

  		for ( ; j < len; j++ ) {
  			first[ i++ ] = second[ j ];
  		}

  		first.length = i;

  		return first;
  	},

  	grep: function( elems, callback, invert ) {
  		var callbackInverse,
  			matches = [],
  			i = 0,
  			length = elems.length,
  			callbackExpect = !invert;

  		// Go through the array, only saving the items
  		// that pass the validator function
  		for ( ; i < length; i++ ) {
  			callbackInverse = !callback( elems[ i ], i );
  			if ( callbackInverse !== callbackExpect ) {
  				matches.push( elems[ i ] );
  			}
  		}

  		return matches;
  	},

  	// arg is for internal usage only
  	map: function( elems, callback, arg ) {
  		var length, value,
  			i = 0,
  			ret = [];

  		// Go through the array, translating each of the items to their new values
  		if ( isArrayLike( elems ) ) {
  			length = elems.length;
  			for ( ; i < length; i++ ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}

  		// Go through every key on the object,
  		} else {
  			for ( i in elems ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}
  		}

  		// Flatten any nested arrays
  		return flat( ret );
  	},

  	// A global GUID counter for objects
  	guid: 1,

  	// jQuery.support is not used in Core but other projects attach their
  	// properties to it so it needs to exist.
  	support: support
  } );

  if ( typeof Symbol === "function" ) {
  	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  }

  // Populate the class2type map
  jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  function( _i, name ) {
  	class2type[ "[object " + name + "]" ] = name.toLowerCase();
  } );

  function isArrayLike( obj ) {

  	// Support: real iOS 8.2 only (not reproducible in simulator)
  	// `in` check used to prevent JIT error (gh-2145)
  	// hasOwn isn't used here due to false negatives
  	// regarding Nodelist length in IE
  	var length = !!obj && "length" in obj && obj.length,
  		type = toType( obj );

  	if ( isFunction( obj ) || isWindow( obj ) ) {
  		return false;
  	}

  	return type === "array" || length === 0 ||
  		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  }
  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.5
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2020-03-14
   */
  ( function( window ) {
  var i,
  	support,
  	Expr,
  	getText,
  	isXML,
  	tokenize,
  	compile,
  	select,
  	outermostContext,
  	sortInput,
  	hasDuplicate,

  	// Local document vars
  	setDocument,
  	document,
  	docElem,
  	documentIsHTML,
  	rbuggyQSA,
  	rbuggyMatches,
  	matches,
  	contains,

  	// Instance-specific data
  	expando = "sizzle" + 1 * new Date(),
  	preferredDoc = window.document,
  	dirruns = 0,
  	done = 0,
  	classCache = createCache(),
  	tokenCache = createCache(),
  	compilerCache = createCache(),
  	nonnativeSelectorCache = createCache(),
  	sortOrder = function( a, b ) {
  		if ( a === b ) {
  			hasDuplicate = true;
  		}
  		return 0;
  	},

  	// Instance methods
  	hasOwn = ( {} ).hasOwnProperty,
  	arr = [],
  	pop = arr.pop,
  	pushNative = arr.push,
  	push = arr.push,
  	slice = arr.slice,

  	// Use a stripped-down indexOf as it's faster than native
  	// https://jsperf.com/thor-indexof-vs-for/5
  	indexOf = function( list, elem ) {
  		var i = 0,
  			len = list.length;
  		for ( ; i < len; i++ ) {
  			if ( list[ i ] === elem ) {
  				return i;
  			}
  		}
  		return -1;
  	},

  	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
  		"ismap|loop|multiple|open|readonly|required|scoped",

  	// Regular expressions

  	// http://www.w3.org/TR/css3-selectors/#whitespace
  	whitespace = "[\\x20\\t\\r\\n\\f]",

  	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
  	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
  		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

  	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

  		// Operator (capture 2)
  		"*([*^$|!~]?=)" + whitespace +

  		// "Attribute values must be CSS identifiers [capture 5]
  		// or strings [capture 3 or capture 4]"
  		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
  		whitespace + "*\\]",

  	pseudos = ":(" + identifier + ")(?:\\((" +

  		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  		// 1. quoted (capture 3; capture 4 or capture 5)
  		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

  		// 2. simple (capture 6)
  		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

  		// 3. anything else (capture 2)
  		".*" +
  		")\\)|)",

  	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  	rwhitespace = new RegExp( whitespace + "+", "g" ),
  	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
  		whitespace + "+$", "g" ),

  	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
  		"*" ),
  	rdescend = new RegExp( whitespace + "|>" ),

  	rpseudo = new RegExp( pseudos ),
  	ridentifier = new RegExp( "^" + identifier + "$" ),

  	matchExpr = {
  		"ID": new RegExp( "^#(" + identifier + ")" ),
  		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
  		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
  		"ATTR": new RegExp( "^" + attributes ),
  		"PSEUDO": new RegExp( "^" + pseudos ),
  		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
  			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
  			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

  		// For use in libraries implementing .is()
  		// We use this for POS matching in `select`
  		"needsContext": new RegExp( "^" + whitespace +
  			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
  			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  	},

  	rhtml = /HTML$/i,
  	rinputs = /^(?:input|select|textarea|button)$/i,
  	rheader = /^h\d$/i,

  	rnative = /^[^{]+\{\s*\[native \w/,

  	// Easily-parseable/retrievable ID or TAG or CLASS selectors
  	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  	rsibling = /[+~]/,

  	// CSS escapes
  	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
  	funescape = function( escape, nonHex ) {
  		var high = "0x" + escape.slice( 1 ) - 0x10000;

  		return nonHex ?

  			// Strip the backslash prefix from a non-hex escape sequence
  			nonHex :

  			// Replace a hexadecimal escape sequence with the encoded Unicode code point
  			// Support: IE <=11+
  			// For values outside the Basic Multilingual Plane (BMP), manually construct a
  			// surrogate pair
  			high < 0 ?
  				String.fromCharCode( high + 0x10000 ) :
  				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  	},

  	// CSS string/identifier serialization
  	// https://drafts.csswg.org/cssom/#common-serializing-idioms
  	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
  	fcssescape = function( ch, asCodePoint ) {
  		if ( asCodePoint ) {

  			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  			if ( ch === "\0" ) {
  				return "\uFFFD";
  			}

  			// Control characters and (dependent upon position) numbers get escaped as code points
  			return ch.slice( 0, -1 ) + "\\" +
  				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
  		}

  		// Other potentially-special ASCII characters get backslash-escaped
  		return "\\" + ch;
  	},

  	// Used for iframes
  	// See setDocument()
  	// Removing the function wrapper causes a "Permission Denied"
  	// error in IE
  	unloadHandler = function() {
  		setDocument();
  	},

  	inDisabledFieldset = addCombinator(
  		function( elem ) {
  			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
  		},
  		{ dir: "parentNode", next: "legend" }
  	);

  // Optimize for push.apply( _, NodeList )
  try {
  	push.apply(
  		( arr = slice.call( preferredDoc.childNodes ) ),
  		preferredDoc.childNodes
  	);

  	// Support: Android<4.0
  	// Detect silently failing push.apply
  	// eslint-disable-next-line no-unused-expressions
  	arr[ preferredDoc.childNodes.length ].nodeType;
  } catch ( e ) {
  	push = { apply: arr.length ?

  		// Leverage slice if possible
  		function( target, els ) {
  			pushNative.apply( target, slice.call( els ) );
  		} :

  		// Support: IE<9
  		// Otherwise append directly
  		function( target, els ) {
  			var j = target.length,
  				i = 0;

  			// Can't trust NodeList.length
  			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
  			target.length = j - 1;
  		}
  	};
  }

  function Sizzle( selector, context, results, seed ) {
  	var m, i, elem, nid, match, groups, newSelector,
  		newContext = context && context.ownerDocument,

  		// nodeType defaults to 9, since context defaults to document
  		nodeType = context ? context.nodeType : 9;

  	results = results || [];

  	// Return early from calls with invalid selector or context
  	if ( typeof selector !== "string" || !selector ||
  		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  		return results;
  	}

  	// Try to shortcut find operations (as opposed to filters) in HTML documents
  	if ( !seed ) {
  		setDocument( context );
  		context = context || document;

  		if ( documentIsHTML ) {

  			// If the selector is sufficiently simple, try using a "get*By*" DOM method
  			// (excepting DocumentFragment context, where the methods don't exist)
  			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

  				// ID selector
  				if ( ( m = match[ 1 ] ) ) {

  					// Document context
  					if ( nodeType === 9 ) {
  						if ( ( elem = context.getElementById( m ) ) ) {

  							// Support: IE, Opera, Webkit
  							// TODO: identify versions
  							// getElementById can match elements by name instead of ID
  							if ( elem.id === m ) {
  								results.push( elem );
  								return results;
  							}
  						} else {
  							return results;
  						}

  					// Element context
  					} else {

  						// Support: IE, Opera, Webkit
  						// TODO: identify versions
  						// getElementById can match elements by name instead of ID
  						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
  							contains( context, elem ) &&
  							elem.id === m ) {

  							results.push( elem );
  							return results;
  						}
  					}

  				// Type selector
  				} else if ( match[ 2 ] ) {
  					push.apply( results, context.getElementsByTagName( selector ) );
  					return results;

  				// Class selector
  				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
  					context.getElementsByClassName ) {

  					push.apply( results, context.getElementsByClassName( m ) );
  					return results;
  				}
  			}

  			// Take advantage of querySelectorAll
  			if ( support.qsa &&
  				!nonnativeSelectorCache[ selector + " " ] &&
  				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

  				// Support: IE 8 only
  				// Exclude object elements
  				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

  				newSelector = selector;
  				newContext = context;

  				// qSA considers elements outside a scoping root when evaluating child or
  				// descendant combinators, which is not what we want.
  				// In such cases, we work around the behavior by prefixing every selector in the
  				// list with an ID selector referencing the scope context.
  				// The technique has to be used as well when a leading combinator is used
  				// as such selectors are not recognized by querySelectorAll.
  				// Thanks to Andrew Dupont for this technique.
  				if ( nodeType === 1 &&
  					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

  					// Expand context for sibling selectors
  					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
  						context;

  					// We can use :scope instead of the ID hack if the browser
  					// supports it & if we're not changing the context.
  					if ( newContext !== context || !support.scope ) {

  						// Capture the context ID, setting it first if necessary
  						if ( ( nid = context.getAttribute( "id" ) ) ) {
  							nid = nid.replace( rcssescape, fcssescape );
  						} else {
  							context.setAttribute( "id", ( nid = expando ) );
  						}
  					}

  					// Prefix every selector in the list
  					groups = tokenize( selector );
  					i = groups.length;
  					while ( i-- ) {
  						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
  							toSelector( groups[ i ] );
  					}
  					newSelector = groups.join( "," );
  				}

  				try {
  					push.apply( results,
  						newContext.querySelectorAll( newSelector )
  					);
  					return results;
  				} catch ( qsaError ) {
  					nonnativeSelectorCache( selector, true );
  				} finally {
  					if ( nid === expando ) {
  						context.removeAttribute( "id" );
  					}
  				}
  			}
  		}
  	}

  	// All others
  	return select( selector.replace( rtrim, "$1" ), context, results, seed );
  }

  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
  	var keys = [];

  	function cache( key, value ) {

  		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
  		if ( keys.push( key + " " ) > Expr.cacheLength ) {

  			// Only keep the most recent entries
  			delete cache[ keys.shift() ];
  		}
  		return ( cache[ key + " " ] = value );
  	}
  	return cache;
  }

  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
  function markFunction( fn ) {
  	fn[ expando ] = true;
  	return fn;
  }

  /**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
  function assert( fn ) {
  	var el = document.createElement( "fieldset" );

  	try {
  		return !!fn( el );
  	} catch ( e ) {
  		return false;
  	} finally {

  		// Remove from its parent by default
  		if ( el.parentNode ) {
  			el.parentNode.removeChild( el );
  		}

  		// release memory in IE
  		el = null;
  	}
  }

  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
  function addHandle( attrs, handler ) {
  	var arr = attrs.split( "|" ),
  		i = arr.length;

  	while ( i-- ) {
  		Expr.attrHandle[ arr[ i ] ] = handler;
  	}
  }

  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
  function siblingCheck( a, b ) {
  	var cur = b && a,
  		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
  			a.sourceIndex - b.sourceIndex;

  	// Use IE sourceIndex if available on both nodes
  	if ( diff ) {
  		return diff;
  	}

  	// Check if b follows a
  	if ( cur ) {
  		while ( ( cur = cur.nextSibling ) ) {
  			if ( cur === b ) {
  				return -1;
  			}
  		}
  	}

  	return a ? 1 : -1;
  }

  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return name === "input" && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return ( name === "input" || name === "button" ) && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
  function createDisabledPseudo( disabled ) {

  	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  	return function( elem ) {

  		// Only certain elements can match :enabled or :disabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  		if ( "form" in elem ) {

  			// Check for inherited disabledness on relevant non-disabled elements:
  			// * listed form-associated elements in a disabled fieldset
  			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  			// * option elements in a disabled optgroup
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  			// All such elements have a "form" property.
  			if ( elem.parentNode && elem.disabled === false ) {

  				// Option elements defer to a parent optgroup if present
  				if ( "label" in elem ) {
  					if ( "label" in elem.parentNode ) {
  						return elem.parentNode.disabled === disabled;
  					} else {
  						return elem.disabled === disabled;
  					}
  				}

  				// Support: IE 6 - 11
  				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
  				return elem.isDisabled === disabled ||

  					// Where there is no isDisabled, check manually
  					/* jshint -W018 */
  					elem.isDisabled !== !disabled &&
  					inDisabledFieldset( elem ) === disabled;
  			}

  			return elem.disabled === disabled;

  		// Try to winnow out elements that can't be disabled before trusting the disabled property.
  		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
  		// even exist on them, let alone have a boolean value.
  		} else if ( "label" in elem ) {
  			return elem.disabled === disabled;
  		}

  		// Remaining elements are neither :enabled nor :disabled
  		return false;
  	};
  }

  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo( fn ) {
  	return markFunction( function( argument ) {
  		argument = +argument;
  		return markFunction( function( seed, matches ) {
  			var j,
  				matchIndexes = fn( [], seed.length, argument ),
  				i = matchIndexes.length;

  			// Match elements found at the specified indexes
  			while ( i-- ) {
  				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
  					seed[ j ] = !( matches[ j ] = seed[ j ] );
  				}
  			}
  		} );
  	} );
  }

  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext( context ) {
  	return context && typeof context.getElementsByTagName !== "undefined" && context;
  }

  // Expose support vars for convenience
  support = Sizzle.support = {};

  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
  isXML = Sizzle.isXML = function( elem ) {
  	var namespace = elem.namespaceURI,
  		docElem = ( elem.ownerDocument || elem ).documentElement;

  	// Support: IE <=8
  	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
  	// https://bugs.jquery.com/ticket/4833
  	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
  };

  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  setDocument = Sizzle.setDocument = function( node ) {
  	var hasCompare, subWindow,
  		doc = node ? node.ownerDocument || node : preferredDoc;

  	// Return early if doc is invalid or already selected
  	// Support: IE 11+, Edge 17 - 18+
  	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  	// two documents; shallow comparisons work.
  	// eslint-disable-next-line eqeqeq
  	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
  		return document;
  	}

  	// Update global variables
  	document = doc;
  	docElem = document.documentElement;
  	documentIsHTML = !isXML( document );

  	// Support: IE 9 - 11+, Edge 12 - 18+
  	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
  	// Support: IE 11+, Edge 17 - 18+
  	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  	// two documents; shallow comparisons work.
  	// eslint-disable-next-line eqeqeq
  	if ( preferredDoc != document &&
  		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

  		// Support: IE 11, Edge
  		if ( subWindow.addEventListener ) {
  			subWindow.addEventListener( "unload", unloadHandler, false );

  		// Support: IE 9 - 10 only
  		} else if ( subWindow.attachEvent ) {
  			subWindow.attachEvent( "onunload", unloadHandler );
  		}
  	}

  	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
  	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
  	// IE/Edge & older browsers don't support the :scope pseudo-class.
  	// Support: Safari 6.0 only
  	// Safari 6.0 supports :scope but it's an alias of :root there.
  	support.scope = assert( function( el ) {
  		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
  		return typeof el.querySelectorAll !== "undefined" &&
  			!el.querySelectorAll( ":scope fieldset div" ).length;
  	} );

  	/* Attributes
  	---------------------------------------------------------------------- */

  	// Support: IE<8
  	// Verify that getAttribute really returns attributes and not properties
  	// (excepting IE8 booleans)
  	support.attributes = assert( function( el ) {
  		el.className = "i";
  		return !el.getAttribute( "className" );
  	} );

  	/* getElement(s)By*
  	---------------------------------------------------------------------- */

  	// Check if getElementsByTagName("*") returns only elements
  	support.getElementsByTagName = assert( function( el ) {
  		el.appendChild( document.createComment( "" ) );
  		return !el.getElementsByTagName( "*" ).length;
  	} );

  	// Support: IE<9
  	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

  	// Support: IE<10
  	// Check if getElementById returns elements by name
  	// The broken getElementById methods don't pick up programmatically-set names,
  	// so use a roundabout getElementsByName test
  	support.getById = assert( function( el ) {
  		docElem.appendChild( el ).id = expando;
  		return !document.getElementsByName || !document.getElementsByName( expando ).length;
  	} );

  	// ID filter and find
  	if ( support.getById ) {
  		Expr.filter[ "ID" ] = function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				return elem.getAttribute( "id" ) === attrId;
  			};
  		};
  		Expr.find[ "ID" ] = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var elem = context.getElementById( id );
  				return elem ? [ elem ] : [];
  			}
  		};
  	} else {
  		Expr.filter[ "ID" ] =  function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				var node = typeof elem.getAttributeNode !== "undefined" &&
  					elem.getAttributeNode( "id" );
  				return node && node.value === attrId;
  			};
  		};

  		// Support: IE 6 - 7 only
  		// getElementById is not reliable as a find shortcut
  		Expr.find[ "ID" ] = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var node, i, elems,
  					elem = context.getElementById( id );

  				if ( elem ) {

  					// Verify the id attribute
  					node = elem.getAttributeNode( "id" );
  					if ( node && node.value === id ) {
  						return [ elem ];
  					}

  					// Fall back on getElementsByName
  					elems = context.getElementsByName( id );
  					i = 0;
  					while ( ( elem = elems[ i++ ] ) ) {
  						node = elem.getAttributeNode( "id" );
  						if ( node && node.value === id ) {
  							return [ elem ];
  						}
  					}
  				}

  				return [];
  			}
  		};
  	}

  	// Tag
  	Expr.find[ "TAG" ] = support.getElementsByTagName ?
  		function( tag, context ) {
  			if ( typeof context.getElementsByTagName !== "undefined" ) {
  				return context.getElementsByTagName( tag );

  			// DocumentFragment nodes don't have gEBTN
  			} else if ( support.qsa ) {
  				return context.querySelectorAll( tag );
  			}
  		} :

  		function( tag, context ) {
  			var elem,
  				tmp = [],
  				i = 0,

  				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
  				results = context.getElementsByTagName( tag );

  			// Filter out possible comments
  			if ( tag === "*" ) {
  				while ( ( elem = results[ i++ ] ) ) {
  					if ( elem.nodeType === 1 ) {
  						tmp.push( elem );
  					}
  				}

  				return tmp;
  			}
  			return results;
  		};

  	// Class
  	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
  		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
  			return context.getElementsByClassName( className );
  		}
  	};

  	/* QSA/matchesSelector
  	---------------------------------------------------------------------- */

  	// QSA and matchesSelector support

  	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  	rbuggyMatches = [];

  	// qSa(:focus) reports false when true (Chrome 21)
  	// We allow this because of a bug in IE8/9 that throws an error
  	// whenever `document.activeElement` is accessed on an iframe
  	// So, we allow :focus to pass through QSA all the time to avoid the IE error
  	// See https://bugs.jquery.com/ticket/13378
  	rbuggyQSA = [];

  	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

  		// Build QSA regex
  		// Regex strategy adopted from Diego Perini
  		assert( function( el ) {

  			var input;

  			// Select is set to empty string on purpose
  			// This is to test IE's treatment of not explicitly
  			// setting a boolean content attribute,
  			// since its presence should be enough
  			// https://bugs.jquery.com/ticket/12359
  			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
  				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
  				"<option selected=''></option></select>";

  			// Support: IE8, Opera 11-12.16
  			// Nothing should be selected when empty strings follow ^= or $= or *=
  			// The test attribute must be unknown in Opera but "safe" for WinRT
  			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
  			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
  				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
  			}

  			// Support: IE8
  			// Boolean attributes and "value" are not treated correctly
  			if ( !el.querySelectorAll( "[selected]" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  			}

  			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
  			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  				rbuggyQSA.push( "~=" );
  			}

  			// Support: IE 11+, Edge 15 - 18+
  			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
  			// Adding a temporary attribute to the document before the selection works
  			// around the issue.
  			// Interestingly, IE 10 & older don't seem to have the issue.
  			input = document.createElement( "input" );
  			input.setAttribute( "name", "" );
  			el.appendChild( input );
  			if ( !el.querySelectorAll( "[name='']" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
  					whitespace + "*(?:''|\"\")" );
  			}

  			// Webkit/Opera - :checked should return selected option elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			// IE8 throws error here and will not see later tests
  			if ( !el.querySelectorAll( ":checked" ).length ) {
  				rbuggyQSA.push( ":checked" );
  			}

  			// Support: Safari 8+, iOS 8+
  			// https://bugs.webkit.org/show_bug.cgi?id=136851
  			// In-page `selector#id sibling-combinator selector` fails
  			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
  				rbuggyQSA.push( ".#.+[+~]" );
  			}

  			// Support: Firefox <=3.6 - 5 only
  			// Old Firefox doesn't throw on a badly-escaped identifier.
  			el.querySelectorAll( "\\\f" );
  			rbuggyQSA.push( "[\\r\\n\\f]" );
  		} );

  		assert( function( el ) {
  			el.innerHTML = "<a href='' disabled='disabled'></a>" +
  				"<select disabled='disabled'><option/></select>";

  			// Support: Windows 8 Native Apps
  			// The type and name attributes are restricted during .innerHTML assignment
  			var input = document.createElement( "input" );
  			input.setAttribute( "type", "hidden" );
  			el.appendChild( input ).setAttribute( "name", "D" );

  			// Support: IE8
  			// Enforce case-sensitivity of name attribute
  			if ( el.querySelectorAll( "[name=d]" ).length ) {
  				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
  			}

  			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
  			// IE8 throws error here and will not see later tests
  			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Support: IE9-11+
  			// IE's :disabled selector does not pick up the children of disabled fieldsets
  			docElem.appendChild( el ).disabled = true;
  			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Support: Opera 10 - 11 only
  			// Opera 10-11 does not throw on post-comma invalid pseudos
  			el.querySelectorAll( "*,:x" );
  			rbuggyQSA.push( ",.*:" );
  		} );
  	}

  	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
  		docElem.webkitMatchesSelector ||
  		docElem.mozMatchesSelector ||
  		docElem.oMatchesSelector ||
  		docElem.msMatchesSelector ) ) ) ) {

  		assert( function( el ) {

  			// Check to see if it's possible to do matchesSelector
  			// on a disconnected node (IE 9)
  			support.disconnectedMatch = matches.call( el, "*" );

  			// This should fail with an exception
  			// Gecko does not error, returns false instead
  			matches.call( el, "[s!='']:x" );
  			rbuggyMatches.push( "!=", pseudos );
  		} );
  	}

  	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
  	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

  	/* Contains
  	---------------------------------------------------------------------- */
  	hasCompare = rnative.test( docElem.compareDocumentPosition );

  	// Element contains another
  	// Purposefully self-exclusive
  	// As in, an element does not contain itself
  	contains = hasCompare || rnative.test( docElem.contains ) ?
  		function( a, b ) {
  			var adown = a.nodeType === 9 ? a.documentElement : a,
  				bup = b && b.parentNode;
  			return a === bup || !!( bup && bup.nodeType === 1 && (
  				adown.contains ?
  					adown.contains( bup ) :
  					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  			) );
  		} :
  		function( a, b ) {
  			if ( b ) {
  				while ( ( b = b.parentNode ) ) {
  					if ( b === a ) {
  						return true;
  					}
  				}
  			}
  			return false;
  		};

  	/* Sorting
  	---------------------------------------------------------------------- */

  	// Document order sorting
  	sortOrder = hasCompare ?
  	function( a, b ) {

  		// Flag for duplicate removal
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		// Sort on method existence if only one input has compareDocumentPosition
  		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  		if ( compare ) {
  			return compare;
  		}

  		// Calculate position if both inputs belong to the same document
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
  			a.compareDocumentPosition( b ) :

  			// Otherwise we know they are disconnected
  			1;

  		// Disconnected nodes
  		if ( compare & 1 ||
  			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

  			// Choose the first element that is related to our preferred document
  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			if ( a == document || a.ownerDocument == preferredDoc &&
  				contains( preferredDoc, a ) ) {
  				return -1;
  			}

  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			if ( b == document || b.ownerDocument == preferredDoc &&
  				contains( preferredDoc, b ) ) {
  				return 1;
  			}

  			// Maintain original order
  			return sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;
  		}

  		return compare & 4 ? -1 : 1;
  	} :
  	function( a, b ) {

  		// Exit early if the nodes are identical
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		var cur,
  			i = 0,
  			aup = a.parentNode,
  			bup = b.parentNode,
  			ap = [ a ],
  			bp = [ b ];

  		// Parentless nodes are either documents or disconnected
  		if ( !aup || !bup ) {

  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			/* eslint-disable eqeqeq */
  			return a == document ? -1 :
  				b == document ? 1 :
  				/* eslint-enable eqeqeq */
  				aup ? -1 :
  				bup ? 1 :
  				sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;

  		// If the nodes are siblings, we can do a quick check
  		} else if ( aup === bup ) {
  			return siblingCheck( a, b );
  		}

  		// Otherwise we need full lists of their ancestors for comparison
  		cur = a;
  		while ( ( cur = cur.parentNode ) ) {
  			ap.unshift( cur );
  		}
  		cur = b;
  		while ( ( cur = cur.parentNode ) ) {
  			bp.unshift( cur );
  		}

  		// Walk down the tree looking for a discrepancy
  		while ( ap[ i ] === bp[ i ] ) {
  			i++;
  		}

  		return i ?

  			// Do a sibling check if the nodes have a common ancestor
  			siblingCheck( ap[ i ], bp[ i ] ) :

  			// Otherwise nodes in our document sort first
  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			/* eslint-disable eqeqeq */
  			ap[ i ] == preferredDoc ? -1 :
  			bp[ i ] == preferredDoc ? 1 :
  			/* eslint-enable eqeqeq */
  			0;
  	};

  	return document;
  };

  Sizzle.matches = function( expr, elements ) {
  	return Sizzle( expr, null, null, elements );
  };

  Sizzle.matchesSelector = function( elem, expr ) {
  	setDocument( elem );

  	if ( support.matchesSelector && documentIsHTML &&
  		!nonnativeSelectorCache[ expr + " " ] &&
  		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
  		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

  		try {
  			var ret = matches.call( elem, expr );

  			// IE 9's matchesSelector returns false on disconnected nodes
  			if ( ret || support.disconnectedMatch ||

  				// As well, disconnected nodes are said to be in a document
  				// fragment in IE 9
  				elem.document && elem.document.nodeType !== 11 ) {
  				return ret;
  			}
  		} catch ( e ) {
  			nonnativeSelectorCache( expr, true );
  		}
  	}

  	return Sizzle( expr, document, null, [ elem ] ).length > 0;
  };

  Sizzle.contains = function( context, elem ) {

  	// Set document vars if needed
  	// Support: IE 11+, Edge 17 - 18+
  	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  	// two documents; shallow comparisons work.
  	// eslint-disable-next-line eqeqeq
  	if ( ( context.ownerDocument || context ) != document ) {
  		setDocument( context );
  	}
  	return contains( context, elem );
  };

  Sizzle.attr = function( elem, name ) {

  	// Set document vars if needed
  	// Support: IE 11+, Edge 17 - 18+
  	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  	// two documents; shallow comparisons work.
  	// eslint-disable-next-line eqeqeq
  	if ( ( elem.ownerDocument || elem ) != document ) {
  		setDocument( elem );
  	}

  	var fn = Expr.attrHandle[ name.toLowerCase() ],

  		// Don't get fooled by Object.prototype properties (jQuery #13807)
  		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  			fn( elem, name, !documentIsHTML ) :
  			undefined;

  	return val !== undefined ?
  		val :
  		support.attributes || !documentIsHTML ?
  			elem.getAttribute( name ) :
  			( val = elem.getAttributeNode( name ) ) && val.specified ?
  				val.value :
  				null;
  };

  Sizzle.escape = function( sel ) {
  	return ( sel + "" ).replace( rcssescape, fcssescape );
  };

  Sizzle.error = function( msg ) {
  	throw new Error( "Syntax error, unrecognized expression: " + msg );
  };

  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  Sizzle.uniqueSort = function( results ) {
  	var elem,
  		duplicates = [],
  		j = 0,
  		i = 0;

  	// Unless we *know* we can detect duplicates, assume their presence
  	hasDuplicate = !support.detectDuplicates;
  	sortInput = !support.sortStable && results.slice( 0 );
  	results.sort( sortOrder );

  	if ( hasDuplicate ) {
  		while ( ( elem = results[ i++ ] ) ) {
  			if ( elem === results[ i ] ) {
  				j = duplicates.push( i );
  			}
  		}
  		while ( j-- ) {
  			results.splice( duplicates[ j ], 1 );
  		}
  	}

  	// Clear input after sorting to release objects
  	// See https://github.com/jquery/sizzle/pull/225
  	sortInput = null;

  	return results;
  };

  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
  getText = Sizzle.getText = function( elem ) {
  	var node,
  		ret = "",
  		i = 0,
  		nodeType = elem.nodeType;

  	if ( !nodeType ) {

  		// If no nodeType, this is expected to be an array
  		while ( ( node = elem[ i++ ] ) ) {

  			// Do not traverse comment nodes
  			ret += getText( node );
  		}
  	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

  		// Use textContent for elements
  		// innerText usage removed for consistency of new lines (jQuery #11153)
  		if ( typeof elem.textContent === "string" ) {
  			return elem.textContent;
  		} else {

  			// Traverse its children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				ret += getText( elem );
  			}
  		}
  	} else if ( nodeType === 3 || nodeType === 4 ) {
  		return elem.nodeValue;
  	}

  	// Do not include comment or processing instruction nodes

  	return ret;
  };

  Expr = Sizzle.selectors = {

  	// Can be adjusted by the user
  	cacheLength: 50,

  	createPseudo: markFunction,

  	match: matchExpr,

  	attrHandle: {},

  	find: {},

  	relative: {
  		">": { dir: "parentNode", first: true },
  		" ": { dir: "parentNode" },
  		"+": { dir: "previousSibling", first: true },
  		"~": { dir: "previousSibling" }
  	},

  	preFilter: {
  		"ATTR": function( match ) {
  			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

  			// Move the given value to match[3] whether quoted or unquoted
  			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
  				match[ 5 ] || "" ).replace( runescape, funescape );

  			if ( match[ 2 ] === "~=" ) {
  				match[ 3 ] = " " + match[ 3 ] + " ";
  			}

  			return match.slice( 0, 4 );
  		},

  		"CHILD": function( match ) {

  			/* matches from matchExpr["CHILD"]
  				1 type (only|nth|...)
  				2 what (child|of-type)
  				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  				4 xn-component of xn+y argument ([+-]?\d*n|)
  				5 sign of xn-component
  				6 x of xn-component
  				7 sign of y-component
  				8 y of y-component
  			*/
  			match[ 1 ] = match[ 1 ].toLowerCase();

  			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

  				// nth-* requires argument
  				if ( !match[ 3 ] ) {
  					Sizzle.error( match[ 0 ] );
  				}

  				// numeric x and y parameters for Expr.filter.CHILD
  				// remember that false/true cast respectively to 0/1
  				match[ 4 ] = +( match[ 4 ] ?
  					match[ 5 ] + ( match[ 6 ] || 1 ) :
  					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
  				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

  				// other types prohibit arguments
  			} else if ( match[ 3 ] ) {
  				Sizzle.error( match[ 0 ] );
  			}

  			return match;
  		},

  		"PSEUDO": function( match ) {
  			var excess,
  				unquoted = !match[ 6 ] && match[ 2 ];

  			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
  				return null;
  			}

  			// Accept quoted arguments as-is
  			if ( match[ 3 ] ) {
  				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

  			// Strip excess characters from unquoted arguments
  			} else if ( unquoted && rpseudo.test( unquoted ) &&

  				// Get excess from tokenize (recursively)
  				( excess = tokenize( unquoted, true ) ) &&

  				// advance to the next closing parenthesis
  				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

  				// excess is a negative index
  				match[ 0 ] = match[ 0 ].slice( 0, excess );
  				match[ 2 ] = unquoted.slice( 0, excess );
  			}

  			// Return only captures needed by the pseudo filter method (type and argument)
  			return match.slice( 0, 3 );
  		}
  	},

  	filter: {

  		"TAG": function( nodeNameSelector ) {
  			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  			return nodeNameSelector === "*" ?
  				function() {
  					return true;
  				} :
  				function( elem ) {
  					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
  				};
  		},

  		"CLASS": function( className ) {
  			var pattern = classCache[ className + " " ];

  			return pattern ||
  				( pattern = new RegExp( "(^|" + whitespace +
  					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
  						className, function( elem ) {
  							return pattern.test(
  								typeof elem.className === "string" && elem.className ||
  								typeof elem.getAttribute !== "undefined" &&
  									elem.getAttribute( "class" ) ||
  								""
  							);
  				} );
  		},

  		"ATTR": function( name, operator, check ) {
  			return function( elem ) {
  				var result = Sizzle.attr( elem, name );

  				if ( result == null ) {
  					return operator === "!=";
  				}
  				if ( !operator ) {
  					return true;
  				}

  				result += "";

  				/* eslint-disable max-len */

  				return operator === "=" ? result === check :
  					operator === "!=" ? result !== check :
  					operator === "^=" ? check && result.indexOf( check ) === 0 :
  					operator === "*=" ? check && result.indexOf( check ) > -1 :
  					operator === "$=" ? check && result.slice( -check.length ) === check :
  					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
  					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
  					false;
  				/* eslint-enable max-len */

  			};
  		},

  		"CHILD": function( type, what, _argument, first, last ) {
  			var simple = type.slice( 0, 3 ) !== "nth",
  				forward = type.slice( -4 ) !== "last",
  				ofType = what === "of-type";

  			return first === 1 && last === 0 ?

  				// Shortcut for :nth-*(n)
  				function( elem ) {
  					return !!elem.parentNode;
  				} :

  				function( elem, _context, xml ) {
  					var cache, uniqueCache, outerCache, node, nodeIndex, start,
  						dir = simple !== forward ? "nextSibling" : "previousSibling",
  						parent = elem.parentNode,
  						name = ofType && elem.nodeName.toLowerCase(),
  						useCache = !xml && !ofType,
  						diff = false;

  					if ( parent ) {

  						// :(first|last|only)-(child|of-type)
  						if ( simple ) {
  							while ( dir ) {
  								node = elem;
  								while ( ( node = node[ dir ] ) ) {
  									if ( ofType ?
  										node.nodeName.toLowerCase() === name :
  										node.nodeType === 1 ) {

  										return false;
  									}
  								}

  								// Reverse direction for :only-* (if we haven't yet done so)
  								start = dir = type === "only" && !start && "nextSibling";
  							}
  							return true;
  						}

  						start = [ forward ? parent.firstChild : parent.lastChild ];

  						// non-xml :nth-child(...) stores cache data on `parent`
  						if ( forward && useCache ) {

  							// Seek `elem` from a previously-cached index

  							// ...in a gzip-friendly way
  							node = parent;
  							outerCache = node[ expando ] || ( node[ expando ] = {} );

  							// Support: IE <9 only
  							// Defend against cloned attroperties (jQuery gh-1709)
  							uniqueCache = outerCache[ node.uniqueID ] ||
  								( outerCache[ node.uniqueID ] = {} );

  							cache = uniqueCache[ type ] || [];
  							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  							diff = nodeIndex && cache[ 2 ];
  							node = nodeIndex && parent.childNodes[ nodeIndex ];

  							while ( ( node = ++nodeIndex && node && node[ dir ] ||

  								// Fallback to seeking `elem` from the start
  								( diff = nodeIndex = 0 ) || start.pop() ) ) {

  								// When found, cache indexes on `parent` and break
  								if ( node.nodeType === 1 && ++diff && node === elem ) {
  									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
  									break;
  								}
  							}

  						} else {

  							// Use previously-cached element index if available
  							if ( useCache ) {

  								// ...in a gzip-friendly way
  								node = elem;
  								outerCache = node[ expando ] || ( node[ expando ] = {} );

  								// Support: IE <9 only
  								// Defend against cloned attroperties (jQuery gh-1709)
  								uniqueCache = outerCache[ node.uniqueID ] ||
  									( outerCache[ node.uniqueID ] = {} );

  								cache = uniqueCache[ type ] || [];
  								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  								diff = nodeIndex;
  							}

  							// xml :nth-child(...)
  							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
  							if ( diff === false ) {

  								// Use the same loop as above to seek `elem` from the start
  								while ( ( node = ++nodeIndex && node && node[ dir ] ||
  									( diff = nodeIndex = 0 ) || start.pop() ) ) {

  									if ( ( ofType ?
  										node.nodeName.toLowerCase() === name :
  										node.nodeType === 1 ) &&
  										++diff ) {

  										// Cache the index of each encountered element
  										if ( useCache ) {
  											outerCache = node[ expando ] ||
  												( node[ expando ] = {} );

  											// Support: IE <9 only
  											// Defend against cloned attroperties (jQuery gh-1709)
  											uniqueCache = outerCache[ node.uniqueID ] ||
  												( outerCache[ node.uniqueID ] = {} );

  											uniqueCache[ type ] = [ dirruns, diff ];
  										}

  										if ( node === elem ) {
  											break;
  										}
  									}
  								}
  							}
  						}

  						// Incorporate the offset, then check against cycle size
  						diff -= last;
  						return diff === first || ( diff % first === 0 && diff / first >= 0 );
  					}
  				};
  		},

  		"PSEUDO": function( pseudo, argument ) {

  			// pseudo-class names are case-insensitive
  			// http://www.w3.org/TR/selectors/#pseudo-classes
  			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  			// Remember that setFilters inherits from pseudos
  			var args,
  				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  					Sizzle.error( "unsupported pseudo: " + pseudo );

  			// The user may use createPseudo to indicate that
  			// arguments are needed to create the filter function
  			// just as Sizzle does
  			if ( fn[ expando ] ) {
  				return fn( argument );
  			}

  			// But maintain support for old signatures
  			if ( fn.length > 1 ) {
  				args = [ pseudo, pseudo, "", argument ];
  				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  					markFunction( function( seed, matches ) {
  						var idx,
  							matched = fn( seed, argument ),
  							i = matched.length;
  						while ( i-- ) {
  							idx = indexOf( seed, matched[ i ] );
  							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
  						}
  					} ) :
  					function( elem ) {
  						return fn( elem, 0, args );
  					};
  			}

  			return fn;
  		}
  	},

  	pseudos: {

  		// Potentially complex pseudos
  		"not": markFunction( function( selector ) {

  			// Trim the selector passed to compile
  			// to avoid treating leading and trailing
  			// spaces as combinators
  			var input = [],
  				results = [],
  				matcher = compile( selector.replace( rtrim, "$1" ) );

  			return matcher[ expando ] ?
  				markFunction( function( seed, matches, _context, xml ) {
  					var elem,
  						unmatched = matcher( seed, null, xml, [] ),
  						i = seed.length;

  					// Match elements unmatched by `matcher`
  					while ( i-- ) {
  						if ( ( elem = unmatched[ i ] ) ) {
  							seed[ i ] = !( matches[ i ] = elem );
  						}
  					}
  				} ) :
  				function( elem, _context, xml ) {
  					input[ 0 ] = elem;
  					matcher( input, null, xml, results );

  					// Don't keep the element (issue #299)
  					input[ 0 ] = null;
  					return !results.pop();
  				};
  		} ),

  		"has": markFunction( function( selector ) {
  			return function( elem ) {
  				return Sizzle( selector, elem ).length > 0;
  			};
  		} ),

  		"contains": markFunction( function( text ) {
  			text = text.replace( runescape, funescape );
  			return function( elem ) {
  				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
  			};
  		} ),

  		// "Whether an element is represented by a :lang() selector
  		// is based solely on the element's language value
  		// being equal to the identifier C,
  		// or beginning with the identifier C immediately followed by "-".
  		// The matching of C against the element's language value is performed case-insensitively.
  		// The identifier C does not have to be a valid language name."
  		// http://www.w3.org/TR/selectors/#lang-pseudo
  		"lang": markFunction( function( lang ) {

  			// lang value must be a valid identifier
  			if ( !ridentifier.test( lang || "" ) ) {
  				Sizzle.error( "unsupported lang: " + lang );
  			}
  			lang = lang.replace( runescape, funescape ).toLowerCase();
  			return function( elem ) {
  				var elemLang;
  				do {
  					if ( ( elemLang = documentIsHTML ?
  						elem.lang :
  						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

  						elemLang = elemLang.toLowerCase();
  						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  					}
  				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
  				return false;
  			};
  		} ),

  		// Miscellaneous
  		"target": function( elem ) {
  			var hash = window.location && window.location.hash;
  			return hash && hash.slice( 1 ) === elem.id;
  		},

  		"root": function( elem ) {
  			return elem === docElem;
  		},

  		"focus": function( elem ) {
  			return elem === document.activeElement &&
  				( !document.hasFocus || document.hasFocus() ) &&
  				!!( elem.type || elem.href || ~elem.tabIndex );
  		},

  		// Boolean properties
  		"enabled": createDisabledPseudo( false ),
  		"disabled": createDisabledPseudo( true ),

  		"checked": function( elem ) {

  			// In CSS3, :checked should return both checked and selected elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			var nodeName = elem.nodeName.toLowerCase();
  			return ( nodeName === "input" && !!elem.checked ) ||
  				( nodeName === "option" && !!elem.selected );
  		},

  		"selected": function( elem ) {

  			// Accessing this property makes selected-by-default
  			// options in Safari work properly
  			if ( elem.parentNode ) {
  				// eslint-disable-next-line no-unused-expressions
  				elem.parentNode.selectedIndex;
  			}

  			return elem.selected === true;
  		},

  		// Contents
  		"empty": function( elem ) {

  			// http://www.w3.org/TR/selectors/#empty-pseudo
  			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  			//   but not by others (comment: 8; processing instruction: 7; etc.)
  			// nodeType < 6 works because attributes (2) do not appear as children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				if ( elem.nodeType < 6 ) {
  					return false;
  				}
  			}
  			return true;
  		},

  		"parent": function( elem ) {
  			return !Expr.pseudos[ "empty" ]( elem );
  		},

  		// Element/input types
  		"header": function( elem ) {
  			return rheader.test( elem.nodeName );
  		},

  		"input": function( elem ) {
  			return rinputs.test( elem.nodeName );
  		},

  		"button": function( elem ) {
  			var name = elem.nodeName.toLowerCase();
  			return name === "input" && elem.type === "button" || name === "button";
  		},

  		"text": function( elem ) {
  			var attr;
  			return elem.nodeName.toLowerCase() === "input" &&
  				elem.type === "text" &&

  				// Support: IE<8
  				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
  				( ( attr = elem.getAttribute( "type" ) ) == null ||
  					attr.toLowerCase() === "text" );
  		},

  		// Position-in-collection
  		"first": createPositionalPseudo( function() {
  			return [ 0 ];
  		} ),

  		"last": createPositionalPseudo( function( _matchIndexes, length ) {
  			return [ length - 1 ];
  		} ),

  		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
  			return [ argument < 0 ? argument + length : argument ];
  		} ),

  		"even": createPositionalPseudo( function( matchIndexes, length ) {
  			var i = 0;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} ),

  		"odd": createPositionalPseudo( function( matchIndexes, length ) {
  			var i = 1;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} ),

  		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
  			var i = argument < 0 ?
  				argument + length :
  				argument > length ?
  					length :
  					argument;
  			for ( ; --i >= 0; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} ),

  		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
  			var i = argument < 0 ? argument + length : argument;
  			for ( ; ++i < length; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} )
  	}
  };

  Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

  // Add button/input type pseudos
  for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  	Expr.pseudos[ i ] = createInputPseudo( i );
  }
  for ( i in { submit: true, reset: true } ) {
  	Expr.pseudos[ i ] = createButtonPseudo( i );
  }

  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();

  tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
  	var matched, match, tokens, type,
  		soFar, groups, preFilters,
  		cached = tokenCache[ selector + " " ];

  	if ( cached ) {
  		return parseOnly ? 0 : cached.slice( 0 );
  	}

  	soFar = selector;
  	groups = [];
  	preFilters = Expr.preFilter;

  	while ( soFar ) {

  		// Comma and first run
  		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
  			if ( match ) {

  				// Don't consume trailing commas as valid
  				soFar = soFar.slice( match[ 0 ].length ) || soFar;
  			}
  			groups.push( ( tokens = [] ) );
  		}

  		matched = false;

  		// Combinators
  		if ( ( match = rcombinators.exec( soFar ) ) ) {
  			matched = match.shift();
  			tokens.push( {
  				value: matched,

  				// Cast descendant combinators to space
  				type: match[ 0 ].replace( rtrim, " " )
  			} );
  			soFar = soFar.slice( matched.length );
  		}

  		// Filters
  		for ( type in Expr.filter ) {
  			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
  				( match = preFilters[ type ]( match ) ) ) ) {
  				matched = match.shift();
  				tokens.push( {
  					value: matched,
  					type: type,
  					matches: match
  				} );
  				soFar = soFar.slice( matched.length );
  			}
  		}

  		if ( !matched ) {
  			break;
  		}
  	}

  	// Return the length of the invalid excess
  	// if we're just parsing
  	// Otherwise, throw an error or return tokens
  	return parseOnly ?
  		soFar.length :
  		soFar ?
  			Sizzle.error( selector ) :

  			// Cache the tokens
  			tokenCache( selector, groups ).slice( 0 );
  };

  function toSelector( tokens ) {
  	var i = 0,
  		len = tokens.length,
  		selector = "";
  	for ( ; i < len; i++ ) {
  		selector += tokens[ i ].value;
  	}
  	return selector;
  }

  function addCombinator( matcher, combinator, base ) {
  	var dir = combinator.dir,
  		skip = combinator.next,
  		key = skip || dir,
  		checkNonElements = base && key === "parentNode",
  		doneName = done++;

  	return combinator.first ?

  		// Check against closest ancestor/preceding element
  		function( elem, context, xml ) {
  			while ( ( elem = elem[ dir ] ) ) {
  				if ( elem.nodeType === 1 || checkNonElements ) {
  					return matcher( elem, context, xml );
  				}
  			}
  			return false;
  		} :

  		// Check against all ancestor/preceding elements
  		function( elem, context, xml ) {
  			var oldCache, uniqueCache, outerCache,
  				newCache = [ dirruns, doneName ];

  			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
  			if ( xml ) {
  				while ( ( elem = elem[ dir ] ) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						if ( matcher( elem, context, xml ) ) {
  							return true;
  						}
  					}
  				}
  			} else {
  				while ( ( elem = elem[ dir ] ) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

  						// Support: IE <9 only
  						// Defend against cloned attroperties (jQuery gh-1709)
  						uniqueCache = outerCache[ elem.uniqueID ] ||
  							( outerCache[ elem.uniqueID ] = {} );

  						if ( skip && skip === elem.nodeName.toLowerCase() ) {
  							elem = elem[ dir ] || elem;
  						} else if ( ( oldCache = uniqueCache[ key ] ) &&
  							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  							// Assign to newCache so results back-propagate to previous elements
  							return ( newCache[ 2 ] = oldCache[ 2 ] );
  						} else {

  							// Reuse newcache so results back-propagate to previous elements
  							uniqueCache[ key ] = newCache;

  							// A match means we're done; a fail means we have to keep checking
  							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
  								return true;
  							}
  						}
  					}
  				}
  			}
  			return false;
  		};
  }

  function elementMatcher( matchers ) {
  	return matchers.length > 1 ?
  		function( elem, context, xml ) {
  			var i = matchers.length;
  			while ( i-- ) {
  				if ( !matchers[ i ]( elem, context, xml ) ) {
  					return false;
  				}
  			}
  			return true;
  		} :
  		matchers[ 0 ];
  }

  function multipleContexts( selector, contexts, results ) {
  	var i = 0,
  		len = contexts.length;
  	for ( ; i < len; i++ ) {
  		Sizzle( selector, contexts[ i ], results );
  	}
  	return results;
  }

  function condense( unmatched, map, filter, context, xml ) {
  	var elem,
  		newUnmatched = [],
  		i = 0,
  		len = unmatched.length,
  		mapped = map != null;

  	for ( ; i < len; i++ ) {
  		if ( ( elem = unmatched[ i ] ) ) {
  			if ( !filter || filter( elem, context, xml ) ) {
  				newUnmatched.push( elem );
  				if ( mapped ) {
  					map.push( i );
  				}
  			}
  		}
  	}

  	return newUnmatched;
  }

  function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  	if ( postFilter && !postFilter[ expando ] ) {
  		postFilter = setMatcher( postFilter );
  	}
  	if ( postFinder && !postFinder[ expando ] ) {
  		postFinder = setMatcher( postFinder, postSelector );
  	}
  	return markFunction( function( seed, results, context, xml ) {
  		var temp, i, elem,
  			preMap = [],
  			postMap = [],
  			preexisting = results.length,

  			// Get initial elements from seed or context
  			elems = seed || multipleContexts(
  				selector || "*",
  				context.nodeType ? [ context ] : context,
  				[]
  			),

  			// Prefilter to get matcher input, preserving a map for seed-results synchronization
  			matcherIn = preFilter && ( seed || !selector ) ?
  				condense( elems, preMap, preFilter, context, xml ) :
  				elems,

  			matcherOut = matcher ?

  				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
  				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  					// ...intermediate processing is necessary
  					[] :

  					// ...otherwise use results directly
  					results :
  				matcherIn;

  		// Find primary matches
  		if ( matcher ) {
  			matcher( matcherIn, matcherOut, context, xml );
  		}

  		// Apply postFilter
  		if ( postFilter ) {
  			temp = condense( matcherOut, postMap );
  			postFilter( temp, [], context, xml );

  			// Un-match failing elements by moving them back to matcherIn
  			i = temp.length;
  			while ( i-- ) {
  				if ( ( elem = temp[ i ] ) ) {
  					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
  				}
  			}
  		}

  		if ( seed ) {
  			if ( postFinder || preFilter ) {
  				if ( postFinder ) {

  					// Get the final matcherOut by condensing this intermediate into postFinder contexts
  					temp = [];
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( ( elem = matcherOut[ i ] ) ) {

  							// Restore matcherIn since elem is not yet a final match
  							temp.push( ( matcherIn[ i ] = elem ) );
  						}
  					}
  					postFinder( null, ( matcherOut = [] ), temp, xml );
  				}

  				// Move matched elements from seed to results to keep them synchronized
  				i = matcherOut.length;
  				while ( i-- ) {
  					if ( ( elem = matcherOut[ i ] ) &&
  						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

  						seed[ temp ] = !( results[ temp ] = elem );
  					}
  				}
  			}

  		// Add elements to results, through postFinder if defined
  		} else {
  			matcherOut = condense(
  				matcherOut === results ?
  					matcherOut.splice( preexisting, matcherOut.length ) :
  					matcherOut
  			);
  			if ( postFinder ) {
  				postFinder( null, results, matcherOut, xml );
  			} else {
  				push.apply( results, matcherOut );
  			}
  		}
  	} );
  }

  function matcherFromTokens( tokens ) {
  	var checkContext, matcher, j,
  		len = tokens.length,
  		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
  		implicitRelative = leadingRelative || Expr.relative[ " " ],
  		i = leadingRelative ? 1 : 0,

  		// The foundational matcher ensures that elements are reachable from top-level context(s)
  		matchContext = addCombinator( function( elem ) {
  			return elem === checkContext;
  		}, implicitRelative, true ),
  		matchAnyContext = addCombinator( function( elem ) {
  			return indexOf( checkContext, elem ) > -1;
  		}, implicitRelative, true ),
  		matchers = [ function( elem, context, xml ) {
  			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
  				( checkContext = context ).nodeType ?
  					matchContext( elem, context, xml ) :
  					matchAnyContext( elem, context, xml ) );

  			// Avoid hanging onto element (issue #299)
  			checkContext = null;
  			return ret;
  		} ];

  	for ( ; i < len; i++ ) {
  		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
  			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
  		} else {
  			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

  			// Return special upon seeing a positional matcher
  			if ( matcher[ expando ] ) {

  				// Find the next relative operator (if any) for proper handling
  				j = ++i;
  				for ( ; j < len; j++ ) {
  					if ( Expr.relative[ tokens[ j ].type ] ) {
  						break;
  					}
  				}
  				return setMatcher(
  					i > 1 && elementMatcher( matchers ),
  					i > 1 && toSelector(

  					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  					tokens
  						.slice( 0, i - 1 )
  						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
  					).replace( rtrim, "$1" ),
  					matcher,
  					i < j && matcherFromTokens( tokens.slice( i, j ) ),
  					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
  					j < len && toSelector( tokens )
  				);
  			}
  			matchers.push( matcher );
  		}
  	}

  	return elementMatcher( matchers );
  }

  function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  	var bySet = setMatchers.length > 0,
  		byElement = elementMatchers.length > 0,
  		superMatcher = function( seed, context, xml, results, outermost ) {
  			var elem, j, matcher,
  				matchedCount = 0,
  				i = "0",
  				unmatched = seed && [],
  				setMatched = [],
  				contextBackup = outermostContext,

  				// We must always have either seed elements or outermost context
  				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

  				// Use integer dirruns iff this is the outermost matcher
  				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
  				len = elems.length;

  			if ( outermost ) {

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				outermostContext = context == document || context || outermost;
  			}

  			// Add elements passing elementMatchers directly to results
  			// Support: IE<9, Safari
  			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
  			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
  				if ( byElement && elem ) {
  					j = 0;

  					// Support: IE 11+, Edge 17 - 18+
  					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  					// two documents; shallow comparisons work.
  					// eslint-disable-next-line eqeqeq
  					if ( !context && elem.ownerDocument != document ) {
  						setDocument( elem );
  						xml = !documentIsHTML;
  					}
  					while ( ( matcher = elementMatchers[ j++ ] ) ) {
  						if ( matcher( elem, context || document, xml ) ) {
  							results.push( elem );
  							break;
  						}
  					}
  					if ( outermost ) {
  						dirruns = dirrunsUnique;
  					}
  				}

  				// Track unmatched elements for set filters
  				if ( bySet ) {

  					// They will have gone through all possible matchers
  					if ( ( elem = !matcher && elem ) ) {
  						matchedCount--;
  					}

  					// Lengthen the array for every element, matched or not
  					if ( seed ) {
  						unmatched.push( elem );
  					}
  				}
  			}

  			// `i` is now the count of elements visited above, and adding it to `matchedCount`
  			// makes the latter nonnegative.
  			matchedCount += i;

  			// Apply set filters to unmatched elements
  			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
  			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
  			// no element matchers and no seed.
  			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
  			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
  			// numerically zero.
  			if ( bySet && i !== matchedCount ) {
  				j = 0;
  				while ( ( matcher = setMatchers[ j++ ] ) ) {
  					matcher( unmatched, setMatched, context, xml );
  				}

  				if ( seed ) {

  					// Reintegrate element matches to eliminate the need for sorting
  					if ( matchedCount > 0 ) {
  						while ( i-- ) {
  							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
  								setMatched[ i ] = pop.call( results );
  							}
  						}
  					}

  					// Discard index placeholder values to get only actual matches
  					setMatched = condense( setMatched );
  				}

  				// Add matches to results
  				push.apply( results, setMatched );

  				// Seedless set matches succeeding multiple successful matchers stipulate sorting
  				if ( outermost && !seed && setMatched.length > 0 &&
  					( matchedCount + setMatchers.length ) > 1 ) {

  					Sizzle.uniqueSort( results );
  				}
  			}

  			// Override manipulation of globals by nested matchers
  			if ( outermost ) {
  				dirruns = dirrunsUnique;
  				outermostContext = contextBackup;
  			}

  			return unmatched;
  		};

  	return bySet ?
  		markFunction( superMatcher ) :
  		superMatcher;
  }

  compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
  	var i,
  		setMatchers = [],
  		elementMatchers = [],
  		cached = compilerCache[ selector + " " ];

  	if ( !cached ) {

  		// Generate a function of recursive functions that can be used to check each element
  		if ( !match ) {
  			match = tokenize( selector );
  		}
  		i = match.length;
  		while ( i-- ) {
  			cached = matcherFromTokens( match[ i ] );
  			if ( cached[ expando ] ) {
  				setMatchers.push( cached );
  			} else {
  				elementMatchers.push( cached );
  			}
  		}

  		// Cache the compiled function
  		cached = compilerCache(
  			selector,
  			matcherFromGroupMatchers( elementMatchers, setMatchers )
  		);

  		// Save selector and tokenization
  		cached.selector = selector;
  	}
  	return cached;
  };

  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  select = Sizzle.select = function( selector, context, results, seed ) {
  	var i, tokens, token, type, find,
  		compiled = typeof selector === "function" && selector,
  		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

  	results = results || [];

  	// Try to minimize operations if there is only one selector in the list and no seed
  	// (the latter of which guarantees us context)
  	if ( match.length === 1 ) {

  		// Reduce context if the leading compound selector is an ID
  		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
  		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
  			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

  			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
  				.replace( runescape, funescape ), context ) || [] )[ 0 ];
  			if ( !context ) {
  				return results;

  			// Precompiled matchers will still verify ancestry, so step up a level
  			} else if ( compiled ) {
  				context = context.parentNode;
  			}

  			selector = selector.slice( tokens.shift().value.length );
  		}

  		// Fetch a seed set for right-to-left matching
  		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
  		while ( i-- ) {
  			token = tokens[ i ];

  			// Abort if we hit a combinator
  			if ( Expr.relative[ ( type = token.type ) ] ) {
  				break;
  			}
  			if ( ( find = Expr.find[ type ] ) ) {

  				// Search, expanding context for leading sibling combinators
  				if ( ( seed = find(
  					token.matches[ 0 ].replace( runescape, funescape ),
  					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
  						context
  				) ) ) {

  					// If seed is empty or no tokens remain, we can return early
  					tokens.splice( i, 1 );
  					selector = seed.length && toSelector( tokens );
  					if ( !selector ) {
  						push.apply( results, seed );
  						return results;
  					}

  					break;
  				}
  			}
  		}
  	}

  	// Compile and execute a filtering function if one is not provided
  	// Provide `match` to avoid retokenization if we modified the selector above
  	( compiled || compile( selector, match ) )(
  		seed,
  		context,
  		!documentIsHTML,
  		results,
  		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  	);
  	return results;
  };

  // One-time assignments

  // Sort stability
  support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

  // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function
  support.detectDuplicates = !!hasDuplicate;

  // Initialize against the default document
  setDocument();

  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert( function( el ) {

  	// Should return 1, but returns 4 (following)
  	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
  } );

  // Support: IE<8
  // Prevent attribute/property "interpolation"
  // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if ( !assert( function( el ) {
  	el.innerHTML = "<a href='#'></a>";
  	return el.firstChild.getAttribute( "href" ) === "#";
  } ) ) {
  	addHandle( "type|href|height|width", function( elem, name, isXML ) {
  		if ( !isXML ) {
  			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
  		}
  	} );
  }

  // Support: IE<9
  // Use defaultValue in place of getAttribute("value")
  if ( !support.attributes || !assert( function( el ) {
  	el.innerHTML = "<input/>";
  	el.firstChild.setAttribute( "value", "" );
  	return el.firstChild.getAttribute( "value" ) === "";
  } ) ) {
  	addHandle( "value", function( elem, _name, isXML ) {
  		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
  			return elem.defaultValue;
  		}
  	} );
  }

  // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies
  if ( !assert( function( el ) {
  	return el.getAttribute( "disabled" ) == null;
  } ) ) {
  	addHandle( booleans, function( elem, name, isXML ) {
  		var val;
  		if ( !isXML ) {
  			return elem[ name ] === true ? name.toLowerCase() :
  				( val = elem.getAttributeNode( name ) ) && val.specified ?
  					val.value :
  					null;
  		}
  	} );
  }

  return Sizzle;

  } )( window );



  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;

  // Deprecated
  jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;




  var dir = function( elem, dir, until ) {
  	var matched = [],
  		truncate = until !== undefined;

  	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
  		if ( elem.nodeType === 1 ) {
  			if ( truncate && jQuery( elem ).is( until ) ) {
  				break;
  			}
  			matched.push( elem );
  		}
  	}
  	return matched;
  };


  var siblings = function( n, elem ) {
  	var matched = [];

  	for ( ; n; n = n.nextSibling ) {
  		if ( n.nodeType === 1 && n !== elem ) {
  			matched.push( n );
  		}
  	}

  	return matched;
  };


  var rneedsContext = jQuery.expr.match.needsContext;



  function nodeName( elem, name ) {

    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

  }var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



  // Implement the identical functionality for filter and not
  function winnow( elements, qualifier, not ) {
  	if ( isFunction( qualifier ) ) {
  		return jQuery.grep( elements, function( elem, i ) {
  			return !!qualifier.call( elem, i, elem ) !== not;
  		} );
  	}

  	// Single element
  	if ( qualifier.nodeType ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( elem === qualifier ) !== not;
  		} );
  	}

  	// Arraylike of elements (jQuery, arguments, Array)
  	if ( typeof qualifier !== "string" ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
  		} );
  	}

  	// Filtered directly for both simple and complex selectors
  	return jQuery.filter( qualifier, elements, not );
  }

  jQuery.filter = function( expr, elems, not ) {
  	var elem = elems[ 0 ];

  	if ( not ) {
  		expr = ":not(" + expr + ")";
  	}

  	if ( elems.length === 1 && elem.nodeType === 1 ) {
  		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  	}

  	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  		return elem.nodeType === 1;
  	} ) );
  };

  jQuery.fn.extend( {
  	find: function( selector ) {
  		var i, ret,
  			len = this.length,
  			self = this;

  		if ( typeof selector !== "string" ) {
  			return this.pushStack( jQuery( selector ).filter( function() {
  				for ( i = 0; i < len; i++ ) {
  					if ( jQuery.contains( self[ i ], this ) ) {
  						return true;
  					}
  				}
  			} ) );
  		}

  		ret = this.pushStack( [] );

  		for ( i = 0; i < len; i++ ) {
  			jQuery.find( selector, self[ i ], ret );
  		}

  		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  	},
  	filter: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], false ) );
  	},
  	not: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], true ) );
  	},
  	is: function( selector ) {
  		return !!winnow(
  			this,

  			// If this is a positional/relative selector, check membership in the returned set
  			// so $("p:first").is("p:last") won't return true for a doc with two "p".
  			typeof selector === "string" && rneedsContext.test( selector ) ?
  				jQuery( selector ) :
  				selector || [],
  			false
  		).length;
  	}
  } );


  // Initialize a jQuery object


  // A central reference to the root jQuery(document)
  var rootjQuery,

  	// A simple way to check for HTML strings
  	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  	// Strict HTML recognition (#11290: must start with <)
  	// Shortcut simple #id case for speed
  	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  	init = jQuery.fn.init = function( selector, context, root ) {
  		var match, elem;

  		// HANDLE: $(""), $(null), $(undefined), $(false)
  		if ( !selector ) {
  			return this;
  		}

  		// Method init() accepts an alternate rootjQuery
  		// so migrate can support jQuery.sub (gh-2101)
  		root = root || rootjQuery;

  		// Handle HTML strings
  		if ( typeof selector === "string" ) {
  			if ( selector[ 0 ] === "<" &&
  				selector[ selector.length - 1 ] === ">" &&
  				selector.length >= 3 ) {

  				// Assume that strings that start and end with <> are HTML and skip the regex check
  				match = [ null, selector, null ];

  			} else {
  				match = rquickExpr.exec( selector );
  			}

  			// Match html or make sure no context is specified for #id
  			if ( match && ( match[ 1 ] || !context ) ) {

  				// HANDLE: $(html) -> $(array)
  				if ( match[ 1 ] ) {
  					context = context instanceof jQuery ? context[ 0 ] : context;

  					// Option to run scripts is true for back-compat
  					// Intentionally let the error be thrown if parseHTML is not present
  					jQuery.merge( this, jQuery.parseHTML(
  						match[ 1 ],
  						context && context.nodeType ? context.ownerDocument || context : document,
  						true
  					) );

  					// HANDLE: $(html, props)
  					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
  						for ( match in context ) {

  							// Properties of context are called as methods if possible
  							if ( isFunction( this[ match ] ) ) {
  								this[ match ]( context[ match ] );

  							// ...and otherwise set as attributes
  							} else {
  								this.attr( match, context[ match ] );
  							}
  						}
  					}

  					return this;

  				// HANDLE: $(#id)
  				} else {
  					elem = document.getElementById( match[ 2 ] );

  					if ( elem ) {

  						// Inject the element directly into the jQuery object
  						this[ 0 ] = elem;
  						this.length = 1;
  					}
  					return this;
  				}

  			// HANDLE: $(expr, $(...))
  			} else if ( !context || context.jquery ) {
  				return ( context || root ).find( selector );

  			// HANDLE: $(expr, context)
  			// (which is just equivalent to: $(context).find(expr)
  			} else {
  				return this.constructor( context ).find( selector );
  			}

  		// HANDLE: $(DOMElement)
  		} else if ( selector.nodeType ) {
  			this[ 0 ] = selector;
  			this.length = 1;
  			return this;

  		// HANDLE: $(function)
  		// Shortcut for document ready
  		} else if ( isFunction( selector ) ) {
  			return root.ready !== undefined ?
  				root.ready( selector ) :

  				// Execute immediately if ready is not present
  				selector( jQuery );
  		}

  		return jQuery.makeArray( selector, this );
  	};

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery( document );


  var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  	// Methods guaranteed to produce a unique set when starting from a unique set
  	guaranteedUnique = {
  		children: true,
  		contents: true,
  		next: true,
  		prev: true
  	};

  jQuery.fn.extend( {
  	has: function( target ) {
  		var targets = jQuery( target, this ),
  			l = targets.length;

  		return this.filter( function() {
  			var i = 0;
  			for ( ; i < l; i++ ) {
  				if ( jQuery.contains( this, targets[ i ] ) ) {
  					return true;
  				}
  			}
  		} );
  	},

  	closest: function( selectors, context ) {
  		var cur,
  			i = 0,
  			l = this.length,
  			matched = [],
  			targets = typeof selectors !== "string" && jQuery( selectors );

  		// Positional selectors never match, since there's no _selection_ context
  		if ( !rneedsContext.test( selectors ) ) {
  			for ( ; i < l; i++ ) {
  				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

  					// Always skip document fragments
  					if ( cur.nodeType < 11 && ( targets ?
  						targets.index( cur ) > -1 :

  						// Don't pass non-elements to Sizzle
  						cur.nodeType === 1 &&
  							jQuery.find.matchesSelector( cur, selectors ) ) ) {

  						matched.push( cur );
  						break;
  					}
  				}
  			}
  		}

  		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  	},

  	// Determine the position of an element within the set
  	index: function( elem ) {

  		// No argument, return index in parent
  		if ( !elem ) {
  			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  		}

  		// Index in selector
  		if ( typeof elem === "string" ) {
  			return indexOf.call( jQuery( elem ), this[ 0 ] );
  		}

  		// Locate the position of the desired element
  		return indexOf.call( this,

  			// If it receives a jQuery object, the first element is used
  			elem.jquery ? elem[ 0 ] : elem
  		);
  	},

  	add: function( selector, context ) {
  		return this.pushStack(
  			jQuery.uniqueSort(
  				jQuery.merge( this.get(), jQuery( selector, context ) )
  			)
  		);
  	},

  	addBack: function( selector ) {
  		return this.add( selector == null ?
  			this.prevObject : this.prevObject.filter( selector )
  		);
  	}
  } );

  function sibling( cur, dir ) {
  	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  	return cur;
  }

  jQuery.each( {
  	parent: function( elem ) {
  		var parent = elem.parentNode;
  		return parent && parent.nodeType !== 11 ? parent : null;
  	},
  	parents: function( elem ) {
  		return dir( elem, "parentNode" );
  	},
  	parentsUntil: function( elem, _i, until ) {
  		return dir( elem, "parentNode", until );
  	},
  	next: function( elem ) {
  		return sibling( elem, "nextSibling" );
  	},
  	prev: function( elem ) {
  		return sibling( elem, "previousSibling" );
  	},
  	nextAll: function( elem ) {
  		return dir( elem, "nextSibling" );
  	},
  	prevAll: function( elem ) {
  		return dir( elem, "previousSibling" );
  	},
  	nextUntil: function( elem, _i, until ) {
  		return dir( elem, "nextSibling", until );
  	},
  	prevUntil: function( elem, _i, until ) {
  		return dir( elem, "previousSibling", until );
  	},
  	siblings: function( elem ) {
  		return siblings( ( elem.parentNode || {} ).firstChild, elem );
  	},
  	children: function( elem ) {
  		return siblings( elem.firstChild );
  	},
  	contents: function( elem ) {
  		if ( elem.contentDocument != null &&

  			// Support: IE 11+
  			// <object> elements with no `data` attribute has an object
  			// `contentDocument` with a `null` prototype.
  			getProto( elem.contentDocument ) ) {

  			return elem.contentDocument;
  		}

  		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
  		// Treat the template element as a regular one in browsers that
  		// don't support it.
  		if ( nodeName( elem, "template" ) ) {
  			elem = elem.content || elem;
  		}

  		return jQuery.merge( [], elem.childNodes );
  	}
  }, function( name, fn ) {
  	jQuery.fn[ name ] = function( until, selector ) {
  		var matched = jQuery.map( this, fn, until );

  		if ( name.slice( -5 ) !== "Until" ) {
  			selector = until;
  		}

  		if ( selector && typeof selector === "string" ) {
  			matched = jQuery.filter( selector, matched );
  		}

  		if ( this.length > 1 ) {

  			// Remove duplicates
  			if ( !guaranteedUnique[ name ] ) {
  				jQuery.uniqueSort( matched );
  			}

  			// Reverse order for parents* and prev-derivatives
  			if ( rparentsprev.test( name ) ) {
  				matched.reverse();
  			}
  		}

  		return this.pushStack( matched );
  	};
  } );
  var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



  // Convert String-formatted options into Object-formatted ones
  function createOptions( options ) {
  	var object = {};
  	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
  		object[ flag ] = true;
  	} );
  	return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function( options ) {

  	// Convert options from String-formatted to Object-formatted if needed
  	// (we check in cache first)
  	options = typeof options === "string" ?
  		createOptions( options ) :
  		jQuery.extend( {}, options );

  	var // Flag to know if list is currently firing
  		firing,

  		// Last fire value for non-forgettable lists
  		memory,

  		// Flag to know if list was already fired
  		fired,

  		// Flag to prevent firing
  		locked,

  		// Actual callback list
  		list = [],

  		// Queue of execution data for repeatable lists
  		queue = [],

  		// Index of currently firing callback (modified by add/remove as needed)
  		firingIndex = -1,

  		// Fire callbacks
  		fire = function() {

  			// Enforce single-firing
  			locked = locked || options.once;

  			// Execute callbacks for all pending executions,
  			// respecting firingIndex overrides and runtime changes
  			fired = firing = true;
  			for ( ; queue.length; firingIndex = -1 ) {
  				memory = queue.shift();
  				while ( ++firingIndex < list.length ) {

  					// Run callback and check for early termination
  					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
  						options.stopOnFalse ) {

  						// Jump to end and forget the data so .add doesn't re-fire
  						firingIndex = list.length;
  						memory = false;
  					}
  				}
  			}

  			// Forget the data if we're done with it
  			if ( !options.memory ) {
  				memory = false;
  			}

  			firing = false;

  			// Clean up if we're done firing for good
  			if ( locked ) {

  				// Keep an empty list if we have data for future add calls
  				if ( memory ) {
  					list = [];

  				// Otherwise, this object is spent
  				} else {
  					list = "";
  				}
  			}
  		},

  		// Actual Callbacks object
  		self = {

  			// Add a callback or a collection of callbacks to the list
  			add: function() {
  				if ( list ) {

  					// If we have memory from a past run, we should fire after adding
  					if ( memory && !firing ) {
  						firingIndex = list.length - 1;
  						queue.push( memory );
  					}

  					( function add( args ) {
  						jQuery.each( args, function( _, arg ) {
  							if ( isFunction( arg ) ) {
  								if ( !options.unique || !self.has( arg ) ) {
  									list.push( arg );
  								}
  							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

  								// Inspect recursively
  								add( arg );
  							}
  						} );
  					} )( arguments );

  					if ( memory && !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Remove a callback from the list
  			remove: function() {
  				jQuery.each( arguments, function( _, arg ) {
  					var index;
  					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  						list.splice( index, 1 );

  						// Handle firing indexes
  						if ( index <= firingIndex ) {
  							firingIndex--;
  						}
  					}
  				} );
  				return this;
  			},

  			// Check if a given callback is in the list.
  			// If no argument is given, return whether or not list has callbacks attached.
  			has: function( fn ) {
  				return fn ?
  					jQuery.inArray( fn, list ) > -1 :
  					list.length > 0;
  			},

  			// Remove all callbacks from the list
  			empty: function() {
  				if ( list ) {
  					list = [];
  				}
  				return this;
  			},

  			// Disable .fire and .add
  			// Abort any current/pending executions
  			// Clear all callbacks and values
  			disable: function() {
  				locked = queue = [];
  				list = memory = "";
  				return this;
  			},
  			disabled: function() {
  				return !list;
  			},

  			// Disable .fire
  			// Also disable .add unless we have memory (since it would have no effect)
  			// Abort any pending executions
  			lock: function() {
  				locked = queue = [];
  				if ( !memory && !firing ) {
  					list = memory = "";
  				}
  				return this;
  			},
  			locked: function() {
  				return !!locked;
  			},

  			// Call all callbacks with the given context and arguments
  			fireWith: function( context, args ) {
  				if ( !locked ) {
  					args = args || [];
  					args = [ context, args.slice ? args.slice() : args ];
  					queue.push( args );
  					if ( !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Call all the callbacks with the given arguments
  			fire: function() {
  				self.fireWith( this, arguments );
  				return this;
  			},

  			// To know if the callbacks have already been called at least once
  			fired: function() {
  				return !!fired;
  			}
  		};

  	return self;
  };


  function Identity( v ) {
  	return v;
  }
  function Thrower( ex ) {
  	throw ex;
  }

  function adoptValue( value, resolve, reject, noValue ) {
  	var method;

  	try {

  		// Check for promise aspect first to privilege synchronous behavior
  		if ( value && isFunction( ( method = value.promise ) ) ) {
  			method.call( value ).done( resolve ).fail( reject );

  		// Other thenables
  		} else if ( value && isFunction( ( method = value.then ) ) ) {
  			method.call( value, resolve, reject );

  		// Other non-thenables
  		} else {

  			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
  			// * false: [ value ].slice( 0 ) => resolve( value )
  			// * true: [ value ].slice( 1 ) => resolve()
  			resolve.apply( undefined, [ value ].slice( noValue ) );
  		}

  	// For Promises/A+, convert exceptions into rejections
  	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  	// Deferred#then to conditionally suppress rejection.
  	} catch ( value ) {

  		// Support: Android 4.0 only
  		// Strict mode functions invoked without .call/.apply get global-object context
  		reject.apply( undefined, [ value ] );
  	}
  }

  jQuery.extend( {

  	Deferred: function( func ) {
  		var tuples = [

  				// action, add listener, callbacks,
  				// ... .then handlers, argument index, [final state]
  				[ "notify", "progress", jQuery.Callbacks( "memory" ),
  					jQuery.Callbacks( "memory" ), 2 ],
  				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
  				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
  			],
  			state = "pending",
  			promise = {
  				state: function() {
  					return state;
  				},
  				always: function() {
  					deferred.done( arguments ).fail( arguments );
  					return this;
  				},
  				"catch": function( fn ) {
  					return promise.then( null, fn );
  				},

  				// Keep pipe for back-compat
  				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
  					var fns = arguments;

  					return jQuery.Deferred( function( newDefer ) {
  						jQuery.each( tuples, function( _i, tuple ) {

  							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
  							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

  							// deferred.progress(function() { bind to newDefer or newDefer.notify })
  							// deferred.done(function() { bind to newDefer or newDefer.resolve })
  							// deferred.fail(function() { bind to newDefer or newDefer.reject })
  							deferred[ tuple[ 1 ] ]( function() {
  								var returned = fn && fn.apply( this, arguments );
  								if ( returned && isFunction( returned.promise ) ) {
  									returned.promise()
  										.progress( newDefer.notify )
  										.done( newDefer.resolve )
  										.fail( newDefer.reject );
  								} else {
  									newDefer[ tuple[ 0 ] + "With" ](
  										this,
  										fn ? [ returned ] : arguments
  									);
  								}
  							} );
  						} );
  						fns = null;
  					} ).promise();
  				},
  				then: function( onFulfilled, onRejected, onProgress ) {
  					var maxDepth = 0;
  					function resolve( depth, deferred, handler, special ) {
  						return function() {
  							var that = this,
  								args = arguments,
  								mightThrow = function() {
  									var returned, then;

  									// Support: Promises/A+ section 2.3.3.3.3
  									// https://promisesaplus.com/#point-59
  									// Ignore double-resolution attempts
  									if ( depth < maxDepth ) {
  										return;
  									}

  									returned = handler.apply( that, args );

  									// Support: Promises/A+ section 2.3.1
  									// https://promisesaplus.com/#point-48
  									if ( returned === deferred.promise() ) {
  										throw new TypeError( "Thenable self-resolution" );
  									}

  									// Support: Promises/A+ sections 2.3.3.1, 3.5
  									// https://promisesaplus.com/#point-54
  									// https://promisesaplus.com/#point-75
  									// Retrieve `then` only once
  									then = returned &&

  										// Support: Promises/A+ section 2.3.4
  										// https://promisesaplus.com/#point-64
  										// Only check objects and functions for thenability
  										( typeof returned === "object" ||
  											typeof returned === "function" ) &&
  										returned.then;

  									// Handle a returned thenable
  									if ( isFunction( then ) ) {

  										// Special processors (notify) just wait for resolution
  										if ( special ) {
  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special )
  											);

  										// Normal processors (resolve) also hook into progress
  										} else {

  											// ...and disregard older resolution values
  											maxDepth++;

  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special ),
  												resolve( maxDepth, deferred, Identity,
  													deferred.notifyWith )
  											);
  										}

  									// Handle all other returned values
  									} else {

  										// Only substitute handlers pass on context
  										// and multiple values (non-spec behavior)
  										if ( handler !== Identity ) {
  											that = undefined;
  											args = [ returned ];
  										}

  										// Process the value(s)
  										// Default process is resolve
  										( special || deferred.resolveWith )( that, args );
  									}
  								},

  								// Only normal processors (resolve) catch and reject exceptions
  								process = special ?
  									mightThrow :
  									function() {
  										try {
  											mightThrow();
  										} catch ( e ) {

  											if ( jQuery.Deferred.exceptionHook ) {
  												jQuery.Deferred.exceptionHook( e,
  													process.stackTrace );
  											}

  											// Support: Promises/A+ section 2.3.3.3.4.1
  											// https://promisesaplus.com/#point-61
  											// Ignore post-resolution exceptions
  											if ( depth + 1 >= maxDepth ) {

  												// Only substitute handlers pass on context
  												// and multiple values (non-spec behavior)
  												if ( handler !== Thrower ) {
  													that = undefined;
  													args = [ e ];
  												}

  												deferred.rejectWith( that, args );
  											}
  										}
  									};

  							// Support: Promises/A+ section 2.3.3.3.1
  							// https://promisesaplus.com/#point-57
  							// Re-resolve promises immediately to dodge false rejection from
  							// subsequent errors
  							if ( depth ) {
  								process();
  							} else {

  								// Call an optional hook to record the stack, in case of exception
  								// since it's otherwise lost when execution goes async
  								if ( jQuery.Deferred.getStackHook ) {
  									process.stackTrace = jQuery.Deferred.getStackHook();
  								}
  								window.setTimeout( process );
  							}
  						};
  					}

  					return jQuery.Deferred( function( newDefer ) {

  						// progress_handlers.add( ... )
  						tuples[ 0 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onProgress ) ?
  									onProgress :
  									Identity,
  								newDefer.notifyWith
  							)
  						);

  						// fulfilled_handlers.add( ... )
  						tuples[ 1 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onFulfilled ) ?
  									onFulfilled :
  									Identity
  							)
  						);

  						// rejected_handlers.add( ... )
  						tuples[ 2 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onRejected ) ?
  									onRejected :
  									Thrower
  							)
  						);
  					} ).promise();
  				},

  				// Get a promise for this deferred
  				// If obj is provided, the promise aspect is added to the object
  				promise: function( obj ) {
  					return obj != null ? jQuery.extend( obj, promise ) : promise;
  				}
  			},
  			deferred = {};

  		// Add list-specific methods
  		jQuery.each( tuples, function( i, tuple ) {
  			var list = tuple[ 2 ],
  				stateString = tuple[ 5 ];

  			// promise.progress = list.add
  			// promise.done = list.add
  			// promise.fail = list.add
  			promise[ tuple[ 1 ] ] = list.add;

  			// Handle state
  			if ( stateString ) {
  				list.add(
  					function() {

  						// state = "resolved" (i.e., fulfilled)
  						// state = "rejected"
  						state = stateString;
  					},

  					// rejected_callbacks.disable
  					// fulfilled_callbacks.disable
  					tuples[ 3 - i ][ 2 ].disable,

  					// rejected_handlers.disable
  					// fulfilled_handlers.disable
  					tuples[ 3 - i ][ 3 ].disable,

  					// progress_callbacks.lock
  					tuples[ 0 ][ 2 ].lock,

  					// progress_handlers.lock
  					tuples[ 0 ][ 3 ].lock
  				);
  			}

  			// progress_handlers.fire
  			// fulfilled_handlers.fire
  			// rejected_handlers.fire
  			list.add( tuple[ 3 ].fire );

  			// deferred.notify = function() { deferred.notifyWith(...) }
  			// deferred.resolve = function() { deferred.resolveWith(...) }
  			// deferred.reject = function() { deferred.rejectWith(...) }
  			deferred[ tuple[ 0 ] ] = function() {
  				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
  				return this;
  			};

  			// deferred.notifyWith = list.fireWith
  			// deferred.resolveWith = list.fireWith
  			// deferred.rejectWith = list.fireWith
  			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
  		} );

  		// Make the deferred a promise
  		promise.promise( deferred );

  		// Call given func if any
  		if ( func ) {
  			func.call( deferred, deferred );
  		}

  		// All done!
  		return deferred;
  	},

  	// Deferred helper
  	when: function( singleValue ) {
  		var

  			// count of uncompleted subordinates
  			remaining = arguments.length,

  			// count of unprocessed arguments
  			i = remaining,

  			// subordinate fulfillment data
  			resolveContexts = Array( i ),
  			resolveValues = slice.call( arguments ),

  			// the master Deferred
  			master = jQuery.Deferred(),

  			// subordinate callback factory
  			updateFunc = function( i ) {
  				return function( value ) {
  					resolveContexts[ i ] = this;
  					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  					if ( !( --remaining ) ) {
  						master.resolveWith( resolveContexts, resolveValues );
  					}
  				};
  			};

  		// Single- and empty arguments are adopted like Promise.resolve
  		if ( remaining <= 1 ) {
  			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
  				!remaining );

  			// Use .then() to unwrap secondary thenables (cf. gh-3000)
  			if ( master.state() === "pending" ||
  				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

  				return master.then();
  			}
  		}

  		// Multiple arguments are aggregated like Promise.all array elements
  		while ( i-- ) {
  			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
  		}

  		return master.promise();
  	}
  } );


  // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function( error, stack ) {

  	// Support: IE 8 - 9 only
  	// Console exists when dev tools are open, which can happen at any time
  	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
  		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
  	}
  };




  jQuery.readyException = function( error ) {
  	window.setTimeout( function() {
  		throw error;
  	} );
  };




  // The deferred used on DOM ready
  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function( fn ) {

  	readyList
  		.then( fn )

  		// Wrap jQuery.readyException in a function so that the lookup
  		// happens at the time of error handling instead of callback
  		// registration.
  		.catch( function( error ) {
  			jQuery.readyException( error );
  		} );

  	return this;
  };

  jQuery.extend( {

  	// Is the DOM ready to be used? Set to true once it occurs.
  	isReady: false,

  	// A counter to track how many items to wait for before
  	// the ready event fires. See #6781
  	readyWait: 1,

  	// Handle when the DOM is ready
  	ready: function( wait ) {

  		// Abort if there are pending holds or we're already ready
  		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  			return;
  		}

  		// Remember that the DOM is ready
  		jQuery.isReady = true;

  		// If a normal DOM Ready event fired, decrement, and wait if need be
  		if ( wait !== true && --jQuery.readyWait > 0 ) {
  			return;
  		}

  		// If there are functions bound, to execute
  		readyList.resolveWith( document, [ jQuery ] );
  	}
  } );

  jQuery.ready.then = readyList.then;

  // The ready event handler and self cleanup method
  function completed() {
  	document.removeEventListener( "DOMContentLoaded", completed );
  	window.removeEventListener( "load", completed );
  	jQuery.ready();
  }

  // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon
  if ( document.readyState === "complete" ||
  	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  	// Handle it asynchronously to allow scripts the opportunity to delay ready
  	window.setTimeout( jQuery.ready );

  } else {

  	// Use the handy event callback
  	document.addEventListener( "DOMContentLoaded", completed );

  	// A fallback to window.onload, that will always work
  	window.addEventListener( "load", completed );
  }




  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  	var i = 0,
  		len = elems.length,
  		bulk = key == null;

  	// Sets many values
  	if ( toType( key ) === "object" ) {
  		chainable = true;
  		for ( i in key ) {
  			access( elems, fn, i, key[ i ], true, emptyGet, raw );
  		}

  	// Sets one value
  	} else if ( value !== undefined ) {
  		chainable = true;

  		if ( !isFunction( value ) ) {
  			raw = true;
  		}

  		if ( bulk ) {

  			// Bulk operations run against the entire set
  			if ( raw ) {
  				fn.call( elems, value );
  				fn = null;

  			// ...except when executing function values
  			} else {
  				bulk = fn;
  				fn = function( elem, _key, value ) {
  					return bulk.call( jQuery( elem ), value );
  				};
  			}
  		}

  		if ( fn ) {
  			for ( ; i < len; i++ ) {
  				fn(
  					elems[ i ], key, raw ?
  					value :
  					value.call( elems[ i ], i, fn( elems[ i ], key ) )
  				);
  			}
  		}
  	}

  	if ( chainable ) {
  		return elems;
  	}

  	// Gets
  	if ( bulk ) {
  		return fn.call( elems );
  	}

  	return len ? fn( elems[ 0 ], key ) : emptyGet;
  };


  // Matches dashed string for camelizing
  var rmsPrefix = /^-ms-/,
  	rdashAlpha = /-([a-z])/g;

  // Used by camelCase as callback to replace()
  function fcamelCase( _all, letter ) {
  	return letter.toUpperCase();
  }

  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)
  function camelCase( string ) {
  	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  }
  var acceptData = function( owner ) {

  	// Accepts only:
  	//  - Node
  	//    - Node.ELEMENT_NODE
  	//    - Node.DOCUMENT_NODE
  	//  - Object
  	//    - Any
  	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  };




  function Data() {
  	this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;

  Data.prototype = {

  	cache: function( owner ) {

  		// Check if the owner object already has a cache
  		var value = owner[ this.expando ];

  		// If not, create one
  		if ( !value ) {
  			value = {};

  			// We can accept data for non-element nodes in modern browsers,
  			// but we should not, see #8335.
  			// Always return an empty object.
  			if ( acceptData( owner ) ) {

  				// If it is a node unlikely to be stringify-ed or looped over
  				// use plain assignment
  				if ( owner.nodeType ) {
  					owner[ this.expando ] = value;

  				// Otherwise secure it in a non-enumerable property
  				// configurable must be true to allow the property to be
  				// deleted when data is removed
  				} else {
  					Object.defineProperty( owner, this.expando, {
  						value: value,
  						configurable: true
  					} );
  				}
  			}
  		}

  		return value;
  	},
  	set: function( owner, data, value ) {
  		var prop,
  			cache = this.cache( owner );

  		// Handle: [ owner, key, value ] args
  		// Always use camelCase key (gh-2257)
  		if ( typeof data === "string" ) {
  			cache[ camelCase( data ) ] = value;

  		// Handle: [ owner, { properties } ] args
  		} else {

  			// Copy the properties one-by-one to the cache object
  			for ( prop in data ) {
  				cache[ camelCase( prop ) ] = data[ prop ];
  			}
  		}
  		return cache;
  	},
  	get: function( owner, key ) {
  		return key === undefined ?
  			this.cache( owner ) :

  			// Always use camelCase key (gh-2257)
  			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  	},
  	access: function( owner, key, value ) {

  		// In cases where either:
  		//
  		//   1. No key was specified
  		//   2. A string key was specified, but no value provided
  		//
  		// Take the "read" path and allow the get method to determine
  		// which value to return, respectively either:
  		//
  		//   1. The entire cache object
  		//   2. The data stored at the key
  		//
  		if ( key === undefined ||
  				( ( key && typeof key === "string" ) && value === undefined ) ) {

  			return this.get( owner, key );
  		}

  		// When the key is not a string, or both a key and value
  		// are specified, set or extend (existing objects) with either:
  		//
  		//   1. An object of properties
  		//   2. A key and value
  		//
  		this.set( owner, key, value );

  		// Since the "set" path can have two possible entry points
  		// return the expected data based on which path was taken[*]
  		return value !== undefined ? value : key;
  	},
  	remove: function( owner, key ) {
  		var i,
  			cache = owner[ this.expando ];

  		if ( cache === undefined ) {
  			return;
  		}

  		if ( key !== undefined ) {

  			// Support array or space separated string of keys
  			if ( Array.isArray( key ) ) {

  				// If key is an array of keys...
  				// We always set camelCase keys, so remove that.
  				key = key.map( camelCase );
  			} else {
  				key = camelCase( key );

  				// If a key with the spaces exists, use it.
  				// Otherwise, create an array by matching non-whitespace
  				key = key in cache ?
  					[ key ] :
  					( key.match( rnothtmlwhite ) || [] );
  			}

  			i = key.length;

  			while ( i-- ) {
  				delete cache[ key[ i ] ];
  			}
  		}

  		// Remove the expando if there's no more data
  		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

  			// Support: Chrome <=35 - 45
  			// Webkit & Blink performance suffers when deleting properties
  			// from DOM nodes, so set to undefined instead
  			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
  			if ( owner.nodeType ) {
  				owner[ this.expando ] = undefined;
  			} else {
  				delete owner[ this.expando ];
  			}
  		}
  	},
  	hasData: function( owner ) {
  		var cache = owner[ this.expando ];
  		return cache !== undefined && !jQuery.isEmptyObject( cache );
  	}
  };
  var dataPriv = new Data();

  var dataUser = new Data();



  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  	rmultiDash = /[A-Z]/g;

  function getData( data ) {
  	if ( data === "true" ) {
  		return true;
  	}

  	if ( data === "false" ) {
  		return false;
  	}

  	if ( data === "null" ) {
  		return null;
  	}

  	// Only convert to a number if it doesn't change the string
  	if ( data === +data + "" ) {
  		return +data;
  	}

  	if ( rbrace.test( data ) ) {
  		return JSON.parse( data );
  	}

  	return data;
  }

  function dataAttr( elem, key, data ) {
  	var name;

  	// If nothing was found internally, try to fetch any
  	// data from the HTML5 data-* attribute
  	if ( data === undefined && elem.nodeType === 1 ) {
  		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
  		data = elem.getAttribute( name );

  		if ( typeof data === "string" ) {
  			try {
  				data = getData( data );
  			} catch ( e ) {}

  			// Make sure we set the data so it isn't changed later
  			dataUser.set( elem, key, data );
  		} else {
  			data = undefined;
  		}
  	}
  	return data;
  }

  jQuery.extend( {
  	hasData: function( elem ) {
  		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  	},

  	data: function( elem, name, data ) {
  		return dataUser.access( elem, name, data );
  	},

  	removeData: function( elem, name ) {
  		dataUser.remove( elem, name );
  	},

  	// TODO: Now that all calls to _data and _removeData have been replaced
  	// with direct calls to dataPriv methods, these can be deprecated.
  	_data: function( elem, name, data ) {
  		return dataPriv.access( elem, name, data );
  	},

  	_removeData: function( elem, name ) {
  		dataPriv.remove( elem, name );
  	}
  } );

  jQuery.fn.extend( {
  	data: function( key, value ) {
  		var i, name, data,
  			elem = this[ 0 ],
  			attrs = elem && elem.attributes;

  		// Gets all values
  		if ( key === undefined ) {
  			if ( this.length ) {
  				data = dataUser.get( elem );

  				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
  					i = attrs.length;
  					while ( i-- ) {

  						// Support: IE 11 only
  						// The attrs elements can be null (#14894)
  						if ( attrs[ i ] ) {
  							name = attrs[ i ].name;
  							if ( name.indexOf( "data-" ) === 0 ) {
  								name = camelCase( name.slice( 5 ) );
  								dataAttr( elem, name, data[ name ] );
  							}
  						}
  					}
  					dataPriv.set( elem, "hasDataAttrs", true );
  				}
  			}

  			return data;
  		}

  		// Sets multiple values
  		if ( typeof key === "object" ) {
  			return this.each( function() {
  				dataUser.set( this, key );
  			} );
  		}

  		return access( this, function( value ) {
  			var data;

  			// The calling jQuery object (element matches) is not empty
  			// (and therefore has an element appears at this[ 0 ]) and the
  			// `value` parameter was not undefined. An empty jQuery object
  			// will result in `undefined` for elem = this[ 0 ] which will
  			// throw an exception if an attempt to read a data cache is made.
  			if ( elem && value === undefined ) {

  				// Attempt to get data from the cache
  				// The key will always be camelCased in Data
  				data = dataUser.get( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// Attempt to "discover" the data in
  				// HTML5 custom data-* attrs
  				data = dataAttr( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// We tried really hard, but the data doesn't exist.
  				return;
  			}

  			// Set the data...
  			this.each( function() {

  				// We always store the camelCased key
  				dataUser.set( this, key, value );
  			} );
  		}, null, value, arguments.length > 1, null, true );
  	},

  	removeData: function( key ) {
  		return this.each( function() {
  			dataUser.remove( this, key );
  		} );
  	}
  } );


  jQuery.extend( {
  	queue: function( elem, type, data ) {
  		var queue;

  		if ( elem ) {
  			type = ( type || "fx" ) + "queue";
  			queue = dataPriv.get( elem, type );

  			// Speed up dequeue by getting out quickly if this is just a lookup
  			if ( data ) {
  				if ( !queue || Array.isArray( data ) ) {
  					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
  				} else {
  					queue.push( data );
  				}
  			}
  			return queue || [];
  		}
  	},

  	dequeue: function( elem, type ) {
  		type = type || "fx";

  		var queue = jQuery.queue( elem, type ),
  			startLength = queue.length,
  			fn = queue.shift(),
  			hooks = jQuery._queueHooks( elem, type ),
  			next = function() {
  				jQuery.dequeue( elem, type );
  			};

  		// If the fx queue is dequeued, always remove the progress sentinel
  		if ( fn === "inprogress" ) {
  			fn = queue.shift();
  			startLength--;
  		}

  		if ( fn ) {

  			// Add a progress sentinel to prevent the fx queue from being
  			// automatically dequeued
  			if ( type === "fx" ) {
  				queue.unshift( "inprogress" );
  			}

  			// Clear up the last queue stop function
  			delete hooks.stop;
  			fn.call( elem, next, hooks );
  		}

  		if ( !startLength && hooks ) {
  			hooks.empty.fire();
  		}
  	},

  	// Not public - generate a queueHooks object, or return the current one
  	_queueHooks: function( elem, type ) {
  		var key = type + "queueHooks";
  		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
  			empty: jQuery.Callbacks( "once memory" ).add( function() {
  				dataPriv.remove( elem, [ type + "queue", key ] );
  			} )
  		} );
  	}
  } );

  jQuery.fn.extend( {
  	queue: function( type, data ) {
  		var setter = 2;

  		if ( typeof type !== "string" ) {
  			data = type;
  			type = "fx";
  			setter--;
  		}

  		if ( arguments.length < setter ) {
  			return jQuery.queue( this[ 0 ], type );
  		}

  		return data === undefined ?
  			this :
  			this.each( function() {
  				var queue = jQuery.queue( this, type, data );

  				// Ensure a hooks for this queue
  				jQuery._queueHooks( this, type );

  				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
  					jQuery.dequeue( this, type );
  				}
  			} );
  	},
  	dequeue: function( type ) {
  		return this.each( function() {
  			jQuery.dequeue( this, type );
  		} );
  	},
  	clearQueue: function( type ) {
  		return this.queue( type || "fx", [] );
  	},

  	// Get a promise resolved when queues of a certain type
  	// are emptied (fx is the type by default)
  	promise: function( type, obj ) {
  		var tmp,
  			count = 1,
  			defer = jQuery.Deferred(),
  			elements = this,
  			i = this.length,
  			resolve = function() {
  				if ( !( --count ) ) {
  					defer.resolveWith( elements, [ elements ] );
  				}
  			};

  		if ( typeof type !== "string" ) {
  			obj = type;
  			type = undefined;
  		}
  		type = type || "fx";

  		while ( i-- ) {
  			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
  			if ( tmp && tmp.empty ) {
  				count++;
  				tmp.empty.add( resolve );
  			}
  		}
  		resolve();
  		return defer.promise( obj );
  	}
  } );
  var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

  var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


  var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  var documentElement = document.documentElement;



  	var isAttached = function( elem ) {
  			return jQuery.contains( elem.ownerDocument, elem );
  		},
  		composed = { composed: true };

  	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  	// Check attachment across shadow DOM boundaries when possible (gh-3504)
  	// Support: iOS 10.0-10.2 only
  	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  	// leading to errors. We need to check for `getRootNode`.
  	if ( documentElement.getRootNode ) {
  		isAttached = function( elem ) {
  			return jQuery.contains( elem.ownerDocument, elem ) ||
  				elem.getRootNode( composed ) === elem.ownerDocument;
  		};
  	}
  var isHiddenWithinTree = function( elem, el ) {

  		// isHiddenWithinTree might be called from jQuery#filter function;
  		// in that case, element will be second argument
  		elem = el || elem;

  		// Inline style trumps all
  		return elem.style.display === "none" ||
  			elem.style.display === "" &&

  			// Otherwise, check computed style
  			// Support: Firefox <=43 - 45
  			// Disconnected elements can have computed display: none, so first confirm that elem is
  			// in the document.
  			isAttached( elem ) &&

  			jQuery.css( elem, "display" ) === "none";
  	};



  function adjustCSS( elem, prop, valueParts, tween ) {
  	var adjusted, scale,
  		maxIterations = 20,
  		currentValue = tween ?
  			function() {
  				return tween.cur();
  			} :
  			function() {
  				return jQuery.css( elem, prop, "" );
  			},
  		initial = currentValue(),
  		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  		// Starting value computation is required for potential unit mismatches
  		initialInUnit = elem.nodeType &&
  			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
  			rcssNum.exec( jQuery.css( elem, prop ) );

  	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

  		// Support: Firefox <=54
  		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
  		initial = initial / 2;

  		// Trust units reported by jQuery.css
  		unit = unit || initialInUnit[ 3 ];

  		// Iteratively approximate from a nonzero starting point
  		initialInUnit = +initial || 1;

  		while ( maxIterations-- ) {

  			// Evaluate and update our best guess (doubling guesses that zero out).
  			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
  			jQuery.style( elem, prop, initialInUnit + unit );
  			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
  				maxIterations = 0;
  			}
  			initialInUnit = initialInUnit / scale;

  		}

  		initialInUnit = initialInUnit * 2;
  		jQuery.style( elem, prop, initialInUnit + unit );

  		// Make sure we update the tween properties later on
  		valueParts = valueParts || [];
  	}

  	if ( valueParts ) {
  		initialInUnit = +initialInUnit || +initial || 0;

  		// Apply relative offset (+=/-=) if specified
  		adjusted = valueParts[ 1 ] ?
  			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
  			+valueParts[ 2 ];
  		if ( tween ) {
  			tween.unit = unit;
  			tween.start = initialInUnit;
  			tween.end = adjusted;
  		}
  	}
  	return adjusted;
  }


  var defaultDisplayMap = {};

  function getDefaultDisplay( elem ) {
  	var temp,
  		doc = elem.ownerDocument,
  		nodeName = elem.nodeName,
  		display = defaultDisplayMap[ nodeName ];

  	if ( display ) {
  		return display;
  	}

  	temp = doc.body.appendChild( doc.createElement( nodeName ) );
  	display = jQuery.css( temp, "display" );

  	temp.parentNode.removeChild( temp );

  	if ( display === "none" ) {
  		display = "block";
  	}
  	defaultDisplayMap[ nodeName ] = display;

  	return display;
  }

  function showHide( elements, show ) {
  	var display, elem,
  		values = [],
  		index = 0,
  		length = elements.length;

  	// Determine new display value for elements that need to change
  	for ( ; index < length; index++ ) {
  		elem = elements[ index ];
  		if ( !elem.style ) {
  			continue;
  		}

  		display = elem.style.display;
  		if ( show ) {

  			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
  			// check is required in this first loop unless we have a nonempty display value (either
  			// inline or about-to-be-restored)
  			if ( display === "none" ) {
  				values[ index ] = dataPriv.get( elem, "display" ) || null;
  				if ( !values[ index ] ) {
  					elem.style.display = "";
  				}
  			}
  			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
  				values[ index ] = getDefaultDisplay( elem );
  			}
  		} else {
  			if ( display !== "none" ) {
  				values[ index ] = "none";

  				// Remember what we're overwriting
  				dataPriv.set( elem, "display", display );
  			}
  		}
  	}

  	// Set the display of the elements in a second loop to avoid constant reflow
  	for ( index = 0; index < length; index++ ) {
  		if ( values[ index ] != null ) {
  			elements[ index ].style.display = values[ index ];
  		}
  	}

  	return elements;
  }

  jQuery.fn.extend( {
  	show: function() {
  		return showHide( this, true );
  	},
  	hide: function() {
  		return showHide( this );
  	},
  	toggle: function( state ) {
  		if ( typeof state === "boolean" ) {
  			return state ? this.show() : this.hide();
  		}

  		return this.each( function() {
  			if ( isHiddenWithinTree( this ) ) {
  				jQuery( this ).show();
  			} else {
  				jQuery( this ).hide();
  			}
  		} );
  	}
  } );
  var rcheckableType = ( /^(?:checkbox|radio)$/i );

  var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

  var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



  ( function() {
  	var fragment = document.createDocumentFragment(),
  		div = fragment.appendChild( document.createElement( "div" ) ),
  		input = document.createElement( "input" );

  	// Support: Android 4.0 - 4.3 only
  	// Check state lost if the name is set (#11217)
  	// Support: Windows Web Apps (WWA)
  	// `name` and `type` must use .setAttribute for WWA (#14901)
  	input.setAttribute( "type", "radio" );
  	input.setAttribute( "checked", "checked" );
  	input.setAttribute( "name", "t" );

  	div.appendChild( input );

  	// Support: Android <=4.1 only
  	// Older WebKit doesn't clone checked state correctly in fragments
  	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  	// Support: IE <=11 only
  	// Make sure textarea (and checkbox) defaultValue is properly cloned
  	div.innerHTML = "<textarea>x</textarea>";
  	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

  	// Support: IE <=9 only
  	// IE <=9 replaces <option> tags with their contents when inserted outside of
  	// the select element.
  	div.innerHTML = "<option></option>";
  	support.option = !!div.lastChild;
  } )();


  // We have to close these tags to support XHTML (#13200)
  var wrapMap = {

  	// XHTML parsers do not magically insert elements in the
  	// same way that tag soup parsers do. So we cannot shorten
  	// this by omitting <tbody> or other required elements.
  	thead: [ 1, "<table>", "</table>" ],
  	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  	_default: [ 0, "", "" ]
  };

  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  // Support: IE <=9 only
  if ( !support.option ) {
  	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
  }


  function getAll( context, tag ) {

  	// Support: IE <=9 - 11 only
  	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
  	var ret;

  	if ( typeof context.getElementsByTagName !== "undefined" ) {
  		ret = context.getElementsByTagName( tag || "*" );

  	} else if ( typeof context.querySelectorAll !== "undefined" ) {
  		ret = context.querySelectorAll( tag || "*" );

  	} else {
  		ret = [];
  	}

  	if ( tag === undefined || tag && nodeName( context, tag ) ) {
  		return jQuery.merge( [ context ], ret );
  	}

  	return ret;
  }


  // Mark scripts as having already been evaluated
  function setGlobalEval( elems, refElements ) {
  	var i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		dataPriv.set(
  			elems[ i ],
  			"globalEval",
  			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
  		);
  	}
  }


  var rhtml = /<|&#?\w+;/;

  function buildFragment( elems, context, scripts, selection, ignored ) {
  	var elem, tmp, tag, wrap, attached, j,
  		fragment = context.createDocumentFragment(),
  		nodes = [],
  		i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		elem = elems[ i ];

  		if ( elem || elem === 0 ) {

  			// Add nodes directly
  			if ( toType( elem ) === "object" ) {

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  			// Convert non-html into a text node
  			} else if ( !rhtml.test( elem ) ) {
  				nodes.push( context.createTextNode( elem ) );

  			// Convert html into DOM nodes
  			} else {
  				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

  				// Deserialize a standard representation
  				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  				wrap = wrapMap[ tag ] || wrapMap._default;
  				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

  				// Descend through wrappers to the right content
  				j = wrap[ 0 ];
  				while ( j-- ) {
  					tmp = tmp.lastChild;
  				}

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, tmp.childNodes );

  				// Remember the top-level container
  				tmp = fragment.firstChild;

  				// Ensure the created nodes are orphaned (#12392)
  				tmp.textContent = "";
  			}
  		}
  	}

  	// Remove wrapper from fragment
  	fragment.textContent = "";

  	i = 0;
  	while ( ( elem = nodes[ i++ ] ) ) {

  		// Skip elements already in the context collection (trac-4087)
  		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
  			if ( ignored ) {
  				ignored.push( elem );
  			}
  			continue;
  		}

  		attached = isAttached( elem );

  		// Append to fragment
  		tmp = getAll( fragment.appendChild( elem ), "script" );

  		// Preserve script evaluation history
  		if ( attached ) {
  			setGlobalEval( tmp );
  		}

  		// Capture executables
  		if ( scripts ) {
  			j = 0;
  			while ( ( elem = tmp[ j++ ] ) ) {
  				if ( rscriptType.test( elem.type || "" ) ) {
  					scripts.push( elem );
  				}
  			}
  		}
  	}

  	return fragment;
  }


  var
  	rkeyEvent = /^key/,
  	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
  	return true;
  }

  function returnFalse() {
  	return false;
  }

  // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).
  function expectSync( elem, type ) {
  	return ( elem === safeActiveElement() ) === ( type === "focus" );
  }

  // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393
  function safeActiveElement() {
  	try {
  		return document.activeElement;
  	} catch ( err ) { }
  }

  function on( elem, types, selector, data, fn, one ) {
  	var origFn, type;

  	// Types can be a map of types/handlers
  	if ( typeof types === "object" ) {

  		// ( types-Object, selector, data )
  		if ( typeof selector !== "string" ) {

  			// ( types-Object, data )
  			data = data || selector;
  			selector = undefined;
  		}
  		for ( type in types ) {
  			on( elem, type, selector, data, types[ type ], one );
  		}
  		return elem;
  	}

  	if ( data == null && fn == null ) {

  		// ( types, fn )
  		fn = selector;
  		data = selector = undefined;
  	} else if ( fn == null ) {
  		if ( typeof selector === "string" ) {

  			// ( types, selector, fn )
  			fn = data;
  			data = undefined;
  		} else {

  			// ( types, data, fn )
  			fn = data;
  			data = selector;
  			selector = undefined;
  		}
  	}
  	if ( fn === false ) {
  		fn = returnFalse;
  	} else if ( !fn ) {
  		return elem;
  	}

  	if ( one === 1 ) {
  		origFn = fn;
  		fn = function( event ) {

  			// Can use an empty set, since event contains the info
  			jQuery().off( event );
  			return origFn.apply( this, arguments );
  		};

  		// Use same guid so caller can remove using origFn
  		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  	}
  	return elem.each( function() {
  		jQuery.event.add( this, types, fn, data, selector );
  	} );
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {

  	global: {},

  	add: function( elem, types, handler, data, selector ) {

  		var handleObjIn, eventHandle, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.get( elem );

  		// Only attach events to objects that accept data
  		if ( !acceptData( elem ) ) {
  			return;
  		}

  		// Caller can pass in an object of custom data in lieu of the handler
  		if ( handler.handler ) {
  			handleObjIn = handler;
  			handler = handleObjIn.handler;
  			selector = handleObjIn.selector;
  		}

  		// Ensure that invalid selectors throw exceptions at attach time
  		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
  		if ( selector ) {
  			jQuery.find.matchesSelector( documentElement, selector );
  		}

  		// Make sure that the handler has a unique ID, used to find/remove it later
  		if ( !handler.guid ) {
  			handler.guid = jQuery.guid++;
  		}

  		// Init the element's event structure and main handler, if this is the first
  		if ( !( events = elemData.events ) ) {
  			events = elemData.events = Object.create( null );
  		}
  		if ( !( eventHandle = elemData.handle ) ) {
  			eventHandle = elemData.handle = function( e ) {

  				// Discard the second event of a jQuery.event.trigger() and
  				// when an event is called after a page has unloaded
  				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
  					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  			};
  		}

  		// Handle multiple events separated by a space
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// There *must* be a type, no attaching namespace-only handlers
  			if ( !type ) {
  				continue;
  			}

  			// If event changes its type, use the special event handlers for the changed type
  			special = jQuery.event.special[ type ] || {};

  			// If selector defined, determine special event api type, otherwise given type
  			type = ( selector ? special.delegateType : special.bindType ) || type;

  			// Update special based on newly reset type
  			special = jQuery.event.special[ type ] || {};

  			// handleObj is passed to all event handlers
  			handleObj = jQuery.extend( {
  				type: type,
  				origType: origType,
  				data: data,
  				handler: handler,
  				guid: handler.guid,
  				selector: selector,
  				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  				namespace: namespaces.join( "." )
  			}, handleObjIn );

  			// Init the event handler queue if we're the first
  			if ( !( handlers = events[ type ] ) ) {
  				handlers = events[ type ] = [];
  				handlers.delegateCount = 0;

  				// Only use addEventListener if the special events handler returns false
  				if ( !special.setup ||
  					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

  					if ( elem.addEventListener ) {
  						elem.addEventListener( type, eventHandle );
  					}
  				}
  			}

  			if ( special.add ) {
  				special.add.call( elem, handleObj );

  				if ( !handleObj.handler.guid ) {
  					handleObj.handler.guid = handler.guid;
  				}
  			}

  			// Add to the element's handler list, delegates in front
  			if ( selector ) {
  				handlers.splice( handlers.delegateCount++, 0, handleObj );
  			} else {
  				handlers.push( handleObj );
  			}

  			// Keep track of which events have ever been used, for event optimization
  			jQuery.event.global[ type ] = true;
  		}

  	},

  	// Detach an event or set of events from an element
  	remove: function( elem, types, handler, selector, mappedTypes ) {

  		var j, origCount, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

  		if ( !elemData || !( events = elemData.events ) ) {
  			return;
  		}

  		// Once for each type.namespace in types; type may be omitted
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// Unbind all events (on this namespace, if provided) for the element
  			if ( !type ) {
  				for ( type in events ) {
  					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  				}
  				continue;
  			}

  			special = jQuery.event.special[ type ] || {};
  			type = ( selector ? special.delegateType : special.bindType ) || type;
  			handlers = events[ type ] || [];
  			tmp = tmp[ 2 ] &&
  				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

  			// Remove matching events
  			origCount = j = handlers.length;
  			while ( j-- ) {
  				handleObj = handlers[ j ];

  				if ( ( mappedTypes || origType === handleObj.origType ) &&
  					( !handler || handler.guid === handleObj.guid ) &&
  					( !tmp || tmp.test( handleObj.namespace ) ) &&
  					( !selector || selector === handleObj.selector ||
  						selector === "**" && handleObj.selector ) ) {
  					handlers.splice( j, 1 );

  					if ( handleObj.selector ) {
  						handlers.delegateCount--;
  					}
  					if ( special.remove ) {
  						special.remove.call( elem, handleObj );
  					}
  				}
  			}

  			// Remove generic event handler if we removed something and no more handlers exist
  			// (avoids potential for endless recursion during removal of special event handlers)
  			if ( origCount && !handlers.length ) {
  				if ( !special.teardown ||
  					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

  					jQuery.removeEvent( elem, type, elemData.handle );
  				}

  				delete events[ type ];
  			}
  		}

  		// Remove data and the expando if it's no longer used
  		if ( jQuery.isEmptyObject( events ) ) {
  			dataPriv.remove( elem, "handle events" );
  		}
  	},

  	dispatch: function( nativeEvent ) {

  		var i, j, ret, matched, handleObj, handlerQueue,
  			args = new Array( arguments.length ),

  			// Make a writable jQuery.Event from the native event object
  			event = jQuery.event.fix( nativeEvent ),

  			handlers = (
  					dataPriv.get( this, "events" ) || Object.create( null )
  				)[ event.type ] || [],
  			special = jQuery.event.special[ event.type ] || {};

  		// Use the fix-ed jQuery.Event rather than the (read-only) native event
  		args[ 0 ] = event;

  		for ( i = 1; i < arguments.length; i++ ) {
  			args[ i ] = arguments[ i ];
  		}

  		event.delegateTarget = this;

  		// Call the preDispatch hook for the mapped type, and let it bail if desired
  		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  			return;
  		}

  		// Determine handlers
  		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  		// Run delegates first; they may want to stop propagation beneath us
  		i = 0;
  		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
  			event.currentTarget = matched.elem;

  			j = 0;
  			while ( ( handleObj = matched.handlers[ j++ ] ) &&
  				!event.isImmediatePropagationStopped() ) {

  				// If the event is namespaced, then each handler is only invoked if it is
  				// specially universal or its namespaces are a superset of the event's.
  				if ( !event.rnamespace || handleObj.namespace === false ||
  					event.rnamespace.test( handleObj.namespace ) ) {

  					event.handleObj = handleObj;
  					event.data = handleObj.data;

  					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
  						handleObj.handler ).apply( matched.elem, args );

  					if ( ret !== undefined ) {
  						if ( ( event.result = ret ) === false ) {
  							event.preventDefault();
  							event.stopPropagation();
  						}
  					}
  				}
  			}
  		}

  		// Call the postDispatch hook for the mapped type
  		if ( special.postDispatch ) {
  			special.postDispatch.call( this, event );
  		}

  		return event.result;
  	},

  	handlers: function( event, handlers ) {
  		var i, handleObj, sel, matchedHandlers, matchedSelectors,
  			handlerQueue = [],
  			delegateCount = handlers.delegateCount,
  			cur = event.target;

  		// Find delegate handlers
  		if ( delegateCount &&

  			// Support: IE <=9
  			// Black-hole SVG <use> instance trees (trac-13180)
  			cur.nodeType &&

  			// Support: Firefox <=42
  			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
  			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
  			// Support: IE 11 only
  			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
  			!( event.type === "click" && event.button >= 1 ) ) {

  			for ( ; cur !== this; cur = cur.parentNode || this ) {

  				// Don't check non-elements (#13208)
  				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
  				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
  					matchedHandlers = [];
  					matchedSelectors = {};
  					for ( i = 0; i < delegateCount; i++ ) {
  						handleObj = handlers[ i ];

  						// Don't conflict with Object.prototype properties (#13203)
  						sel = handleObj.selector + " ";

  						if ( matchedSelectors[ sel ] === undefined ) {
  							matchedSelectors[ sel ] = handleObj.needsContext ?
  								jQuery( sel, this ).index( cur ) > -1 :
  								jQuery.find( sel, this, null, [ cur ] ).length;
  						}
  						if ( matchedSelectors[ sel ] ) {
  							matchedHandlers.push( handleObj );
  						}
  					}
  					if ( matchedHandlers.length ) {
  						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
  					}
  				}
  			}
  		}

  		// Add the remaining (directly-bound) handlers
  		cur = this;
  		if ( delegateCount < handlers.length ) {
  			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
  		}

  		return handlerQueue;
  	},

  	addProp: function( name, hook ) {
  		Object.defineProperty( jQuery.Event.prototype, name, {
  			enumerable: true,
  			configurable: true,

  			get: isFunction( hook ) ?
  				function() {
  					if ( this.originalEvent ) {
  							return hook( this.originalEvent );
  					}
  				} :
  				function() {
  					if ( this.originalEvent ) {
  							return this.originalEvent[ name ];
  					}
  				},

  			set: function( value ) {
  				Object.defineProperty( this, name, {
  					enumerable: true,
  					configurable: true,
  					writable: true,
  					value: value
  				} );
  			}
  		} );
  	},

  	fix: function( originalEvent ) {
  		return originalEvent[ jQuery.expando ] ?
  			originalEvent :
  			new jQuery.Event( originalEvent );
  	},

  	special: {
  		load: {

  			// Prevent triggered image.load events from bubbling to window.load
  			noBubble: true
  		},
  		click: {

  			// Utilize native event to ensure correct state for checkable inputs
  			setup: function( data ) {

  				// For mutual compressibility with _default, replace `this` access with a local var.
  				// `|| data` is dead code meant only to preserve the variable through minification.
  				var el = this || data;

  				// Claim the first handler
  				if ( rcheckableType.test( el.type ) &&
  					el.click && nodeName( el, "input" ) ) {

  					// dataPriv.set( el, "click", ... )
  					leverageNative( el, "click", returnTrue );
  				}

  				// Return false to allow normal processing in the caller
  				return false;
  			},
  			trigger: function( data ) {

  				// For mutual compressibility with _default, replace `this` access with a local var.
  				// `|| data` is dead code meant only to preserve the variable through minification.
  				var el = this || data;

  				// Force setup before triggering a click
  				if ( rcheckableType.test( el.type ) &&
  					el.click && nodeName( el, "input" ) ) {

  					leverageNative( el, "click" );
  				}

  				// Return non-false to allow normal event-path propagation
  				return true;
  			},

  			// For cross-browser consistency, suppress native .click() on links
  			// Also prevent it if we're currently inside a leveraged native-event stack
  			_default: function( event ) {
  				var target = event.target;
  				return rcheckableType.test( target.type ) &&
  					target.click && nodeName( target, "input" ) &&
  					dataPriv.get( target, "click" ) ||
  					nodeName( target, "a" );
  			}
  		},

  		beforeunload: {
  			postDispatch: function( event ) {

  				// Support: Firefox 20+
  				// Firefox doesn't alert if the returnValue field is not set.
  				if ( event.result !== undefined && event.originalEvent ) {
  					event.originalEvent.returnValue = event.result;
  				}
  			}
  		}
  	}
  };

  // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.
  function leverageNative( el, type, expectSync ) {

  	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
  	if ( !expectSync ) {
  		if ( dataPriv.get( el, type ) === undefined ) {
  			jQuery.event.add( el, type, returnTrue );
  		}
  		return;
  	}

  	// Register the controller as a special universal handler for all event namespaces
  	dataPriv.set( el, type, false );
  	jQuery.event.add( el, type, {
  		namespace: false,
  		handler: function( event ) {
  			var notAsync, result,
  				saved = dataPriv.get( this, type );

  			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

  				// Interrupt processing of the outer synthetic .trigger()ed event
  				// Saved data should be false in such cases, but might be a leftover capture object
  				// from an async native handler (gh-4350)
  				if ( !saved.length ) {

  					// Store arguments for use when handling the inner native event
  					// There will always be at least one argument (an event object), so this array
  					// will not be confused with a leftover capture object.
  					saved = slice.call( arguments );
  					dataPriv.set( this, type, saved );

  					// Trigger the native event and capture its result
  					// Support: IE <=9 - 11+
  					// focus() and blur() are asynchronous
  					notAsync = expectSync( this, type );
  					this[ type ]();
  					result = dataPriv.get( this, type );
  					if ( saved !== result || notAsync ) {
  						dataPriv.set( this, type, false );
  					} else {
  						result = {};
  					}
  					if ( saved !== result ) {

  						// Cancel the outer synthetic event
  						event.stopImmediatePropagation();
  						event.preventDefault();
  						return result.value;
  					}

  				// If this is an inner synthetic event for an event with a bubbling surrogate
  				// (focus or blur), assume that the surrogate already propagated from triggering the
  				// native event and prevent that from happening again here.
  				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
  				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
  				// less bad than duplication.
  				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
  					event.stopPropagation();
  				}

  			// If this is a native event triggered above, everything is now in order
  			// Fire an inner synthetic event with the original arguments
  			} else if ( saved.length ) {

  				// ...and capture the result
  				dataPriv.set( this, type, {
  					value: jQuery.event.trigger(

  						// Support: IE <=9 - 11+
  						// Extend with the prototype to reset the above stopImmediatePropagation()
  						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
  						saved.slice( 1 ),
  						this
  					)
  				} );

  				// Abort handling of the native event
  				event.stopImmediatePropagation();
  			}
  		}
  	} );
  }

  jQuery.removeEvent = function( elem, type, handle ) {

  	// This "if" is needed for plain objects
  	if ( elem.removeEventListener ) {
  		elem.removeEventListener( type, handle );
  	}
  };

  jQuery.Event = function( src, props ) {

  	// Allow instantiation without the 'new' keyword
  	if ( !( this instanceof jQuery.Event ) ) {
  		return new jQuery.Event( src, props );
  	}

  	// Event object
  	if ( src && src.type ) {
  		this.originalEvent = src;
  		this.type = src.type;

  		// Events bubbling up the document may have been marked as prevented
  		// by a handler lower down the tree; reflect the correct value.
  		this.isDefaultPrevented = src.defaultPrevented ||
  				src.defaultPrevented === undefined &&

  				// Support: Android <=2.3 only
  				src.returnValue === false ?
  			returnTrue :
  			returnFalse;

  		// Create target properties
  		// Support: Safari <=6 - 7 only
  		// Target should not be a text node (#504, #13143)
  		this.target = ( src.target && src.target.nodeType === 3 ) ?
  			src.target.parentNode :
  			src.target;

  		this.currentTarget = src.currentTarget;
  		this.relatedTarget = src.relatedTarget;

  	// Event type
  	} else {
  		this.type = src;
  	}

  	// Put explicitly provided properties onto the event object
  	if ( props ) {
  		jQuery.extend( this, props );
  	}

  	// Create a timestamp if incoming event doesn't have one
  	this.timeStamp = src && src.timeStamp || Date.now();

  	// Mark it as fixed
  	this[ jQuery.expando ] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
  	constructor: jQuery.Event,
  	isDefaultPrevented: returnFalse,
  	isPropagationStopped: returnFalse,
  	isImmediatePropagationStopped: returnFalse,
  	isSimulated: false,

  	preventDefault: function() {
  		var e = this.originalEvent;

  		this.isDefaultPrevented = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.preventDefault();
  		}
  	},
  	stopPropagation: function() {
  		var e = this.originalEvent;

  		this.isPropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopPropagation();
  		}
  	},
  	stopImmediatePropagation: function() {
  		var e = this.originalEvent;

  		this.isImmediatePropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopImmediatePropagation();
  		}

  		this.stopPropagation();
  	}
  };

  // Includes all common event props including KeyEvent and MouseEvent specific props
  jQuery.each( {
  	altKey: true,
  	bubbles: true,
  	cancelable: true,
  	changedTouches: true,
  	ctrlKey: true,
  	detail: true,
  	eventPhase: true,
  	metaKey: true,
  	pageX: true,
  	pageY: true,
  	shiftKey: true,
  	view: true,
  	"char": true,
  	code: true,
  	charCode: true,
  	key: true,
  	keyCode: true,
  	button: true,
  	buttons: true,
  	clientX: true,
  	clientY: true,
  	offsetX: true,
  	offsetY: true,
  	pointerId: true,
  	pointerType: true,
  	screenX: true,
  	screenY: true,
  	targetTouches: true,
  	toElement: true,
  	touches: true,

  	which: function( event ) {
  		var button = event.button;

  		// Add which for key events
  		if ( event.which == null && rkeyEvent.test( event.type ) ) {
  			return event.charCode != null ? event.charCode : event.keyCode;
  		}

  		// Add which for click: 1 === left; 2 === middle; 3 === right
  		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
  			if ( button & 1 ) {
  				return 1;
  			}

  			if ( button & 2 ) {
  				return 3;
  			}

  			if ( button & 4 ) {
  				return 2;
  			}

  			return 0;
  		}

  		return event.which;
  	}
  }, jQuery.event.addProp );

  jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
  	jQuery.event.special[ type ] = {

  		// Utilize native event if possible so blur/focus sequence is correct
  		setup: function() {

  			// Claim the first handler
  			// dataPriv.set( this, "focus", ... )
  			// dataPriv.set( this, "blur", ... )
  			leverageNative( this, type, expectSync );

  			// Return false to allow normal processing in the caller
  			return false;
  		},
  		trigger: function() {

  			// Force setup before trigger
  			leverageNative( this, type );

  			// Return non-false to allow normal event-path propagation
  			return true;
  		},

  		delegateType: delegateType
  	};
  } );

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each( {
  	mouseenter: "mouseover",
  	mouseleave: "mouseout",
  	pointerenter: "pointerover",
  	pointerleave: "pointerout"
  }, function( orig, fix ) {
  	jQuery.event.special[ orig ] = {
  		delegateType: fix,
  		bindType: fix,

  		handle: function( event ) {
  			var ret,
  				target = this,
  				related = event.relatedTarget,
  				handleObj = event.handleObj;

  			// For mouseenter/leave call the handler if related is outside the target.
  			// NB: No relatedTarget if the mouse left/entered the browser window
  			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
  				event.type = handleObj.origType;
  				ret = handleObj.handler.apply( this, arguments );
  				event.type = fix;
  			}
  			return ret;
  		}
  	};
  } );

  jQuery.fn.extend( {

  	on: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn );
  	},
  	one: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn, 1 );
  	},
  	off: function( types, selector, fn ) {
  		var handleObj, type;
  		if ( types && types.preventDefault && types.handleObj ) {

  			// ( event )  dispatched jQuery.Event
  			handleObj = types.handleObj;
  			jQuery( types.delegateTarget ).off(
  				handleObj.namespace ?
  					handleObj.origType + "." + handleObj.namespace :
  					handleObj.origType,
  				handleObj.selector,
  				handleObj.handler
  			);
  			return this;
  		}
  		if ( typeof types === "object" ) {

  			// ( types-object [, selector] )
  			for ( type in types ) {
  				this.off( type, selector, types[ type ] );
  			}
  			return this;
  		}
  		if ( selector === false || typeof selector === "function" ) {

  			// ( types [, fn] )
  			fn = selector;
  			selector = undefined;
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		}
  		return this.each( function() {
  			jQuery.event.remove( this, types, fn, selector );
  		} );
  	}
  } );


  var

  	// Support: IE <=10 - 11, Edge 12 - 13 only
  	// In IE/Edge using regex groups here causes severe slowdowns.
  	// See https://connect.microsoft.com/IE/feedback/details/1736512/
  	rnoInnerhtml = /<script|<style|<link/i,

  	// checked="checked" or checked
  	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  // Prefer a tbody over its parent table for containing new rows
  function manipulationTarget( elem, content ) {
  	if ( nodeName( elem, "table" ) &&
  		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

  		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  	}

  	return elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript( elem ) {
  	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  	return elem;
  }
  function restoreScript( elem ) {
  	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
  		elem.type = elem.type.slice( 5 );
  	} else {
  		elem.removeAttribute( "type" );
  	}

  	return elem;
  }

  function cloneCopyEvent( src, dest ) {
  	var i, l, type, pdataOld, udataOld, udataCur, events;

  	if ( dest.nodeType !== 1 ) {
  		return;
  	}

  	// 1. Copy private data: events, handlers, etc.
  	if ( dataPriv.hasData( src ) ) {
  		pdataOld = dataPriv.get( src );
  		events = pdataOld.events;

  		if ( events ) {
  			dataPriv.remove( dest, "handle events" );

  			for ( type in events ) {
  				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  					jQuery.event.add( dest, type, events[ type ][ i ] );
  				}
  			}
  		}
  	}

  	// 2. Copy user data
  	if ( dataUser.hasData( src ) ) {
  		udataOld = dataUser.access( src );
  		udataCur = jQuery.extend( {}, udataOld );

  		dataUser.set( dest, udataCur );
  	}
  }

  // Fix IE bugs, see support tests
  function fixInput( src, dest ) {
  	var nodeName = dest.nodeName.toLowerCase();

  	// Fails to persist the checked state of a cloned checkbox or radio button.
  	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  		dest.checked = src.checked;

  	// Fails to return the selected option to the default selected state when cloning options
  	} else if ( nodeName === "input" || nodeName === "textarea" ) {
  		dest.defaultValue = src.defaultValue;
  	}
  }

  function domManip( collection, args, callback, ignored ) {

  	// Flatten any nested arrays
  	args = flat( args );

  	var fragment, first, scripts, hasScripts, node, doc,
  		i = 0,
  		l = collection.length,
  		iNoClone = l - 1,
  		value = args[ 0 ],
  		valueIsFunction = isFunction( value );

  	// We can't cloneNode fragments that contain checked, in WebKit
  	if ( valueIsFunction ||
  			( l > 1 && typeof value === "string" &&
  				!support.checkClone && rchecked.test( value ) ) ) {
  		return collection.each( function( index ) {
  			var self = collection.eq( index );
  			if ( valueIsFunction ) {
  				args[ 0 ] = value.call( this, index, self.html() );
  			}
  			domManip( self, args, callback, ignored );
  		} );
  	}

  	if ( l ) {
  		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
  		first = fragment.firstChild;

  		if ( fragment.childNodes.length === 1 ) {
  			fragment = first;
  		}

  		// Require either new content or an interest in ignored elements to invoke the callback
  		if ( first || ignored ) {
  			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  			hasScripts = scripts.length;

  			// Use the original fragment for the last item
  			// instead of the first because it can end up
  			// being emptied incorrectly in certain situations (#8070).
  			for ( ; i < l; i++ ) {
  				node = fragment;

  				if ( i !== iNoClone ) {
  					node = jQuery.clone( node, true, true );

  					// Keep references to cloned scripts for later restoration
  					if ( hasScripts ) {

  						// Support: Android <=4.0 only, PhantomJS 1 only
  						// push.apply(_, arraylike) throws on ancient WebKit
  						jQuery.merge( scripts, getAll( node, "script" ) );
  					}
  				}

  				callback.call( collection[ i ], node, i );
  			}

  			if ( hasScripts ) {
  				doc = scripts[ scripts.length - 1 ].ownerDocument;

  				// Reenable scripts
  				jQuery.map( scripts, restoreScript );

  				// Evaluate executable scripts on first document insertion
  				for ( i = 0; i < hasScripts; i++ ) {
  					node = scripts[ i ];
  					if ( rscriptType.test( node.type || "" ) &&
  						!dataPriv.access( node, "globalEval" ) &&
  						jQuery.contains( doc, node ) ) {

  						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

  							// Optional AJAX dependency, but won't run scripts if not present
  							if ( jQuery._evalUrl && !node.noModule ) {
  								jQuery._evalUrl( node.src, {
  									nonce: node.nonce || node.getAttribute( "nonce" )
  								}, doc );
  							}
  						} else {
  							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
  						}
  					}
  				}
  			}
  		}
  	}

  	return collection;
  }

  function remove( elem, selector, keepData ) {
  	var node,
  		nodes = selector ? jQuery.filter( selector, elem ) : elem,
  		i = 0;

  	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
  		if ( !keepData && node.nodeType === 1 ) {
  			jQuery.cleanData( getAll( node ) );
  		}

  		if ( node.parentNode ) {
  			if ( keepData && isAttached( node ) ) {
  				setGlobalEval( getAll( node, "script" ) );
  			}
  			node.parentNode.removeChild( node );
  		}
  	}

  	return elem;
  }

  jQuery.extend( {
  	htmlPrefilter: function( html ) {
  		return html;
  	},

  	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  		var i, l, srcElements, destElements,
  			clone = elem.cloneNode( true ),
  			inPage = isAttached( elem );

  		// Fix IE cloning issues
  		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  				!jQuery.isXMLDoc( elem ) ) {

  			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
  			destElements = getAll( clone );
  			srcElements = getAll( elem );

  			for ( i = 0, l = srcElements.length; i < l; i++ ) {
  				fixInput( srcElements[ i ], destElements[ i ] );
  			}
  		}

  		// Copy the events from the original to the clone
  		if ( dataAndEvents ) {
  			if ( deepDataAndEvents ) {
  				srcElements = srcElements || getAll( elem );
  				destElements = destElements || getAll( clone );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  				}
  			} else {
  				cloneCopyEvent( elem, clone );
  			}
  		}

  		// Preserve script evaluation history
  		destElements = getAll( clone, "script" );
  		if ( destElements.length > 0 ) {
  			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  		}

  		// Return the cloned set
  		return clone;
  	},

  	cleanData: function( elems ) {
  		var data, elem, type,
  			special = jQuery.event.special,
  			i = 0;

  		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
  			if ( acceptData( elem ) ) {
  				if ( ( data = elem[ dataPriv.expando ] ) ) {
  					if ( data.events ) {
  						for ( type in data.events ) {
  							if ( special[ type ] ) {
  								jQuery.event.remove( elem, type );

  							// This is a shortcut to avoid jQuery.event.remove's overhead
  							} else {
  								jQuery.removeEvent( elem, type, data.handle );
  							}
  						}
  					}

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataPriv.expando ] = undefined;
  				}
  				if ( elem[ dataUser.expando ] ) {

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataUser.expando ] = undefined;
  				}
  			}
  		}
  	}
  } );

  jQuery.fn.extend( {
  	detach: function( selector ) {
  		return remove( this, selector, true );
  	},

  	remove: function( selector ) {
  		return remove( this, selector );
  	},

  	text: function( value ) {
  		return access( this, function( value ) {
  			return value === undefined ?
  				jQuery.text( this ) :
  				this.empty().each( function() {
  					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  						this.textContent = value;
  					}
  				} );
  		}, null, value, arguments.length );
  	},

  	append: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.appendChild( elem );
  			}
  		} );
  	},

  	prepend: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.insertBefore( elem, target.firstChild );
  			}
  		} );
  	},

  	before: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this );
  			}
  		} );
  	},

  	after: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this.nextSibling );
  			}
  		} );
  	},

  	empty: function() {
  		var elem,
  			i = 0;

  		for ( ; ( elem = this[ i ] ) != null; i++ ) {
  			if ( elem.nodeType === 1 ) {

  				// Prevent memory leaks
  				jQuery.cleanData( getAll( elem, false ) );

  				// Remove any remaining nodes
  				elem.textContent = "";
  			}
  		}

  		return this;
  	},

  	clone: function( dataAndEvents, deepDataAndEvents ) {
  		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  		return this.map( function() {
  			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  		} );
  	},

  	html: function( value ) {
  		return access( this, function( value ) {
  			var elem = this[ 0 ] || {},
  				i = 0,
  				l = this.length;

  			if ( value === undefined && elem.nodeType === 1 ) {
  				return elem.innerHTML;
  			}

  			// See if we can take a shortcut and just use innerHTML
  			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  				value = jQuery.htmlPrefilter( value );

  				try {
  					for ( ; i < l; i++ ) {
  						elem = this[ i ] || {};

  						// Remove element nodes and prevent memory leaks
  						if ( elem.nodeType === 1 ) {
  							jQuery.cleanData( getAll( elem, false ) );
  							elem.innerHTML = value;
  						}
  					}

  					elem = 0;

  				// If using innerHTML throws an exception, use the fallback method
  				} catch ( e ) {}
  			}

  			if ( elem ) {
  				this.empty().append( value );
  			}
  		}, null, value, arguments.length );
  	},

  	replaceWith: function() {
  		var ignored = [];

  		// Make the changes, replacing each non-ignored context element with the new content
  		return domManip( this, arguments, function( elem ) {
  			var parent = this.parentNode;

  			if ( jQuery.inArray( this, ignored ) < 0 ) {
  				jQuery.cleanData( getAll( this ) );
  				if ( parent ) {
  					parent.replaceChild( elem, this );
  				}
  			}

  		// Force callback invocation
  		}, ignored );
  	}
  } );

  jQuery.each( {
  	appendTo: "append",
  	prependTo: "prepend",
  	insertBefore: "before",
  	insertAfter: "after",
  	replaceAll: "replaceWith"
  }, function( name, original ) {
  	jQuery.fn[ name ] = function( selector ) {
  		var elems,
  			ret = [],
  			insert = jQuery( selector ),
  			last = insert.length - 1,
  			i = 0;

  		for ( ; i <= last; i++ ) {
  			elems = i === last ? this : this.clone( true );
  			jQuery( insert[ i ] )[ original ]( elems );

  			// Support: Android <=4.0 only, PhantomJS 1 only
  			// .get() because push.apply(_, arraylike) throws on ancient WebKit
  			push.apply( ret, elems.get() );
  		}

  		return this.pushStack( ret );
  	};
  } );
  var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  var getStyles = function( elem ) {

  		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
  		// IE throws on elements created in popups
  		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  		var view = elem.ownerDocument.defaultView;

  		if ( !view || !view.opener ) {
  			view = window;
  		}

  		return view.getComputedStyle( elem );
  	};

  var swap = function( elem, options, callback ) {
  	var ret, name,
  		old = {};

  	// Remember the old values, and insert the new ones
  	for ( name in options ) {
  		old[ name ] = elem.style[ name ];
  		elem.style[ name ] = options[ name ];
  	}

  	ret = callback.call( elem );

  	// Revert the old values
  	for ( name in options ) {
  		elem.style[ name ] = old[ name ];
  	}

  	return ret;
  };


  var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



  ( function() {

  	// Executing both pixelPosition & boxSizingReliable tests require only one layout
  	// so they're executed at the same time to save the second computation.
  	function computeStyleTests() {

  		// This is a singleton, we need to execute it only once
  		if ( !div ) {
  			return;
  		}

  		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
  			"margin-top:1px;padding:0;border:0";
  		div.style.cssText =
  			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
  			"margin:auto;border:1px;padding:1px;" +
  			"width:60%;top:1%";
  		documentElement.appendChild( container ).appendChild( div );

  		var divStyle = window.getComputedStyle( div );
  		pixelPositionVal = divStyle.top !== "1%";

  		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
  		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

  		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
  		// Some styles come back with percentage values, even though they shouldn't
  		div.style.right = "60%";
  		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

  		// Support: IE 9 - 11 only
  		// Detect misreporting of content dimensions for box-sizing:border-box elements
  		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

  		// Support: IE 9 only
  		// Detect overflow:scroll screwiness (gh-3699)
  		// Support: Chrome <=64
  		// Don't get tricked when zoom affects offsetWidth (gh-4029)
  		div.style.position = "absolute";
  		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

  		documentElement.removeChild( container );

  		// Nullify the div so it wouldn't be stored in the memory and
  		// it will also be a sign that checks already performed
  		div = null;
  	}

  	function roundPixelMeasures( measure ) {
  		return Math.round( parseFloat( measure ) );
  	}

  	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
  		reliableTrDimensionsVal, reliableMarginLeftVal,
  		container = document.createElement( "div" ),
  		div = document.createElement( "div" );

  	// Finish early in limited (non-browser) environments
  	if ( !div.style ) {
  		return;
  	}

  	// Support: IE <=9 - 11 only
  	// Style of cloned element affects source element cloned (#8908)
  	div.style.backgroundClip = "content-box";
  	div.cloneNode( true ).style.backgroundClip = "";
  	support.clearCloneStyle = div.style.backgroundClip === "content-box";

  	jQuery.extend( support, {
  		boxSizingReliable: function() {
  			computeStyleTests();
  			return boxSizingReliableVal;
  		},
  		pixelBoxStyles: function() {
  			computeStyleTests();
  			return pixelBoxStylesVal;
  		},
  		pixelPosition: function() {
  			computeStyleTests();
  			return pixelPositionVal;
  		},
  		reliableMarginLeft: function() {
  			computeStyleTests();
  			return reliableMarginLeftVal;
  		},
  		scrollboxSize: function() {
  			computeStyleTests();
  			return scrollboxSizeVal;
  		},

  		// Support: IE 9 - 11+, Edge 15 - 18+
  		// IE/Edge misreport `getComputedStyle` of table rows with width/height
  		// set in CSS while `offset*` properties report correct values.
  		// Behavior in IE 9 is more subtle than in newer versions & it passes
  		// some versions of this test; make sure not to make it pass there!
  		reliableTrDimensions: function() {
  			var table, tr, trChild, trStyle;
  			if ( reliableTrDimensionsVal == null ) {
  				table = document.createElement( "table" );
  				tr = document.createElement( "tr" );
  				trChild = document.createElement( "div" );

  				table.style.cssText = "position:absolute;left:-11111px";
  				tr.style.height = "1px";
  				trChild.style.height = "9px";

  				documentElement
  					.appendChild( table )
  					.appendChild( tr )
  					.appendChild( trChild );

  				trStyle = window.getComputedStyle( tr );
  				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

  				documentElement.removeChild( table );
  			}
  			return reliableTrDimensionsVal;
  		}
  	} );
  } )();


  function curCSS( elem, name, computed ) {
  	var width, minWidth, maxWidth, ret,

  		// Support: Firefox 51+
  		// Retrieving style before computed somehow
  		// fixes an issue with getting wrong values
  		// on detached elements
  		style = elem.style;

  	computed = computed || getStyles( elem );

  	// getPropertyValue is needed for:
  	//   .css('filter') (IE 9 only, #12537)
  	//   .css('--customProperty) (#3144)
  	if ( computed ) {
  		ret = computed.getPropertyValue( name ) || computed[ name ];

  		if ( ret === "" && !isAttached( elem ) ) {
  			ret = jQuery.style( elem, name );
  		}

  		// A tribute to the "awesome hack by Dean Edwards"
  		// Android Browser returns percentage for some values,
  		// but width seems to be reliably pixels.
  		// This is against the CSSOM draft spec:
  		// https://drafts.csswg.org/cssom/#resolved-values
  		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

  			// Remember the original values
  			width = style.width;
  			minWidth = style.minWidth;
  			maxWidth = style.maxWidth;

  			// Put in the new values to get a computed value out
  			style.minWidth = style.maxWidth = style.width = ret;
  			ret = computed.width;

  			// Revert the changed values
  			style.width = width;
  			style.minWidth = minWidth;
  			style.maxWidth = maxWidth;
  		}
  	}

  	return ret !== undefined ?

  		// Support: IE <=9 - 11 only
  		// IE returns zIndex value as an integer.
  		ret + "" :
  		ret;
  }


  function addGetHookIf( conditionFn, hookFn ) {

  	// Define the hook, we'll check on the first run if it's really needed.
  	return {
  		get: function() {
  			if ( conditionFn() ) {

  				// Hook not needed (or it's not possible to use it due
  				// to missing dependency), remove it.
  				delete this.get;
  				return;
  			}

  			// Hook needed; redefine it so that the support test is not executed again.
  			return ( this.get = hookFn ).apply( this, arguments );
  		}
  	};
  }


  var cssPrefixes = [ "Webkit", "Moz", "ms" ],
  	emptyStyle = document.createElement( "div" ).style,
  	vendorProps = {};

  // Return a vendor-prefixed property or undefined
  function vendorPropName( name ) {

  	// Check for vendor prefixed names
  	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
  		i = cssPrefixes.length;

  	while ( i-- ) {
  		name = cssPrefixes[ i ] + capName;
  		if ( name in emptyStyle ) {
  			return name;
  		}
  	}
  }

  // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
  function finalPropName( name ) {
  	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

  	if ( final ) {
  		return final;
  	}
  	if ( name in emptyStyle ) {
  		return name;
  	}
  	return vendorProps[ name ] = vendorPropName( name ) || name;
  }


  var

  	// Swappable if display is none or starts with table
  	// except "table", "table-cell", or "table-caption"
  	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  	rcustomProp = /^--/,
  	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  	cssNormalTransform = {
  		letterSpacing: "0",
  		fontWeight: "400"
  	};

  function setPositiveNumber( _elem, value, subtract ) {

  	// Any relative (+/-) values have already been
  	// normalized at this point
  	var matches = rcssNum.exec( value );
  	return matches ?

  		// Guard against undefined "subtract", e.g., when used as in cssHooks
  		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
  		value;
  }

  function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  	var i = dimension === "width" ? 1 : 0,
  		extra = 0,
  		delta = 0;

  	// Adjustment may not be necessary
  	if ( box === ( isBorderBox ? "border" : "content" ) ) {
  		return 0;
  	}

  	for ( ; i < 4; i += 2 ) {

  		// Both box models exclude margin
  		if ( box === "margin" ) {
  			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
  		}

  		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
  		if ( !isBorderBox ) {

  			// Add padding
  			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  			// For "border" or "margin", add border
  			if ( box !== "padding" ) {
  				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

  			// But still keep track of it otherwise
  			} else {
  				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}

  		// If we get here with a border-box (content + padding + border), we're seeking "content" or
  		// "padding" or "margin"
  		} else {

  			// For "content", subtract padding
  			if ( box === "content" ) {
  				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  			}

  			// For "content" or "padding", subtract border
  			if ( box !== "margin" ) {
  				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}
  		}
  	}

  	// Account for positive content-box scroll gutter when requested by providing computedVal
  	if ( !isBorderBox && computedVal >= 0 ) {

  		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
  		// Assuming integer scroll gutter, subtract the rest and round down
  		delta += Math.max( 0, Math.ceil(
  			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  			computedVal -
  			delta -
  			extra -
  			0.5

  		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
  		// Use an explicit zero to avoid NaN (gh-3964)
  		) ) || 0;
  	}

  	return delta;
  }

  function getWidthOrHeight( elem, dimension, extra ) {

  	// Start with computed style
  	var styles = getStyles( elem ),

  		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
  		// Fake content-box until we know it's needed to know the true value.
  		boxSizingNeeded = !support.boxSizingReliable() || extra,
  		isBorderBox = boxSizingNeeded &&
  			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  		valueIsBorderBox = isBorderBox,

  		val = curCSS( elem, dimension, styles ),
  		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

  	// Support: Firefox <=54
  	// Return a confounding non-pixel value or feign ignorance, as appropriate.
  	if ( rnumnonpx.test( val ) ) {
  		if ( !extra ) {
  			return val;
  		}
  		val = "auto";
  	}


  	// Support: IE 9 - 11 only
  	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
  	// In those cases, the computed value can be trusted to be border-box.
  	if ( ( !support.boxSizingReliable() && isBorderBox ||

  		// Support: IE 10 - 11+, Edge 15 - 18+
  		// IE/Edge misreport `getComputedStyle` of table rows with width/height
  		// set in CSS while `offset*` properties report correct values.
  		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
  		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

  		// Fall back to offsetWidth/offsetHeight when value is "auto"
  		// This happens for inline elements with no explicit setting (gh-3571)
  		val === "auto" ||

  		// Support: Android <=4.1 - 4.3 only
  		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

  		// Make sure the element is visible & connected
  		elem.getClientRects().length ) {

  		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
  		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
  		// retrieved value as a content box dimension.
  		valueIsBorderBox = offsetProp in elem;
  		if ( valueIsBorderBox ) {
  			val = elem[ offsetProp ];
  		}
  	}

  	// Normalize "" and auto
  	val = parseFloat( val ) || 0;

  	// Adjust for the element's box model
  	return ( val +
  		boxModelAdjustment(
  			elem,
  			dimension,
  			extra || ( isBorderBox ? "border" : "content" ),
  			valueIsBorderBox,
  			styles,

  			// Provide the current computed size to request scroll gutter calculation (gh-3589)
  			val
  		)
  	) + "px";
  }

  jQuery.extend( {

  	// Add in style property hooks for overriding the default
  	// behavior of getting and setting a style property
  	cssHooks: {
  		opacity: {
  			get: function( elem, computed ) {
  				if ( computed ) {

  					// We should always get a number back from opacity
  					var ret = curCSS( elem, "opacity" );
  					return ret === "" ? "1" : ret;
  				}
  			}
  		}
  	},

  	// Don't automatically add "px" to these possibly-unitless properties
  	cssNumber: {
  		"animationIterationCount": true,
  		"columnCount": true,
  		"fillOpacity": true,
  		"flexGrow": true,
  		"flexShrink": true,
  		"fontWeight": true,
  		"gridArea": true,
  		"gridColumn": true,
  		"gridColumnEnd": true,
  		"gridColumnStart": true,
  		"gridRow": true,
  		"gridRowEnd": true,
  		"gridRowStart": true,
  		"lineHeight": true,
  		"opacity": true,
  		"order": true,
  		"orphans": true,
  		"widows": true,
  		"zIndex": true,
  		"zoom": true
  	},

  	// Add in properties whose names you wish to fix before
  	// setting or getting the value
  	cssProps: {},

  	// Get and set the style property on a DOM Node
  	style: function( elem, name, value, extra ) {

  		// Don't set styles on text and comment nodes
  		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  			return;
  		}

  		// Make sure that we're working with the right name
  		var ret, type, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name ),
  			style = elem.style;

  		// Make sure that we're working with the right name. We don't
  		// want to query the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Gets hook for the prefixed version, then unprefixed version
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// Check if we're setting a value
  		if ( value !== undefined ) {
  			type = typeof value;

  			// Convert "+=" or "-=" to relative numbers (#7345)
  			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
  				value = adjustCSS( elem, name, ret );

  				// Fixes bug #9237
  				type = "number";
  			}

  			// Make sure that null and NaN values aren't set (#7116)
  			if ( value == null || value !== value ) {
  				return;
  			}

  			// If a number was passed in, add the unit (except for certain CSS properties)
  			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
  			// "px" to a few hardcoded values.
  			if ( type === "number" && !isCustomProp ) {
  				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
  			}

  			// background-* props affect original clone's values
  			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  				style[ name ] = "inherit";
  			}

  			// If a hook was provided, use that value, otherwise just set the specified value
  			if ( !hooks || !( "set" in hooks ) ||
  				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

  				if ( isCustomProp ) {
  					style.setProperty( name, value );
  				} else {
  					style[ name ] = value;
  				}
  			}

  		} else {

  			// If a hook was provided get the non-computed value from there
  			if ( hooks && "get" in hooks &&
  				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

  				return ret;
  			}

  			// Otherwise just get the value from the style object
  			return style[ name ];
  		}
  	},

  	css: function( elem, name, extra, styles ) {
  		var val, num, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name );

  		// Make sure that we're working with the right name. We don't
  		// want to modify the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Try prefixed name followed by the unprefixed name
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// If a hook was provided get the computed value from there
  		if ( hooks && "get" in hooks ) {
  			val = hooks.get( elem, true, extra );
  		}

  		// Otherwise, if a way to get the computed value exists, use that
  		if ( val === undefined ) {
  			val = curCSS( elem, name, styles );
  		}

  		// Convert "normal" to computed value
  		if ( val === "normal" && name in cssNormalTransform ) {
  			val = cssNormalTransform[ name ];
  		}

  		// Make numeric if forced or a qualifier was provided and val looks numeric
  		if ( extra === "" || extra ) {
  			num = parseFloat( val );
  			return extra === true || isFinite( num ) ? num || 0 : val;
  		}

  		return val;
  	}
  } );

  jQuery.each( [ "height", "width" ], function( _i, dimension ) {
  	jQuery.cssHooks[ dimension ] = {
  		get: function( elem, computed, extra ) {
  			if ( computed ) {

  				// Certain elements can have dimension info if we invisibly show them
  				// but it must have a current display style that would benefit
  				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

  					// Support: Safari 8+
  					// Table columns in Safari have non-zero offsetWidth & zero
  					// getBoundingClientRect().width unless display is changed.
  					// Support: IE <=11 only
  					// Running getBoundingClientRect on a disconnected node
  					// in IE throws an error.
  					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
  						swap( elem, cssShow, function() {
  							return getWidthOrHeight( elem, dimension, extra );
  						} ) :
  						getWidthOrHeight( elem, dimension, extra );
  			}
  		},

  		set: function( elem, value, extra ) {
  			var matches,
  				styles = getStyles( elem ),

  				// Only read styles.position if the test has a chance to fail
  				// to avoid forcing a reflow.
  				scrollboxSizeBuggy = !support.scrollboxSize() &&
  					styles.position === "absolute",

  				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
  				boxSizingNeeded = scrollboxSizeBuggy || extra,
  				isBorderBox = boxSizingNeeded &&
  					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  				subtract = extra ?
  					boxModelAdjustment(
  						elem,
  						dimension,
  						extra,
  						isBorderBox,
  						styles
  					) :
  					0;

  			// Account for unreliable border-box dimensions by comparing offset* to computed and
  			// faking a content-box to get border and padding (gh-3699)
  			if ( isBorderBox && scrollboxSizeBuggy ) {
  				subtract -= Math.ceil(
  					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  					parseFloat( styles[ dimension ] ) -
  					boxModelAdjustment( elem, dimension, "border", false, styles ) -
  					0.5
  				);
  			}

  			// Convert to pixels if value adjustment is needed
  			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
  				( matches[ 3 ] || "px" ) !== "px" ) {

  				elem.style[ dimension ] = value;
  				value = jQuery.css( elem, dimension );
  			}

  			return setPositiveNumber( elem, value, subtract );
  		}
  	};
  } );

  jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  	function( elem, computed ) {
  		if ( computed ) {
  			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
  				elem.getBoundingClientRect().left -
  					swap( elem, { marginLeft: 0 }, function() {
  						return elem.getBoundingClientRect().left;
  					} )
  				) + "px";
  		}
  	}
  );

  // These hooks are used by animate to expand properties
  jQuery.each( {
  	margin: "",
  	padding: "",
  	border: "Width"
  }, function( prefix, suffix ) {
  	jQuery.cssHooks[ prefix + suffix ] = {
  		expand: function( value ) {
  			var i = 0,
  				expanded = {},

  				// Assumes a single number if not a string
  				parts = typeof value === "string" ? value.split( " " ) : [ value ];

  			for ( ; i < 4; i++ ) {
  				expanded[ prefix + cssExpand[ i ] + suffix ] =
  					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  			}

  			return expanded;
  		}
  	};

  	if ( prefix !== "margin" ) {
  		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  	}
  } );

  jQuery.fn.extend( {
  	css: function( name, value ) {
  		return access( this, function( elem, name, value ) {
  			var styles, len,
  				map = {},
  				i = 0;

  			if ( Array.isArray( name ) ) {
  				styles = getStyles( elem );
  				len = name.length;

  				for ( ; i < len; i++ ) {
  					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  				}

  				return map;
  			}

  			return value !== undefined ?
  				jQuery.style( elem, name, value ) :
  				jQuery.css( elem, name );
  		}, name, value, arguments.length > 1 );
  	}
  } );


  function Tween( elem, options, prop, end, easing ) {
  	return new Tween.prototype.init( elem, options, prop, end, easing );
  }
  jQuery.Tween = Tween;

  Tween.prototype = {
  	constructor: Tween,
  	init: function( elem, options, prop, end, easing, unit ) {
  		this.elem = elem;
  		this.prop = prop;
  		this.easing = easing || jQuery.easing._default;
  		this.options = options;
  		this.start = this.now = this.cur();
  		this.end = end;
  		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  	},
  	cur: function() {
  		var hooks = Tween.propHooks[ this.prop ];

  		return hooks && hooks.get ?
  			hooks.get( this ) :
  			Tween.propHooks._default.get( this );
  	},
  	run: function( percent ) {
  		var eased,
  			hooks = Tween.propHooks[ this.prop ];

  		if ( this.options.duration ) {
  			this.pos = eased = jQuery.easing[ this.easing ](
  				percent, this.options.duration * percent, 0, 1, this.options.duration
  			);
  		} else {
  			this.pos = eased = percent;
  		}
  		this.now = ( this.end - this.start ) * eased + this.start;

  		if ( this.options.step ) {
  			this.options.step.call( this.elem, this.now, this );
  		}

  		if ( hooks && hooks.set ) {
  			hooks.set( this );
  		} else {
  			Tween.propHooks._default.set( this );
  		}
  		return this;
  	}
  };

  Tween.prototype.init.prototype = Tween.prototype;

  Tween.propHooks = {
  	_default: {
  		get: function( tween ) {
  			var result;

  			// Use a property on the element directly when it is not a DOM element,
  			// or when there is no matching style property that exists.
  			if ( tween.elem.nodeType !== 1 ||
  				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
  				return tween.elem[ tween.prop ];
  			}

  			// Passing an empty string as a 3rd parameter to .css will automatically
  			// attempt a parseFloat and fallback to a string if the parse fails.
  			// Simple values such as "10px" are parsed to Float;
  			// complex values such as "rotate(1rad)" are returned as-is.
  			result = jQuery.css( tween.elem, tween.prop, "" );

  			// Empty strings, null, undefined and "auto" are converted to 0.
  			return !result || result === "auto" ? 0 : result;
  		},
  		set: function( tween ) {

  			// Use step hook for back compat.
  			// Use cssHook if its there.
  			// Use .style if available and use plain properties where available.
  			if ( jQuery.fx.step[ tween.prop ] ) {
  				jQuery.fx.step[ tween.prop ]( tween );
  			} else if ( tween.elem.nodeType === 1 && (
  					jQuery.cssHooks[ tween.prop ] ||
  					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
  				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
  			} else {
  				tween.elem[ tween.prop ] = tween.now;
  			}
  		}
  	}
  };

  // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  	set: function( tween ) {
  		if ( tween.elem.nodeType && tween.elem.parentNode ) {
  			tween.elem[ tween.prop ] = tween.now;
  		}
  	}
  };

  jQuery.easing = {
  	linear: function( p ) {
  		return p;
  	},
  	swing: function( p ) {
  		return 0.5 - Math.cos( p * Math.PI ) / 2;
  	},
  	_default: "swing"
  };

  jQuery.fx = Tween.prototype.init;

  // Back compat <1.8 extension point
  jQuery.fx.step = {};




  var
  	fxNow, inProgress,
  	rfxtypes = /^(?:toggle|show|hide)$/,
  	rrun = /queueHooks$/;

  function schedule() {
  	if ( inProgress ) {
  		if ( document.hidden === false && window.requestAnimationFrame ) {
  			window.requestAnimationFrame( schedule );
  		} else {
  			window.setTimeout( schedule, jQuery.fx.interval );
  		}

  		jQuery.fx.tick();
  	}
  }

  // Animations created synchronously will run synchronously
  function createFxNow() {
  	window.setTimeout( function() {
  		fxNow = undefined;
  	} );
  	return ( fxNow = Date.now() );
  }

  // Generate parameters to create a standard animation
  function genFx( type, includeWidth ) {
  	var which,
  		i = 0,
  		attrs = { height: type };

  	// If we include width, step value is 1 to do all cssExpand values,
  	// otherwise step value is 2 to skip over Left and Right
  	includeWidth = includeWidth ? 1 : 0;
  	for ( ; i < 4; i += 2 - includeWidth ) {
  		which = cssExpand[ i ];
  		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  	}

  	if ( includeWidth ) {
  		attrs.opacity = attrs.width = type;
  	}

  	return attrs;
  }

  function createTween( value, prop, animation ) {
  	var tween,
  		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
  		index = 0,
  		length = collection.length;
  	for ( ; index < length; index++ ) {
  		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

  			// We're done with this property
  			return tween;
  		}
  	}
  }

  function defaultPrefilter( elem, props, opts ) {
  	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
  		isBox = "width" in props || "height" in props,
  		anim = this,
  		orig = {},
  		style = elem.style,
  		hidden = elem.nodeType && isHiddenWithinTree( elem ),
  		dataShow = dataPriv.get( elem, "fxshow" );

  	// Queue-skipping animations hijack the fx hooks
  	if ( !opts.queue ) {
  		hooks = jQuery._queueHooks( elem, "fx" );
  		if ( hooks.unqueued == null ) {
  			hooks.unqueued = 0;
  			oldfire = hooks.empty.fire;
  			hooks.empty.fire = function() {
  				if ( !hooks.unqueued ) {
  					oldfire();
  				}
  			};
  		}
  		hooks.unqueued++;

  		anim.always( function() {

  			// Ensure the complete handler is called before this completes
  			anim.always( function() {
  				hooks.unqueued--;
  				if ( !jQuery.queue( elem, "fx" ).length ) {
  					hooks.empty.fire();
  				}
  			} );
  		} );
  	}

  	// Detect show/hide animations
  	for ( prop in props ) {
  		value = props[ prop ];
  		if ( rfxtypes.test( value ) ) {
  			delete props[ prop ];
  			toggle = toggle || value === "toggle";
  			if ( value === ( hidden ? "hide" : "show" ) ) {

  				// Pretend to be hidden if this is a "show" and
  				// there is still data from a stopped show/hide
  				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
  					hidden = true;

  				// Ignore all other no-op show/hide data
  				} else {
  					continue;
  				}
  			}
  			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
  		}
  	}

  	// Bail out if this is a no-op like .hide().hide()
  	propTween = !jQuery.isEmptyObject( props );
  	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
  		return;
  	}

  	// Restrict "overflow" and "display" styles during box animations
  	if ( isBox && elem.nodeType === 1 ) {

  		// Support: IE <=9 - 11, Edge 12 - 15
  		// Record all 3 overflow attributes because IE does not infer the shorthand
  		// from identically-valued overflowX and overflowY and Edge just mirrors
  		// the overflowX value there.
  		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

  		// Identify a display type, preferring old show/hide data over the CSS cascade
  		restoreDisplay = dataShow && dataShow.display;
  		if ( restoreDisplay == null ) {
  			restoreDisplay = dataPriv.get( elem, "display" );
  		}
  		display = jQuery.css( elem, "display" );
  		if ( display === "none" ) {
  			if ( restoreDisplay ) {
  				display = restoreDisplay;
  			} else {

  				// Get nonempty value(s) by temporarily forcing visibility
  				showHide( [ elem ], true );
  				restoreDisplay = elem.style.display || restoreDisplay;
  				display = jQuery.css( elem, "display" );
  				showHide( [ elem ] );
  			}
  		}

  		// Animate inline elements as inline-block
  		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
  			if ( jQuery.css( elem, "float" ) === "none" ) {

  				// Restore the original display value at the end of pure show/hide animations
  				if ( !propTween ) {
  					anim.done( function() {
  						style.display = restoreDisplay;
  					} );
  					if ( restoreDisplay == null ) {
  						display = style.display;
  						restoreDisplay = display === "none" ? "" : display;
  					}
  				}
  				style.display = "inline-block";
  			}
  		}
  	}

  	if ( opts.overflow ) {
  		style.overflow = "hidden";
  		anim.always( function() {
  			style.overflow = opts.overflow[ 0 ];
  			style.overflowX = opts.overflow[ 1 ];
  			style.overflowY = opts.overflow[ 2 ];
  		} );
  	}

  	// Implement show/hide animations
  	propTween = false;
  	for ( prop in orig ) {

  		// General show/hide setup for this element animation
  		if ( !propTween ) {
  			if ( dataShow ) {
  				if ( "hidden" in dataShow ) {
  					hidden = dataShow.hidden;
  				}
  			} else {
  				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
  			}

  			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
  			if ( toggle ) {
  				dataShow.hidden = !hidden;
  			}

  			// Show elements before animating them
  			if ( hidden ) {
  				showHide( [ elem ], true );
  			}

  			/* eslint-disable no-loop-func */

  			anim.done( function() {

  			/* eslint-enable no-loop-func */

  				// The final step of a "hide" animation is actually hiding the element
  				if ( !hidden ) {
  					showHide( [ elem ] );
  				}
  				dataPriv.remove( elem, "fxshow" );
  				for ( prop in orig ) {
  					jQuery.style( elem, prop, orig[ prop ] );
  				}
  			} );
  		}

  		// Per-property setup
  		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
  		if ( !( prop in dataShow ) ) {
  			dataShow[ prop ] = propTween.start;
  			if ( hidden ) {
  				propTween.end = propTween.start;
  				propTween.start = 0;
  			}
  		}
  	}
  }

  function propFilter( props, specialEasing ) {
  	var index, name, easing, value, hooks;

  	// camelCase, specialEasing and expand cssHook pass
  	for ( index in props ) {
  		name = camelCase( index );
  		easing = specialEasing[ name ];
  		value = props[ index ];
  		if ( Array.isArray( value ) ) {
  			easing = value[ 1 ];
  			value = props[ index ] = value[ 0 ];
  		}

  		if ( index !== name ) {
  			props[ name ] = value;
  			delete props[ index ];
  		}

  		hooks = jQuery.cssHooks[ name ];
  		if ( hooks && "expand" in hooks ) {
  			value = hooks.expand( value );
  			delete props[ name ];

  			// Not quite $.extend, this won't overwrite existing keys.
  			// Reusing 'index' because we have the correct "name"
  			for ( index in value ) {
  				if ( !( index in props ) ) {
  					props[ index ] = value[ index ];
  					specialEasing[ index ] = easing;
  				}
  			}
  		} else {
  			specialEasing[ name ] = easing;
  		}
  	}
  }

  function Animation( elem, properties, options ) {
  	var result,
  		stopped,
  		index = 0,
  		length = Animation.prefilters.length,
  		deferred = jQuery.Deferred().always( function() {

  			// Don't match elem in the :animated selector
  			delete tick.elem;
  		} ),
  		tick = function() {
  			if ( stopped ) {
  				return false;
  			}
  			var currentTime = fxNow || createFxNow(),
  				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

  				// Support: Android 2.3 only
  				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
  				temp = remaining / animation.duration || 0,
  				percent = 1 - temp,
  				index = 0,
  				length = animation.tweens.length;

  			for ( ; index < length; index++ ) {
  				animation.tweens[ index ].run( percent );
  			}

  			deferred.notifyWith( elem, [ animation, percent, remaining ] );

  			// If there's more to do, yield
  			if ( percent < 1 && length ) {
  				return remaining;
  			}

  			// If this was an empty animation, synthesize a final progress notification
  			if ( !length ) {
  				deferred.notifyWith( elem, [ animation, 1, 0 ] );
  			}

  			// Resolve the animation and report its conclusion
  			deferred.resolveWith( elem, [ animation ] );
  			return false;
  		},
  		animation = deferred.promise( {
  			elem: elem,
  			props: jQuery.extend( {}, properties ),
  			opts: jQuery.extend( true, {
  				specialEasing: {},
  				easing: jQuery.easing._default
  			}, options ),
  			originalProperties: properties,
  			originalOptions: options,
  			startTime: fxNow || createFxNow(),
  			duration: options.duration,
  			tweens: [],
  			createTween: function( prop, end ) {
  				var tween = jQuery.Tween( elem, animation.opts, prop, end,
  						animation.opts.specialEasing[ prop ] || animation.opts.easing );
  				animation.tweens.push( tween );
  				return tween;
  			},
  			stop: function( gotoEnd ) {
  				var index = 0,

  					// If we are going to the end, we want to run all the tweens
  					// otherwise we skip this part
  					length = gotoEnd ? animation.tweens.length : 0;
  				if ( stopped ) {
  					return this;
  				}
  				stopped = true;
  				for ( ; index < length; index++ ) {
  					animation.tweens[ index ].run( 1 );
  				}

  				// Resolve when we played the last frame; otherwise, reject
  				if ( gotoEnd ) {
  					deferred.notifyWith( elem, [ animation, 1, 0 ] );
  					deferred.resolveWith( elem, [ animation, gotoEnd ] );
  				} else {
  					deferred.rejectWith( elem, [ animation, gotoEnd ] );
  				}
  				return this;
  			}
  		} ),
  		props = animation.props;

  	propFilter( props, animation.opts.specialEasing );

  	for ( ; index < length; index++ ) {
  		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
  		if ( result ) {
  			if ( isFunction( result.stop ) ) {
  				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
  					result.stop.bind( result );
  			}
  			return result;
  		}
  	}

  	jQuery.map( props, createTween, animation );

  	if ( isFunction( animation.opts.start ) ) {
  		animation.opts.start.call( elem, animation );
  	}

  	// Attach callbacks from options
  	animation
  		.progress( animation.opts.progress )
  		.done( animation.opts.done, animation.opts.complete )
  		.fail( animation.opts.fail )
  		.always( animation.opts.always );

  	jQuery.fx.timer(
  		jQuery.extend( tick, {
  			elem: elem,
  			anim: animation,
  			queue: animation.opts.queue
  		} )
  	);

  	return animation;
  }

  jQuery.Animation = jQuery.extend( Animation, {

  	tweeners: {
  		"*": [ function( prop, value ) {
  			var tween = this.createTween( prop, value );
  			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
  			return tween;
  		} ]
  	},

  	tweener: function( props, callback ) {
  		if ( isFunction( props ) ) {
  			callback = props;
  			props = [ "*" ];
  		} else {
  			props = props.match( rnothtmlwhite );
  		}

  		var prop,
  			index = 0,
  			length = props.length;

  		for ( ; index < length; index++ ) {
  			prop = props[ index ];
  			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
  			Animation.tweeners[ prop ].unshift( callback );
  		}
  	},

  	prefilters: [ defaultPrefilter ],

  	prefilter: function( callback, prepend ) {
  		if ( prepend ) {
  			Animation.prefilters.unshift( callback );
  		} else {
  			Animation.prefilters.push( callback );
  		}
  	}
  } );

  jQuery.speed = function( speed, easing, fn ) {
  	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
  		complete: fn || !fn && easing ||
  			isFunction( speed ) && speed,
  		duration: speed,
  		easing: fn && easing || easing && !isFunction( easing ) && easing
  	};

  	// Go to the end state if fx are off
  	if ( jQuery.fx.off ) {
  		opt.duration = 0;

  	} else {
  		if ( typeof opt.duration !== "number" ) {
  			if ( opt.duration in jQuery.fx.speeds ) {
  				opt.duration = jQuery.fx.speeds[ opt.duration ];

  			} else {
  				opt.duration = jQuery.fx.speeds._default;
  			}
  		}
  	}

  	// Normalize opt.queue - true/undefined/null -> "fx"
  	if ( opt.queue == null || opt.queue === true ) {
  		opt.queue = "fx";
  	}

  	// Queueing
  	opt.old = opt.complete;

  	opt.complete = function() {
  		if ( isFunction( opt.old ) ) {
  			opt.old.call( this );
  		}

  		if ( opt.queue ) {
  			jQuery.dequeue( this, opt.queue );
  		}
  	};

  	return opt;
  };

  jQuery.fn.extend( {
  	fadeTo: function( speed, to, easing, callback ) {

  		// Show any hidden elements after setting opacity to 0
  		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

  			// Animate to the value specified
  			.end().animate( { opacity: to }, speed, easing, callback );
  	},
  	animate: function( prop, speed, easing, callback ) {
  		var empty = jQuery.isEmptyObject( prop ),
  			optall = jQuery.speed( speed, easing, callback ),
  			doAnimation = function() {

  				// Operate on a copy of prop so per-property easing won't be lost
  				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

  				// Empty animations, or finishing resolves immediately
  				if ( empty || dataPriv.get( this, "finish" ) ) {
  					anim.stop( true );
  				}
  			};
  			doAnimation.finish = doAnimation;

  		return empty || optall.queue === false ?
  			this.each( doAnimation ) :
  			this.queue( optall.queue, doAnimation );
  	},
  	stop: function( type, clearQueue, gotoEnd ) {
  		var stopQueue = function( hooks ) {
  			var stop = hooks.stop;
  			delete hooks.stop;
  			stop( gotoEnd );
  		};

  		if ( typeof type !== "string" ) {
  			gotoEnd = clearQueue;
  			clearQueue = type;
  			type = undefined;
  		}
  		if ( clearQueue ) {
  			this.queue( type || "fx", [] );
  		}

  		return this.each( function() {
  			var dequeue = true,
  				index = type != null && type + "queueHooks",
  				timers = jQuery.timers,
  				data = dataPriv.get( this );

  			if ( index ) {
  				if ( data[ index ] && data[ index ].stop ) {
  					stopQueue( data[ index ] );
  				}
  			} else {
  				for ( index in data ) {
  					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
  						stopQueue( data[ index ] );
  					}
  				}
  			}

  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this &&
  					( type == null || timers[ index ].queue === type ) ) {

  					timers[ index ].anim.stop( gotoEnd );
  					dequeue = false;
  					timers.splice( index, 1 );
  				}
  			}

  			// Start the next in the queue if the last step wasn't forced.
  			// Timers currently will call their complete callbacks, which
  			// will dequeue but only if they were gotoEnd.
  			if ( dequeue || !gotoEnd ) {
  				jQuery.dequeue( this, type );
  			}
  		} );
  	},
  	finish: function( type ) {
  		if ( type !== false ) {
  			type = type || "fx";
  		}
  		return this.each( function() {
  			var index,
  				data = dataPriv.get( this ),
  				queue = data[ type + "queue" ],
  				hooks = data[ type + "queueHooks" ],
  				timers = jQuery.timers,
  				length = queue ? queue.length : 0;

  			// Enable finishing flag on private data
  			data.finish = true;

  			// Empty the queue first
  			jQuery.queue( this, type, [] );

  			if ( hooks && hooks.stop ) {
  				hooks.stop.call( this, true );
  			}

  			// Look for any active animations, and finish them
  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
  					timers[ index ].anim.stop( true );
  					timers.splice( index, 1 );
  				}
  			}

  			// Look for any animations in the old queue and finish them
  			for ( index = 0; index < length; index++ ) {
  				if ( queue[ index ] && queue[ index ].finish ) {
  					queue[ index ].finish.call( this );
  				}
  			}

  			// Turn off finishing flag
  			delete data.finish;
  		} );
  	}
  } );

  jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
  	var cssFn = jQuery.fn[ name ];
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return speed == null || typeof speed === "boolean" ?
  			cssFn.apply( this, arguments ) :
  			this.animate( genFx( name, true ), speed, easing, callback );
  	};
  } );

  // Generate shortcuts for custom animations
  jQuery.each( {
  	slideDown: genFx( "show" ),
  	slideUp: genFx( "hide" ),
  	slideToggle: genFx( "toggle" ),
  	fadeIn: { opacity: "show" },
  	fadeOut: { opacity: "hide" },
  	fadeToggle: { opacity: "toggle" }
  }, function( name, props ) {
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return this.animate( props, speed, easing, callback );
  	};
  } );

  jQuery.timers = [];
  jQuery.fx.tick = function() {
  	var timer,
  		i = 0,
  		timers = jQuery.timers;

  	fxNow = Date.now();

  	for ( ; i < timers.length; i++ ) {
  		timer = timers[ i ];

  		// Run the timer and safely remove it when done (allowing for external removal)
  		if ( !timer() && timers[ i ] === timer ) {
  			timers.splice( i--, 1 );
  		}
  	}

  	if ( !timers.length ) {
  		jQuery.fx.stop();
  	}
  	fxNow = undefined;
  };

  jQuery.fx.timer = function( timer ) {
  	jQuery.timers.push( timer );
  	jQuery.fx.start();
  };

  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
  	if ( inProgress ) {
  		return;
  	}

  	inProgress = true;
  	schedule();
  };

  jQuery.fx.stop = function() {
  	inProgress = null;
  };

  jQuery.fx.speeds = {
  	slow: 600,
  	fast: 200,

  	// Default speed
  	_default: 400
  };


  // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function( time, type ) {
  	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  	type = type || "fx";

  	return this.queue( type, function( next, hooks ) {
  		var timeout = window.setTimeout( next, time );
  		hooks.stop = function() {
  			window.clearTimeout( timeout );
  		};
  	} );
  };


  ( function() {
  	var input = document.createElement( "input" ),
  		select = document.createElement( "select" ),
  		opt = select.appendChild( document.createElement( "option" ) );

  	input.type = "checkbox";

  	// Support: Android <=4.3 only
  	// Default value for a checkbox should be "on"
  	support.checkOn = input.value !== "";

  	// Support: IE <=11 only
  	// Must access selectedIndex to make default options select
  	support.optSelected = opt.selected;

  	// Support: IE <=11 only
  	// An input loses its value after becoming a radio
  	input = document.createElement( "input" );
  	input.value = "t";
  	input.type = "radio";
  	support.radioValue = input.value === "t";
  } )();


  var boolHook,
  	attrHandle = jQuery.expr.attrHandle;

  jQuery.fn.extend( {
  	attr: function( name, value ) {
  		return access( this, jQuery.attr, name, value, arguments.length > 1 );
  	},

  	removeAttr: function( name ) {
  		return this.each( function() {
  			jQuery.removeAttr( this, name );
  		} );
  	}
  } );

  jQuery.extend( {
  	attr: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set attributes on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		// Fallback to prop when attributes are not supported
  		if ( typeof elem.getAttribute === "undefined" ) {
  			return jQuery.prop( elem, name, value );
  		}

  		// Attribute hooks are determined by the lowercase version
  		// Grab necessary hook if one is defined
  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
  				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
  		}

  		if ( value !== undefined ) {
  			if ( value === null ) {
  				jQuery.removeAttr( elem, name );
  				return;
  			}

  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			elem.setAttribute( name, value + "" );
  			return value;
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		ret = jQuery.find.attr( elem, name );

  		// Non-existent attributes return null, we normalize to undefined
  		return ret == null ? undefined : ret;
  	},

  	attrHooks: {
  		type: {
  			set: function( elem, value ) {
  				if ( !support.radioValue && value === "radio" &&
  					nodeName( elem, "input" ) ) {
  					var val = elem.value;
  					elem.setAttribute( "type", value );
  					if ( val ) {
  						elem.value = val;
  					}
  					return value;
  				}
  			}
  		}
  	},

  	removeAttr: function( elem, value ) {
  		var name,
  			i = 0,

  			// Attribute names can contain non-HTML whitespace characters
  			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
  			attrNames = value && value.match( rnothtmlwhite );

  		if ( attrNames && elem.nodeType === 1 ) {
  			while ( ( name = attrNames[ i++ ] ) ) {
  				elem.removeAttribute( name );
  			}
  		}
  	}
  } );

  // Hooks for boolean attributes
  boolHook = {
  	set: function( elem, value, name ) {
  		if ( value === false ) {

  			// Remove boolean attributes when set to false
  			jQuery.removeAttr( elem, name );
  		} else {
  			elem.setAttribute( name, name );
  		}
  		return name;
  	}
  };

  jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
  	var getter = attrHandle[ name ] || jQuery.find.attr;

  	attrHandle[ name ] = function( elem, name, isXML ) {
  		var ret, handle,
  			lowercaseName = name.toLowerCase();

  		if ( !isXML ) {

  			// Avoid an infinite loop by temporarily removing this function from the getter
  			handle = attrHandle[ lowercaseName ];
  			attrHandle[ lowercaseName ] = ret;
  			ret = getter( elem, name, isXML ) != null ?
  				lowercaseName :
  				null;
  			attrHandle[ lowercaseName ] = handle;
  		}
  		return ret;
  	};
  } );




  var rfocusable = /^(?:input|select|textarea|button)$/i,
  	rclickable = /^(?:a|area)$/i;

  jQuery.fn.extend( {
  	prop: function( name, value ) {
  		return access( this, jQuery.prop, name, value, arguments.length > 1 );
  	},

  	removeProp: function( name ) {
  		return this.each( function() {
  			delete this[ jQuery.propFix[ name ] || name ];
  		} );
  	}
  } );

  jQuery.extend( {
  	prop: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set properties on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

  			// Fix name and attach hooks
  			name = jQuery.propFix[ name ] || name;
  			hooks = jQuery.propHooks[ name ];
  		}

  		if ( value !== undefined ) {
  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			return ( elem[ name ] = value );
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		return elem[ name ];
  	},

  	propHooks: {
  		tabIndex: {
  			get: function( elem ) {

  				// Support: IE <=9 - 11 only
  				// elem.tabIndex doesn't always return the
  				// correct value when it hasn't been explicitly set
  				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
  				// Use proper attribute retrieval(#12072)
  				var tabindex = jQuery.find.attr( elem, "tabindex" );

  				if ( tabindex ) {
  					return parseInt( tabindex, 10 );
  				}

  				if (
  					rfocusable.test( elem.nodeName ) ||
  					rclickable.test( elem.nodeName ) &&
  					elem.href
  				) {
  					return 0;
  				}

  				return -1;
  			}
  		}
  	},

  	propFix: {
  		"for": "htmlFor",
  		"class": "className"
  	}
  } );

  // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop
  if ( !support.optSelected ) {
  	jQuery.propHooks.selected = {
  		get: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent && parent.parentNode ) {
  				parent.parentNode.selectedIndex;
  			}
  			return null;
  		},
  		set: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent ) {
  				parent.selectedIndex;

  				if ( parent.parentNode ) {
  					parent.parentNode.selectedIndex;
  				}
  			}
  		}
  	};
  }

  jQuery.each( [
  	"tabIndex",
  	"readOnly",
  	"maxLength",
  	"cellSpacing",
  	"cellPadding",
  	"rowSpan",
  	"colSpan",
  	"useMap",
  	"frameBorder",
  	"contentEditable"
  ], function() {
  	jQuery.propFix[ this.toLowerCase() ] = this;
  } );




  	// Strip and collapse whitespace according to HTML spec
  	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  	function stripAndCollapse( value ) {
  		var tokens = value.match( rnothtmlwhite ) || [];
  		return tokens.join( " " );
  	}


  function getClass( elem ) {
  	return elem.getAttribute && elem.getAttribute( "class" ) || "";
  }

  function classesToArray( value ) {
  	if ( Array.isArray( value ) ) {
  		return value;
  	}
  	if ( typeof value === "string" ) {
  		return value.match( rnothtmlwhite ) || [];
  	}
  	return [];
  }

  jQuery.fn.extend( {
  	addClass: function( value ) {
  		var classes, elem, cur, curValue, clazz, j, finalValue,
  			i = 0;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		classes = classesToArray( value );

  		if ( classes.length ) {
  			while ( ( elem = this[ i++ ] ) ) {
  				curValue = getClass( elem );
  				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					j = 0;
  					while ( ( clazz = classes[ j++ ] ) ) {
  						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
  							cur += clazz + " ";
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						elem.setAttribute( "class", finalValue );
  					}
  				}
  			}
  		}

  		return this;
  	},

  	removeClass: function( value ) {
  		var classes, elem, cur, curValue, clazz, j, finalValue,
  			i = 0;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		if ( !arguments.length ) {
  			return this.attr( "class", "" );
  		}

  		classes = classesToArray( value );

  		if ( classes.length ) {
  			while ( ( elem = this[ i++ ] ) ) {
  				curValue = getClass( elem );

  				// This expression is here for better compressibility (see addClass)
  				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					j = 0;
  					while ( ( clazz = classes[ j++ ] ) ) {

  						// Remove *all* instances
  						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
  							cur = cur.replace( " " + clazz + " ", " " );
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						elem.setAttribute( "class", finalValue );
  					}
  				}
  			}
  		}

  		return this;
  	},

  	toggleClass: function( value, stateVal ) {
  		var type = typeof value,
  			isValidValue = type === "string" || Array.isArray( value );

  		if ( typeof stateVal === "boolean" && isValidValue ) {
  			return stateVal ? this.addClass( value ) : this.removeClass( value );
  		}

  		if ( isFunction( value ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).toggleClass(
  					value.call( this, i, getClass( this ), stateVal ),
  					stateVal
  				);
  			} );
  		}

  		return this.each( function() {
  			var className, i, self, classNames;

  			if ( isValidValue ) {

  				// Toggle individual class names
  				i = 0;
  				self = jQuery( this );
  				classNames = classesToArray( value );

  				while ( ( className = classNames[ i++ ] ) ) {

  					// Check each className given, space separated list
  					if ( self.hasClass( className ) ) {
  						self.removeClass( className );
  					} else {
  						self.addClass( className );
  					}
  				}

  			// Toggle whole class name
  			} else if ( value === undefined || type === "boolean" ) {
  				className = getClass( this );
  				if ( className ) {

  					// Store className if set
  					dataPriv.set( this, "__className__", className );
  				}

  				// If the element has a class name or if we're passed `false`,
  				// then remove the whole classname (if there was one, the above saved it).
  				// Otherwise bring back whatever was previously saved (if anything),
  				// falling back to the empty string if nothing was stored.
  				if ( this.setAttribute ) {
  					this.setAttribute( "class",
  						className || value === false ?
  						"" :
  						dataPriv.get( this, "__className__" ) || ""
  					);
  				}
  			}
  		} );
  	},

  	hasClass: function( selector ) {
  		var className, elem,
  			i = 0;

  		className = " " + selector + " ";
  		while ( ( elem = this[ i++ ] ) ) {
  			if ( elem.nodeType === 1 &&
  				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
  					return true;
  			}
  		}

  		return false;
  	}
  } );




  var rreturn = /\r/g;

  jQuery.fn.extend( {
  	val: function( value ) {
  		var hooks, ret, valueIsFunction,
  			elem = this[ 0 ];

  		if ( !arguments.length ) {
  			if ( elem ) {
  				hooks = jQuery.valHooks[ elem.type ] ||
  					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  				if ( hooks &&
  					"get" in hooks &&
  					( ret = hooks.get( elem, "value" ) ) !== undefined
  				) {
  					return ret;
  				}

  				ret = elem.value;

  				// Handle most common string cases
  				if ( typeof ret === "string" ) {
  					return ret.replace( rreturn, "" );
  				}

  				// Handle cases where value is null/undef or number
  				return ret == null ? "" : ret;
  			}

  			return;
  		}

  		valueIsFunction = isFunction( value );

  		return this.each( function( i ) {
  			var val;

  			if ( this.nodeType !== 1 ) {
  				return;
  			}

  			if ( valueIsFunction ) {
  				val = value.call( this, i, jQuery( this ).val() );
  			} else {
  				val = value;
  			}

  			// Treat null/undefined as ""; convert numbers to string
  			if ( val == null ) {
  				val = "";

  			} else if ( typeof val === "number" ) {
  				val += "";

  			} else if ( Array.isArray( val ) ) {
  				val = jQuery.map( val, function( value ) {
  					return value == null ? "" : value + "";
  				} );
  			}

  			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  			// If set returns undefined, fall back to normal setting
  			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
  				this.value = val;
  			}
  		} );
  	}
  } );

  jQuery.extend( {
  	valHooks: {
  		option: {
  			get: function( elem ) {

  				var val = jQuery.find.attr( elem, "value" );
  				return val != null ?
  					val :

  					// Support: IE <=10 - 11 only
  					// option.text throws exceptions (#14686, #14858)
  					// Strip and collapse whitespace
  					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
  					stripAndCollapse( jQuery.text( elem ) );
  			}
  		},
  		select: {
  			get: function( elem ) {
  				var value, option, i,
  					options = elem.options,
  					index = elem.selectedIndex,
  					one = elem.type === "select-one",
  					values = one ? null : [],
  					max = one ? index + 1 : options.length;

  				if ( index < 0 ) {
  					i = max;

  				} else {
  					i = one ? index : 0;
  				}

  				// Loop through all the selected options
  				for ( ; i < max; i++ ) {
  					option = options[ i ];

  					// Support: IE <=9 only
  					// IE8-9 doesn't update selected after form reset (#2551)
  					if ( ( option.selected || i === index ) &&

  							// Don't return options that are disabled or in a disabled optgroup
  							!option.disabled &&
  							( !option.parentNode.disabled ||
  								!nodeName( option.parentNode, "optgroup" ) ) ) {

  						// Get the specific value for the option
  						value = jQuery( option ).val();

  						// We don't need an array for one selects
  						if ( one ) {
  							return value;
  						}

  						// Multi-Selects return an array
  						values.push( value );
  					}
  				}

  				return values;
  			},

  			set: function( elem, value ) {
  				var optionSet, option,
  					options = elem.options,
  					values = jQuery.makeArray( value ),
  					i = options.length;

  				while ( i-- ) {
  					option = options[ i ];

  					/* eslint-disable no-cond-assign */

  					if ( option.selected =
  						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
  					) {
  						optionSet = true;
  					}

  					/* eslint-enable no-cond-assign */
  				}

  				// Force browsers to behave consistently when non-matching value is set
  				if ( !optionSet ) {
  					elem.selectedIndex = -1;
  				}
  				return values;
  			}
  		}
  	}
  } );

  // Radios and checkboxes getter/setter
  jQuery.each( [ "radio", "checkbox" ], function() {
  	jQuery.valHooks[ this ] = {
  		set: function( elem, value ) {
  			if ( Array.isArray( value ) ) {
  				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
  			}
  		}
  	};
  	if ( !support.checkOn ) {
  		jQuery.valHooks[ this ].get = function( elem ) {
  			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
  		};
  	}
  } );




  // Return jQuery for attributes-only inclusion


  support.focusin = "onfocusin" in window;


  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  	stopPropagationCallback = function( e ) {
  		e.stopPropagation();
  	};

  jQuery.extend( jQuery.event, {

  	trigger: function( event, data, elem, onlyHandlers ) {

  		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
  			eventPath = [ elem || document ],
  			type = hasOwn.call( event, "type" ) ? event.type : event,
  			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

  		cur = lastElement = tmp = elem = elem || document;

  		// Don't do events on text and comment nodes
  		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  			return;
  		}

  		// focus/blur morphs to focusin/out; ensure we're not firing them right now
  		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  			return;
  		}

  		if ( type.indexOf( "." ) > -1 ) {

  			// Namespaced trigger; create a regexp to match event type in handle()
  			namespaces = type.split( "." );
  			type = namespaces.shift();
  			namespaces.sort();
  		}
  		ontype = type.indexOf( ":" ) < 0 && "on" + type;

  		// Caller can pass in a jQuery.Event object, Object, or just an event type string
  		event = event[ jQuery.expando ] ?
  			event :
  			new jQuery.Event( type, typeof event === "object" && event );

  		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  		event.isTrigger = onlyHandlers ? 2 : 3;
  		event.namespace = namespaces.join( "." );
  		event.rnamespace = event.namespace ?
  			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
  			null;

  		// Clean up the event in case it is being reused
  		event.result = undefined;
  		if ( !event.target ) {
  			event.target = elem;
  		}

  		// Clone any incoming data and prepend the event, creating the handler arg list
  		data = data == null ?
  			[ event ] :
  			jQuery.makeArray( data, [ event ] );

  		// Allow special events to draw outside the lines
  		special = jQuery.event.special[ type ] || {};
  		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  			return;
  		}

  		// Determine event propagation path in advance, per W3C events spec (#9951)
  		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
  		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

  			bubbleType = special.delegateType || type;
  			if ( !rfocusMorph.test( bubbleType + type ) ) {
  				cur = cur.parentNode;
  			}
  			for ( ; cur; cur = cur.parentNode ) {
  				eventPath.push( cur );
  				tmp = cur;
  			}

  			// Only add window if we got to document (e.g., not plain obj or detached DOM)
  			if ( tmp === ( elem.ownerDocument || document ) ) {
  				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  			}
  		}

  		// Fire handlers on the event path
  		i = 0;
  		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  			lastElement = cur;
  			event.type = i > 1 ?
  				bubbleType :
  				special.bindType || type;

  			// jQuery handler
  			handle = (
  					dataPriv.get( cur, "events" ) || Object.create( null )
  				)[ event.type ] &&
  				dataPriv.get( cur, "handle" );
  			if ( handle ) {
  				handle.apply( cur, data );
  			}

  			// Native handler
  			handle = ontype && cur[ ontype ];
  			if ( handle && handle.apply && acceptData( cur ) ) {
  				event.result = handle.apply( cur, data );
  				if ( event.result === false ) {
  					event.preventDefault();
  				}
  			}
  		}
  		event.type = type;

  		// If nobody prevented the default action, do it now
  		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  			if ( ( !special._default ||
  				special._default.apply( eventPath.pop(), data ) === false ) &&
  				acceptData( elem ) ) {

  				// Call a native DOM method on the target with the same name as the event.
  				// Don't do default actions on window, that's where global variables be (#6170)
  				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

  					// Don't re-trigger an onFOO event when we call its FOO() method
  					tmp = elem[ ontype ];

  					if ( tmp ) {
  						elem[ ontype ] = null;
  					}

  					// Prevent re-triggering of the same event, since we already bubbled it above
  					jQuery.event.triggered = type;

  					if ( event.isPropagationStopped() ) {
  						lastElement.addEventListener( type, stopPropagationCallback );
  					}

  					elem[ type ]();

  					if ( event.isPropagationStopped() ) {
  						lastElement.removeEventListener( type, stopPropagationCallback );
  					}

  					jQuery.event.triggered = undefined;

  					if ( tmp ) {
  						elem[ ontype ] = tmp;
  					}
  				}
  			}
  		}

  		return event.result;
  	},

  	// Piggyback on a donor event to simulate a different one
  	// Used only for `focus(in | out)` events
  	simulate: function( type, elem, event ) {
  		var e = jQuery.extend(
  			new jQuery.Event(),
  			event,
  			{
  				type: type,
  				isSimulated: true
  			}
  		);

  		jQuery.event.trigger( e, null, elem );
  	}

  } );

  jQuery.fn.extend( {

  	trigger: function( type, data ) {
  		return this.each( function() {
  			jQuery.event.trigger( type, data, this );
  		} );
  	},
  	triggerHandler: function( type, data ) {
  		var elem = this[ 0 ];
  		if ( elem ) {
  			return jQuery.event.trigger( type, data, elem, true );
  		}
  	}
  } );


  // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  if ( !support.focusin ) {
  	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

  		// Attach a single capturing handler on the document while someone wants focusin/focusout
  		var handler = function( event ) {
  			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
  		};

  		jQuery.event.special[ fix ] = {
  			setup: function() {

  				// Handle: regular nodes (via `this.ownerDocument`), window
  				// (via `this.document`) & document (via `this`).
  				var doc = this.ownerDocument || this.document || this,
  					attaches = dataPriv.access( doc, fix );

  				if ( !attaches ) {
  					doc.addEventListener( orig, handler, true );
  				}
  				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
  			},
  			teardown: function() {
  				var doc = this.ownerDocument || this.document || this,
  					attaches = dataPriv.access( doc, fix ) - 1;

  				if ( !attaches ) {
  					doc.removeEventListener( orig, handler, true );
  					dataPriv.remove( doc, fix );

  				} else {
  					dataPriv.access( doc, fix, attaches );
  				}
  			}
  		};
  	} );
  }
  var location = window.location;

  var nonce = { guid: Date.now() };

  var rquery = ( /\?/ );



  // Cross-browser xml parsing
  jQuery.parseXML = function( data ) {
  	var xml;
  	if ( !data || typeof data !== "string" ) {
  		return null;
  	}

  	// Support: IE 9 - 11 only
  	// IE throws on parseFromString with invalid input.
  	try {
  		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  	} catch ( e ) {
  		xml = undefined;
  	}

  	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
  		jQuery.error( "Invalid XML: " + data );
  	}
  	return xml;
  };


  var
  	rbracket = /\[\]$/,
  	rCRLF = /\r?\n/g,
  	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  	rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams( prefix, obj, traditional, add ) {
  	var name;

  	if ( Array.isArray( obj ) ) {

  		// Serialize array item.
  		jQuery.each( obj, function( i, v ) {
  			if ( traditional || rbracket.test( prefix ) ) {

  				// Treat each array item as a scalar.
  				add( prefix, v );

  			} else {

  				// Item is non-scalar (array or object), encode its numeric index.
  				buildParams(
  					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
  					v,
  					traditional,
  					add
  				);
  			}
  		} );

  	} else if ( !traditional && toType( obj ) === "object" ) {

  		// Serialize object item.
  		for ( name in obj ) {
  			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  		}

  	} else {

  		// Serialize scalar item.
  		add( prefix, obj );
  	}
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function( a, traditional ) {
  	var prefix,
  		s = [],
  		add = function( key, valueOrFunction ) {

  			// If value is a function, invoke it and use its return value
  			var value = isFunction( valueOrFunction ) ?
  				valueOrFunction() :
  				valueOrFunction;

  			s[ s.length ] = encodeURIComponent( key ) + "=" +
  				encodeURIComponent( value == null ? "" : value );
  		};

  	if ( a == null ) {
  		return "";
  	}

  	// If an array was passed in, assume that it is an array of form elements.
  	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

  		// Serialize the form elements
  		jQuery.each( a, function() {
  			add( this.name, this.value );
  		} );

  	} else {

  		// If traditional, encode the "old" way (the way 1.3.2 or older
  		// did it), otherwise encode params recursively.
  		for ( prefix in a ) {
  			buildParams( prefix, a[ prefix ], traditional, add );
  		}
  	}

  	// Return the resulting serialization
  	return s.join( "&" );
  };

  jQuery.fn.extend( {
  	serialize: function() {
  		return jQuery.param( this.serializeArray() );
  	},
  	serializeArray: function() {
  		return this.map( function() {

  			// Can add propHook for "elements" to filter or add form elements
  			var elements = jQuery.prop( this, "elements" );
  			return elements ? jQuery.makeArray( elements ) : this;
  		} )
  		.filter( function() {
  			var type = this.type;

  			// Use .is( ":disabled" ) so that fieldset[disabled] works
  			return this.name && !jQuery( this ).is( ":disabled" ) &&
  				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  				( this.checked || !rcheckableType.test( type ) );
  		} )
  		.map( function( _i, elem ) {
  			var val = jQuery( this ).val();

  			if ( val == null ) {
  				return null;
  			}

  			if ( Array.isArray( val ) ) {
  				return jQuery.map( val, function( val ) {
  					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  				} );
  			}

  			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  		} ).get();
  	}
  } );


  var
  	r20 = /%20/g,
  	rhash = /#.*$/,
  	rantiCache = /([?&])_=[^&]*/,
  	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

  	// #7653, #8125, #8152: local protocol detection
  	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  	rnoContent = /^(?:GET|HEAD)$/,
  	rprotocol = /^\/\//,

  	/* Prefilters
  	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  	 * 2) These are called:
  	 *    - BEFORE asking for a transport
  	 *    - AFTER param serialization (s.data is a string if s.processData is true)
  	 * 3) key is the dataType
  	 * 4) the catchall symbol "*" can be used
  	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  	 */
  	prefilters = {},

  	/* Transports bindings
  	 * 1) key is the dataType
  	 * 2) the catchall symbol "*" can be used
  	 * 3) selection will start with transport dataType and THEN go to "*" if needed
  	 */
  	transports = {},

  	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  	allTypes = "*/".concat( "*" ),

  	// Anchor tag for parsing the document origin
  	originAnchor = document.createElement( "a" );
  	originAnchor.href = location.href;

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports( structure ) {

  	// dataTypeExpression is optional and defaults to "*"
  	return function( dataTypeExpression, func ) {

  		if ( typeof dataTypeExpression !== "string" ) {
  			func = dataTypeExpression;
  			dataTypeExpression = "*";
  		}

  		var dataType,
  			i = 0,
  			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

  		if ( isFunction( func ) ) {

  			// For each dataType in the dataTypeExpression
  			while ( ( dataType = dataTypes[ i++ ] ) ) {

  				// Prepend if requested
  				if ( dataType[ 0 ] === "+" ) {
  					dataType = dataType.slice( 1 ) || "*";
  					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

  				// Otherwise append
  				} else {
  					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
  				}
  			}
  		}
  	};
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  	var inspected = {},
  		seekingTransport = ( structure === transports );

  	function inspect( dataType ) {
  		var selected;
  		inspected[ dataType ] = true;
  		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
  			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
  			if ( typeof dataTypeOrTransport === "string" &&
  				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

  				options.dataTypes.unshift( dataTypeOrTransport );
  				inspect( dataTypeOrTransport );
  				return false;
  			} else if ( seekingTransport ) {
  				return !( selected = dataTypeOrTransport );
  			}
  		} );
  		return selected;
  	}

  	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend( target, src ) {
  	var key, deep,
  		flatOptions = jQuery.ajaxSettings.flatOptions || {};

  	for ( key in src ) {
  		if ( src[ key ] !== undefined ) {
  			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
  		}
  	}
  	if ( deep ) {
  		jQuery.extend( true, target, deep );
  	}

  	return target;
  }

  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses( s, jqXHR, responses ) {

  	var ct, type, finalDataType, firstDataType,
  		contents = s.contents,
  		dataTypes = s.dataTypes;

  	// Remove auto dataType and get content-type in the process
  	while ( dataTypes[ 0 ] === "*" ) {
  		dataTypes.shift();
  		if ( ct === undefined ) {
  			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
  		}
  	}

  	// Check if we're dealing with a known content-type
  	if ( ct ) {
  		for ( type in contents ) {
  			if ( contents[ type ] && contents[ type ].test( ct ) ) {
  				dataTypes.unshift( type );
  				break;
  			}
  		}
  	}

  	// Check to see if we have a response for the expected dataType
  	if ( dataTypes[ 0 ] in responses ) {
  		finalDataType = dataTypes[ 0 ];
  	} else {

  		// Try convertible dataTypes
  		for ( type in responses ) {
  			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
  				finalDataType = type;
  				break;
  			}
  			if ( !firstDataType ) {
  				firstDataType = type;
  			}
  		}

  		// Or just use first one
  		finalDataType = finalDataType || firstDataType;
  	}

  	// If we found a dataType
  	// We add the dataType to the list if needed
  	// and return the corresponding response
  	if ( finalDataType ) {
  		if ( finalDataType !== dataTypes[ 0 ] ) {
  			dataTypes.unshift( finalDataType );
  		}
  		return responses[ finalDataType ];
  	}
  }

  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert( s, response, jqXHR, isSuccess ) {
  	var conv2, current, conv, tmp, prev,
  		converters = {},

  		// Work with a copy of dataTypes in case we need to modify it for conversion
  		dataTypes = s.dataTypes.slice();

  	// Create converters map with lowercased keys
  	if ( dataTypes[ 1 ] ) {
  		for ( conv in s.converters ) {
  			converters[ conv.toLowerCase() ] = s.converters[ conv ];
  		}
  	}

  	current = dataTypes.shift();

  	// Convert to each sequential dataType
  	while ( current ) {

  		if ( s.responseFields[ current ] ) {
  			jqXHR[ s.responseFields[ current ] ] = response;
  		}

  		// Apply the dataFilter if provided
  		if ( !prev && isSuccess && s.dataFilter ) {
  			response = s.dataFilter( response, s.dataType );
  		}

  		prev = current;
  		current = dataTypes.shift();

  		if ( current ) {

  			// There's only work to do if current dataType is non-auto
  			if ( current === "*" ) {

  				current = prev;

  			// Convert response if prev dataType is non-auto and differs from current
  			} else if ( prev !== "*" && prev !== current ) {

  				// Seek a direct converter
  				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

  				// If none found, seek a pair
  				if ( !conv ) {
  					for ( conv2 in converters ) {

  						// If conv2 outputs current
  						tmp = conv2.split( " " );
  						if ( tmp[ 1 ] === current ) {

  							// If prev can be converted to accepted input
  							conv = converters[ prev + " " + tmp[ 0 ] ] ||
  								converters[ "* " + tmp[ 0 ] ];
  							if ( conv ) {

  								// Condense equivalence converters
  								if ( conv === true ) {
  									conv = converters[ conv2 ];

  								// Otherwise, insert the intermediate dataType
  								} else if ( converters[ conv2 ] !== true ) {
  									current = tmp[ 0 ];
  									dataTypes.unshift( tmp[ 1 ] );
  								}
  								break;
  							}
  						}
  					}
  				}

  				// Apply converter (if not an equivalence)
  				if ( conv !== true ) {

  					// Unless errors are allowed to bubble, catch and return them
  					if ( conv && s.throws ) {
  						response = conv( response );
  					} else {
  						try {
  							response = conv( response );
  						} catch ( e ) {
  							return {
  								state: "parsererror",
  								error: conv ? e : "No conversion from " + prev + " to " + current
  							};
  						}
  					}
  				}
  			}
  		}
  	}

  	return { state: "success", data: response };
  }

  jQuery.extend( {

  	// Counter for holding the number of active queries
  	active: 0,

  	// Last-Modified header cache for next request
  	lastModified: {},
  	etag: {},

  	ajaxSettings: {
  		url: location.href,
  		type: "GET",
  		isLocal: rlocalProtocol.test( location.protocol ),
  		global: true,
  		processData: true,
  		async: true,
  		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

  		/*
  		timeout: 0,
  		data: null,
  		dataType: null,
  		username: null,
  		password: null,
  		cache: null,
  		throws: false,
  		traditional: false,
  		headers: {},
  		*/

  		accepts: {
  			"*": allTypes,
  			text: "text/plain",
  			html: "text/html",
  			xml: "application/xml, text/xml",
  			json: "application/json, text/javascript"
  		},

  		contents: {
  			xml: /\bxml\b/,
  			html: /\bhtml/,
  			json: /\bjson\b/
  		},

  		responseFields: {
  			xml: "responseXML",
  			text: "responseText",
  			json: "responseJSON"
  		},

  		// Data converters
  		// Keys separate source (or catchall "*") and destination types with a single space
  		converters: {

  			// Convert anything to text
  			"* text": String,

  			// Text to html (true = no transformation)
  			"text html": true,

  			// Evaluate text as a json expression
  			"text json": JSON.parse,

  			// Parse text as xml
  			"text xml": jQuery.parseXML
  		},

  		// For options that shouldn't be deep extended:
  		// you can add your own custom options here if
  		// and when you create one that shouldn't be
  		// deep extended (see ajaxExtend)
  		flatOptions: {
  			url: true,
  			context: true
  		}
  	},

  	// Creates a full fledged settings object into target
  	// with both ajaxSettings and settings fields.
  	// If target is omitted, writes into ajaxSettings.
  	ajaxSetup: function( target, settings ) {
  		return settings ?

  			// Building a settings object
  			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

  			// Extending ajaxSettings
  			ajaxExtend( jQuery.ajaxSettings, target );
  	},

  	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  	ajaxTransport: addToPrefiltersOrTransports( transports ),

  	// Main method
  	ajax: function( url, options ) {

  		// If url is an object, simulate pre-1.5 signature
  		if ( typeof url === "object" ) {
  			options = url;
  			url = undefined;
  		}

  		// Force options to be an object
  		options = options || {};

  		var transport,

  			// URL without anti-cache param
  			cacheURL,

  			// Response headers
  			responseHeadersString,
  			responseHeaders,

  			// timeout handle
  			timeoutTimer,

  			// Url cleanup var
  			urlAnchor,

  			// Request state (becomes false upon send and true upon completion)
  			completed,

  			// To know if global events are to be dispatched
  			fireGlobals,

  			// Loop variable
  			i,

  			// uncached part of the url
  			uncached,

  			// Create the final options object
  			s = jQuery.ajaxSetup( {}, options ),

  			// Callbacks context
  			callbackContext = s.context || s,

  			// Context for global events is callbackContext if it is a DOM node or jQuery collection
  			globalEventContext = s.context &&
  				( callbackContext.nodeType || callbackContext.jquery ) ?
  					jQuery( callbackContext ) :
  					jQuery.event,

  			// Deferreds
  			deferred = jQuery.Deferred(),
  			completeDeferred = jQuery.Callbacks( "once memory" ),

  			// Status-dependent callbacks
  			statusCode = s.statusCode || {},

  			// Headers (they are sent all at once)
  			requestHeaders = {},
  			requestHeadersNames = {},

  			// Default abort message
  			strAbort = "canceled",

  			// Fake xhr
  			jqXHR = {
  				readyState: 0,

  				// Builds headers hashtable if needed
  				getResponseHeader: function( key ) {
  					var match;
  					if ( completed ) {
  						if ( !responseHeaders ) {
  							responseHeaders = {};
  							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
  								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
  									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
  										.concat( match[ 2 ] );
  							}
  						}
  						match = responseHeaders[ key.toLowerCase() + " " ];
  					}
  					return match == null ? null : match.join( ", " );
  				},

  				// Raw string
  				getAllResponseHeaders: function() {
  					return completed ? responseHeadersString : null;
  				},

  				// Caches the header
  				setRequestHeader: function( name, value ) {
  					if ( completed == null ) {
  						name = requestHeadersNames[ name.toLowerCase() ] =
  							requestHeadersNames[ name.toLowerCase() ] || name;
  						requestHeaders[ name ] = value;
  					}
  					return this;
  				},

  				// Overrides response content-type header
  				overrideMimeType: function( type ) {
  					if ( completed == null ) {
  						s.mimeType = type;
  					}
  					return this;
  				},

  				// Status-dependent callbacks
  				statusCode: function( map ) {
  					var code;
  					if ( map ) {
  						if ( completed ) {

  							// Execute the appropriate callbacks
  							jqXHR.always( map[ jqXHR.status ] );
  						} else {

  							// Lazy-add the new callbacks in a way that preserves old ones
  							for ( code in map ) {
  								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
  							}
  						}
  					}
  					return this;
  				},

  				// Cancel the request
  				abort: function( statusText ) {
  					var finalText = statusText || strAbort;
  					if ( transport ) {
  						transport.abort( finalText );
  					}
  					done( 0, finalText );
  					return this;
  				}
  			};

  		// Attach deferreds
  		deferred.promise( jqXHR );

  		// Add protocol if not provided (prefilters might expect it)
  		// Handle falsy url in the settings object (#10093: consistency with old signature)
  		// We also use the url parameter if available
  		s.url = ( ( url || s.url || location.href ) + "" )
  			.replace( rprotocol, location.protocol + "//" );

  		// Alias method option to type as per ticket #12004
  		s.type = options.method || options.type || s.method || s.type;

  		// Extract dataTypes list
  		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

  		// A cross-domain request is in order when the origin doesn't match the current origin.
  		if ( s.crossDomain == null ) {
  			urlAnchor = document.createElement( "a" );

  			// Support: IE <=8 - 11, Edge 12 - 15
  			// IE throws exception on accessing the href property if url is malformed,
  			// e.g. http://example.com:80x/
  			try {
  				urlAnchor.href = s.url;

  				// Support: IE <=8 - 11 only
  				// Anchor's host property isn't correctly set when s.url is relative
  				urlAnchor.href = urlAnchor.href;
  				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
  					urlAnchor.protocol + "//" + urlAnchor.host;
  			} catch ( e ) {

  				// If there is an error parsing the URL, assume it is crossDomain,
  				// it can be rejected by the transport if it is invalid
  				s.crossDomain = true;
  			}
  		}

  		// Convert data if not already a string
  		if ( s.data && s.processData && typeof s.data !== "string" ) {
  			s.data = jQuery.param( s.data, s.traditional );
  		}

  		// Apply prefilters
  		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

  		// If request was aborted inside a prefilter, stop there
  		if ( completed ) {
  			return jqXHR;
  		}

  		// We can fire global events as of now if asked to
  		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
  		fireGlobals = jQuery.event && s.global;

  		// Watch for a new set of requests
  		if ( fireGlobals && jQuery.active++ === 0 ) {
  			jQuery.event.trigger( "ajaxStart" );
  		}

  		// Uppercase the type
  		s.type = s.type.toUpperCase();

  		// Determine if request has content
  		s.hasContent = !rnoContent.test( s.type );

  		// Save the URL in case we're toying with the If-Modified-Since
  		// and/or If-None-Match header later on
  		// Remove hash to simplify url manipulation
  		cacheURL = s.url.replace( rhash, "" );

  		// More options handling for requests with no content
  		if ( !s.hasContent ) {

  			// Remember the hash so we can put it back
  			uncached = s.url.slice( cacheURL.length );

  			// If data is available and should be processed, append data to url
  			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
  				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

  				// #9682: remove data so that it's not used in an eventual retry
  				delete s.data;
  			}

  			// Add or update anti-cache param if needed
  			if ( s.cache === false ) {
  				cacheURL = cacheURL.replace( rantiCache, "$1" );
  				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
  					uncached;
  			}

  			// Put hash and anti-cache on the URL that will be requested (gh-1732)
  			s.url = cacheURL + uncached;

  		// Change '%20' to '+' if this is encoded form body content (gh-2658)
  		} else if ( s.data && s.processData &&
  			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
  			s.data = s.data.replace( r20, "+" );
  		}

  		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  		if ( s.ifModified ) {
  			if ( jQuery.lastModified[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
  			}
  			if ( jQuery.etag[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
  			}
  		}

  		// Set the correct header, if data is being sent
  		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
  			jqXHR.setRequestHeader( "Content-Type", s.contentType );
  		}

  		// Set the Accepts header for the server, depending on the dataType
  		jqXHR.setRequestHeader(
  			"Accept",
  			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
  				s.accepts[ s.dataTypes[ 0 ] ] +
  					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
  				s.accepts[ "*" ]
  		);

  		// Check for headers option
  		for ( i in s.headers ) {
  			jqXHR.setRequestHeader( i, s.headers[ i ] );
  		}

  		// Allow custom headers/mimetypes and early abort
  		if ( s.beforeSend &&
  			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

  			// Abort if not done already and return
  			return jqXHR.abort();
  		}

  		// Aborting is no longer a cancellation
  		strAbort = "abort";

  		// Install callbacks on deferreds
  		completeDeferred.add( s.complete );
  		jqXHR.done( s.success );
  		jqXHR.fail( s.error );

  		// Get transport
  		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

  		// If no transport, we auto-abort
  		if ( !transport ) {
  			done( -1, "No Transport" );
  		} else {
  			jqXHR.readyState = 1;

  			// Send global event
  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
  			}

  			// If request was aborted inside ajaxSend, stop there
  			if ( completed ) {
  				return jqXHR;
  			}

  			// Timeout
  			if ( s.async && s.timeout > 0 ) {
  				timeoutTimer = window.setTimeout( function() {
  					jqXHR.abort( "timeout" );
  				}, s.timeout );
  			}

  			try {
  				completed = false;
  				transport.send( requestHeaders, done );
  			} catch ( e ) {

  				// Rethrow post-completion exceptions
  				if ( completed ) {
  					throw e;
  				}

  				// Propagate others as results
  				done( -1, e );
  			}
  		}

  		// Callback for when everything is done
  		function done( status, nativeStatusText, responses, headers ) {
  			var isSuccess, success, error, response, modified,
  				statusText = nativeStatusText;

  			// Ignore repeat invocations
  			if ( completed ) {
  				return;
  			}

  			completed = true;

  			// Clear timeout if it exists
  			if ( timeoutTimer ) {
  				window.clearTimeout( timeoutTimer );
  			}

  			// Dereference transport for early garbage collection
  			// (no matter how long the jqXHR object will be used)
  			transport = undefined;

  			// Cache response headers
  			responseHeadersString = headers || "";

  			// Set readyState
  			jqXHR.readyState = status > 0 ? 4 : 0;

  			// Determine if successful
  			isSuccess = status >= 200 && status < 300 || status === 304;

  			// Get response data
  			if ( responses ) {
  				response = ajaxHandleResponses( s, jqXHR, responses );
  			}

  			// Use a noop converter for missing script
  			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
  				s.converters[ "text script" ] = function() {};
  			}

  			// Convert no matter what (that way responseXXX fields are always set)
  			response = ajaxConvert( s, response, jqXHR, isSuccess );

  			// If successful, handle type chaining
  			if ( isSuccess ) {

  				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  				if ( s.ifModified ) {
  					modified = jqXHR.getResponseHeader( "Last-Modified" );
  					if ( modified ) {
  						jQuery.lastModified[ cacheURL ] = modified;
  					}
  					modified = jqXHR.getResponseHeader( "etag" );
  					if ( modified ) {
  						jQuery.etag[ cacheURL ] = modified;
  					}
  				}

  				// if no content
  				if ( status === 204 || s.type === "HEAD" ) {
  					statusText = "nocontent";

  				// if not modified
  				} else if ( status === 304 ) {
  					statusText = "notmodified";

  				// If we have data, let's convert it
  				} else {
  					statusText = response.state;
  					success = response.data;
  					error = response.error;
  					isSuccess = !error;
  				}
  			} else {

  				// Extract error from statusText and normalize for non-aborts
  				error = statusText;
  				if ( status || !statusText ) {
  					statusText = "error";
  					if ( status < 0 ) {
  						status = 0;
  					}
  				}
  			}

  			// Set data for the fake xhr object
  			jqXHR.status = status;
  			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

  			// Success/Error
  			if ( isSuccess ) {
  				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
  			} else {
  				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
  			}

  			// Status-dependent callbacks
  			jqXHR.statusCode( statusCode );
  			statusCode = undefined;

  			if ( fireGlobals ) {
  				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
  					[ jqXHR, s, isSuccess ? success : error ] );
  			}

  			// Complete
  			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

  				// Handle the global AJAX counter
  				if ( !( --jQuery.active ) ) {
  					jQuery.event.trigger( "ajaxStop" );
  				}
  			}
  		}

  		return jqXHR;
  	},

  	getJSON: function( url, data, callback ) {
  		return jQuery.get( url, data, callback, "json" );
  	},

  	getScript: function( url, callback ) {
  		return jQuery.get( url, undefined, callback, "script" );
  	}
  } );

  jQuery.each( [ "get", "post" ], function( _i, method ) {
  	jQuery[ method ] = function( url, data, callback, type ) {

  		// Shift arguments if data argument was omitted
  		if ( isFunction( data ) ) {
  			type = type || callback;
  			callback = data;
  			data = undefined;
  		}

  		// The url can be an options object (which then must have .url)
  		return jQuery.ajax( jQuery.extend( {
  			url: url,
  			type: method,
  			dataType: type,
  			data: data,
  			success: callback
  		}, jQuery.isPlainObject( url ) && url ) );
  	};
  } );

  jQuery.ajaxPrefilter( function( s ) {
  	var i;
  	for ( i in s.headers ) {
  		if ( i.toLowerCase() === "content-type" ) {
  			s.contentType = s.headers[ i ] || "";
  		}
  	}
  } );


  jQuery._evalUrl = function( url, options, doc ) {
  	return jQuery.ajax( {
  		url: url,

  		// Make this explicit, since user can override this through ajaxSetup (#11264)
  		type: "GET",
  		dataType: "script",
  		cache: true,
  		async: false,
  		global: false,

  		// Only evaluate the response if it is successful (gh-4126)
  		// dataFilter is not invoked for failure responses, so using it instead
  		// of the default converter is kludgy but it works.
  		converters: {
  			"text script": function() {}
  		},
  		dataFilter: function( response ) {
  			jQuery.globalEval( response, options, doc );
  		}
  	} );
  };


  jQuery.fn.extend( {
  	wrapAll: function( html ) {
  		var wrap;

  		if ( this[ 0 ] ) {
  			if ( isFunction( html ) ) {
  				html = html.call( this[ 0 ] );
  			}

  			// The elements to wrap the target around
  			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  			if ( this[ 0 ].parentNode ) {
  				wrap.insertBefore( this[ 0 ] );
  			}

  			wrap.map( function() {
  				var elem = this;

  				while ( elem.firstElementChild ) {
  					elem = elem.firstElementChild;
  				}

  				return elem;
  			} ).append( this );
  		}

  		return this;
  	},

  	wrapInner: function( html ) {
  		if ( isFunction( html ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).wrapInner( html.call( this, i ) );
  			} );
  		}

  		return this.each( function() {
  			var self = jQuery( this ),
  				contents = self.contents();

  			if ( contents.length ) {
  				contents.wrapAll( html );

  			} else {
  				self.append( html );
  			}
  		} );
  	},

  	wrap: function( html ) {
  		var htmlIsFunction = isFunction( html );

  		return this.each( function( i ) {
  			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
  		} );
  	},

  	unwrap: function( selector ) {
  		this.parent( selector ).not( "body" ).each( function() {
  			jQuery( this ).replaceWith( this.childNodes );
  		} );
  		return this;
  	}
  } );


  jQuery.expr.pseudos.hidden = function( elem ) {
  	return !jQuery.expr.pseudos.visible( elem );
  };
  jQuery.expr.pseudos.visible = function( elem ) {
  	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  };




  jQuery.ajaxSettings.xhr = function() {
  	try {
  		return new window.XMLHttpRequest();
  	} catch ( e ) {}
  };

  var xhrSuccessStatus = {

  		// File protocol always yields status code 0, assume 200
  		0: 200,

  		// Support: IE <=9 only
  		// #1450: sometimes IE returns 1223 when it should be 204
  		1223: 204
  	},
  	xhrSupported = jQuery.ajaxSettings.xhr();

  support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  support.ajax = xhrSupported = !!xhrSupported;

  jQuery.ajaxTransport( function( options ) {
  	var callback, errorCallback;

  	// Cross domain only allowed if supported through XMLHttpRequest
  	if ( support.cors || xhrSupported && !options.crossDomain ) {
  		return {
  			send: function( headers, complete ) {
  				var i,
  					xhr = options.xhr();

  				xhr.open(
  					options.type,
  					options.url,
  					options.async,
  					options.username,
  					options.password
  				);

  				// Apply custom fields if provided
  				if ( options.xhrFields ) {
  					for ( i in options.xhrFields ) {
  						xhr[ i ] = options.xhrFields[ i ];
  					}
  				}

  				// Override mime type if needed
  				if ( options.mimeType && xhr.overrideMimeType ) {
  					xhr.overrideMimeType( options.mimeType );
  				}

  				// X-Requested-With header
  				// For cross-domain requests, seeing as conditions for a preflight are
  				// akin to a jigsaw puzzle, we simply never set it to be sure.
  				// (it can always be set on a per-request basis or even using ajaxSetup)
  				// For same-domain requests, won't change header if already provided.
  				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
  					headers[ "X-Requested-With" ] = "XMLHttpRequest";
  				}

  				// Set headers
  				for ( i in headers ) {
  					xhr.setRequestHeader( i, headers[ i ] );
  				}

  				// Callback
  				callback = function( type ) {
  					return function() {
  						if ( callback ) {
  							callback = errorCallback = xhr.onload =
  								xhr.onerror = xhr.onabort = xhr.ontimeout =
  									xhr.onreadystatechange = null;

  							if ( type === "abort" ) {
  								xhr.abort();
  							} else if ( type === "error" ) {

  								// Support: IE <=9 only
  								// On a manual native abort, IE9 throws
  								// errors on any property access that is not readyState
  								if ( typeof xhr.status !== "number" ) {
  									complete( 0, "error" );
  								} else {
  									complete(

  										// File: protocol always yields status 0; see #8605, #14207
  										xhr.status,
  										xhr.statusText
  									);
  								}
  							} else {
  								complete(
  									xhrSuccessStatus[ xhr.status ] || xhr.status,
  									xhr.statusText,

  									// Support: IE <=9 only
  									// IE9 has no XHR2 but throws on binary (trac-11426)
  									// For XHR2 non-text, let the caller handle it (gh-2498)
  									( xhr.responseType || "text" ) !== "text"  ||
  									typeof xhr.responseText !== "string" ?
  										{ binary: xhr.response } :
  										{ text: xhr.responseText },
  									xhr.getAllResponseHeaders()
  								);
  							}
  						}
  					};
  				};

  				// Listen to events
  				xhr.onload = callback();
  				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

  				// Support: IE 9 only
  				// Use onreadystatechange to replace onabort
  				// to handle uncaught aborts
  				if ( xhr.onabort !== undefined ) {
  					xhr.onabort = errorCallback;
  				} else {
  					xhr.onreadystatechange = function() {

  						// Check readyState before timeout as it changes
  						if ( xhr.readyState === 4 ) {

  							// Allow onerror to be called first,
  							// but that will not handle a native abort
  							// Also, save errorCallback to a variable
  							// as xhr.onerror cannot be accessed
  							window.setTimeout( function() {
  								if ( callback ) {
  									errorCallback();
  								}
  							} );
  						}
  					};
  				}

  				// Create the abort callback
  				callback = callback( "abort" );

  				try {

  					// Do send the request (this may raise an exception)
  					xhr.send( options.hasContent && options.data || null );
  				} catch ( e ) {

  					// #14683: Only rethrow if this hasn't been notified as an error yet
  					if ( callback ) {
  						throw e;
  					}
  				}
  			},

  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  } );




  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  jQuery.ajaxPrefilter( function( s ) {
  	if ( s.crossDomain ) {
  		s.contents.script = false;
  	}
  } );

  // Install script dataType
  jQuery.ajaxSetup( {
  	accepts: {
  		script: "text/javascript, application/javascript, " +
  			"application/ecmascript, application/x-ecmascript"
  	},
  	contents: {
  		script: /\b(?:java|ecma)script\b/
  	},
  	converters: {
  		"text script": function( text ) {
  			jQuery.globalEval( text );
  			return text;
  		}
  	}
  } );

  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter( "script", function( s ) {
  	if ( s.cache === undefined ) {
  		s.cache = false;
  	}
  	if ( s.crossDomain ) {
  		s.type = "GET";
  	}
  } );

  // Bind script tag hack transport
  jQuery.ajaxTransport( "script", function( s ) {

  	// This transport only deals with cross domain or forced-by-attrs requests
  	if ( s.crossDomain || s.scriptAttrs ) {
  		var script, callback;
  		return {
  			send: function( _, complete ) {
  				script = jQuery( "<script>" )
  					.attr( s.scriptAttrs || {} )
  					.prop( { charset: s.scriptCharset, src: s.url } )
  					.on( "load error", callback = function( evt ) {
  						script.remove();
  						callback = null;
  						if ( evt ) {
  							complete( evt.type === "error" ? 404 : 200, evt.type );
  						}
  					} );

  				// Use native DOM manipulation to avoid our domManip AJAX trickery
  				document.head.appendChild( script[ 0 ] );
  			},
  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  } );




  var oldCallbacks = [],
  	rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup( {
  	jsonp: "callback",
  	jsonpCallback: function() {
  		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
  		this[ callback ] = true;
  		return callback;
  	}
  } );

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  	var callbackName, overwritten, responseContainer,
  		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
  			"url" :
  			typeof s.data === "string" &&
  				( s.contentType || "" )
  					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
  				rjsonp.test( s.data ) && "data"
  		);

  	// Handle iff the expected data type is "jsonp" or we have a parameter to set
  	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

  		// Get callback name, remembering preexisting value associated with it
  		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
  			s.jsonpCallback() :
  			s.jsonpCallback;

  		// Insert callback into url or form data
  		if ( jsonProp ) {
  			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
  		} else if ( s.jsonp !== false ) {
  			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
  		}

  		// Use data converter to retrieve json after script execution
  		s.converters[ "script json" ] = function() {
  			if ( !responseContainer ) {
  				jQuery.error( callbackName + " was not called" );
  			}
  			return responseContainer[ 0 ];
  		};

  		// Force json dataType
  		s.dataTypes[ 0 ] = "json";

  		// Install callback
  		overwritten = window[ callbackName ];
  		window[ callbackName ] = function() {
  			responseContainer = arguments;
  		};

  		// Clean-up function (fires after converters)
  		jqXHR.always( function() {

  			// If previous value didn't exist - remove it
  			if ( overwritten === undefined ) {
  				jQuery( window ).removeProp( callbackName );

  			// Otherwise restore preexisting value
  			} else {
  				window[ callbackName ] = overwritten;
  			}

  			// Save back as free
  			if ( s[ callbackName ] ) {

  				// Make sure that re-using the options doesn't screw things around
  				s.jsonpCallback = originalSettings.jsonpCallback;

  				// Save the callback name for future use
  				oldCallbacks.push( callbackName );
  			}

  			// Call if it was a function and we have a response
  			if ( responseContainer && isFunction( overwritten ) ) {
  				overwritten( responseContainer[ 0 ] );
  			}

  			responseContainer = overwritten = undefined;
  		} );

  		// Delegate to script
  		return "script";
  	}
  } );




  // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337
  support.createHTMLDocument = ( function() {
  	var body = document.implementation.createHTMLDocument( "" ).body;
  	body.innerHTML = "<form></form><form></form>";
  	return body.childNodes.length === 2;
  } )();


  // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function( data, context, keepScripts ) {
  	if ( typeof data !== "string" ) {
  		return [];
  	}
  	if ( typeof context === "boolean" ) {
  		keepScripts = context;
  		context = false;
  	}

  	var base, parsed, scripts;

  	if ( !context ) {

  		// Stop scripts or inline event handlers from being executed immediately
  		// by using document.implementation
  		if ( support.createHTMLDocument ) {
  			context = document.implementation.createHTMLDocument( "" );

  			// Set the base href for the created document
  			// so any parsed elements with URLs
  			// are based on the document's URL (gh-2965)
  			base = context.createElement( "base" );
  			base.href = document.location.href;
  			context.head.appendChild( base );
  		} else {
  			context = document;
  		}
  	}

  	parsed = rsingleTag.exec( data );
  	scripts = !keepScripts && [];

  	// Single tag
  	if ( parsed ) {
  		return [ context.createElement( parsed[ 1 ] ) ];
  	}

  	parsed = buildFragment( [ data ], context, scripts );

  	if ( scripts && scripts.length ) {
  		jQuery( scripts ).remove();
  	}

  	return jQuery.merge( [], parsed.childNodes );
  };


  /**
   * Load a url into a page
   */
  jQuery.fn.load = function( url, params, callback ) {
  	var selector, type, response,
  		self = this,
  		off = url.indexOf( " " );

  	if ( off > -1 ) {
  		selector = stripAndCollapse( url.slice( off ) );
  		url = url.slice( 0, off );
  	}

  	// If it's a function
  	if ( isFunction( params ) ) {

  		// We assume that it's the callback
  		callback = params;
  		params = undefined;

  	// Otherwise, build a param string
  	} else if ( params && typeof params === "object" ) {
  		type = "POST";
  	}

  	// If we have elements to modify, make the request
  	if ( self.length > 0 ) {
  		jQuery.ajax( {
  			url: url,

  			// If "type" variable is undefined, then "GET" method will be used.
  			// Make value of this field explicit since
  			// user can override it through ajaxSetup method
  			type: type || "GET",
  			dataType: "html",
  			data: params
  		} ).done( function( responseText ) {

  			// Save response for use in complete callback
  			response = arguments;

  			self.html( selector ?

  				// If a selector was specified, locate the right elements in a dummy div
  				// Exclude scripts to avoid IE 'Permission Denied' errors
  				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

  				// Otherwise use the full result
  				responseText );

  		// If the request succeeds, this function gets "data", "status", "jqXHR"
  		// but they are ignored because response was set above.
  		// If it fails, this function gets "jqXHR", "status", "error"
  		} ).always( callback && function( jqXHR, status ) {
  			self.each( function() {
  				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
  			} );
  		} );
  	}

  	return this;
  };




  jQuery.expr.pseudos.animated = function( elem ) {
  	return jQuery.grep( jQuery.timers, function( fn ) {
  		return elem === fn.elem;
  	} ).length;
  };




  jQuery.offset = {
  	setOffset: function( elem, options, i ) {
  		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  			position = jQuery.css( elem, "position" ),
  			curElem = jQuery( elem ),
  			props = {};

  		// Set position first, in-case top/left are set even on static elem
  		if ( position === "static" ) {
  			elem.style.position = "relative";
  		}

  		curOffset = curElem.offset();
  		curCSSTop = jQuery.css( elem, "top" );
  		curCSSLeft = jQuery.css( elem, "left" );
  		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

  		// Need to be able to calculate position if either
  		// top or left is auto and position is either absolute or fixed
  		if ( calculatePosition ) {
  			curPosition = curElem.position();
  			curTop = curPosition.top;
  			curLeft = curPosition.left;

  		} else {
  			curTop = parseFloat( curCSSTop ) || 0;
  			curLeft = parseFloat( curCSSLeft ) || 0;
  		}

  		if ( isFunction( options ) ) {

  			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
  			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
  		}

  		if ( options.top != null ) {
  			props.top = ( options.top - curOffset.top ) + curTop;
  		}
  		if ( options.left != null ) {
  			props.left = ( options.left - curOffset.left ) + curLeft;
  		}

  		if ( "using" in options ) {
  			options.using.call( elem, props );

  		} else {
  			if ( typeof props.top === "number" ) {
  				props.top += "px";
  			}
  			if ( typeof props.left === "number" ) {
  				props.left += "px";
  			}
  			curElem.css( props );
  		}
  	}
  };

  jQuery.fn.extend( {

  	// offset() relates an element's border box to the document origin
  	offset: function( options ) {

  		// Preserve chaining for setter
  		if ( arguments.length ) {
  			return options === undefined ?
  				this :
  				this.each( function( i ) {
  					jQuery.offset.setOffset( this, options, i );
  				} );
  		}

  		var rect, win,
  			elem = this[ 0 ];

  		if ( !elem ) {
  			return;
  		}

  		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  		// Support: IE <=11 only
  		// Running getBoundingClientRect on a
  		// disconnected node in IE throws an error
  		if ( !elem.getClientRects().length ) {
  			return { top: 0, left: 0 };
  		}

  		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
  		rect = elem.getBoundingClientRect();
  		win = elem.ownerDocument.defaultView;
  		return {
  			top: rect.top + win.pageYOffset,
  			left: rect.left + win.pageXOffset
  		};
  	},

  	// position() relates an element's margin box to its offset parent's padding box
  	// This corresponds to the behavior of CSS absolute positioning
  	position: function() {
  		if ( !this[ 0 ] ) {
  			return;
  		}

  		var offsetParent, offset, doc,
  			elem = this[ 0 ],
  			parentOffset = { top: 0, left: 0 };

  		// position:fixed elements are offset from the viewport, which itself always has zero offset
  		if ( jQuery.css( elem, "position" ) === "fixed" ) {

  			// Assume position:fixed implies availability of getBoundingClientRect
  			offset = elem.getBoundingClientRect();

  		} else {
  			offset = this.offset();

  			// Account for the *real* offset parent, which can be the document or its root element
  			// when a statically positioned element is identified
  			doc = elem.ownerDocument;
  			offsetParent = elem.offsetParent || doc.documentElement;
  			while ( offsetParent &&
  				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
  				jQuery.css( offsetParent, "position" ) === "static" ) {

  				offsetParent = offsetParent.parentNode;
  			}
  			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

  				// Incorporate borders into its offset, since they are outside its content origin
  				parentOffset = jQuery( offsetParent ).offset();
  				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
  				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
  			}
  		}

  		// Subtract parent offsets and element margins
  		return {
  			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  		};
  	},

  	// This method will return documentElement in the following cases:
  	// 1) For the element inside the iframe without offsetParent, this method will return
  	//    documentElement of the parent window
  	// 2) For the hidden or detached element
  	// 3) For body or html element, i.e. in case of the html node - it will return itself
  	//
  	// but those exceptions were never presented as a real life use-cases
  	// and might be considered as more preferable results.
  	//
  	// This logic, however, is not guaranteed and can change at any point in the future
  	offsetParent: function() {
  		return this.map( function() {
  			var offsetParent = this.offsetParent;

  			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
  				offsetParent = offsetParent.offsetParent;
  			}

  			return offsetParent || documentElement;
  		} );
  	}
  } );

  // Create scrollLeft and scrollTop methods
  jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  	var top = "pageYOffset" === prop;

  	jQuery.fn[ method ] = function( val ) {
  		return access( this, function( elem, method, val ) {

  			// Coalesce documents and windows
  			var win;
  			if ( isWindow( elem ) ) {
  				win = elem;
  			} else if ( elem.nodeType === 9 ) {
  				win = elem.defaultView;
  			}

  			if ( val === undefined ) {
  				return win ? win[ prop ] : elem[ method ];
  			}

  			if ( win ) {
  				win.scrollTo(
  					!top ? val : win.pageXOffset,
  					top ? val : win.pageYOffset
  				);

  			} else {
  				elem[ method ] = val;
  			}
  		}, method, val, arguments.length );
  	};
  } );

  // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each( [ "top", "left" ], function( _i, prop ) {
  	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  		function( elem, computed ) {
  			if ( computed ) {
  				computed = curCSS( elem, prop );

  				// If curCSS returns percentage, fallback to offset
  				return rnumnonpx.test( computed ) ?
  					jQuery( elem ).position()[ prop ] + "px" :
  					computed;
  			}
  		}
  	);
  } );


  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
  		function( defaultExtra, funcName ) {

  		// Margin is only for outerHeight, outerWidth
  		jQuery.fn[ funcName ] = function( margin, value ) {
  			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  			return access( this, function( elem, type, value ) {
  				var doc;

  				if ( isWindow( elem ) ) {

  					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
  					return funcName.indexOf( "outer" ) === 0 ?
  						elem[ "inner" + name ] :
  						elem.document.documentElement[ "client" + name ];
  				}

  				// Get document width or height
  				if ( elem.nodeType === 9 ) {
  					doc = elem.documentElement;

  					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  					// whichever is greatest
  					return Math.max(
  						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  						elem.body[ "offset" + name ], doc[ "offset" + name ],
  						doc[ "client" + name ]
  					);
  				}

  				return value === undefined ?

  					// Get width or height on the element, requesting but not forcing parseFloat
  					jQuery.css( elem, type, extra ) :

  					// Set width or height on the element
  					jQuery.style( elem, type, value, extra );
  			}, type, chainable ? margin : undefined, chainable );
  		};
  	} );
  } );


  jQuery.each( [
  	"ajaxStart",
  	"ajaxStop",
  	"ajaxComplete",
  	"ajaxError",
  	"ajaxSuccess",
  	"ajaxSend"
  ], function( _i, type ) {
  	jQuery.fn[ type ] = function( fn ) {
  		return this.on( type, fn );
  	};
  } );




  jQuery.fn.extend( {

  	bind: function( types, data, fn ) {
  		return this.on( types, null, data, fn );
  	},
  	unbind: function( types, fn ) {
  		return this.off( types, null, fn );
  	},

  	delegate: function( selector, types, data, fn ) {
  		return this.on( types, selector, data, fn );
  	},
  	undelegate: function( selector, types, fn ) {

  		// ( namespace ) or ( selector, types [, fn] )
  		return arguments.length === 1 ?
  			this.off( selector, "**" ) :
  			this.off( types, selector || "**", fn );
  	},

  	hover: function( fnOver, fnOut ) {
  		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  	}
  } );

  jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
  	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
  	function( _i, name ) {

  		// Handle event binding
  		jQuery.fn[ name ] = function( data, fn ) {
  			return arguments.length > 0 ?
  				this.on( name, null, data, fn ) :
  				this.trigger( name );
  		};
  	} );




  // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP
  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

  // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon
  jQuery.proxy = function( fn, context ) {
  	var tmp, args, proxy;

  	if ( typeof context === "string" ) {
  		tmp = fn[ context ];
  		context = fn;
  		fn = tmp;
  	}

  	// Quick check to determine if target is callable, in the spec
  	// this throws a TypeError, but we will just return undefined.
  	if ( !isFunction( fn ) ) {
  		return undefined;
  	}

  	// Simulated bind
  	args = slice.call( arguments, 2 );
  	proxy = function() {
  		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  	};

  	// Set the guid of unique handler to the same of original handler, so it can be removed
  	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  	return proxy;
  };

  jQuery.holdReady = function( hold ) {
  	if ( hold ) {
  		jQuery.readyWait++;
  	} else {
  		jQuery.ready( true );
  	}
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;

  jQuery.now = Date.now;

  jQuery.isNumeric = function( obj ) {

  	// As of jQuery 3.0, isNumeric is limited to
  	// strings and numbers (primitives or objects)
  	// that can be coerced to finite numbers (gh-2662)
  	var type = jQuery.type( obj );
  	return ( type === "number" || type === "string" ) &&

  		// parseFloat NaNs numeric-cast false positives ("")
  		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  		// subtraction forces infinities to NaN
  		!isNaN( obj - parseFloat( obj ) );
  };

  jQuery.trim = function( text ) {
  	return text == null ?
  		"" :
  		( text + "" ).replace( rtrim, "" );
  };




  var

  	// Map over jQuery in case of overwrite
  	_jQuery = window.jQuery,

  	// Map over the $ in case of overwrite
  	_$ = window.$;

  jQuery.noConflict = function( deep ) {
  	if ( window.$ === jQuery ) {
  		window.$ = _$;
  	}

  	if ( deep && window.jQuery === jQuery ) {
  		window.jQuery = _jQuery;
  	}

  	return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if ( typeof noGlobal === "undefined" ) {
  	window.jQuery = window.$ = jQuery;
  }




  return jQuery;
  } );
  });

  /**
   * @author qiao / https://github.com/qiao
   * @author mrdoob / http://mrdoob.com
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author erich666 / http://erichaines.com
   * @author ScieCode / http://github.com/sciecode
   */

  // This set of controls performs orbiting, dollying (zooming), and panning.
  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  //
  //    Orbit - left mouse / touch: one-finger move
  //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
  //    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

  var OrbitControls = function ( object, domElement ) {

  	if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
  	if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

  	this.object = object;
  	this.domElement = domElement;

  	// Set to false to disable this control
  	this.enabled = true;

  	// "target" sets the location of focus, where the object orbits around
  	this.target = new Vector3();

  	// How far you can dolly in and out ( PerspectiveCamera only )
  	this.minDistance = 0;
  	this.maxDistance = Infinity;

  	// How far you can zoom in and out ( OrthographicCamera only )
  	this.minZoom = 0;
  	this.maxZoom = Infinity;

  	// How far you can orbit vertically, upper and lower limits.
  	// Range is 0 to Math.PI radians.
  	this.minPolarAngle = 0; // radians
  	this.maxPolarAngle = Math.PI; // radians

  	// How far you can orbit horizontally, upper and lower limits.
  	// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
  	this.minAzimuthAngle = - Infinity; // radians
  	this.maxAzimuthAngle = Infinity; // radians

  	// Set to true to enable damping (inertia)
  	// If damping is enabled, you must call controls.update() in your animation loop
  	this.enableDamping = false;
  	this.dampingFactor = 0.05;

  	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  	// Set to false to disable zooming
  	this.enableZoom = true;
  	this.zoomSpeed = 1.0;

  	// Set to false to disable rotating
  	this.enableRotate = true;
  	this.rotateSpeed = 1.0;

  	// Set to false to disable panning
  	this.enablePan = true;
  	this.panSpeed = 1.0;
  	this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
  	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

  	// Set to true to automatically rotate around the target
  	// If auto-rotate is enabled, you must call controls.update() in your animation loop
  	this.autoRotate = false;
  	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  	// Set to false to disable use of the keys
  	this.enableKeys = true;

  	// The four arrow keys
  	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

  	// Mouse buttons
  	this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

  	// Touch fingers
  	this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

  	// for reset
  	this.target0 = this.target.clone();
  	this.position0 = this.object.position.clone();
  	this.zoom0 = this.object.zoom;

  	//
  	// public methods
  	//

  	this.getPolarAngle = function () {

  		return spherical.phi;

  	};

  	this.getAzimuthalAngle = function () {

  		return spherical.theta;

  	};

  	this.saveState = function () {

  		scope.target0.copy( scope.target );
  		scope.position0.copy( scope.object.position );
  		scope.zoom0 = scope.object.zoom;

  	};

  	this.reset = function () {

  		scope.target.copy( scope.target0 );
  		scope.object.position.copy( scope.position0 );
  		scope.object.zoom = scope.zoom0;

  		scope.object.updateProjectionMatrix();
  		scope.dispatchEvent( changeEvent );

  		scope.update();

  		state = STATE.NONE;

  	};

  	// this method is exposed, but perhaps it would be better if we can make it private...
  	this.update = function () {

  		var offset = new Vector3();

  		// so camera.up is the orbit axis
  		var quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
  		var quatInverse = quat.clone().inverse();

  		var lastPosition = new Vector3();
  		var lastQuaternion = new Quaternion();

  		var twoPI = 2 * Math.PI;

  		return function update() {

  			var position = scope.object.position;

  			offset.copy( position ).sub( scope.target );

  			// rotate offset to "y-axis-is-up" space
  			offset.applyQuaternion( quat );

  			// angle from z-axis around y-axis
  			spherical.setFromVector3( offset );

  			if ( scope.autoRotate && state === STATE.NONE ) {

  				rotateLeft( getAutoRotationAngle() );

  			}

  			if ( scope.enableDamping ) {

  				spherical.theta += sphericalDelta.theta * scope.dampingFactor;
  				spherical.phi += sphericalDelta.phi * scope.dampingFactor;

  			} else {

  				spherical.theta += sphericalDelta.theta;
  				spherical.phi += sphericalDelta.phi;

  			}

  			// restrict theta to be between desired limits

  			var min = scope.minAzimuthAngle;
  			var max = scope.maxAzimuthAngle;

  			if ( isFinite ( min ) && isFinite( max ) ) {

  				if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

  				if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

  				if ( min < max ) {

  					spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

  				} else {

  					spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
  						Math.max( min, spherical.theta ) :
  						Math.min( max, spherical.theta );

  				}

  			}

  			// restrict phi to be between desired limits
  			spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

  			spherical.makeSafe();


  			spherical.radius *= scale;

  			// restrict radius to be between desired limits
  			spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

  			// move target to panned location

  			if ( scope.enableDamping === true ) {

  				scope.target.addScaledVector( panOffset, scope.dampingFactor );

  			} else {

  				scope.target.add( panOffset );

  			}

  			offset.setFromSpherical( spherical );

  			// rotate offset back to "camera-up-vector-is-up" space
  			offset.applyQuaternion( quatInverse );

  			position.copy( scope.target ).add( offset );

  			scope.object.lookAt( scope.target );

  			if ( scope.enableDamping === true ) {

  				sphericalDelta.theta *= ( 1 - scope.dampingFactor );
  				sphericalDelta.phi *= ( 1 - scope.dampingFactor );

  				panOffset.multiplyScalar( 1 - scope.dampingFactor );

  			} else {

  				sphericalDelta.set( 0, 0, 0 );

  				panOffset.set( 0, 0, 0 );

  			}

  			scale = 1;

  			// update condition is:
  			// min(camera displacement, camera rotation in radians)^2 > EPS
  			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  			if ( zoomChanged ||
  				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
  				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

  				scope.dispatchEvent( changeEvent );

  				lastPosition.copy( scope.object.position );
  				lastQuaternion.copy( scope.object.quaternion );
  				zoomChanged = false;

  				return true;

  			}

  			return false;

  		};

  	}();

  	this.dispose = function () {

  		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
  		scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
  		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

  		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
  		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
  		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

  		scope.domElement.ownerDocument.removeEventListener( 'mousemove', onMouseMove, false );
  		scope.domElement.ownerDocument.removeEventListener( 'mouseup', onMouseUp, false );

  		scope.domElement.removeEventListener( 'keydown', onKeyDown, false );

  		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

  	};

  	//
  	// internals
  	//

  	var scope = this;

  	var changeEvent = { type: 'change' };
  	var startEvent = { type: 'start' };
  	var endEvent = { type: 'end' };

  	var STATE = {
  		NONE: - 1,
  		ROTATE: 0,
  		DOLLY: 1,
  		PAN: 2,
  		TOUCH_ROTATE: 3,
  		TOUCH_PAN: 4,
  		TOUCH_DOLLY_PAN: 5,
  		TOUCH_DOLLY_ROTATE: 6
  	};

  	var state = STATE.NONE;

  	var EPS = 0.000001;

  	// current position in spherical coordinates
  	var spherical = new Spherical();
  	var sphericalDelta = new Spherical();

  	var scale = 1;
  	var panOffset = new Vector3();
  	var zoomChanged = false;

  	var rotateStart = new Vector2();
  	var rotateEnd = new Vector2();
  	var rotateDelta = new Vector2();

  	var panStart = new Vector2();
  	var panEnd = new Vector2();
  	var panDelta = new Vector2();

  	var dollyStart = new Vector2();
  	var dollyEnd = new Vector2();
  	var dollyDelta = new Vector2();

  	function getAutoRotationAngle() {

  		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  	}

  	function getZoomScale() {

  		return Math.pow( 0.95, scope.zoomSpeed );

  	}

  	function rotateLeft( angle ) {

  		sphericalDelta.theta -= angle;

  	}

  	function rotateUp( angle ) {

  		sphericalDelta.phi -= angle;

  	}

  	var panLeft = function () {

  		var v = new Vector3();

  		return function panLeft( distance, objectMatrix ) {

  			v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  			v.multiplyScalar( - distance );

  			panOffset.add( v );

  		};

  	}();

  	var panUp = function () {

  		var v = new Vector3();

  		return function panUp( distance, objectMatrix ) {

  			if ( scope.screenSpacePanning === true ) {

  				v.setFromMatrixColumn( objectMatrix, 1 );

  			} else {

  				v.setFromMatrixColumn( objectMatrix, 0 );
  				v.crossVectors( scope.object.up, v );

  			}

  			v.multiplyScalar( distance );

  			panOffset.add( v );

  		};

  	}();

  	// deltaX and deltaY are in pixels; right and down are positive
  	var pan = function () {

  		var offset = new Vector3();

  		return function pan( deltaX, deltaY ) {

  			var element = scope.domElement;

  			if ( scope.object.isPerspectiveCamera ) {

  				// perspective
  				var position = scope.object.position;
  				offset.copy( position ).sub( scope.target );
  				var targetDistance = offset.length();

  				// half of the fov is center to top of screen
  				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

  				// we use only clientHeight here so aspect ratio does not distort speed
  				panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
  				panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

  			} else if ( scope.object.isOrthographicCamera ) {

  				// orthographic
  				panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
  				panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

  			} else {

  				// camera neither orthographic nor perspective
  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
  				scope.enablePan = false;

  			}

  		};

  	}();

  	function dollyOut( dollyScale ) {

  		if ( scope.object.isPerspectiveCamera ) {

  			scale /= dollyScale;

  		} else if ( scope.object.isOrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	function dollyIn( dollyScale ) {

  		if ( scope.object.isPerspectiveCamera ) {

  			scale *= dollyScale;

  		} else if ( scope.object.isOrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	//
  	// event callbacks - update the object state
  	//

  	function handleMouseDownRotate( event ) {

  		rotateStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownDolly( event ) {

  		dollyStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownPan( event ) {

  		panStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseMoveRotate( event ) {

  		rotateEnd.set( event.clientX, event.clientY );

  		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

  		var element = scope.domElement;

  		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

  		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

  		rotateStart.copy( rotateEnd );

  		scope.update();

  	}

  	function handleMouseMoveDolly( event ) {

  		dollyEnd.set( event.clientX, event.clientY );

  		dollyDelta.subVectors( dollyEnd, dollyStart );

  		if ( dollyDelta.y > 0 ) {

  			dollyOut( getZoomScale() );

  		} else if ( dollyDelta.y < 0 ) {

  			dollyIn( getZoomScale() );

  		}

  		dollyStart.copy( dollyEnd );

  		scope.update();

  	}

  	function handleMouseMovePan( event ) {

  		panEnd.set( event.clientX, event.clientY );

  		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

  		pan( panDelta.x, panDelta.y );

  		panStart.copy( panEnd );

  		scope.update();

  	}

  	function handleMouseWheel( event ) {

  		if ( event.deltaY < 0 ) {

  			dollyIn( getZoomScale() );

  		} else if ( event.deltaY > 0 ) {

  			dollyOut( getZoomScale() );

  		}

  		scope.update();

  	}

  	function handleKeyDown( event ) {

  		var needsUpdate = false;

  		switch ( event.keyCode ) {

  			case scope.keys.UP:
  				pan( 0, scope.keyPanSpeed );
  				needsUpdate = true;
  				break;

  			case scope.keys.BOTTOM:
  				pan( 0, - scope.keyPanSpeed );
  				needsUpdate = true;
  				break;

  			case scope.keys.LEFT:
  				pan( scope.keyPanSpeed, 0 );
  				needsUpdate = true;
  				break;

  			case scope.keys.RIGHT:
  				pan( - scope.keyPanSpeed, 0 );
  				needsUpdate = true;
  				break;

  		}

  		if ( needsUpdate ) {

  			// prevent the browser from scrolling on cursor keys
  			event.preventDefault();

  			scope.update();

  		}


  	}

  	function handleTouchStartRotate( event ) {

  		if ( event.touches.length == 1 ) {

  			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		} else {

  			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
  			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

  			rotateStart.set( x, y );

  		}

  	}

  	function handleTouchStartPan( event ) {

  		if ( event.touches.length == 1 ) {

  			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		} else {

  			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
  			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

  			panStart.set( x, y );

  		}

  	}

  	function handleTouchStartDolly( event ) {

  		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  		var distance = Math.sqrt( dx * dx + dy * dy );

  		dollyStart.set( 0, distance );

  	}

  	function handleTouchStartDollyPan( event ) {

  		if ( scope.enableZoom ) handleTouchStartDolly( event );

  		if ( scope.enablePan ) handleTouchStartPan( event );

  	}

  	function handleTouchStartDollyRotate( event ) {

  		if ( scope.enableZoom ) handleTouchStartDolly( event );

  		if ( scope.enableRotate ) handleTouchStartRotate( event );

  	}

  	function handleTouchMoveRotate( event ) {

  		if ( event.touches.length == 1 ) {

  			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		} else {

  			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
  			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

  			rotateEnd.set( x, y );

  		}

  		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

  		var element = scope.domElement;

  		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

  		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

  		rotateStart.copy( rotateEnd );

  	}

  	function handleTouchMovePan( event ) {

  		if ( event.touches.length == 1 ) {

  			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		} else {

  			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
  			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

  			panEnd.set( x, y );

  		}

  		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

  		pan( panDelta.x, panDelta.y );

  		panStart.copy( panEnd );

  	}

  	function handleTouchMoveDolly( event ) {

  		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  		var distance = Math.sqrt( dx * dx + dy * dy );

  		dollyEnd.set( 0, distance );

  		dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

  		dollyOut( dollyDelta.y );

  		dollyStart.copy( dollyEnd );

  	}

  	function handleTouchMoveDollyPan( event ) {

  		if ( scope.enableZoom ) handleTouchMoveDolly( event );

  		if ( scope.enablePan ) handleTouchMovePan( event );

  	}

  	function handleTouchMoveDollyRotate( event ) {

  		if ( scope.enableZoom ) handleTouchMoveDolly( event );

  		if ( scope.enableRotate ) handleTouchMoveRotate( event );

  	}

  	//
  	// event handlers - FSM: listen for events and reset state
  	//

  	function onMouseDown( event ) {

  		if ( scope.enabled === false ) return;

  		// Prevent the browser from scrolling.
  		event.preventDefault();

  		// Manually set the focus since calling preventDefault above
  		// prevents the browser from setting it automatically.

  		scope.domElement.focus ? scope.domElement.focus() : window.focus();

  		var mouseAction;

  		switch ( event.button ) {

  			case 0:

  				mouseAction = scope.mouseButtons.LEFT;
  				break;

  			case 1:

  				mouseAction = scope.mouseButtons.MIDDLE;
  				break;

  			case 2:

  				mouseAction = scope.mouseButtons.RIGHT;
  				break;

  			default:

  				mouseAction = - 1;

  		}

  		switch ( mouseAction ) {

  			case MOUSE.DOLLY:

  				if ( scope.enableZoom === false ) return;

  				handleMouseDownDolly( event );

  				state = STATE.DOLLY;

  				break;

  			case MOUSE.ROTATE:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( scope.enablePan === false ) return;

  					handleMouseDownPan( event );

  					state = STATE.PAN;

  				} else {

  					if ( scope.enableRotate === false ) return;

  					handleMouseDownRotate( event );

  					state = STATE.ROTATE;

  				}

  				break;

  			case MOUSE.PAN:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( scope.enableRotate === false ) return;

  					handleMouseDownRotate( event );

  					state = STATE.ROTATE;

  				} else {

  					if ( scope.enablePan === false ) return;

  					handleMouseDownPan( event );

  					state = STATE.PAN;

  				}

  				break;

  			default:

  				state = STATE.NONE;

  		}

  		if ( state !== STATE.NONE ) {

  			scope.domElement.ownerDocument.addEventListener( 'mousemove', onMouseMove, false );
  			scope.domElement.ownerDocument.addEventListener( 'mouseup', onMouseUp, false );

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onMouseMove( event ) {

  		if ( scope.enabled === false ) return;

  		event.preventDefault();

  		switch ( state ) {

  			case STATE.ROTATE:

  				if ( scope.enableRotate === false ) return;

  				handleMouseMoveRotate( event );

  				break;

  			case STATE.DOLLY:

  				if ( scope.enableZoom === false ) return;

  				handleMouseMoveDolly( event );

  				break;

  			case STATE.PAN:

  				if ( scope.enablePan === false ) return;

  				handleMouseMovePan( event );

  				break;

  		}

  	}

  	function onMouseUp( event ) {

  		if ( scope.enabled === false ) return;

  		scope.domElement.ownerDocument.removeEventListener( 'mousemove', onMouseMove, false );
  		scope.domElement.ownerDocument.removeEventListener( 'mouseup', onMouseUp, false );

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onMouseWheel( event ) {

  		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

  		event.preventDefault();
  		event.stopPropagation();

  		scope.dispatchEvent( startEvent );

  		handleMouseWheel( event );

  		scope.dispatchEvent( endEvent );

  	}

  	function onKeyDown( event ) {

  		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

  		handleKeyDown( event );

  	}

  	function onTouchStart( event ) {

  		if ( scope.enabled === false ) return;

  		event.preventDefault(); // prevent scrolling

  		switch ( event.touches.length ) {

  			case 1:

  				switch ( scope.touches.ONE ) {

  					case TOUCH.ROTATE:

  						if ( scope.enableRotate === false ) return;

  						handleTouchStartRotate( event );

  						state = STATE.TOUCH_ROTATE;

  						break;

  					case TOUCH.PAN:

  						if ( scope.enablePan === false ) return;

  						handleTouchStartPan( event );

  						state = STATE.TOUCH_PAN;

  						break;

  					default:

  						state = STATE.NONE;

  				}

  				break;

  			case 2:

  				switch ( scope.touches.TWO ) {

  					case TOUCH.DOLLY_PAN:

  						if ( scope.enableZoom === false && scope.enablePan === false ) return;

  						handleTouchStartDollyPan( event );

  						state = STATE.TOUCH_DOLLY_PAN;

  						break;

  					case TOUCH.DOLLY_ROTATE:

  						if ( scope.enableZoom === false && scope.enableRotate === false ) return;

  						handleTouchStartDollyRotate( event );

  						state = STATE.TOUCH_DOLLY_ROTATE;

  						break;

  					default:

  						state = STATE.NONE;

  				}

  				break;

  			default:

  				state = STATE.NONE;

  		}

  		if ( state !== STATE.NONE ) {

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onTouchMove( event ) {

  		if ( scope.enabled === false ) return;

  		event.preventDefault(); // prevent scrolling
  		event.stopPropagation();

  		switch ( state ) {

  			case STATE.TOUCH_ROTATE:

  				if ( scope.enableRotate === false ) return;

  				handleTouchMoveRotate( event );

  				scope.update();

  				break;

  			case STATE.TOUCH_PAN:

  				if ( scope.enablePan === false ) return;

  				handleTouchMovePan( event );

  				scope.update();

  				break;

  			case STATE.TOUCH_DOLLY_PAN:

  				if ( scope.enableZoom === false && scope.enablePan === false ) return;

  				handleTouchMoveDollyPan( event );

  				scope.update();

  				break;

  			case STATE.TOUCH_DOLLY_ROTATE:

  				if ( scope.enableZoom === false && scope.enableRotate === false ) return;

  				handleTouchMoveDollyRotate( event );

  				scope.update();

  				break;

  			default:

  				state = STATE.NONE;

  		}

  	}

  	function onTouchEnd( event ) {

  		if ( scope.enabled === false ) return;

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onContextMenu( event ) {

  		if ( scope.enabled === false ) return;

  		event.preventDefault();

  	}

  	//

  	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

  	scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
  	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

  	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
  	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
  	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

  	scope.domElement.addEventListener( 'keydown', onKeyDown, false );

  	// make sure element can receive keys.

  	if ( scope.domElement.tabIndex === - 1 ) {

  		scope.domElement.tabIndex = 0;

  	}

  	// force an update at start

  	this.update();

  };

  OrbitControls.prototype = Object.create( EventDispatcher.prototype );
  OrbitControls.prototype.constructor = OrbitControls;


  // This set of controls performs orbiting, dollying (zooming), and panning.
  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  // This is very similar to OrbitControls, another set of touch behavior
  //
  //    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
  //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
  //    Pan - left mouse, or arrow keys / touch: one-finger move

  var MapControls = function ( object, domElement ) {

  	OrbitControls.call( this, object, domElement );

  	this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

  	this.mouseButtons.LEFT = MOUSE.PAN;
  	this.mouseButtons.RIGHT = MOUSE.ROTATE;

  	this.touches.ONE = TOUCH.PAN;
  	this.touches.TWO = TOUCH.DOLLY_ROTATE;

  };

  MapControls.prototype = Object.create( EventDispatcher.prototype );
  MapControls.prototype.constructor = MapControls;

  /**
   * @author zz85 / https://github.com/zz85
   * @author mrdoob / http://mrdoob.com
   * Running this will allow you to drag three.js objects around the screen.
   */

  var DragControls = function ( _objects, _camera, _domElement ) {

  	var _plane = new Plane();
  	var _raycaster = new Raycaster();

  	var _mouse = new Vector2();
  	var _offset = new Vector3();
  	var _intersection = new Vector3();
  	var _worldPosition = new Vector3();
  	var _inverseMatrix = new Matrix4();
  	var _intersections = [];

  	var _selected = null, _hovered = null;

  	//

  	var scope = this;

  	function activate() {

  		_domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
  		_domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
  		_domElement.addEventListener( 'mouseup', onDocumentMouseCancel, false );
  		_domElement.addEventListener( 'mouseleave', onDocumentMouseCancel, false );
  		_domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );
  		_domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
  		_domElement.addEventListener( 'touchend', onDocumentTouchEnd, false );

  	}

  	function deactivate() {

  		_domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
  		_domElement.removeEventListener( 'mousedown', onDocumentMouseDown, false );
  		_domElement.removeEventListener( 'mouseup', onDocumentMouseCancel, false );
  		_domElement.removeEventListener( 'mouseleave', onDocumentMouseCancel, false );
  		_domElement.removeEventListener( 'touchmove', onDocumentTouchMove, false );
  		_domElement.removeEventListener( 'touchstart', onDocumentTouchStart, false );
  		_domElement.removeEventListener( 'touchend', onDocumentTouchEnd, false );

  		_domElement.style.cursor = '';

  	}

  	function dispose() {

  		deactivate();

  	}

  	function getObjects() {

  		return _objects;

  	}

  	function onDocumentMouseMove( event ) {

  		event.preventDefault();

  		var rect = _domElement.getBoundingClientRect();

  		_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
  		_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

  		_raycaster.setFromCamera( _mouse, _camera );

  		if ( _selected && scope.enabled ) {

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_selected.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );

  			}

  			scope.dispatchEvent( { type: 'drag', object: _selected } );

  			return;

  		}

  		_intersections.length = 0;

  		_raycaster.setFromCamera( _mouse, _camera );
  		_raycaster.intersectObjects( _objects, true, _intersections );

  		if ( _intersections.length > 0 ) {

  			var object = _intersections[ 0 ].object;

  			_plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( object.matrixWorld ) );

  			if ( _hovered !== object ) {

  				scope.dispatchEvent( { type: 'hoveron', object: object } );

  				_domElement.style.cursor = 'pointer';
  				_hovered = object;

  			}

  		} else {

  			if ( _hovered !== null ) {

  				scope.dispatchEvent( { type: 'hoveroff', object: _hovered } );

  				_domElement.style.cursor = 'auto';
  				_hovered = null;

  			}

  		}

  	}

  	function onDocumentMouseDown( event ) {

  		event.preventDefault();

  		_intersections.length = 0;

  		_raycaster.setFromCamera( _mouse, _camera );
  		_raycaster.intersectObjects( _objects, true, _intersections );

  		if ( _intersections.length > 0 ) {

  			_selected = ( scope.transformGroup === true ) ? _objects[ 0 ] : _intersections[ 0 ].object;

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_inverseMatrix.getInverse( _selected.parent.matrixWorld );
  				_offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );

  			}

  			_domElement.style.cursor = 'move';

  			scope.dispatchEvent( { type: 'dragstart', object: _selected } );

  		}


  	}

  	function onDocumentMouseCancel( event ) {

  		event.preventDefault();

  		if ( _selected ) {

  			scope.dispatchEvent( { type: 'dragend', object: _selected } );

  			_selected = null;

  		}

  		_domElement.style.cursor = _hovered ? 'pointer' : 'auto';

  	}

  	function onDocumentTouchMove( event ) {

  		event.preventDefault();
  		event = event.changedTouches[ 0 ];

  		var rect = _domElement.getBoundingClientRect();

  		_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
  		_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

  		_raycaster.setFromCamera( _mouse, _camera );

  		if ( _selected && scope.enabled ) {

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_selected.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );

  			}

  			scope.dispatchEvent( { type: 'drag', object: _selected } );

  			return;

  		}

  	}

  	function onDocumentTouchStart( event ) {

  		event.preventDefault();
  		event = event.changedTouches[ 0 ];

  		var rect = _domElement.getBoundingClientRect();

  		_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
  		_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

  		_intersections.length = 0;

  		_raycaster.setFromCamera( _mouse, _camera );
  		 _raycaster.intersectObjects( _objects, true, _intersections );

  		if ( _intersections.length > 0 ) {

  			_selected = ( scope.transformGroup === true ) ? _objects[ 0 ] : _intersections[ 0 ].object;

  			_plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_inverseMatrix.getInverse( _selected.parent.matrixWorld );
  				_offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );

  			}

  			_domElement.style.cursor = 'move';

  			scope.dispatchEvent( { type: 'dragstart', object: _selected } );

  		}


  	}

  	function onDocumentTouchEnd( event ) {

  		event.preventDefault();

  		if ( _selected ) {

  			scope.dispatchEvent( { type: 'dragend', object: _selected } );

  			_selected = null;

  		}

  		_domElement.style.cursor = 'auto';

  	}

  	activate();

  	// API

  	this.enabled = true;
  	this.transformGroup = false;

  	this.activate = activate;
  	this.deactivate = deactivate;
  	this.dispose = dispose;
  	this.getObjects = getObjects;

  };

  DragControls.prototype = Object.create( EventDispatcher.prototype );
  DragControls.prototype.constructor = DragControls;

  var Skybox = function (_EventDispatcher) {
      inherits(Skybox, _EventDispatcher);

      function Skybox(scene, renderer) {
          classCallCheck(this, Skybox);

          var _this = possibleConstructorReturn(this, (Skybox.__proto__ || Object.getPrototypeOf(Skybox)).call(this));

          _this.defaultEnvironment = 'rooms/textures/envs/Garden.png';
          _this.useEnvironment = false;
          _this.topColor = 0x92b2ce; //0xe9e9e9; //0xf9f9f9;//0x565e63
          _this.bottomColor = 0xffffff; //0xD8ECF9
          _this.verticalOffset = 400;
          _this.exponent = 0.5;

          var uniforms = { topColor: { type: 'c', value: new Color(_this.topColor) }, bottomColor: { type: 'c', value: new Color(_this.bottomColor) }, offset: { type: 'f', value: _this.verticalOffset }, exponent: { type: 'f', value: _this.exponent } };

          _this.scene = scene;
          _this.renderer = renderer;

          _this.sphereRadius = 4000;
          _this.widthSegments = 32;
          _this.heightSegments = 15;
          _this.sky = null;

          _this.plainVertexShader = ['varying vec3 vWorldPosition;', 'void main() {', 'vec4 worldPosition = modelMatrix * vec4( position, 1.0 );', 'vWorldPosition = worldPosition.xyz;', 'gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );', '}'].join('\n');
          _this.plainFragmentShader = ['uniform vec3 bottomColor;', 'uniform vec3 topColor;', 'uniform float offset;', 'uniform float exponent;', 'varying vec3 vWorldPosition;', 'void main() {', ' float h = normalize( vWorldPosition + offset ).y;', ' gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max(h, 0.0 ), exponent ), 0.0 ) ), 1.0 );', '}'].join('\n');

          _this.vertexShader = ['varying vec2 vUV;', 'void main() {', '  vUV=uv;', '  vec4 pos = vec4(position, 1.0);', '   gl_Position = projectionMatrix * modelViewMatrix * pos;', '}'].join('\n');
          _this.fragmentShader = ['uniform sampler2D texture;', 'varying vec2 vUV;', 'void main() {  ', 'vec4 sample = texture2D(texture, vUV);', 'gl_FragColor = vec4(sample.xyz, sample.w);', '}'].join('\n');

          _this.texture = new TextureLoader();
          _this.plainSkyMat = new ShaderMaterial({ vertexShader: _this.plainVertexShader, fragmentShader: _this.plainFragmentShader, uniforms: uniforms, side: DoubleSide });
          _this.plainSkyMat.name = 'PlainSkyMaterial';
          _this.skyMat = undefined;

          _this.skyGeo = new SphereGeometry(_this.sphereRadius, _this.widthSegments, _this.heightSegments);
          _this.sky = new Mesh(_this.skyGeo, _this.skyMat);
          //		this.sky.position.x += this.sphereRadius*0.5;

          _this.ground = new GridHelper(10000, 100, 0x0F0F0F, 0x808080);
          _this.ground.position.y = -10;

          _this.scene.add(_this.sky);
          _this.scene.add(_this.ground);

          var axesHelper = new AxesHelper(1000);
          _this.scene.add(axesHelper);
          // axesHelper.visible = false;

          _this.init();
          return _this;
      }

      createClass(Skybox, [{
          key: 'setEnabled',
          value: function setEnabled(flag) {
              if (!flag) {
                  this.scene.remove(this.sky);
                  this.scene.remove(this.ground);
              } else {
                  this.scene.add(this.sky);
                  this.scene.add(this.ground);
              }
              //		this.sky.visible = this.ground.visible = flag;
          }
      }, {
          key: 'toggleEnvironment',
          value: function toggleEnvironment(flag) {
              this.useEnvironment = flag;
              if (!flag) {
                  this.ground.visible = true;
                  this.sky.material = this.plainSkyMat;
                  this.sky.material.needsUpdate = true;
              } else {
                  this.ground.visible = false;
                  if (!this.skyMat) {
                      this.setEnvironmentMap(this.defaultEnvironment);
                  } else {
                      this.sky.material = this.skyMat;
                  }
                  this.sky.visible = true;
              }
              this.scene.needsUpdate = true;
          }
      }, {
          key: 'setEnvironmentMap',
          value: function setEnvironmentMap(url) {
              var scope = this;
              scope.texture.load(url, function (t) {
                  var textureUniform = { type: 't', value: t };
                  var uniforms = { texture: textureUniform };
                  scope.skyMat = new ShaderMaterial({ vertexShader: scope.vertexShader, fragmentShader: scope.fragmentShader, uniforms: uniforms, side: DoubleSide });
                  scope.skyMat.name = 'SkyMaterial';
                  scope.toggleEnvironment(scope.useEnvironment);
              }, undefined, function () {
                  console.log('ERROR LOADEING FILE');
              });
          }
      }, {
          key: 'init',
          value: function init() {
              this.toggleEnvironment(false);
          }
      }]);
      return Skybox;
  }(EventDispatcher);

  var Edge3D = function (_EventDispatcher) {
      inherits(Edge3D, _EventDispatcher);

      function Edge3D(scene, edge, controls) {
          classCallCheck(this, Edge3D);

          var _this = possibleConstructorReturn(this, (Edge3D.__proto__ || Object.getPrototypeOf(Edge3D)).call(this));

          _this.name = 'edge';
          _this.scene = scene;
          _this.edge = edge;
          _this.controls = controls;

          _this.wall = edge.wall;
          _this.front = edge.front;

          _this.planes = [];
          _this.phantomPlanes = [];
          _this.basePlanes = []; // always visible

          //Debug wall intersection planes. Edge.plane is the plane used for intersection
          //		this.phantomPlanes.push(this.edge.plane);//Enable this line to see the wall planes

          _this.texture = new TextureLoader();

          _this.lightMap = new TextureLoader().load('rooms/textures/walllightmap.png');
          _this.fillerColor = 0xdddddd;
          _this.sideColor = 0xcccccc;
          _this.baseColor = 0xdddddd;
          _this.visible = false;

          var scope = _this;

          _this.redrawevent = function () {
              scope.redraw();
          };
          _this.visibilityevent = function () {
              scope.updateVisibility();
          };
          _this.showallevent = function () {
              scope.showAll();
          };

          _this.visibilityfactor = true;
          _this.init();
          return _this;
      }

      createClass(Edge3D, [{
          key: 'remove',
          value: function remove() {
              this.edge.removeEventListener(EVENT_REDRAW, this.redrawevent);
              this.controls.removeEventListener('change', this.visibilityevent);
              this.removeFromScene();
          }
      }, {
          key: 'init',
          value: function init() {
              this.edge.addEventListener(EVENT_REDRAW, this.redrawevent);
              this.controls.addEventListener('change', this.visibilityevent);

              this.updateTexture();
              this.updatePlanes();
              this.addToScene();
          }
      }, {
          key: 'redraw',
          value: function redraw() {
              this.removeFromScene();
              this.updateTexture();
              this.updatePlanes();
              this.addToScene();
          }
      }, {
          key: 'removeFromScene',
          value: function removeFromScene() {
              var scope = this;
              scope.planes.forEach(function (plane) {
                  scope.scene.remove(plane);
              });
              scope.basePlanes.forEach(function (plane) {
                  scope.scene.remove(plane);
              });
              scope.phantomPlanes.forEach(function (plane) {
                  scope.scene.remove(plane);
              });
              scope.planes = [];
              scope.basePlanes = [];
          }
      }, {
          key: 'addToScene',
          value: function addToScene() {
              var scope = this;
              this.planes.forEach(function (plane) {
                  scope.scene.add(plane);
              });
              this.basePlanes.forEach(function (plane) {
                  scope.scene.add(plane);
              });
              this.phantomPlanes.forEach(function (plane) {
                  scope.scene.add(plane);
              });
              this.updateVisibility();
          }
      }, {
          key: 'showAll',
          value: function showAll() {
              var scope = this;
              scope.visible = true;
              scope.planes.forEach(function (plane) {
                  plane.material.transparent = !scope.visible;
                  plane.material.opacity = 1.0;
                  plane.visible = scope.visible;
              });

              this.wall.items.forEach(function (item) {
                  item.updateEdgeVisibility(scope.visible, scope.front);
              });
              this.wall.onItems.forEach(function (item) {
                  item.updateEdgeVisibility(scope.visible, scope.front);
              });
          }
      }, {
          key: 'switchWireframe',
          value: function switchWireframe(flag) {
              var scope = this;
              scope.visible = true;
              scope.planes.forEach(function (plane) {
                  plane.material.wireframe = flag;
              });
          }
      }, {
          key: 'updateVisibility',
          value: function updateVisibility() {
              var scope = this;
              // finds the normal from the specified edge
              var start = scope.edge.interiorStart();
              var end = scope.edge.interiorEnd();
              var x = end.x - start.x;
              var y = end.y - start.y;
              // rotate 90 degrees CCW
              var normal = new Vector3(-y, 0, x);
              normal.normalize();

              // setup camera: scope.controls.object refers to the camera of the scene
              var position = scope.controls.object.position.clone();
              var focus = new Vector3((start.x + end.x) / 2.0, 0, (start.y + end.y) / 2.0);
              var direction = position.sub(focus).normalize();

              // find dot
              var dot = normal.dot(direction);
              // update visible
              scope.visible = dot >= 0;
              // show or hide planes
              scope.planes.forEach(function (plane) {
                  // plane.material.transparent = !scope.visible;
                  // plane.material.opacity = (scope.visible) ? 1.0 : 0.3;
                  plane.visible = scope.visible;
              });
              scope.updateObjectVisibility();
          }
      }, {
          key: 'updateObjectVisibility',
          value: function updateObjectVisibility() {
              //		var scope = this;
              //		this.wall.items.forEach((item) => {
              //			item.updateEdgeVisibility(scope.visible, scope.front);
              //		});
              //		this.wall.onItems.forEach((item) => {
              //			item.updateEdgeVisibility(scope.visible, scope.front);
              //		});
          }
      }, {
          key: 'updateTexture',
          value: function updateTexture(callback) {
              if (this.edge == null) {
                  return;
              }
              var scope = this;
              // callback is fired when texture loads
              callback = callback || function () {
                  scope.scene.needsUpdate = true;
              };
              var textureData = this.edge.getTexture();
              var stretch = textureData.stretch;
              var url = textureData.url; //this is a hack temperory
              var scale = textureData.scale;
              this.texture = new TextureLoader().load(url, callback);

              if (!stretch) {
                  var height = this.wall.height;
                  var width = this.edge.interiorDistance();
                  this.texture.wrapT = RepeatWrapping;
                  this.texture.wrapS = RepeatWrapping;
                  this.texture.repeat.set(width / scale, height / scale);
                  this.texture.needsUpdate = true;
              }
          }
      }, {
          key: 'updatePlanes',
          value: function updatePlanes() {
              var extStartCorner = this.edge.getStart();
              var extEndCorner = this.edge.getEnd();

              if (extStartCorner == null || extEndCorner == null) {
                  return;
              }

              var interiorStart = this.edge.interiorStart();
              var interiorEnd = this.edge.interiorEnd();
              var exteriorStart = this.edge.exteriorStart();
              var exteriorEnd = this.edge.exteriorEnd();

              var color = 0xFFFFFF;
              var wallMaterial = new MeshBasicMaterial({
                  color: color,
                  side: FrontSide,
                  map: this.texture,
                  transparent: true,
                  lightMap: this.lightMap,
                  opacity: 1.0,
                  wireframe: false
              });
              var fillerMaterial = new MeshBasicMaterial({
                  color: this.fillerColor,
                  side: DoubleSide,
                  map: this.texture,
                  transparent: true,
                  opacity: 1.0,
                  wireframe: false
              });

              // exterior plane for real exterior walls
              //If the walls have corners that have more than one room attached
              //Then there is no need to construct an exterior wall
              if (this.edge.wall.start.getAttachedRooms().length < 2 || this.edge.wall.end.getAttachedRooms().length < 2) {
                  this.planes.push(this.makeWall(exteriorStart, exteriorEnd, this.edge.exteriorTransform, this.edge.invExteriorTransform, fillerMaterial));
              }
              // interior plane
              this.planes.push(this.makeWall(interiorStart, interiorEnd, this.edge.interiorTransform, this.edge.invInteriorTransform, wallMaterial));
              // bottom
              // put into basePlanes since this is always visible
              this.basePlanes.push(this.buildFillerUniformHeight(this.edge, 0, BackSide, this.baseColor));
              if (this.edge.wall.start.getAttachedRooms().length < 2 || this.edge.wall.end.getAttachedRooms().length < 2) {
                  this.planes.push(this.buildFillerVaryingHeights(this.edge, DoubleSide, this.fillerColor));
              }

              // sides
              this.planes.push(this.buildSideFillter(this.edge.interiorStart(), this.edge.exteriorStart(), extStartCorner.elevation, this.sideColor));
              this.planes.push(this.buildSideFillter(this.edge.interiorEnd(), this.edge.exteriorEnd(), extEndCorner.elevation, this.sideColor));
              //		this.planes.push(this.buildSideFillter(this.edge.interiorStart(), this.edge.exteriorStart(), this.wall.startElevation, this.sideColor));
              //		this.planes.push(this.buildSideFillter(this.edge.interiorEnd(), this.edge.exteriorEnd(), extEndCorner.endElevation, this.sideColor));
          }

          // start, end have x and y attributes (i.e. corners)

      }, {
          key: 'makeWall',
          value: function makeWall(start, end, transform, invTransform, material) {
              var v1 = this.toVec3(start);
              var v2 = this.toVec3(end);
              var v3 = v2.clone();
              var v4 = v1.clone();

              v3.y = this.edge.getEnd().elevation;
              v4.y = this.edge.getStart().elevation;

              //		v3.y = this.wall.getClosestCorner(end).elevation;
              //		v4.y = this.wall.getClosestCorner(start).elevation;

              var points = [v1.clone(), v2.clone(), v3.clone(), v4.clone()];
              points.forEach(function (p) {
                  p.applyMatrix4(transform);
              });

              var spoints = [new Vector2(points[0].x, points[0].y), new Vector2(points[1].x, points[1].y), new Vector2(points[2].x, points[2].y), new Vector2(points[3].x, points[3].y)];
              var shape = new Shape(spoints);

              // add holes for each wall item
              this.wall.items.forEach(function (item) {
                  var pos = item.position.clone();
                  pos.applyMatrix4(transform);
                  var halfSize = item.halfSize;
                  var min = halfSize.clone().multiplyScalar(-1);
                  var max = halfSize.clone();
                  min.add(pos);
                  max.add(pos);

                  var holePoints = [new Vector2(min.x, min.y), new Vector2(max.x, min.y), new Vector2(max.x, max.y), new Vector2(min.x, max.y)];
                  shape.holes.push(new Path(holePoints));
              });

              var geometry = new ShapeGeometry(shape);
              geometry.vertices.forEach(function (v) {
                  v.applyMatrix4(invTransform);
              });

              // make UVs
              var totalDistance = Utils.distance(new Vector2(v1.x, v1.z), new Vector2(v2.x, v2.z));
              var height = this.wall.height;
              geometry.faceVertexUvs[0] = [];

              geometry.faces.forEach(function (face) {
                  var vertA = geometry.vertices[face.a];
                  var vertB = geometry.vertices[face.b];
                  var vertC = geometry.vertices[face.c];
                  geometry.faceVertexUvs[0].push([vertexToUv(vertA), vertexToUv(vertB), vertexToUv(vertC)]);
              });

              geometry.faceVertexUvs[1] = geometry.faceVertexUvs[0];
              geometry.computeFaceNormals();
              geometry.computeVertexNormals();

              function vertexToUv(vertex) {
                  var x = Utils.distance(new Vector2(v1.x, v1.z), new Vector2(vertex.x, vertex.z)) / totalDistance;
                  var y = vertex.y / height;
                  return new Vector2(x, y);
              }

              var mesh = new Mesh(geometry, material);
              mesh.name = 'wall';
              return mesh;
          }
      }, {
          key: 'buildSideFillter',
          value: function buildSideFillter(p1, p2, height, color) {
              var points = [this.toVec3(p1), this.toVec3(p2), this.toVec3(p2, height), this.toVec3(p1, height)];

              var geometry = new Geometry();
              points.forEach(function (p) {
                  geometry.vertices.push(p);
              });
              geometry.faces.push(new Face3(0, 1, 2));
              geometry.faces.push(new Face3(0, 2, 3));

              var fillerMaterial = new MeshBasicMaterial({ color: color, side: DoubleSide });
              var filler = new Mesh(geometry, fillerMaterial);
              return filler;
          }
      }, {
          key: 'buildFillerVaryingHeights',
          value: function buildFillerVaryingHeights(edge, side, color) {
              var a = this.toVec3(edge.exteriorStart(), this.edge.getStart().elevation);
              var b = this.toVec3(edge.exteriorEnd(), this.edge.getEnd().elevation);
              var c = this.toVec3(edge.interiorEnd(), this.edge.getEnd().elevation);
              var d = this.toVec3(edge.interiorStart(), this.edge.getStart().elevation);

              //		var a = this.toVec3(edge.exteriorStart(), this.wall.getClosestCorner(edge.exteriorStart()).elevation);
              //		var b = this.toVec3(edge.exteriorEnd(), this.wall.getClosestCorner(edge.exteriorEnd()).elevation);
              //		var c = this.toVec3(edge.interiorEnd(), this.wall.getClosestCorner(edge.interiorEnd()).elevation);
              //		var d = this.toVec3(edge.interiorStart(), this.wall.getClosestCorner(edge.interiorStart()).elevation);


              var fillerMaterial = new MeshBasicMaterial({ color: color, side: side });

              var geometry = new Geometry();
              geometry.vertices.push(a, b, c, d);
              geometry.faces.push(new Face3(0, 1, 2));
              geometry.faces.push(new Face3(0, 2, 3));

              var filler = new Mesh(geometry, fillerMaterial);
              return filler;
          }
      }, {
          key: 'buildFillerUniformHeight',
          value: function buildFillerUniformHeight(edge, height, side, color) {
              var points = [this.toVec2(edge.exteriorStart()), this.toVec2(edge.exteriorEnd()), this.toVec2(edge.interiorEnd()), this.toVec2(edge.interiorStart())];

              var fillerMaterial = new MeshBasicMaterial({ color: color, side: side });
              var shape = new Shape(points);
              var geometry = new ShapeGeometry(shape);
              var filler = new Mesh(geometry, fillerMaterial);
              filler.rotation.set(Math.PI / 2, 0, 0);
              filler.position.y = height;
              return filler;
          }
      }, {
          key: 'toVec2',
          value: function toVec2(pos) {
              return new Vector2(pos.x, pos.y);
          }
      }, {
          key: 'toVec3',
          value: function toVec3(pos, height) {
              height = height || 0;
              return new Vector3(pos.x, height, pos.y);
          }
      }]);
      return Edge3D;
  }(EventDispatcher);

  var Floor3D = function (_EventDispatcher) {
      inherits(Floor3D, _EventDispatcher);

      function Floor3D(scene, room) {
          classCallCheck(this, Floor3D);

          var _this = possibleConstructorReturn(this, (Floor3D.__proto__ || Object.getPrototypeOf(Floor3D)).call(this));

          _this.scene = scene;
          _this.room = room;
          _this.floorPlane = null;
          _this.roofPlane = null;
          _this.changedevent = function () {
              _this.redraw();
          };
          _this.init();
          return _this;
      }

      createClass(Floor3D, [{
          key: 'switchWireframe',
          value: function switchWireframe(flag) {
              this.floorPlane.visible = !flag;
              this.roofPlane.visible = !flag;
          }
      }, {
          key: 'init',
          value: function init() {
              this.room.addEventListener(EVENT_CHANGED, this.changedevent);
              this.floorPlane = this.buildFloor();
              // roofs look weird, so commented out
              // this.roofPlane = this.buildRoofUniformHeight();
              this.roofPlane = this.buildRoofVaryingHeight();
          }
      }, {
          key: 'redraw',
          value: function redraw() {
              this.removeFromScene();
              this.floorPlane = this.buildFloor();
              this.roofPlane = this.buildRoofVaryingHeight();
              this.addToScene();
          }
      }, {
          key: 'buildFloor',
          value: function buildFloor() {
              var textureSettings = this.room.getTexture();
              // setup texture
              //		var floorTexture = ImageUtils.loadTexture(textureSettings.url);
              var floorTexture = new TextureLoader().load(textureSettings.url);
              floorTexture.wrapS = RepeatWrapping;
              floorTexture.wrapT = RepeatWrapping;
              floorTexture.repeat.set(1, 1);

              var textureScale = textureSettings.scale;
              // http://stackoverflow.com/questions/19182298/how-to-texture-a-three-js-mesh-created-with-shapegeometry
              // scale down coords to fit 0 -> 1, then rescale

              var points = [];
              this.room.interiorCorners.forEach(function (corner) {
                  points.push(new Vector2(corner.x / textureScale, corner.y / textureScale));
              });
              var shape = new Shape(points);
              var geometry = new ShapeGeometry(shape);
              // var floor = new Mesh(geometry, floorMaterialTop);
              var floor = new Mesh(geometry, new MeshBasicMaterial({ color: 0xC00C0C0, side: DoubleSide }));

              floor.rotation.set(Math.PI / 2, 0, 0);
              floor.scale.set(textureScale, textureScale, textureScale);
              // floor.receiveShadow = true;
              floor.castShadow = false;
              return floor;
          }
      }, {
          key: 'buildRoofVaryingHeight',
          value: function buildRoofVaryingHeight() {
              // setup texture
              var roofMaterial = new MeshBasicMaterial({ side: FrontSide, color: 0xe5e5e5 });
              var geometry = new Geometry();

              this.room.corners.forEach(function (corner) {
                  var vertex = new Vector3(corner.x, corner.elevation, corner.y);
                  geometry.vertices.push(vertex);
              });
              for (var i = 2; i < geometry.vertices.length; i++) {
                  var face = new Face3(0, i - 1, i);
                  geometry.faces.push(face);
              }
              var roof = new Mesh(geometry, roofMaterial);
              // roof.rotation.set(Math.PI / 2, 0, 0);
              // roof.position.y = Configuration.getNumericValue(configWallHeight);
              return roof;
          }
      }, {
          key: 'buildRoofUniformHeight',
          value: function buildRoofUniformHeight() {
              // setup texture
              var roofMaterial = new MeshBasicMaterial({ side: FrontSide, color: 0xe5e5e5 });
              var points = [];
              this.room.interiorCorners.forEach(function (corner) {
                  points.push(new Vector2(corner.x, corner.y));
              });
              var shape = new Shape(points);
              var geometry = new ShapeGeometry(shape);
              var roof = new Mesh(geometry, roofMaterial);
              roof.rotation.set(Math.PI / 2, 0, 0);
              roof.position.y = Configuration.getNumericValue(configWallHeight);
              return roof;
          }
      }, {
          key: 'addToScene',
          value: function addToScene() {
              this.scene.add(this.floorPlane);
              this.scene.add(this.roofPlane);
              //scene.add(roofPlane);
              // hack so we can do intersect testing
              this.scene.add(this.room.floorPlane);
              this.scene.add(this.room.roofPlane);
          }
      }, {
          key: 'removeFromScene',
          value: function removeFromScene() {
              this.scene.remove(this.floorPlane);
              this.scene.remove(this.roofPlane);
              this.scene.remove(this.room.floorPlane);
              this.scene.remove(this.room.roofPlane);
          }
      }, {
          key: 'showRoof',
          value: function showRoof(flag) {
              console.log(flag);
              // this.roofPlane.visible = flag;
          }
      }]);
      return Floor3D;
  }(EventDispatcher);

  var Lights3D = function (_EventDispatcher) {
      inherits(Lights3D, _EventDispatcher);

      function Lights3D(scene, floorplan) {
          classCallCheck(this, Lights3D);

          var _this = possibleConstructorReturn(this, (Lights3D.__proto__ || Object.getPrototypeOf(Lights3D)).call(this));

          _this.scene = scene;
          _this.floorplan = floorplan;
          _this.tol = 1;
          _this.height = 300; // TODO: share with Blueprint.Wall
          _this.dirLight = null;
          _this.updatedroomsevent = function () {
              _this.updateShadowCamera();
          };
          _this.init();
          return _this;
      }

      createClass(Lights3D, [{
          key: 'getDirLight',
          value: function getDirLight() {
              return this.dirLight;
          }
      }, {
          key: 'init',
          value: function init() {
              var light = new HemisphereLight(0xffffff, 0x888888, 1.1);
              light.position.set(300, this.height, 500);
              this.scene.add(light);

              this.dirLight = new DirectionalLight(0xffffff, 0.5);
              this.dirLight.color.setHSL(1, 1, 0.1);

              this.ambLight = new AmbientLight(0x404040); // soft white light
              this.ambLight.intensity = 1.25;

              this.dirLight.castShadow = true;

              this.dirLight.shadow.mapSize.width = 1024;
              this.dirLight.shadow.mapSize.height = 1024;

              this.dirLight.shadow.camera.far = this.height + this.tol;
              this.dirLight.shadow.bias = -0.0001;
              this.dirLight.shadowDarkness = 0.2;
              this.dirLight.visible = true;
              this.dirLight.shadowCameraVisible = false;

              this.scene.add(this.dirLight);
              this.scene.add(this.dirLight.target);
              this.scene.add(this.ambLight);

              this.floorplan.addEventListener(EVENT_UPDATED, this.updatedroomsevent);
          }
      }, {
          key: 'updateShadowCamera',
          value: function updateShadowCamera() {
              var size = this.floorplan.getSize();
              var d = (Math.max(size.z, size.x) + this.tol) / 2.0;
              var center = this.floorplan.getCenter();
              var pos = new Vector3(center.x, this.height, center.z);
              this.dirLight.position.copy(pos);
              this.dirLight.target.position.copy(center);
              //dirLight.updateMatrix();
              //dirLight.updateWorldMatrix()
              this.dirLight.shadow.camera.left = -d;
              this.dirLight.shadow.camera.right = d;
              this.dirLight.shadow.camera.top = d;
              this.dirLight.shadow.camera.bottom = -d;
              // this is necessary for updates
              if (this.dirLight.shadowCamera) {
                  this.dirLight.shadow.camera.left = this.dirLight.shadowCameraLeft;
                  this.dirLight.shadow.camera.right = this.dirLight.shadowCameraRight;
                  this.dirLight.shadow.camera.top = this.dirLight.shadowCameraTop;
                  this.dirLight.shadow.camera.bottom = this.dirLight.shadowCameraBottom;
                  this.dirLight.shadowCamera.updateProjectionMatrix();
              }
          }
      }]);
      return Lights3D;
  }(EventDispatcher);

  var Viewer3D = function (_EventDispatcher) {
      inherits(Viewer3D, _EventDispatcher);

      function Viewer3D(model, element, opts) {
          classCallCheck(this, Viewer3D);

          var _this = possibleConstructorReturn(this, (Viewer3D.__proto__ || Object.getPrototypeOf(Viewer3D)).call(this));

          var options = { resize: true, pushHref: false, spin: true, spinSpeed: .00002, clickPan: true, canMoveFixedItems: false };
          for (var opt in options) {
              if (options.hasOwnProperty(opt) && opts.hasOwnProperty(opt)) {
                  options[opt] = opts[opt];
              }
          }
          _this.model = model;
          _this.floorplan = _this.model.floorplan;
          _this.scene = model.scene;
          _this.element = jquery(element);
          _this.options = options;

          _this.domElement = null;
          _this.perspectivecamera = null;
          _this.camera = null;

          _this.cameraNear = 10;
          _this.cameraFar = 10000;

          _this.controls = null;

          _this.renderer = null;
          _this.controller = null;

          _this.needsUpdate = false;
          _this.lastRender = Date.now();

          _this.heightMargin = null;
          _this.widthMargin = null;
          _this.elementHeight = null;
          _this.elementWidth = null;
          _this.pauseRender = false;
          _this.edges3d = [];
          _this.floors3d = [];
          // this.walls3d = [];
          _this.draggables = [];

          _this.scene.needsUpdate = true;

          _this.init();
          return _this;
      }

      createClass(Viewer3D, [{
          key: 'init',
          value: function init() {
              var scope = this;
              ImageUtils.crossOrigin = '';
              scope.domElement = scope.element.get(0);

              scope.camera = new PerspectiveCamera(45, 10, scope.cameraNear, scope.cameraFar);

              scope.renderer = scope.getARenderer();
              scope.domElement.appendChild(scope.renderer.domElement);

              scope.lights = new Lights3D(scope.scene, scope.floorplan);
              scope.dragcontrols = new DragControls(scope.scene.items, scope.camera, scope.renderer.domElement);
              scope.controls = new OrbitControls(scope.camera, scope.domElement);
              // scope.controls.autoRotate = this.options['spin'];
              scope.controls.enableDamping = false;
              scope.controls.dampingFactor = 0.1;
              scope.controls.maxPolarAngle = Math.PI * 1.0; //Math.PI * 0.5; //Math.PI * 0.35;
              scope.controls.maxDistance = 2500; //2500
              scope.controls.minDistance = 10; //1000; //1000
              scope.controls.screenSpacePanning = true;

              scope.skybox = new Skybox(scope.scene, scope.renderer);
              scope.camera.position.set(0, 600, 1500);
              scope.controls.update();

              scope.axes = new AxesHelper(500);
              // scope.scene.add(scope.axes);

              scope.dragcontrols.addEventListener('dragstart', function () {
                  scope.controls.enabled = false;
              });
              scope.dragcontrols.addEventListener('drag', function () {
                  scope.scene.needsUpdate = true;
              });
              scope.dragcontrols.addEventListener('dragend', function () {
                  scope.controls.enabled = true;
              });

              // handle window resizing
              scope.updateWindowSize();

              if (scope.options.resize) {
                  jquery(window).resize(function () {
                      scope.updateWindowSize();
                  });
              }

              function animate() {
                  scope.renderer.setAnimationLoop(function () {
                      scope.render();
                  });
                  scope.render();
              }
              scope.floorplan.addEventListener(EVENT_UPDATED, function (evt) {
                  return scope.addWalls(evt);
              });
              // scope.addWalls();
              this.controls.addEventListener('change', function () {
                  scope.scene.needsUpdate = true;
              });
              animate();
          }
      }, {
          key: 'addWalls',
          value: function addWalls() {
              var scope = this;
              var i = 0;

              // clear scene
              scope.floors3d.forEach(function (floor) {
                  floor.removeFromScene();
              });

              scope.edges3d.forEach(function (edge3d) {
                  edge3d.remove();
              });

              // for (i = 0; i < scope.walls3d.length; i++) {
              //     scope.scene.remove(scope.walls3d[i]);
              // }
              // scope.walls3d = [];

              scope.edges3d = [];
              var wallEdges = scope.floorplan.wallEdges();
              var rooms = scope.floorplan.getRooms();

              // draw floors
              for (i = 0; i < rooms.length; i++) {
                  var threeFloor = new Floor3D(scope.scene, rooms[i]);
                  scope.floors3d.push(threeFloor);
                  threeFloor.addToScene();
              }

              for (i = 0; i < wallEdges.length; i++) {
                  var edge3d = new Edge3D(scope.model.scene, wallEdges[i], scope.controls);
                  scope.edges3d.push(edge3d);
              }

              // let walls = scope.floorplan.getWalls();
              // for (i = 0; i < walls.length; i++) {
              //     let wall3d = new WallView3D(walls[i], scope.floorplan, scope, scope.controls);
              //     scope.scene.add(wall3d);
              //     scope.walls3d.push(wall3d);
              // }

              scope.shouldRender = true;

              var floorplanCenter = scope.floorplan.getDimensions(true);
              scope.controls.target = floorplanCenter.clone();
              scope.camera.position.set(floorplanCenter.x, 300, floorplanCenter.z * 5);
              scope.controls.update();
          }
      }, {
          key: 'getARenderer',
          value: function getARenderer() {
              var renderer = new WebGLRenderer({ antialias: true, alpha: true });

              // scope.renderer.autoClear = false;
              renderer.shadowMap.enabled = true;
              renderer.shadowMapSoft = true;
              renderer.shadowMap.type = PCFSoftShadowMap;
              renderer.setClearColor(0xFFFFFF, 1);
              renderer.localClippingEnabled = false;
              //		renderer.setPixelRatio(window.devicePixelRatio);
              // renderer.sortObjects = false;
              return renderer;
          }
      }, {
          key: 'updateWindowSize',
          value: function updateWindowSize() {
              var scope = this;

              scope.heightMargin = scope.element.offset().top;
              scope.widthMargin = scope.element.offset().left;
              scope.elementWidth = scope.element.innerWidth();

              if (scope.options.resize) {
                  scope.elementHeight = window.innerHeight - scope.heightMargin;
              } else {
                  scope.elementHeight = scope.element.innerHeight();
              }
              scope.camera.aspect = scope.elementWidth / scope.elementHeight;
              scope.camera.updateProjectionMatrix();
              scope.renderer.setSize(scope.elementWidth, scope.elementHeight);
              scope.scene.needsUpdate = true;
          }
      }, {
          key: 'render',
          value: function render() {
              var scope = this;
              // scope.controls.update();
              if (!scope.scene.needsUpdate) {
                  return;
              }
              scope.renderer.render(scope.scene.getScene(), scope.camera);
              scope.lastRender = Date.now();
              this.scene.needsUpdate = false;
          }
      }]);
      return Viewer3D;
  }(EventDispatcher);

  var empty = {};

  var empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': empty
  });

  var require$$2 = getCjsExportFromNamespace(empty$1);

  var fabric_1 = createCommonjsModule(function (module, exports) {
  /* build: `node build.js modules=ALL exclude=gestures,accessors requirejs minifier=uglifyjs` */
  /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

  var fabric = fabric || { version: '3.6.3' };
  {
    exports.fabric = fabric;
  }
  /* _AMD_END_ */
  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    if (document instanceof (typeof HTMLDocument !== 'undefined' ? HTMLDocument : Document)) {
      fabric.document = document;
    }
    else {
      fabric.document = document.implementation.createHTMLDocument('');
    }
    fabric.window = window;
  }
  else {
    // assume we're running under node.js when document/window are not present
    var jsdom = require$$2;
    var virtualWindow = new jsdom.JSDOM(
      decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
      {
        features: {
          FetchExternalResources: ['img']
        },
        resources: 'usable'
      }).window;
    fabric.document = virtualWindow.document;
    fabric.jsdomImplForWrapper = require$$2.implForWrapper;
    fabric.nodeCanvas = require$$2.Canvas;
    fabric.window = virtualWindow;
    DOMParser = fabric.window.DOMParser;
  }

  /**
   * True when in environment that supports touch events
   * @type boolean
   */
  fabric.isTouchSupported = 'ontouchstart' in fabric.window || 'ontouchstart' in fabric.document ||
    (fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0);

  /**
   * True when in environment that's probably Node.js
   * @type boolean
   */
  fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                        typeof window === 'undefined';

  /* _FROM_SVG_START_ */
  /**
   * Attributes parsed from all SVG elements
   * @type array
   */
  fabric.SHARED_ATTRIBUTES = [
    'display',
    'transform',
    'fill', 'fill-opacity', 'fill-rule',
    'opacity',
    'stroke', 'stroke-dasharray', 'stroke-linecap', 'stroke-dashoffset',
    'stroke-linejoin', 'stroke-miterlimit',
    'stroke-opacity', 'stroke-width',
    'id', 'paint-order', 'vector-effect',
    'instantiated_by_use', 'clip-path'
  ];
  /* _FROM_SVG_END_ */

  /**
   * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
   */
  fabric.DPI = 96;
  fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)';
  fabric.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig;
  fabric.reNonWord = /[ \n\.,;!\?\-]/;
  fabric.fontPaths = { };
  fabric.iMatrix = [1, 0, 0, 1, 0, 0];
  fabric.svgNS = 'http://www.w3.org/2000/svg';

  /**
   * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.perfLimitSizeTotal = 2097152;

  /**
   * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.maxCacheSideLimit = 4096;

  /**
   * Lowest pixel limit for cache canvases, set at 256PX
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.minCacheSideLimit = 256;

  /**
   * Cache Object for widths of chars in text rendering.
   */
  fabric.charWidthsCache = { };

  /**
   * if webgl is enabled and available, textureSize will determine the size
   * of the canvas backend
   * @since 2.0.0
   * @type Number
   * @default
   */
  fabric.textureSize = 2048;

  /**
   * When 'true', style information is not retained when copy/pasting text, making
   * pasted text use destination style.
   * Defaults to 'false'.
   * @type Boolean
   * @default
   */
  fabric.disableStyleCopyPaste = false;

  /**
   * Enable webgl for filtering picture is available
   * A filtering backend will be initialized, this will both take memory and
   * time since a default 2048x2048 canvas will be created for the gl context
   * @since 2.0.0
   * @type Boolean
   * @default
   */
  fabric.enableGLFiltering = true;

  /**
   * Device Pixel Ratio
   * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
   */
  fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                            fabric.window.webkitDevicePixelRatio ||
                            fabric.window.mozDevicePixelRatio ||
                            1;
  /**
   * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,
   * which is unitless and not rendered equally across browsers.
   *
   * Values that work quite well (as of October 2017) are:
   * - Chrome: 1.5
   * - Edge: 1.75
   * - Firefox: 0.9
   * - Safari: 0.95
   *
   * @since 2.0.0
   * @type Number
   * @default 1
   */
  fabric.browserShadowBlurConstant = 1;

  /**
   * This object contains the result of arc to beizer conversion for faster retrieving if the same arc needs to be converted again.
   * It was an internal variable, is accessible since version 2.3.4
   */
  fabric.arcToSegmentsCache = { };

  /**
   * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.
   * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing
   * you do not get any speed benefit and you get a big object in memory.
   * The object was a private variable before, while now is appended to the lib so that you have access to it and you
   * can eventually clear it.
   * It was an internal variable, is accessible since version 2.3.4
   */
  fabric.boundsOfCurveCache = { };

  /**
   * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better
   * @default true
   */
  fabric.cachesBoundsOfCurve = true;

  /**
   * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on
   * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true
   * this has to be set before instantiating the filtering backend ( before filtering the first image )
   * @type Boolean
   * @default false
   */
  fabric.forceGLPutImageData = false;

  fabric.initFilterBackend = function() {
    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
      console.log('max texture size: ' + fabric.maxTextureSize);
      return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
    }
    else if (fabric.Canvas2dFilterBackend) {
      return (new fabric.Canvas2dFilterBackend());
    }
  };


  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
    window.fabric = fabric;
  }


  (function() {

    /**
     * @private
     * @param {String} eventName
     * @param {Function} handler
     */
    function _removeEventListener(eventName, handler) {
      if (!this.__eventListeners[eventName]) {
        return;
      }
      var eventListener = this.__eventListeners[eventName];
      if (handler) {
        eventListener[eventListener.indexOf(handler)] = false;
      }
      else {
        fabric.util.array.fill(eventListener, false);
      }
    }

    /**
     * Observes specified event
     * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
     * @memberOf fabric.Observable
     * @alias on
     * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     * @param {Function} handler Function that receives a notification when an event of the specified type occurs
     * @return {Self} thisArg
     * @chainable
     */
    function observe(eventName, handler) {
      if (!this.__eventListeners) {
        this.__eventListeners = { };
      }
      // one object with key/value pairs was passed
      if (arguments.length === 1) {
        for (var prop in eventName) {
          this.on(prop, eventName[prop]);
        }
      }
      else {
        if (!this.__eventListeners[eventName]) {
          this.__eventListeners[eventName] = [];
        }
        this.__eventListeners[eventName].push(handler);
      }
      return this;
    }

    /**
     * Stops event observing for a particular event handler. Calling this method
     * without arguments removes all handlers for all events
     * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
     * @memberOf fabric.Observable
     * @alias off
     * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     * @param {Function} handler Function to be deleted from EventListeners
     * @return {Self} thisArg
     * @chainable
     */
    function stopObserving(eventName, handler) {
      if (!this.__eventListeners) {
        return this;
      }

      // remove all key/value pairs (event name -> event handler)
      if (arguments.length === 0) {
        for (eventName in this.__eventListeners) {
          _removeEventListener.call(this, eventName);
        }
      }
      // one object with key/value pairs was passed
      else if (arguments.length === 1 && typeof arguments[0] === 'object') {
        for (var prop in eventName) {
          _removeEventListener.call(this, prop, eventName[prop]);
        }
      }
      else {
        _removeEventListener.call(this, eventName, handler);
      }
      return this;
    }

    /**
     * Fires event with an optional options object
     * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
     * @memberOf fabric.Observable
     * @alias trigger
     * @param {String} eventName Event name to fire
     * @param {Object} [options] Options object
     * @return {Self} thisArg
     * @chainable
     */
    function fire(eventName, options) {
      if (!this.__eventListeners) {
        return this;
      }

      var listenersForEvent = this.__eventListeners[eventName];
      if (!listenersForEvent) {
        return this;
      }

      for (var i = 0, len = listenersForEvent.length; i < len; i++) {
        listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
      }
      this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
        return value !== false;
      });
      return this;
    }

    /**
     * @namespace fabric.Observable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
     * @see {@link http://fabricjs.com/events|Events demo}
     */
    fabric.Observable = {
      observe: observe,
      stopObserving: stopObserving,
      fire: fire,

      on: observe,
      off: stopObserving,
      trigger: fire
    };
  })();


  /**
   * @namespace fabric.Collection
   */
  fabric.Collection = {

    _objects: [],

    /**
     * Adds objects to collection, Canvas or Group, then renders canvas
     * (if `renderOnAddRemove` is not `false`).
     * in case of Group no changes to bounding box are made.
     * Objects should be instances of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the add method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    add: function () {
      this._objects.push.apply(this._objects, arguments);
      if (this._onObjectAdded) {
        for (var i = 0, length = arguments.length; i < length; i++) {
          this._onObjectAdded(arguments[i]);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
     * An object should be an instance of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the insertAt method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {Object} object Object to insert
     * @param {Number} index Index to insert object at
     * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
     * @return {Self} thisArg
     * @chainable
     */
    insertAt: function (object, index, nonSplicing) {
      var objects = this._objects;
      if (nonSplicing) {
        objects[index] = object;
      }
      else {
        objects.splice(index, 0, object);
      }
      this._onObjectAdded && this._onObjectAdded(object);
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    remove: function() {
      var objects = this._objects,
          index, somethingRemoved = false;

      for (var i = 0, length = arguments.length; i < length; i++) {
        index = objects.indexOf(arguments[i]);

        // only call onObjectRemoved if an object was actually removed
        if (index !== -1) {
          somethingRemoved = true;
          objects.splice(index, 1);
          this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
        }
      }

      this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
      return this;
    },

    /**
     * Executes given function for each object in this group
     * @param {Function} callback
     *                   Callback invoked with current object as first argument,
     *                   index - as second and an array of all objects - as third.
     *                   Callback is invoked in a context of Global Object (e.g. `window`)
     *                   when no `context` argument is given
     *
     * @param {Object} context Context (aka thisObject)
     * @return {Self} thisArg
     * @chainable
     */
    forEachObject: function(callback, context) {
      var objects = this.getObjects();
      for (var i = 0, len = objects.length; i < len; i++) {
        callback.call(context, objects[i], i, objects);
      }
      return this;
    },

    /**
     * Returns an array of children objects of this instance
     * Type parameter introduced in 1.3.10
     * since 2.3.5 this method return always a COPY of the array;
     * @param {String} [type] When specified, only objects of this type are returned
     * @return {Array}
     */
    getObjects: function(type) {
      if (typeof type === 'undefined') {
        return this._objects.concat();
      }
      return this._objects.filter(function(o) {
        return o.type === type;
      });
    },

    /**
     * Returns object at specified index
     * @param {Number} index
     * @return {Self} thisArg
     */
    item: function (index) {
      return this._objects[index];
    },

    /**
     * Returns true if collection contains no objects
     * @return {Boolean} true if collection is empty
     */
    isEmpty: function () {
      return this._objects.length === 0;
    },

    /**
     * Returns a size of a collection (i.e: length of an array containing its objects)
     * @return {Number} Collection size
     */
    size: function() {
      return this._objects.length;
    },

    /**
     * Returns true if collection contains an object
     * @param {Object} object Object to check against
     * @return {Boolean} `true` if collection contains an object
     */
    contains: function(object) {
      return this._objects.indexOf(object) > -1;
    },

    /**
     * Returns number representation of a collection complexity
     * @return {Number} complexity
     */
    complexity: function () {
      return this._objects.reduce(function (memo, current) {
        memo += current.complexity ? current.complexity() : 0;
        return memo;
      }, 0);
    }
  };


  /**
   * @namespace fabric.CommonMethods
   */
  fabric.CommonMethods = {

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    _setOptions: function(options) {
      for (var prop in options) {
        this.set(prop, options[prop]);
      }
    },

    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Gradient to
     */
    _initGradient: function(filler, property) {
      if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
        this.set(property, new fabric.Gradient(filler));
      }
    },

    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Pattern to
     * @param {Function} [callback] callback to invoke after pattern load
     */
    _initPattern: function(filler, property, callback) {
      if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
        this.set(property, new fabric.Pattern(filler, callback));
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initClipping: function(options) {
      if (!options.clipTo || typeof options.clipTo !== 'string') {
        return;
      }

      var functionBody = fabric.util.getFunctionBody(options.clipTo);
      if (typeof functionBody !== 'undefined') {
        this.clipTo = new Function('ctx', functionBody);
      }
    },

    /**
     * @private
     */
    _setObject: function(obj) {
      for (var prop in obj) {
        this._set(prop, obj[prop]);
      }
    },

    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(key, value) {
      if (typeof key === 'object') {
        this._setObject(key);
      }
      else {
        if (typeof value === 'function' && key !== 'clipTo') {
          this._set(key, value(this.get(key)));
        }
        else {
          this._set(key, value);
        }
      }
      return this;
    },

    _set: function(key, value) {
      this[key] = value;
    },

    /**
     * Toggles specified property from `true` to `false` or from `false` to `true`
     * @param {String} property Property to toggle
     * @return {fabric.Object} thisArg
     * @chainable
     */
    toggle: function(property) {
      var value = this.get(property);
      if (typeof value === 'boolean') {
        this.set(property, !value);
      }
      return this;
    },

    /**
     * Basic getter
     * @param {String} property Property name
     * @return {*} value of a property
     */
    get: function(property) {
      return this[property];
    }
  };


  (function(global) {

    var sqrt = Math.sqrt,
        atan2 = Math.atan2,
        pow = Math.pow,
        PiBy180 = Math.PI / 180,
        PiBy2 = Math.PI / 2;

    /**
     * @namespace fabric.util
     */
    fabric.util = {

      /**
       * Calculate the cos of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      cos: function(angle) {
        if (angle === 0) { return 1; }
        if (angle < 0) {
          // cos(a) = cos(-a)
          angle = -angle;
        }
        var angleSlice = angle / PiBy2;
        switch (angleSlice) {
          case 1: case 3: return 0;
          case 2: return -1;
        }
        return Math.cos(angle);
      },

      /**
       * Calculate the sin of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      sin: function(angle) {
        if (angle === 0) { return 0; }
        var angleSlice = angle / PiBy2, sign = 1;
        if (angle < 0) {
          // sin(-a) = -sin(a)
          sign = -1;
        }
        switch (angleSlice) {
          case 1: return sign;
          case 2: return 0;
          case 3: return -sign;
        }
        return Math.sin(angle);
      },

      /**
       * Removes value from an array.
       * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
       * @static
       * @memberOf fabric.util
       * @param {Array} array
       * @param {*} value
       * @return {Array} original array
       */
      removeFromArray: function(array, value) {
        var idx = array.indexOf(value);
        if (idx !== -1) {
          array.splice(idx, 1);
        }
        return array;
      },

      /**
       * Returns random number between 2 specified ones.
       * @static
       * @memberOf fabric.util
       * @param {Number} min lower limit
       * @param {Number} max upper limit
       * @return {Number} random value (between min and max)
       */
      getRandomInt: function(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      },

      /**
       * Transforms degrees to radians.
       * @static
       * @memberOf fabric.util
       * @param {Number} degrees value in degrees
       * @return {Number} value in radians
       */
      degreesToRadians: function(degrees) {
        return degrees * PiBy180;
      },

      /**
       * Transforms radians to degrees.
       * @static
       * @memberOf fabric.util
       * @param {Number} radians value in radians
       * @return {Number} value in degrees
       */
      radiansToDegrees: function(radians) {
        return radians / PiBy180;
      },

      /**
       * Rotates `point` around `origin` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {fabric.Point} point The point to rotate
       * @param {fabric.Point} origin The origin of the rotation
       * @param {Number} radians The radians of the angle for the rotation
       * @return {fabric.Point} The new rotated point
       */
      rotatePoint: function(point, origin, radians) {
        point.subtractEquals(origin);
        var v = fabric.util.rotateVector(point, radians);
        return new fabric.Point(v.x, v.y).addEquals(origin);
      },

      /**
       * Rotates `vector` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {Object} vector The vector to rotate (x and y)
       * @param {Number} radians The radians of the angle for the rotation
       * @return {Object} The new rotated point
       */
      rotateVector: function(vector, radians) {
        var sin = fabric.util.sin(radians),
            cos = fabric.util.cos(radians),
            rx = vector.x * cos - vector.y * sin,
            ry = vector.x * sin + vector.y * cos;
        return {
          x: rx,
          y: ry
        };
      },

      /**
       * Apply transform t to point p
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Point} p The point to transform
       * @param  {Array} t The transform
       * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
       * @return {fabric.Point} The transformed point
       */
      transformPoint: function(p, t, ignoreOffset) {
        if (ignoreOffset) {
          return new fabric.Point(
            t[0] * p.x + t[2] * p.y,
            t[1] * p.x + t[3] * p.y
          );
        }
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y + t[4],
          t[1] * p.x + t[3] * p.y + t[5]
        );
      },

      /**
       * Returns coordinates of points's bounding rectangle (left, top, width, height)
       * @param {Array} points 4 points array
       * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix
       * @return {Object} Object with left, top, width, height properties
       */
      makeBoundingBoxFromPoints: function(points, transform) {
        if (transform) {
          for (var i = 0; i < points.length; i++) {
            points[i] = fabric.util.transformPoint(points[i], transform);
          }
        }
        var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
            minX = fabric.util.array.min(xPoints),
            maxX = fabric.util.array.max(xPoints),
            width = maxX - minX,
            yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
            minY = fabric.util.array.min(yPoints),
            maxY = fabric.util.array.max(yPoints),
            height = maxY - minY;

        return {
          left: minX,
          top: minY,
          width: width,
          height: height
        };
      },

      /**
       * Invert transformation t
       * @static
       * @memberOf fabric.util
       * @param {Array} t The transform
       * @return {Array} The inverted transform
       */
      invertTransform: function(t) {
        var a = 1 / (t[0] * t[3] - t[1] * t[2]),
            r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
            o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
        r[4] = -o.x;
        r[5] = -o.y;
        return r;
      },

      /**
       * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
       * @static
       * @memberOf fabric.util
       * @param {Number|String} number number to operate on
       * @param {Number} fractionDigits number of fraction digits to "leave"
       * @return {Number}
       */
      toFixed: function(number, fractionDigits) {
        return parseFloat(Number(number).toFixed(fractionDigits));
      },

      /**
       * Converts from attribute value to pixel value if applicable.
       * Returns converted pixels or original value not converted.
       * @param {Number|String} value number to operate on
       * @param {Number} fontSize
       * @return {Number|String}
       */
      parseUnit: function(value, fontSize) {
        var unit = /\D{0,2}$/.exec(value),
            number = parseFloat(value);
        if (!fontSize) {
          fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
        }
        switch (unit[0]) {
          case 'mm':
            return number * fabric.DPI / 25.4;

          case 'cm':
            return number * fabric.DPI / 2.54;

          case 'in':
            return number * fabric.DPI;

          case 'pt':
            return number * fabric.DPI / 72; // or * 4 / 3

          case 'pc':
            return number * fabric.DPI / 72 * 12; // or * 16

          case 'em':
            return number * fontSize;

          default:
            return number;
        }
      },

      /**
       * Function which always returns `false`.
       * @static
       * @memberOf fabric.util
       * @return {Boolean}
       */
      falseFunction: function() {
        return false;
      },

      /**
       * Returns klass "Class" object of given namespace
       * @memberOf fabric.util
       * @param {String} type Type of object (eg. 'circle')
       * @param {String} namespace Namespace to get klass "Class" object from
       * @return {Object} klass "Class"
       */
      getKlass: function(type, namespace) {
        // capitalize first letter only
        type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
        return fabric.util.resolveNamespace(namespace)[type];
      },

      /**
       * Returns array of attributes for given svg that fabric parses
       * @memberOf fabric.util
       * @param {String} type Type of svg element (eg. 'circle')
       * @return {Array} string names of supported attributes
       */
      getSvgAttributes: function(type) {
        var attributes = [
          'instantiated_by_use',
          'style',
          'id',
          'class'
        ];
        switch (type) {
          case 'linearGradient':
            attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);
            break;
          case 'radialGradient':
            attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);
            break;
          case 'stop':
            attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);
            break;
        }
        return attributes;
      },

      /**
       * Returns object of given namespace
       * @memberOf fabric.util
       * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
       * @return {Object} Object for given namespace (default fabric)
       */
      resolveNamespace: function(namespace) {
        if (!namespace) {
          return fabric;
        }

        var parts = namespace.split('.'),
            len = parts.length, i,
            obj = global || fabric.window;

        for (i = 0; i < len; ++i) {
          obj = obj[parts[i]];
        }

        return obj;
      },

      /**
       * Loads image element from given url and passes it to a callback
       * @memberOf fabric.util
       * @param {String} url URL representing an image
       * @param {Function} callback Callback; invoked with loaded image
       * @param {*} [context] Context to invoke callback in
       * @param {Object} [crossOrigin] crossOrigin value to set image element to
       */
      loadImage: function(url, callback, context, crossOrigin) {
        if (!url) {
          callback && callback.call(context, url);
          return;
        }

        var img = fabric.util.createImage();

        /** @ignore */
        var onLoadCallback = function () {
          callback && callback.call(context, img);
          img = img.onload = img.onerror = null;
        };

        img.onload = onLoadCallback;
        /** @ignore */
        img.onerror = function() {
          fabric.log('Error loading ' + img.src);
          callback && callback.call(context, null, true);
          img = img.onload = img.onerror = null;
        };

        // data-urls appear to be buggy with crossOrigin
        // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
        // see https://code.google.com/p/chromium/issues/detail?id=315152
        //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
        if (url.indexOf('data') !== 0 && crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        // IE10 / IE11-Fix: SVG contents from data: URI
        // will only be available if the IMG is present
        // in the DOM (and visible)
        if (url.substring(0,14) === 'data:image/svg') {
          img.onload = null;
          fabric.util.loadImageInDom(img, onLoadCallback);
        }

        img.src = url;
      },

      /**
       * Attaches SVG image with data: URL to the dom
       * @memberOf fabric.util
       * @param {Object} img Image object with data:image/svg src
       * @param {Function} callback Callback; invoked with loaded image
       * @return {Object} DOM element (div containing the SVG image)
       */
      loadImageInDom: function(img, onLoadCallback) {
        var div = fabric.document.createElement('div');
        div.style.width = div.style.height = '1px';
        div.style.left = div.style.top = '-100%';
        div.style.position = 'absolute';
        div.appendChild(img);
        fabric.document.querySelector('body').appendChild(div);
        /**
         * Wrap in function to:
         *   1. Call existing callback
         *   2. Cleanup DOM
         */
        img.onload = function () {
          onLoadCallback();
          div.parentNode.removeChild(div);
          div = null;
        };
      },

      /**
       * Creates corresponding fabric instances from their object representations
       * @static
       * @memberOf fabric.util
       * @param {Array} objects Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * @param {String} namespace Namespace to get klass "Class" object from
       * @param {Function} reviver Method for further parsing of object elements,
       * called after each fabric object created.
       */
      enlivenObjects: function(objects, callback, namespace, reviver) {
        objects = objects || [];

        var enlivenedObjects = [],
            numLoadedObjects = 0,
            numTotalObjects = objects.length;

        function onLoaded() {
          if (++numLoadedObjects === numTotalObjects) {
            callback && callback(enlivenedObjects.filter(function(obj) {
              // filter out undefined objects (objects that gave error)
              return obj;
            }));
          }
        }

        if (!numTotalObjects) {
          callback && callback(enlivenedObjects);
          return;
        }

        objects.forEach(function (o, index) {
          // if sparse array
          if (!o || !o.type) {
            onLoaded();
            return;
          }
          var klass = fabric.util.getKlass(o.type, namespace);
          klass.fromObject(o, function (obj, error) {
            error || (enlivenedObjects[index] = obj);
            reviver && reviver(o, obj, error);
            onLoaded();
          });
        });
      },

      /**
       * Create and wait for loading of patterns
       * @static
       * @memberOf fabric.util
       * @param {Array} patterns Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * called after each fabric object created.
       */
      enlivenPatterns: function(patterns, callback) {
        patterns = patterns || [];

        function onLoaded() {
          if (++numLoadedPatterns === numPatterns) {
            callback && callback(enlivenedPatterns);
          }
        }

        var enlivenedPatterns = [],
            numLoadedPatterns = 0,
            numPatterns = patterns.length;

        if (!numPatterns) {
          callback && callback(enlivenedPatterns);
          return;
        }

        patterns.forEach(function (p, index) {
          if (p && p.source) {
            new fabric.Pattern(p, function(pattern) {
              enlivenedPatterns[index] = pattern;
              onLoaded();
            });
          }
          else {
            enlivenedPatterns[index] = p;
            onLoaded();
          }
        });
      },

      /**
       * Groups SVG elements (usually those retrieved from SVG document)
       * @static
       * @memberOf fabric.util
       * @param {Array} elements SVG elements to group
       * @param {Object} [options] Options object
       * @param {String} path Value to set sourcePath to
       * @return {fabric.Object|fabric.Group}
       */
      groupSVGElements: function(elements, options, path) {
        var object;
        if (elements && elements.length === 1) {
          return elements[0];
        }
        if (options) {
          if (options.width && options.height) {
            options.centerPoint = {
              x: options.width / 2,
              y: options.height / 2
            };
          }
          else {
            delete options.width;
            delete options.height;
          }
        }
        object = new fabric.Group(elements, options);
        if (typeof path !== 'undefined') {
          object.sourcePath = path;
        }
        return object;
      },

      /**
       * Populates an object with properties of another object
       * @static
       * @memberOf fabric.util
       * @param {Object} source Source object
       * @param {Object} destination Destination object
       * @return {Array} properties Properties names to include
       */
      populateWithProperties: function(source, destination, properties) {
        if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
          for (var i = 0, len = properties.length; i < len; i++) {
            if (properties[i] in source) {
              destination[properties[i]] = source[properties[i]];
            }
          }
        }
      },

      /**
       * Draws a dashed line between two points
       *
       * This method is used to draw dashed line around selection area.
       * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
       *
       * @param {CanvasRenderingContext2D} ctx context
       * @param {Number} x  start x coordinate
       * @param {Number} y start y coordinate
       * @param {Number} x2 end x coordinate
       * @param {Number} y2 end y coordinate
       * @param {Array} da dash array pattern
       */
      drawDashedLine: function(ctx, x, y, x2, y2, da) {
        var dx = x2 - x,
            dy = y2 - y,
            len = sqrt(dx * dx + dy * dy),
            rot = atan2(dy, dx),
            dc = da.length,
            di = 0,
            draw = true;

        ctx.save();
        ctx.translate(x, y);
        ctx.moveTo(0, 0);
        ctx.rotate(rot);

        x = 0;
        while (len > x) {
          x += da[di++ % dc];
          if (x > len) {
            x = len;
          }
          ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
          draw = !draw;
        }

        ctx.restore();
      },

      /**
       * Creates canvas element
       * @static
       * @memberOf fabric.util
       * @return {CanvasElement} initialized canvas element
       */
      createCanvasElement: function() {
        return fabric.document.createElement('canvas');
      },

      /**
       * Creates a canvas element that is a copy of another and is also painted
       * @param {CanvasElement} canvas to copy size and content of
       * @static
       * @memberOf fabric.util
       * @return {CanvasElement} initialized canvas element
       */
      copyCanvasElement: function(canvas) {
        var newCanvas = fabric.util.createCanvasElement();
        newCanvas.width = canvas.width;
        newCanvas.height = canvas.height;
        newCanvas.getContext('2d').drawImage(canvas, 0, 0);
        return newCanvas;
      },

      /**
       * since 2.6.0 moved from canvas instance to utility.
       * @param {CanvasElement} canvasEl to copy size and content of
       * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too
       * @param {Number} quality <= 1 and > 0
       * @static
       * @memberOf fabric.util
       * @return {String} data url
       */
      toDataURL: function(canvasEl, format, quality) {
        return canvasEl.toDataURL('image/' + format, quality);
      },

      /**
       * Creates image element (works on client and node)
       * @static
       * @memberOf fabric.util
       * @return {HTMLImageElement} HTML image element
       */
      createImage: function() {
        return fabric.document.createElement('img');
      },

      /**
       * @static
       * @memberOf fabric.util
       * @deprecated since 2.0.0
       * @param {fabric.Object} receiver Object implementing `clipTo` method
       * @param {CanvasRenderingContext2D} ctx Context to clip
       */
      clipContext: function(receiver, ctx) {
        ctx.save();
        ctx.beginPath();
        receiver.clipTo(ctx);
        ctx.clip();
      },

      /**
       * Multiply matrix A by matrix B to nest transformations
       * @static
       * @memberOf fabric.util
       * @param  {Array} a First transformMatrix
       * @param  {Array} b Second transformMatrix
       * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
       * @return {Array} The product of the two transform matrices
       */
      multiplyTransformMatrices: function(a, b, is2x2) {
        // Matrix multiply a * b
        return [
          a[0] * b[0] + a[2] * b[1],
          a[1] * b[0] + a[3] * b[1],
          a[0] * b[2] + a[2] * b[3],
          a[1] * b[2] + a[3] * b[3],
          is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
          is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
        ];
      },

      /**
       * Decomposes standard 2x3 matrix into transform components
       * @static
       * @memberOf fabric.util
       * @param  {Array} a transformMatrix
       * @return {Object} Components of transform
       */
      qrDecompose: function(a) {
        var angle = atan2(a[1], a[0]),
            denom = pow(a[0], 2) + pow(a[1], 2),
            scaleX = sqrt(denom),
            scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,
            skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
        return {
          angle: angle  / PiBy180,
          scaleX: scaleX,
          scaleY: scaleY,
          skewX: skewX / PiBy180,
          skewY: 0,
          translateX: a[4],
          translateY: a[5]
        };
      },

      /**
       * Returns a transform matrix starting from an object of the same kind of
       * the one returned from qrDecompose, useful also if you want to calculate some
       * transformations from an object that is not enlived yet
       * @static
       * @memberOf fabric.util
       * @param  {Object} options
       * @param  {Number} [options.angle] angle in degrees
       * @return {Number[]} transform matrix
       */
      calcRotateMatrix: function(options) {
        if (!options.angle) {
          return fabric.iMatrix.concat();
        }
        var theta = fabric.util.degreesToRadians(options.angle),
            cos = fabric.util.cos(theta),
            sin = fabric.util.sin(theta);
        return [cos, sin, -sin, cos, 0, 0];
      },

      /**
       * Returns a transform matrix starting from an object of the same kind of
       * the one returned from qrDecompose, useful also if you want to calculate some
       * transformations from an object that is not enlived yet.
       * is called DimensionsTransformMatrix because those properties are the one that influence
       * the size of the resulting box of the object.
       * @static
       * @memberOf fabric.util
       * @param  {Object} options
       * @param  {Number} [options.scaleX]
       * @param  {Number} [options.scaleY]
       * @param  {Boolean} [options.flipX]
       * @param  {Boolean} [options.flipY]
       * @param  {Number} [options.skewX]
       * @param  {Number} [options.skewX]
       * @return {Number[]} transform matrix
       */
      calcDimensionsMatrix: function(options) {
        var scaleX = typeof options.scaleX === 'undefined' ? 1 : options.scaleX,
            scaleY = typeof options.scaleY === 'undefined' ? 1 : options.scaleY,
            scaleMatrix = [
              options.flipX ? -scaleX : scaleX,
              0,
              0,
              options.flipY ? -scaleY : scaleY,
              0,
              0],
            multiply = fabric.util.multiplyTransformMatrices,
            degreesToRadians = fabric.util.degreesToRadians;
        if (options.skewX) {
          scaleMatrix = multiply(
            scaleMatrix,
            [1, 0, Math.tan(degreesToRadians(options.skewX)), 1],
            true);
        }
        if (options.skewY) {
          scaleMatrix = multiply(
            scaleMatrix,
            [1, Math.tan(degreesToRadians(options.skewY)), 0, 1],
            true);
        }
        return scaleMatrix;
      },

      /**
       * Returns a transform matrix starting from an object of the same kind of
       * the one returned from qrDecompose, useful also if you want to calculate some
       * transformations from an object that is not enlived yet
       * @static
       * @memberOf fabric.util
       * @param  {Object} options
       * @param  {Number} [options.angle]
       * @param  {Number} [options.scaleX]
       * @param  {Number} [options.scaleY]
       * @param  {Boolean} [options.flipX]
       * @param  {Boolean} [options.flipY]
       * @param  {Number} [options.skewX]
       * @param  {Number} [options.skewX]
       * @param  {Number} [options.translateX]
       * @param  {Number} [options.translateY]
       * @return {Number[]} transform matrix
       */
      composeMatrix: function(options) {
        var matrix = [1, 0, 0, 1, options.translateX || 0, options.translateY || 0],
            multiply = fabric.util.multiplyTransformMatrices;
        if (options.angle) {
          matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));
        }
        if (options.scaleX || options.scaleY || options.skewX || options.skewY || options.flipX || options.flipY) {
          matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));
        }
        return matrix;
      },

      /**
       * Returns a transform matrix that has the same effect of scaleX, scaleY and skewX.
       * Is deprecated for composeMatrix. Please do not use it.
       * @static
       * @deprecated since 3.4.0
       * @memberOf fabric.util
       * @param  {Number} scaleX
       * @param  {Number} scaleY
       * @param  {Number} skewX
       * @return {Number[]} transform matrix
       */
      customTransformMatrix: function(scaleX, scaleY, skewX) {
        return fabric.util.composeMatrix({ scaleX: scaleX, scaleY: scaleY, skewX: skewX });
      },

      /**
       * reset an object transform state to neutral. Top and left are not accounted for
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Object} target object to transform
       */
      resetObjectTransform: function (target) {
        target.scaleX = 1;
        target.scaleY = 1;
        target.skewX = 0;
        target.skewY = 0;
        target.flipX = false;
        target.flipY = false;
        target.rotate(0);
      },

      /**
       * Extract Object transform values
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Object} target object to read from
       * @return {Object} Components of transform
       */
      saveObjectTransform: function (target) {
        return {
          scaleX: target.scaleX,
          scaleY: target.scaleY,
          skewX: target.skewX,
          skewY: target.skewY,
          angle: target.angle,
          left: target.left,
          flipX: target.flipX,
          flipY: target.flipY,
          top: target.top
        };
      },

      /**
       * Returns string representation of function body
       * @param {Function} fn Function to get body of
       * @return {String} Function body
       */
      getFunctionBody: function(fn) {
        return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
      },

      /**
       * Returns true if context has transparent pixel
       * at specified location (taking tolerance into account)
       * @param {CanvasRenderingContext2D} ctx context
       * @param {Number} x x coordinate
       * @param {Number} y y coordinate
       * @param {Number} tolerance Tolerance
       */
      isTransparent: function(ctx, x, y, tolerance) {

        // If tolerance is > 0 adjust start coords to take into account.
        // If moves off Canvas fix to 0
        if (tolerance > 0) {
          if (x > tolerance) {
            x -= tolerance;
          }
          else {
            x = 0;
          }
          if (y > tolerance) {
            y -= tolerance;
          }
          else {
            y = 0;
          }
        }

        var _isTransparent = true, i, temp,
            imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
            l = imageData.data.length;

        // Split image data - for tolerance > 1, pixelDataSize = 4;
        for (i = 3; i < l; i += 4) {
          temp = imageData.data[i];
          _isTransparent = temp <= 0;
          if (_isTransparent === false) {
            break; // Stop if colour found
          }
        }

        imageData = null;

        return _isTransparent;
      },

      /**
       * Parse preserveAspectRatio attribute from element
       * @param {string} attribute to be parsed
       * @return {Object} an object containing align and meetOrSlice attribute
       */
      parsePreserveAspectRatioAttribute: function(attribute) {
        var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
            aspectRatioAttrs = attribute.split(' '), align;

        if (aspectRatioAttrs && aspectRatioAttrs.length) {
          meetOrSlice = aspectRatioAttrs.pop();
          if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
            align = meetOrSlice;
            meetOrSlice = 'meet';
          }
          else if (aspectRatioAttrs.length) {
            align = aspectRatioAttrs.pop();
          }
        }
        //divide align in alignX and alignY
        alignX = align !== 'none' ? align.slice(1, 4) : 'none';
        alignY = align !== 'none' ? align.slice(5, 8) : 'none';
        return {
          meetOrSlice: meetOrSlice,
          alignX: alignX,
          alignY: alignY
        };
      },

      /**
       * Clear char widths cache for the given font family or all the cache if no
       * fontFamily is specified.
       * Use it if you know you are loading fonts in a lazy way and you are not waiting
       * for custom fonts to load properly when adding text objects to the canvas.
       * If a text object is added when its own font is not loaded yet, you will get wrong
       * measurement and so wrong bounding boxes.
       * After the font cache is cleared, either change the textObject text content or call
       * initDimensions() to trigger a recalculation
       * @memberOf fabric.util
       * @param {String} [fontFamily] font family to clear
       */
      clearFabricFontCache: function(fontFamily) {
        fontFamily = (fontFamily || '').toLowerCase();
        if (!fontFamily) {
          fabric.charWidthsCache = { };
        }
        else if (fabric.charWidthsCache[fontFamily]) {
          delete fabric.charWidthsCache[fontFamily];
        }
      },

      /**
       * Given current aspect ratio, determines the max width and height that can
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Number} ar aspect ratio
       * @param {Number} maximumArea Maximum area you want to achieve
       * @return {Object.x} Limited dimensions by X
       * @return {Object.y} Limited dimensions by Y
       */
      limitDimsByArea: function(ar, maximumArea) {
        var roughWidth = Math.sqrt(maximumArea * ar),
            perfLimitSizeY = Math.floor(maximumArea / roughWidth);
        return { x: Math.floor(roughWidth), y: perfLimitSizeY };
      },

      capValue: function(min, value, max) {
        return Math.max(min, Math.min(value, max));
      },

      /**
       * Finds the scale for the object source to fit inside the object destination,
       * keeping aspect ratio intact.
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Object | fabric.Object} source
       * @param {Number} source.height natural unscaled height of the object
       * @param {Number} source.width natural unscaled width of the object
       * @param {Object | fabric.Object} destination
       * @param {Number} destination.height natural unscaled height of the object
       * @param {Number} destination.width natural unscaled width of the object
       * @return {Number} scale factor to apply to source to fit into destination
       */
      findScaleToFit: function(source, destination) {
        return Math.min(destination.width / source.width, destination.height / source.height);
      },

      /**
       * Finds the scale for the object source to cover entirely the object destination,
       * keeping aspect ratio intact.
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Object | fabric.Object} source
       * @param {Number} source.height natural unscaled height of the object
       * @param {Number} source.width natural unscaled width of the object
       * @param {Object | fabric.Object} destination
       * @param {Number} destination.height natural unscaled height of the object
       * @param {Number} destination.width natural unscaled width of the object
       * @return {Number} scale factor to apply to source to cover destination
       */
      findScaleToCover: function(source, destination) {
        return Math.max(destination.width / source.width, destination.height / source.height);
      },

      /**
       * given an array of 6 number returns something like `"matrix(...numbers)"`
       * @memberOf fabric.util
       * @param {Array} trasnform an array with 6 numbers
       * @return {String} transform matrix for svg
       * @return {Object.y} Limited dimensions by Y
       */
      matrixToSVG: function(transform) {
        return 'matrix(' + transform.map(function(value) {
          return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);
        }).join(' ') + ')';
      }
    };
  })( exports );


  (function() {

    var _join = Array.prototype.join;

    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
     * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
     * http://mozilla.org/MPL/2.0/
     */
    function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
      var argsString = _join.call(arguments);
      if (fabric.arcToSegmentsCache[argsString]) {
        return fabric.arcToSegmentsCache[argsString];
      }

      var PI = Math.PI, th = rotateX * PI / 180,
          sinTh = fabric.util.sin(th),
          cosTh = fabric.util.cos(th),
          fromX = 0, fromY = 0;

      rx = Math.abs(rx);
      ry = Math.abs(ry);

      var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
          py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
          rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
          pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
          root = 0;

      if (pl < 0) {
        var s = Math.sqrt(1 - pl / (rx2 * ry2));
        rx *= s;
        ry *= s;
      }
      else {
        root = (large === sweep ? -1.0 : 1.0) *
                Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
      }

      var cx = root * rx * py / ry,
          cy = -root * ry * px / rx,
          cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
          cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
          mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
          dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

      if (sweep === 0 && dtheta > 0) {
        dtheta -= 2 * PI;
      }
      else if (sweep === 1 && dtheta < 0) {
        dtheta += 2 * PI;
      }

      // Convert into cubic bezier segments <= 90deg
      var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
          result = [], mDelta = dtheta / segments,
          mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
          th3 = mTheta + mDelta;

      for (var i = 0; i < segments; i++) {
        result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
        fromX = result[i][4];
        fromY = result[i][5];
        mTheta = th3;
        th3 += mDelta;
      }
      fabric.arcToSegmentsCache[argsString] = result;
      return result;
    }

    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
      var costh2 = fabric.util.cos(th2),
          sinth2 = fabric.util.sin(th2),
          costh3 = fabric.util.cos(th3),
          sinth3 = fabric.util.sin(th3),
          toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
          toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
          cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
          cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
          cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
          cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

      return [
        cp1X, cp1Y,
        cp2X, cp2Y,
        toX, toY
      ];
    }

    /*
     * Private
     */
    function calcVectorAngle(ux, uy, vx, vy) {
      var ta = Math.atan2(uy, ux),
          tb = Math.atan2(vy, vx);
      if (tb >= ta) {
        return tb - ta;
      }
      else {
        return 2 * Math.PI - (ta - tb);
      }
    }

    /**
     * Draws arc
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} fx
     * @param {Number} fy
     * @param {Array} coords
     */
    fabric.util.drawArc = function(ctx, fx, fy, coords) {
      var rx = coords[0],
          ry = coords[1],
          rot = coords[2],
          large = coords[3],
          sweep = coords[4],
          tx = coords[5],
          ty = coords[6],
          segs = [[], [], [], []],
          segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

      for (var i = 0, len = segsNorm.length; i < len; i++) {
        segs[i][0] = segsNorm[i][0] + fx;
        segs[i][1] = segsNorm[i][1] + fy;
        segs[i][2] = segsNorm[i][2] + fx;
        segs[i][3] = segsNorm[i][3] + fy;
        segs[i][4] = segsNorm[i][4] + fx;
        segs[i][5] = segsNorm[i][5] + fy;
        ctx.bezierCurveTo.apply(ctx, segs[i]);
      }
    };

    /**
     * Calculate bounding box of a elliptic-arc
     * @param {Number} fx start point of arc
     * @param {Number} fy
     * @param {Number} rx horizontal radius
     * @param {Number} ry vertical radius
     * @param {Number} rot angle of horizontal axe
     * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
     * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
     * @param {Number} tx end point of arc
     * @param {Number} ty
     */
    fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

      var fromX = 0, fromY = 0, bound, bounds = [],
          segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

      for (var i = 0, len = segs.length; i < len; i++) {
        bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
        bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
        bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
        fromX = segs[i][4];
        fromY = segs[i][5];
      }
      return bounds;
    };

    /**
     * Calculate bounding box of a beziercurve
     * @param {Number} x0 starting point
     * @param {Number} y0
     * @param {Number} x1 first control point
     * @param {Number} y1
     * @param {Number} x2 secondo control point
     * @param {Number} y2
     * @param {Number} x3 end of beizer
     * @param {Number} y3
     */
    // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
      var argsString;
      if (fabric.cachesBoundsOfCurve) {
        argsString = _join.call(arguments);
        if (fabric.boundsOfCurveCache[argsString]) {
          return fabric.boundsOfCurveCache[argsString];
        }
      }

      var sqrt = Math.sqrt,
          min = Math.min, max = Math.max,
          abs = Math.abs, tvalues = [],
          bounds = [[], []],
          a, b, c, t, t1, t2, b2ac, sqrtb2ac;

      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;

      for (var i = 0; i < 2; ++i) {
        if (i > 0) {
          b = 6 * y0 - 12 * y1 + 6 * y2;
          a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
          c = 3 * y1 - 3 * y0;
        }

        if (abs(a) < 1e-12) {
          if (abs(b) < 1e-12) {
            continue;
          }
          t = -c / b;
          if (0 < t && t < 1) {
            tvalues.push(t);
          }
          continue;
        }
        b2ac = b * b - 4 * c * a;
        if (b2ac < 0) {
          continue;
        }
        sqrtb2ac = sqrt(b2ac);
        t1 = (-b + sqrtb2ac) / (2 * a);
        if (0 < t1 && t1 < 1) {
          tvalues.push(t1);
        }
        t2 = (-b - sqrtb2ac) / (2 * a);
        if (0 < t2 && t2 < 1) {
          tvalues.push(t2);
        }
      }

      var x, y, j = tvalues.length, jlen = j, mt;
      while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
        bounds[0][j] = x;

        y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
        bounds[1][j] = y;
      }

      bounds[0][jlen] = x0;
      bounds[1][jlen] = y0;
      bounds[0][jlen + 1] = x3;
      bounds[1][jlen + 1] = y3;
      var result = [
        {
          x: min.apply(null, bounds[0]),
          y: min.apply(null, bounds[1])
        },
        {
          x: max.apply(null, bounds[0]),
          y: max.apply(null, bounds[1])
        }
      ];
      if (fabric.cachesBoundsOfCurve) {
        fabric.boundsOfCurveCache[argsString] = result;
      }
      return result;
    }

    fabric.util.getBoundsOfCurve = getBoundsOfCurve;

  })();


  (function() {

    var slice = Array.prototype.slice;

    /**
     * Invokes method on all items in a given array
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} method Name of a method to invoke
     * @return {Array}
     */
    function invoke(array, method) {
      var args = slice.call(arguments, 2), result = [];
      for (var i = 0, len = array.length; i < len; i++) {
        result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
      }
      return result;
    }

    /**
     * Finds maximum value in array (not necessarily "first" one)
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} byProperty
     * @return {*}
     */
    function max(array, byProperty) {
      return find(array, byProperty, function(value1, value2) {
        return value1 >= value2;
      });
    }

    /**
     * Finds minimum value in array (not necessarily "first" one)
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} byProperty
     * @return {*}
     */
    function min(array, byProperty) {
      return find(array, byProperty, function(value1, value2) {
        return value1 < value2;
      });
    }

    /**
     * @private
     */
    function fill(array, value) {
      var k = array.length;
      while (k--) {
        array[k] = value;
      }
      return array;
    }

    /**
     * @private
     */
    function find(array, byProperty, condition) {
      if (!array || array.length === 0) {
        return;
      }

      var i = array.length - 1,
          result = byProperty ? array[i][byProperty] : array[i];
      if (byProperty) {
        while (i--) {
          if (condition(array[i][byProperty], result)) {
            result = array[i][byProperty];
          }
        }
      }
      else {
        while (i--) {
          if (condition(array[i], result)) {
            result = array[i];
          }
        }
      }
      return result;
    }

    /**
     * @namespace fabric.util.array
     */
    fabric.util.array = {
      fill: fill,
      invoke: invoke,
      min: min,
      max: max
    };

  })();


  (function() {
    /**
     * Copies all enumerable properties of one js object to another
     * this does not and cannot compete with generic utils.
     * Does not clone or extend fabric.Object subclasses.
     * This is mostly for internal use and has extra handling for fabricJS objects
     * it skips the canvas property in deep cloning.
     * @memberOf fabric.util.object
     * @param {Object} destination Where to copy to
     * @param {Object} source Where to copy from
     * @return {Object}
     */

    function extend(destination, source, deep) {
      // JScript DontEnum bug is not taken care of
      // the deep clone is for internal use, is not meant to avoid
      // javascript traps or cloning html element or self referenced objects.
      if (deep) {
        if (!fabric.isLikelyNode && source instanceof Element) {
          // avoid cloning deep images, canvases,
          destination = source;
        }
        else if (source instanceof Array) {
          destination = [];
          for (var i = 0, len = source.length; i < len; i++) {
            destination[i] = extend({ }, source[i], deep);
          }
        }
        else if (source && typeof source === 'object') {
          for (var property in source) {
            if (property === 'canvas') {
              destination[property] = extend({ }, source[property]);
            }
            else if (source.hasOwnProperty(property)) {
              destination[property] = extend({ }, source[property], deep);
            }
          }
        }
        else {
          // this sounds odd for an extend but is ok for recursive use
          destination = source;
        }
      }
      else {
        for (var property in source) {
          destination[property] = source[property];
        }
      }
      return destination;
    }

    /**
     * Creates an empty object and copies all enumerable properties of another object to it
     * @memberOf fabric.util.object
     * TODO: this function return an empty object if you try to clone null
     * @param {Object} object Object to clone
     * @return {Object}
     */
    function clone(object, deep) {
      return extend({ }, object, deep);
    }

    /** @namespace fabric.util.object */
    fabric.util.object = {
      extend: extend,
      clone: clone
    };
    fabric.util.object.extend(fabric.util, fabric.Observable);
  })();


  (function() {

    /**
     * Camelizes a string
     * @memberOf fabric.util.string
     * @param {String} string String to camelize
     * @return {String} Camelized version of a string
     */
    function camelize(string) {
      return string.replace(/-+(.)?/g, function(match, character) {
        return character ? character.toUpperCase() : '';
      });
    }

    /**
     * Capitalizes a string
     * @memberOf fabric.util.string
     * @param {String} string String to capitalize
     * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
     * and other letters stay untouched, if false first letter is capitalized
     * and other letters are converted to lowercase.
     * @return {String} Capitalized version of a string
     */
    function capitalize(string, firstLetterOnly) {
      return string.charAt(0).toUpperCase() +
        (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
    }

    /**
     * Escapes XML in a string
     * @memberOf fabric.util.string
     * @param {String} string String to escape
     * @return {String} Escaped version of a string
     */
    function escapeXml(string) {
      return string.replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    /**
     * Divide a string in the user perceived single units
     * @memberOf fabric.util.string
     * @param {String} textstring String to escape
     * @return {Array} array containing the graphemes
     */
    function graphemeSplit(textstring) {
      var i = 0, chr, graphemes = [];
      for (i = 0, chr; i < textstring.length; i++) {
        if ((chr = getWholeChar(textstring, i)) === false) {
          continue;
        }
        graphemes.push(chr);
      }
      return graphemes;
    }

    // taken from mdn in the charAt doc page.
    function getWholeChar(str, i) {
      var code = str.charCodeAt(i);

      if (isNaN(code)) {
        return ''; // Position not found
      }
      if (code < 0xD800 || code > 0xDFFF) {
        return str.charAt(i);
      }

      // High surrogate (could change last hex to 0xDB7F to treat high private
      // surrogates as single characters)
      if (0xD800 <= code && code <= 0xDBFF) {
        if (str.length <= (i + 1)) {
          throw 'High surrogate without following low surrogate';
        }
        var next = str.charCodeAt(i + 1);
        if (0xDC00 > next || next > 0xDFFF) {
          throw 'High surrogate without following low surrogate';
        }
        return str.charAt(i) + str.charAt(i + 1);
      }
      // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
      if (i === 0) {
        throw 'Low surrogate without preceding high surrogate';
      }
      var prev = str.charCodeAt(i - 1);

      // (could change last hex to 0xDB7F to treat high private
      // surrogates as single characters)
      if (0xD800 > prev || prev > 0xDBFF) {
        throw 'Low surrogate without preceding high surrogate';
      }
      // We can pass over low surrogates now as the second component
      // in a pair which we have already processed
      return false;
    }


    /**
     * String utilities
     * @namespace fabric.util.string
     */
    fabric.util.string = {
      camelize: camelize,
      capitalize: capitalize,
      escapeXml: escapeXml,
      graphemeSplit: graphemeSplit
    };
  })();


  (function() {

    var slice = Array.prototype.slice, emptyFunction = function() { },

        IS_DONTENUM_BUGGY = (function() {
          for (var p in { toString: 1 }) {
            if (p === 'toString') {
              return false;
            }
          }
          return true;
        })(),

        /** @ignore */
        addMethods = function(klass, source, parent) {
          for (var property in source) {

            if (property in klass.prototype &&
                typeof klass.prototype[property] === 'function' &&
                (source[property] + '').indexOf('callSuper') > -1) {

              klass.prototype[property] = (function(property) {
                return function() {

                  var superclass = this.constructor.superclass;
                  this.constructor.superclass = parent;
                  var returnValue = source[property].apply(this, arguments);
                  this.constructor.superclass = superclass;

                  if (property !== 'initialize') {
                    return returnValue;
                  }
                };
              })(property);
            }
            else {
              klass.prototype[property] = source[property];
            }

            if (IS_DONTENUM_BUGGY) {
              if (source.toString !== Object.prototype.toString) {
                klass.prototype.toString = source.toString;
              }
              if (source.valueOf !== Object.prototype.valueOf) {
                klass.prototype.valueOf = source.valueOf;
              }
            }
          }
        };

    function Subclass() { }

    function callSuper(methodName) {
      var parentMethod = null,
          _this = this;

      // climb prototype chain to find method not equal to callee's method
      while (_this.constructor.superclass) {
        var superClassMethod = _this.constructor.superclass.prototype[methodName];
        if (_this[methodName] !== superClassMethod) {
          parentMethod = superClassMethod;
          break;
        }
        // eslint-disable-next-line
        _this = _this.constructor.superclass.prototype;
      }

      if (!parentMethod) {
        return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
      }

      return (arguments.length > 1)
        ? parentMethod.apply(this, slice.call(arguments, 1))
        : parentMethod.call(this);
    }

    /**
     * Helper for creation of "classes".
     * @memberOf fabric.util
     * @param {Function} [parent] optional "Class" to inherit from
     * @param {Object} [properties] Properties shared by all instances of this class
     *                  (be careful modifying objects defined here as this would affect all instances)
     */
    function createClass() {
      var parent = null,
          properties = slice.call(arguments, 0);

      if (typeof properties[0] === 'function') {
        parent = properties.shift();
      }
      function klass() {
        this.initialize.apply(this, arguments);
      }

      klass.superclass = parent;
      klass.subclasses = [];

      if (parent) {
        Subclass.prototype = parent.prototype;
        klass.prototype = new Subclass();
        parent.subclasses.push(klass);
      }
      for (var i = 0, length = properties.length; i < length; i++) {
        addMethods(klass, properties[i], parent);
      }
      if (!klass.prototype.initialize) {
        klass.prototype.initialize = emptyFunction;
      }
      klass.prototype.constructor = klass;
      klass.prototype.callSuper = callSuper;
      return klass;
    }

    fabric.util.createClass = createClass;
  })();


  (function () {
    // since ie10 or ie9 can use addEventListener but they do not support options, i need to check
    var couldUseAttachEvent = !!fabric.document.createElement('div').attachEvent;
    /**
     * Adds an event listener to an element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {String} eventName
     * @param {Function} handler
     */
    fabric.util.addListener = function(element, eventName, handler, options) {
      element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
    };

    /**
     * Removes an event listener from an element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {String} eventName
     * @param {Function} handler
     */
    fabric.util.removeListener = function(element, eventName, handler, options) {
      element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
    };

    function getTouchInfo(event) {
      var touchProp = event.changedTouches;
      if (touchProp && touchProp[0]) {
        return touchProp[0];
      }
      return event;
    }

    fabric.util.getPointer = function(event) {
      var element = event.target,
          scroll = fabric.util.getScrollLeftTop(element),
          _evt = getTouchInfo(event);
      return {
        x: _evt.clientX + scroll.left,
        y: _evt.clientY + scroll.top
      };
    };
  })();


  (function () {

    /**
     * Cross-browser wrapper for setting element's style
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {Object} styles
     * @return {HTMLElement} Element that was passed as a first argument
     */
    function setStyle(element, styles) {
      var elementStyle = element.style;
      if (!elementStyle) {
        return element;
      }
      if (typeof styles === 'string') {
        element.style.cssText += ';' + styles;
        return styles.indexOf('opacity') > -1
          ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
          : element;
      }
      for (var property in styles) {
        if (property === 'opacity') {
          setOpacity(element, styles[property]);
        }
        else {
          var normalizedProperty = (property === 'float' || property === 'cssFloat')
            ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
            : property;
          elementStyle[normalizedProperty] = styles[property];
        }
      }
      return element;
    }

    var parseEl = fabric.document.createElement('div'),
        supportsOpacity = typeof parseEl.style.opacity === 'string',
        supportsFilters = typeof parseEl.style.filter === 'string',
        reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

        /** @ignore */
        setOpacity = function (element) { return element; };

    if (supportsOpacity) {
      /** @ignore */
      setOpacity = function(element, value) {
        element.style.opacity = value;
        return element;
      };
    }
    else if (supportsFilters) {
      /** @ignore */
      setOpacity = function(element, value) {
        var es = element.style;
        if (element.currentStyle && !element.currentStyle.hasLayout) {
          es.zoom = 1;
        }
        if (reOpacity.test(es.filter)) {
          value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
          es.filter = es.filter.replace(reOpacity, value);
        }
        else {
          es.filter += ' alpha(opacity=' + (value * 100) + ')';
        }
        return element;
      };
    }

    fabric.util.setStyle = setStyle;

  })();


  (function() {

    var _slice = Array.prototype.slice;

    /**
     * Takes id and returns an element with that id (if one exists in a document)
     * @memberOf fabric.util
     * @param {String|HTMLElement} id
     * @return {HTMLElement|null}
     */
    function getById(id) {
      return typeof id === 'string' ? fabric.document.getElementById(id) : id;
    }

    var sliceCanConvertNodelists,
        /**
         * Converts an array-like object (e.g. arguments or NodeList) to an array
         * @memberOf fabric.util
         * @param {Object} arrayLike
         * @return {Array}
         */
        toArray = function(arrayLike) {
          return _slice.call(arrayLike, 0);
        };

    try {
      sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
    }
    catch (err) { }

    if (!sliceCanConvertNodelists) {
      toArray = function(arrayLike) {
        var arr = new Array(arrayLike.length), i = arrayLike.length;
        while (i--) {
          arr[i] = arrayLike[i];
        }
        return arr;
      };
    }

    /**
     * Creates specified element with specified attributes
     * @memberOf fabric.util
     * @param {String} tagName Type of an element to create
     * @param {Object} [attributes] Attributes to set on an element
     * @return {HTMLElement} Newly created element
     */
    function makeElement(tagName, attributes) {
      var el = fabric.document.createElement(tagName);
      for (var prop in attributes) {
        if (prop === 'class') {
          el.className = attributes[prop];
        }
        else if (prop === 'for') {
          el.htmlFor = attributes[prop];
        }
        else {
          el.setAttribute(prop, attributes[prop]);
        }
      }
      return el;
    }

    /**
     * Adds class to an element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to add class to
     * @param {String} className Class to add to an element
     */
    function addClass(element, className) {
      if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
        element.className += (element.className ? ' ' : '') + className;
      }
    }

    /**
     * Wraps element with another element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to wrap
     * @param {HTMLElement|String} wrapper Element to wrap with
     * @param {Object} [attributes] Attributes to set on a wrapper
     * @return {HTMLElement} wrapper
     */
    function wrapElement(element, wrapper, attributes) {
      if (typeof wrapper === 'string') {
        wrapper = makeElement(wrapper, attributes);
      }
      if (element.parentNode) {
        element.parentNode.replaceChild(wrapper, element);
      }
      wrapper.appendChild(element);
      return wrapper;
    }

    /**
     * Returns element scroll offsets
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to operate on
     * @return {Object} Object with left/top values
     */
    function getScrollLeftTop(element) {

      var left = 0,
          top = 0,
          docElement = fabric.document.documentElement,
          body = fabric.document.body || {
            scrollLeft: 0, scrollTop: 0
          };

      // While loop checks (and then sets element to) .parentNode OR .host
      //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
      //  but the .parentNode of a root ShadowDOM node will always be null, instead
      //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
      while (element && (element.parentNode || element.host)) {

        // Set element to element parent, or 'host' in case of ShadowDOM
        element = element.parentNode || element.host;

        if (element === fabric.document) {
          left = body.scrollLeft || docElement.scrollLeft || 0;
          top = body.scrollTop ||  docElement.scrollTop || 0;
        }
        else {
          left += element.scrollLeft || 0;
          top += element.scrollTop || 0;
        }

        if (element.nodeType === 1 && element.style.position === 'fixed') {
          break;
        }
      }

      return { left: left, top: top };
    }

    /**
     * Returns offset for a given element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to get offset for
     * @return {Object} Object with "left" and "top" properties
     */
    function getElementOffset(element) {
      var docElem,
          doc = element && element.ownerDocument,
          box = { left: 0, top: 0 },
          offset = { left: 0, top: 0 },
          scrollLeftTop,
          offsetAttributes = {
            borderLeftWidth: 'left',
            borderTopWidth:  'top',
            paddingLeft:     'left',
            paddingTop:      'top'
          };

      if (!doc) {
        return offset;
      }

      for (var attr in offsetAttributes) {
        offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
      }

      docElem = doc.documentElement;
      if ( typeof element.getBoundingClientRect !== 'undefined' ) {
        box = element.getBoundingClientRect();
      }

      scrollLeftTop = getScrollLeftTop(element);

      return {
        left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
        top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
      };
    }

    /**
     * Returns style attribute value of a given element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to get style attribute for
     * @param {String} attr Style attribute to get for element
     * @return {String} Style attribute value of the given element.
     */
    var getElementStyle;
    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
      getElementStyle = function(element, attr) {
        var style = fabric.document.defaultView.getComputedStyle(element, null);
        return style ? style[attr] : undefined;
      };
    }
    else {
      getElementStyle = function(element, attr) {
        var value = element.style[attr];
        if (!value && element.currentStyle) {
          value = element.currentStyle[attr];
        }
        return value;
      };
    }

    (function () {
      var style = fabric.document.documentElement.style,
          selectProp = 'userSelect' in style
            ? 'userSelect'
            : 'MozUserSelect' in style
              ? 'MozUserSelect'
              : 'WebkitUserSelect' in style
                ? 'WebkitUserSelect'
                : 'KhtmlUserSelect' in style
                  ? 'KhtmlUserSelect'
                  : '';

      /**
       * Makes element unselectable
       * @memberOf fabric.util
       * @param {HTMLElement} element Element to make unselectable
       * @return {HTMLElement} Element that was passed in
       */
      function makeElementUnselectable(element) {
        if (typeof element.onselectstart !== 'undefined') {
          element.onselectstart = fabric.util.falseFunction;
        }
        if (selectProp) {
          element.style[selectProp] = 'none';
        }
        else if (typeof element.unselectable === 'string') {
          element.unselectable = 'on';
        }
        return element;
      }

      /**
       * Makes element selectable
       * @memberOf fabric.util
       * @param {HTMLElement} element Element to make selectable
       * @return {HTMLElement} Element that was passed in
       */
      function makeElementSelectable(element) {
        if (typeof element.onselectstart !== 'undefined') {
          element.onselectstart = null;
        }
        if (selectProp) {
          element.style[selectProp] = '';
        }
        else if (typeof element.unselectable === 'string') {
          element.unselectable = '';
        }
        return element;
      }

      fabric.util.makeElementUnselectable = makeElementUnselectable;
      fabric.util.makeElementSelectable = makeElementSelectable;
    })();

    (function() {

      /**
       * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
       * @memberOf fabric.util
       * @param {String} url URL of a script to load
       * @param {Function} callback Callback to execute when script is finished loading
       */
      function getScript(url, callback) {
        var headEl = fabric.document.getElementsByTagName('head')[0],
            scriptEl = fabric.document.createElement('script'),
            loading = true;

        /** @ignore */
        scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
          if (loading) {
            if (typeof this.readyState === 'string' &&
                this.readyState !== 'loaded' &&
                this.readyState !== 'complete') {
              return;
            }
            loading = false;
            callback(e || fabric.window.event);
            scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
          }
        };
        scriptEl.src = url;
        headEl.appendChild(scriptEl);
        // causes issue in Opera
        // headEl.removeChild(scriptEl);
      }

      fabric.util.getScript = getScript;
    })();

    function getNodeCanvas(element) {
      var impl = fabric.jsdomImplForWrapper(element);
      return impl._canvas || impl._image;
    }
    function cleanUpJsdomNode(element) {
      if (!fabric.isLikelyNode) {
        return;
      }
      var impl = fabric.jsdomImplForWrapper(element);
      if (impl) {
        impl._image = null;
        impl._canvas = null;
        // unsure if necessary
        impl._currentSrc = null;
        impl._attributes = null;
        impl._classList = null;
      }
    }

    fabric.util.getById = getById;
    fabric.util.toArray = toArray;
    fabric.util.makeElement = makeElement;
    fabric.util.addClass = addClass;
    fabric.util.wrapElement = wrapElement;
    fabric.util.getScrollLeftTop = getScrollLeftTop;
    fabric.util.getElementOffset = getElementOffset;
    fabric.util.getElementStyle = getElementStyle;
    fabric.util.getNodeCanvas = getNodeCanvas;
    fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;

  })();


  (function() {

    function addParamToUrl(url, param) {
      return url + (/\?/.test(url) ? '&' : '?') + param;
    }

    function emptyFn() { }

    /**
     * Cross-browser abstraction for sending XMLHttpRequest
     * @memberOf fabric.util
     * @param {String} url URL to send XMLHttpRequest to
     * @param {Object} [options] Options object
     * @param {String} [options.method="GET"]
     * @param {String} [options.parameters] parameters to append to url in GET or in body
     * @param {String} [options.body] body to send with POST or PUT request
     * @param {Function} options.onComplete Callback to invoke when request is completed
     * @return {XMLHttpRequest} request
     */
    function request(url, options) {
      options || (options = { });

      var method = options.method ? options.method.toUpperCase() : 'GET',
          onComplete = options.onComplete || function() { },
          xhr = new fabric.window.XMLHttpRequest(),
          body = options.body || options.parameters;

      /** @ignore */
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          onComplete(xhr);
          xhr.onreadystatechange = emptyFn;
        }
      };

      if (method === 'GET') {
        body = null;
        if (typeof options.parameters === 'string') {
          url = addParamToUrl(url, options.parameters);
        }
      }

      xhr.open(method, url, true);

      if (method === 'POST' || method === 'PUT') {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      }

      xhr.send(body);
      return xhr;
    }

    fabric.util.request = request;
  })();


  /**
   * Wrapper around `console.log` (when available)
   * @param {*} [values] Values to log
   */
  fabric.log = console.log;

  /**
   * Wrapper around `console.warn` (when available)
   * @param {*} [values] Values to log as a warning
   */
  fabric.warn = console.warn;


  (function() {

    function noop() {
      return false;
    }

    function defaultEasing(t, b, c, d) {
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    }

    /**
     * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
     * @memberOf fabric.util
     * @param {Object} [options] Animation options
     * @param {Function} [options.onChange] Callback; invoked on every value change
     * @param {Function} [options.onComplete] Callback; invoked when value change is completed
     * @param {Number} [options.startValue=0] Starting value
     * @param {Number} [options.endValue=100] Ending value
     * @param {Number} [options.byValue=100] Value to modify the property by
     * @param {Function} [options.easing] Easing function
     * @param {Number} [options.duration=500] Duration of change (in ms)
     * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
     */
    function animate(options) {

      requestAnimFrame(function(timestamp) {
        options || (options = { });

        var start = timestamp || +new Date(),
            duration = options.duration || 500,
            finish = start + duration, time,
            onChange = options.onChange || noop,
            abort = options.abort || noop,
            onComplete = options.onComplete || noop,
            easing = options.easing || defaultEasing,
            startValue = 'startValue' in options ? options.startValue : 0,
            endValue = 'endValue' in options ? options.endValue : 100,
            byValue = options.byValue || endValue - startValue;

        options.onStart && options.onStart();

        (function tick(ticktime) {
          // TODO: move abort call after calculation
          // and pass (current,valuePerc, timePerc) as arguments
          time = ticktime || +new Date();
          var currentTime = time > finish ? duration : (time - start),
              timePerc = currentTime / duration,
              current = easing(currentTime, startValue, byValue, duration),
              valuePerc = Math.abs((current - startValue) / byValue);
          if (abort()) {
            onComplete(endValue, 1, 1);
            return;
          }
          if (time > finish) {
            onChange(endValue, 1, 1);
            onComplete(endValue, 1, 1);
            return;
          }
          else {
            onChange(current, valuePerc, timePerc);
            requestAnimFrame(tick);
          }
        })(start);
      });
    }

    var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                            fabric.window.webkitRequestAnimationFrame ||
                            fabric.window.mozRequestAnimationFrame    ||
                            fabric.window.oRequestAnimationFrame      ||
                            fabric.window.msRequestAnimationFrame     ||
                            function(callback) {
                              return fabric.window.setTimeout(callback, 1000 / 60);
                            };

    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

    /**
     * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
     * @memberOf fabric.util
     * @param {Function} callback Callback to invoke
     * @param {DOMElement} element optional Element to associate with animation
     */
    function requestAnimFrame() {
      return _requestAnimFrame.apply(fabric.window, arguments);
    }

    function cancelAnimFrame() {
      return _cancelAnimFrame.apply(fabric.window, arguments);
    }

    fabric.util.animate = animate;
    fabric.util.requestAnimFrame = requestAnimFrame;
    fabric.util.cancelAnimFrame = cancelAnimFrame;
  })();


  (function() {
    // Calculate an in-between color. Returns a "rgba()" string.
    // Credit: Edwin Martin <edwin@bitstorm.org>
    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
    function calculateColor(begin, end, pos) {
      var color = 'rgba('
          + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
          + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
          + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

      color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
      color += ')';
      return color;
    }

    /**
     * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
     * @memberOf fabric.util
     * @param {String} fromColor The starting color in hex or rgb(a) format.
     * @param {String} toColor The starting color in hex or rgb(a) format.
     * @param {Number} [duration] Duration of change (in ms).
     * @param {Object} [options] Animation options
     * @param {Function} [options.onChange] Callback; invoked on every value change
     * @param {Function} [options.onComplete] Callback; invoked when value change is completed
     * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
     * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
     */
    function animateColor(fromColor, toColor, duration, options) {
      var startColor = new fabric.Color(fromColor).getSource(),
          endColor = new fabric.Color(toColor).getSource();

      options = options || {};

      fabric.util.animate(fabric.util.object.extend(options, {
        duration: duration || 500,
        startValue: startColor,
        endValue: endColor,
        byValue: endColor,
        easing: function (currentTime, startValue, byValue, duration) {
          var posValue = options.colorEasing
            ? options.colorEasing(currentTime, duration)
            : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
          return calculateColor(startValue, byValue, posValue);
        }
      }));
    }

    fabric.util.animateColor = animateColor;

  })();


  (function() {

    function normalize(a, c, p, s) {
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        //handle the 0/0 case:
        if (c === 0 && a === 0) {
          s = p / (2 * Math.PI) * Math.asin(1);
        }
        else {
          s = p / (2 * Math.PI) * Math.asin(c / a);
        }
      }
      return { a: a, c: c, p: p, s: s };
    }

    function elastic(opts, t, d) {
      return opts.a *
        Math.pow(2, 10 * (t -= 1)) *
        Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
    }

    /**
     * Cubic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutCubic(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    }

    /**
     * Cubic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutCubic(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t + 2) + b;
    }

    /**
     * Quartic easing in
     * @memberOf fabric.util.ease
     */
    function easeInQuart(t, b, c, d) {
      return c * (t /= d) * t * t * t + b;
    }

    /**
     * Quartic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutQuart(t, b, c, d) {
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    }

    /**
     * Quartic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutQuart(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t * t + b;
      }
      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    }

    /**
     * Quintic easing in
     * @memberOf fabric.util.ease
     */
    function easeInQuint(t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    }

    /**
     * Quintic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutQuint(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }

    /**
     * Quintic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutQuint(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    }

    /**
     * Sinusoidal easing in
     * @memberOf fabric.util.ease
     */
    function easeInSine(t, b, c, d) {
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    }

    /**
     * Sinusoidal easing out
     * @memberOf fabric.util.ease
     */
    function easeOutSine(t, b, c, d) {
      return c * Math.sin(t / d * (Math.PI / 2)) + b;
    }

    /**
     * Sinusoidal easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutSine(t, b, c, d) {
      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    }

    /**
     * Exponential easing in
     * @memberOf fabric.util.ease
     */
    function easeInExpo(t, b, c, d) {
      return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    }

    /**
     * Exponential easing out
     * @memberOf fabric.util.ease
     */
    function easeOutExpo(t, b, c, d) {
      return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    }

    /**
     * Exponential easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutExpo(t, b, c, d) {
      if (t === 0) {
        return b;
      }
      if (t === d) {
        return b + c;
      }
      t /= d / 2;
      if (t < 1) {
        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
      }
      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
    }

    /**
     * Circular easing in
     * @memberOf fabric.util.ease
     */
    function easeInCirc(t, b, c, d) {
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    }

    /**
     * Circular easing out
     * @memberOf fabric.util.ease
     */
    function easeOutCirc(t, b, c, d) {
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    }

    /**
     * Circular easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutCirc(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
      }
      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    }

    /**
     * Elastic easing in
     * @memberOf fabric.util.ease
     */
    function easeInElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d;
      if (t === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      var opts = normalize(a, c, p, s);
      return -elastic(opts, t, d) + b;
    }

    /**
     * Elastic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d;
      if (t === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      var opts = normalize(a, c, p, s);
      return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
    }

    /**
     * Elastic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d / 2;
      if (t === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      var opts = normalize(a, c, p, s);
      if (t < 1) {
        return -0.5 * elastic(opts, t, d) + b;
      }
      return opts.a * Math.pow(2, -10 * (t -= 1)) *
        Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
    }

    /**
     * Backwards easing in
     * @memberOf fabric.util.ease
     */
    function easeInBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    }

    /**
     * Backwards easing out
     * @memberOf fabric.util.ease
     */
    function easeOutBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    }

    /**
     * Backwards easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      t /= d / 2;
      if (t < 1) {
        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    }

    /**
     * Bouncing easing in
     * @memberOf fabric.util.ease
     */
    function easeInBounce(t, b, c, d) {
      return c - easeOutBounce (d - t, 0, c, d) + b;
    }

    /**
     * Bouncing easing out
     * @memberOf fabric.util.ease
     */
    function easeOutBounce(t, b, c, d) {
      if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
      }
      else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
      }
      else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
      }
      else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
      }
    }

    /**
     * Bouncing easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutBounce(t, b, c, d) {
      if (t < d / 2) {
        return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
      }
      return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }

    /**
     * Easing functions
     * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
     * @namespace fabric.util.ease
     */
    fabric.util.ease = {

      /**
       * Quadratic easing in
       * @memberOf fabric.util.ease
       */
      easeInQuad: function(t, b, c, d) {
        return c * (t /= d) * t + b;
      },

      /**
       * Quadratic easing out
       * @memberOf fabric.util.ease
       */
      easeOutQuad: function(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },

      /**
       * Quadratic easing in and out
       * @memberOf fabric.util.ease
       */
      easeInOutQuad: function(t, b, c, d) {
        t /= (d / 2);
        if (t < 1) {
          return c / 2 * t * t + b;
        }
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
      },

      /**
       * Cubic easing in
       * @memberOf fabric.util.ease
       */
      easeInCubic: function(t, b, c, d) {
        return c * (t /= d) * t * t + b;
      },

      easeOutCubic: easeOutCubic,
      easeInOutCubic: easeInOutCubic,
      easeInQuart: easeInQuart,
      easeOutQuart: easeOutQuart,
      easeInOutQuart: easeInOutQuart,
      easeInQuint: easeInQuint,
      easeOutQuint: easeOutQuint,
      easeInOutQuint: easeInOutQuint,
      easeInSine: easeInSine,
      easeOutSine: easeOutSine,
      easeInOutSine: easeInOutSine,
      easeInExpo: easeInExpo,
      easeOutExpo: easeOutExpo,
      easeInOutExpo: easeInOutExpo,
      easeInCirc: easeInCirc,
      easeOutCirc: easeOutCirc,
      easeInOutCirc: easeInOutCirc,
      easeInElastic: easeInElastic,
      easeOutElastic: easeOutElastic,
      easeInOutElastic: easeInOutElastic,
      easeInBack: easeInBack,
      easeOutBack: easeOutBack,
      easeInOutBack: easeInOutBack,
      easeInBounce: easeInBounce,
      easeOutBounce: easeOutBounce,
      easeInOutBounce: easeInOutBounce
    };

  })();


  (function(global) {

    /**
     * @name fabric
     * @namespace
     */

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        toFixed = fabric.util.toFixed,
        parseUnit = fabric.util.parseUnit,
        multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

        svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
          'image', 'text'],
        svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
        svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
        svgValidParents = ['symbol', 'g', 'a', 'svg', 'clipPath', 'defs'],

        attributesMap = {
          cx:                   'left',
          x:                    'left',
          r:                    'radius',
          cy:                   'top',
          y:                    'top',
          display:              'visible',
          visibility:           'visible',
          transform:            'transformMatrix',
          'fill-opacity':       'fillOpacity',
          'fill-rule':          'fillRule',
          'font-family':        'fontFamily',
          'font-size':          'fontSize',
          'font-style':         'fontStyle',
          'font-weight':        'fontWeight',
          'letter-spacing':     'charSpacing',
          'paint-order':        'paintFirst',
          'stroke-dasharray':   'strokeDashArray',
          'stroke-dashoffset':  'strokeDashOffset',
          'stroke-linecap':     'strokeLineCap',
          'stroke-linejoin':    'strokeLineJoin',
          'stroke-miterlimit':  'strokeMiterLimit',
          'stroke-opacity':     'strokeOpacity',
          'stroke-width':       'strokeWidth',
          'text-decoration':    'textDecoration',
          'text-anchor':        'textAnchor',
          opacity:              'opacity',
          'clip-path':          'clipPath',
          'clip-rule':          'clipRule',
          'vector-effect':      'strokeUniform'
        },

        colorAttributes = {
          stroke: 'strokeOpacity',
          fill:   'fillOpacity'
        },

        fSize = 'font-size', cPath = 'clip-path';

    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);

    fabric.cssRules = { };
    fabric.gradientDefs = { };
    fabric.clipPaths = { };

    function normalizeAttr(attr) {
      // transform attribute names
      if (attr in attributesMap) {
        return attributesMap[attr];
      }
      return attr;
    }

    function normalizeValue(attr, value, parentAttributes, fontSize) {
      var isArray = Object.prototype.toString.call(value) === '[object Array]',
          parsed;

      if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
        value = '';
      }
      else if (attr === 'vector-effect') {
        value = value === 'non-scaling-stroke';
      }
      else if (attr === 'strokeDashArray') {
        if (value === 'none') {
          value = null;
        }
        else {
          value = value.replace(/,/g, ' ').split(/\s+/).map(parseFloat);
        }
      }
      else if (attr === 'transformMatrix') {
        if (parentAttributes && parentAttributes.transformMatrix) {
          value = multiplyTransformMatrices(
            parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
        }
        else {
          value = fabric.parseTransformAttribute(value);
        }
      }
      else if (attr === 'visible') {
        value = value !== 'none' && value !== 'hidden';
        // display=none on parent element always takes precedence over child element
        if (parentAttributes && parentAttributes.visible === false) {
          value = false;
        }
      }
      else if (attr === 'opacity') {
        value = parseFloat(value);
        if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
          value *= parentAttributes.opacity;
        }
      }
      else if (attr === 'textAnchor' /* text-anchor */) {
        value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
      }
      else if (attr === 'charSpacing') {
        // parseUnit returns px and we convert it to em
        parsed = parseUnit(value, fontSize) / fontSize * 1000;
      }
      else if (attr === 'paintFirst') {
        var fillIndex = value.indexOf('fill');
        var strokeIndex = value.indexOf('stroke');
        var value = 'fill';
        if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
          value = 'stroke';
        }
        else if (fillIndex === -1 && strokeIndex > -1) {
          value = 'stroke';
        }
      }
      else if (attr === 'href' || attr === 'xlink:href') {
        return value;
      }
      else {
        parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
      }

      return (!isArray && isNaN(parsed) ? value : parsed);
    }

    /**
      * @private
      */
    function getSvgRegex(arr) {
      return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
    }

    /**
     * @private
     * @param {Object} attributes Array of attributes to parse
     */
    function _setStrokeFillOpacity(attributes) {
      for (var attr in colorAttributes) {

        if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
          continue;
        }

        if (typeof attributes[attr] === 'undefined') {
          if (!fabric.Object.prototype[attr]) {
            continue;
          }
          attributes[attr] = fabric.Object.prototype[attr];
        }

        if (attributes[attr].indexOf('url(') === 0) {
          continue;
        }

        var color = new fabric.Color(attributes[attr]);
        attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
      }
      return attributes;
    }

    /**
     * @private
     */
    function _getMultipleNodes(doc, nodeNames) {
      var nodeName, nodeArray = [], nodeList, i, len;
      for (i = 0, len = nodeNames.length; i < len; i++) {
        nodeName = nodeNames[i];
        nodeList = doc.getElementsByTagName(nodeName);
        nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
      }
      return nodeArray;
    }

    /**
     * Parses "transform" attribute, returning an array of values
     * @static
     * @function
     * @memberOf fabric
     * @param {String} attributeValue String containing attribute value
     * @return {Array} Array of 6 elements representing transformation matrix
     */
    fabric.parseTransformAttribute = (function() {
      function rotateMatrix(matrix, args) {
        var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
            x = 0, y = 0;
        if (args.length === 3) {
          x = args[1];
          y = args[2];
        }

        matrix[0] = cos;
        matrix[1] = sin;
        matrix[2] = -sin;
        matrix[3] = cos;
        matrix[4] = x - (cos * x - sin * y);
        matrix[5] = y - (sin * x + cos * y);
      }

      function scaleMatrix(matrix, args) {
        var multiplierX = args[0],
            multiplierY = (args.length === 2) ? args[1] : args[0];

        matrix[0] = multiplierX;
        matrix[3] = multiplierY;
      }

      function skewMatrix(matrix, args, pos) {
        matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
      }

      function translateMatrix(matrix, args) {
        matrix[4] = args[0];
        if (args.length === 2) {
          matrix[5] = args[1];
        }
      }

      // identity matrix
      var iMatrix = fabric.iMatrix,

          // == begin transform regexp
          number = fabric.reNum,

          commaWsp = '(?:\\s+,?\\s*|,\\s*)',

          skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

          skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

          rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + ')' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          matrix = '(?:(matrix)\\s*\\(\\s*' +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' +
                    '\\s*\\))',

          transform = '(?:' +
                      matrix + '|' +
                      translate + '|' +
                      scale + '|' +
                      rotate + '|' +
                      skewX + '|' +
                      skewY +
                      ')',

          transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

          transformList = '^\\s*(?:' + transforms + '?)\\s*$',

          // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
          reTransformList = new RegExp(transformList),
          // == end transform regexp

          reTransform = new RegExp(transform, 'g');

      return function(attributeValue) {

        // start with identity matrix
        var matrix = iMatrix.concat(),
            matrices = [];

        // return if no argument was given or
        // an argument does not match transform attribute regexp
        if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
          return matrix;
        }

        attributeValue.replace(reTransform, function(match) {

          var m = new RegExp(transform).exec(match).filter(function (match) {
                // match !== '' && match != null
                return (!!match);
              }),
              operation = m[1],
              args = m.slice(2).map(parseFloat);

          switch (operation) {
            case 'translate':
              translateMatrix(matrix, args);
              break;
            case 'rotate':
              args[0] = fabric.util.degreesToRadians(args[0]);
              rotateMatrix(matrix, args);
              break;
            case 'scale':
              scaleMatrix(matrix, args);
              break;
            case 'skewX':
              skewMatrix(matrix, args, 2);
              break;
            case 'skewY':
              skewMatrix(matrix, args, 1);
              break;
            case 'matrix':
              matrix = args;
              break;
          }

          // snapshot current matrix into matrices array
          matrices.push(matrix.concat());
          // reset
          matrix = iMatrix.concat();
        });

        var combinedMatrix = matrices[0];
        while (matrices.length > 1) {
          matrices.shift();
          combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
        }
        return combinedMatrix;
      };
    })();

    /**
     * @private
     */
    function parseStyleString(style, oStyle) {
      var attr, value;
      style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
        var pair = chunk.split(':');

        attr = pair[0].trim().toLowerCase();
        value =  pair[1].trim();

        oStyle[attr] = value;
      });
    }

    /**
     * @private
     */
    function parseStyleObject(style, oStyle) {
      var attr, value;
      for (var prop in style) {
        if (typeof style[prop] === 'undefined') {
          continue;
        }

        attr = prop.toLowerCase();
        value = style[prop];

        oStyle[attr] = value;
      }
    }

    /**
     * @private
     */
    function getGlobalStylesForElement(element, svgUid) {
      var styles = { };
      for (var rule in fabric.cssRules[svgUid]) {
        if (elementMatchesRule(element, rule.split(' '))) {
          for (var property in fabric.cssRules[svgUid][rule]) {
            styles[property] = fabric.cssRules[svgUid][rule][property];
          }
        }
      }
      return styles;
    }

    /**
     * @private
     */
    function elementMatchesRule(element, selectors) {
      var firstMatching, parentMatching = true;
      //start from rightmost selector.
      firstMatching = selectorMatches(element, selectors.pop());
      if (firstMatching && selectors.length) {
        parentMatching = doesSomeParentMatch(element, selectors);
      }
      return firstMatching && parentMatching && (selectors.length === 0);
    }

    function doesSomeParentMatch(element, selectors) {
      var selector, parentMatching = true;
      while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
        if (parentMatching) {
          selector = selectors.pop();
        }
        element = element.parentNode;
        parentMatching = selectorMatches(element, selector);
      }
      return selectors.length === 0;
    }

    /**
     * @private
     */
    function selectorMatches(element, selector) {
      var nodeName = element.nodeName,
          classNames = element.getAttribute('class'),
          id = element.getAttribute('id'), matcher, i;
      // i check if a selector matches slicing away part from it.
      // if i get empty string i should match
      matcher = new RegExp('^' + nodeName, 'i');
      selector = selector.replace(matcher, '');
      if (id && selector.length) {
        matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
      if (classNames && selector.length) {
        classNames = classNames.split(' ');
        for (i = classNames.length; i--;) {
          matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
          selector = selector.replace(matcher, '');
        }
      }
      return selector.length === 0;
    }

    /**
     * @private
     * to support IE8 missing getElementById on SVGdocument and on node xmlDOM
     */
    function elementById(doc, id) {
      var el;
      doc.getElementById && (el = doc.getElementById(id));
      if (el) {
        return el;
      }
      var node, i, len, nodelist = doc.getElementsByTagName('*');
      for (i = 0, len = nodelist.length; i < len; i++) {
        node = nodelist[i];
        if (id === node.getAttribute('id')) {
          return node;
        }
      }
    }

    /**
     * @private
     */
    function parseUseDirectives(doc) {
      var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
      while (nodelist.length && i < nodelist.length) {
        var el = nodelist[i],
            xlink = (el.getAttribute('xlink:href') || el.getAttribute('href')).substr(1),
            x = el.getAttribute('x') || 0,
            y = el.getAttribute('y') || 0,
            el2 = elementById(doc, xlink).cloneNode(true),
            currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
            parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;

        applyViewboxTransform(el2);
        if (/^svg$/i.test(el2.nodeName)) {
          var el3 = el2.ownerDocument.createElementNS(namespace, 'g');
          for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
            attr = attrs.item(j);
            el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
          }
          // el2.firstChild != null
          while (el2.firstChild) {
            el3.appendChild(el2.firstChild);
          }
          el2 = el3;
        }

        for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          if (attr.nodeName === 'x' || attr.nodeName === 'y' ||
            attr.nodeName === 'xlink:href' || attr.nodeName === 'href') {
            continue;
          }

          if (attr.nodeName === 'transform') {
            currentTrans = attr.nodeValue + ' ' + currentTrans;
          }
          else {
            el2.setAttribute(attr.nodeName, attr.nodeValue);
          }
        }

        el2.setAttribute('transform', currentTrans);
        el2.setAttribute('instantiated_by_use', '1');
        el2.removeAttribute('id');
        parentNode = el.parentNode;
        parentNode.replaceChild(el2, el);
        // some browsers do not shorten nodelist after replaceChild (IE8)
        if (nodelist.length === oldLength) {
          i++;
        }
      }
    }

    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
    // matches, e.g.: +14.56e-12, etc.
    var reViewBoxAttrValue = new RegExp(
      '^' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*' +
      '$'
    );

    /**
     * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
     */
    function applyViewboxTransform(element) {

      var viewBoxAttr = element.getAttribute('viewBox'),
          scaleX = 1,
          scaleY = 1,
          minX = 0,
          minY = 0,
          viewBoxWidth, viewBoxHeight, matrix, el,
          widthAttr = element.getAttribute('width'),
          heightAttr = element.getAttribute('height'),
          x = element.getAttribute('x') || 0,
          y = element.getAttribute('y') || 0,
          preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
          missingViewBox = (!viewBoxAttr || !fabric.svgViewBoxElementsRegEx.test(element.nodeName)
                             || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
          missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
          toBeParsed = missingViewBox && missingDimAttr,
          parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;

      parsedDim.width = 0;
      parsedDim.height = 0;
      parsedDim.toBeParsed = toBeParsed;

      if (toBeParsed) {
        return parsedDim;
      }

      if (missingViewBox) {
        parsedDim.width = parseUnit(widthAttr);
        parsedDim.height = parseUnit(heightAttr);
        return parsedDim;
      }
      minX = -parseFloat(viewBoxAttr[1]);
      minY = -parseFloat(viewBoxAttr[2]);
      viewBoxWidth = parseFloat(viewBoxAttr[3]);
      viewBoxHeight = parseFloat(viewBoxAttr[4]);
      parsedDim.minX = minX;
      parsedDim.minY = minY;
      parsedDim.viewBoxWidth = viewBoxWidth;
      parsedDim.viewBoxHeight = viewBoxHeight;
      if (!missingDimAttr) {
        parsedDim.width = parseUnit(widthAttr);
        parsedDim.height = parseUnit(heightAttr);
        scaleX = parsedDim.width / viewBoxWidth;
        scaleY = parsedDim.height / viewBoxHeight;
      }
      else {
        parsedDim.width = viewBoxWidth;
        parsedDim.height = viewBoxHeight;
      }

      // default is to preserve aspect ratio
      preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
      if (preserveAspectRatio.alignX !== 'none') {
        //translate all container for the effect of Mid, Min, Max
        if (preserveAspectRatio.meetOrSlice === 'meet') {
          scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
          // calculate additional translation to move the viewbox
        }
        if (preserveAspectRatio.meetOrSlice === 'slice') {
          scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
          // calculate additional translation to move the viewbox
        }
        widthDiff = parsedDim.width - viewBoxWidth * scaleX;
        heightDiff = parsedDim.height - viewBoxHeight * scaleX;
        if (preserveAspectRatio.alignX === 'Mid') {
          widthDiff /= 2;
        }
        if (preserveAspectRatio.alignY === 'Mid') {
          heightDiff /= 2;
        }
        if (preserveAspectRatio.alignX === 'Min') {
          widthDiff = 0;
        }
        if (preserveAspectRatio.alignY === 'Min') {
          heightDiff = 0;
        }
      }

      if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
        return parsedDim;
      }

      if (x || y) {
        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
      }

      matrix = translateMatrix + ' matrix(' + scaleX +
                    ' 0' +
                    ' 0 ' +
                    scaleY + ' ' +
                    (minX * scaleX + widthDiff) + ' ' +
                    (minY * scaleY + heightDiff) + ') ';
      parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);
      if (element.nodeName === 'svg') {
        el = element.ownerDocument.createElementNS(fabric.svgNS, 'g');
        // element.firstChild != null
        while (element.firstChild) {
          el.appendChild(element.firstChild);
        }
        element.appendChild(el);
      }
      else {
        el = element;
        matrix = el.getAttribute('transform') + matrix;
      }
      el.setAttribute('transform', matrix);
      return parsedDim;
    }

    function hasAncestorWithNodeName(element, nodeName) {
      while (element && (element = element.parentNode)) {
        if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
          && !element.getAttribute('instantiated_by_use')) {
          return true;
        }
      }
      return false;
    }

    /**
     * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @param {Function} callback Callback to call when parsing is finished;
     * It's being passed an array of elements (parsed from a document).
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [parsingOptions] options for parsing document
     * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
     */
    fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
      if (!doc) {
        return;
      }

      parseUseDirectives(doc);

      var svgUid =  fabric.Object.__uid++, i, len,
          options = applyViewboxTransform(doc),
          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
      options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
      options.svgUid = svgUid;

      if (descendants.length === 0 && fabric.isLikelyNode) {
        // we're likely in node, where "o3-xml" library fails to gEBTN("*")
        // https://github.com/ajaxorg/node-o3-xml/issues/21
        descendants = doc.selectNodes('//*[name(.)!="svg"]');
        var arr = [];
        for (i = 0, len = descendants.length; i < len; i++) {
          arr[i] = descendants[i];
        }
        descendants = arr;
      }

      var elements = descendants.filter(function(el) {
        applyViewboxTransform(el);
        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
              !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
      });

      if (!elements || (elements && !elements.length)) {
        callback && callback([], {});
        return;
      }
      var clipPaths = { };
      descendants.filter(function(el) {
        return el.nodeName.replace('svg:', '') === 'clipPath';
      }).forEach(function(el) {
        var id = el.getAttribute('id');
        clipPaths[id] = fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el) {
          return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));
        });
      });
      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
      fabric.clipPaths[svgUid] = clipPaths;
      // Precedence of rules:   style > class > attribute
      fabric.parseElements(elements, function(instances, elements) {
        if (callback) {
          callback(instances, options, elements, descendants);
          delete fabric.gradientDefs[svgUid];
          delete fabric.cssRules[svgUid];
          delete fabric.clipPaths[svgUid];
        }
      }, clone(options), reviver, parsingOptions);
    };

    function recursivelyParseGradientsXlink(doc, gradient) {
      var gradientsAttrs = ['gradientTransform', 'x1', 'x2', 'y1', 'y2', 'gradientUnits', 'cx', 'cy', 'r', 'fx', 'fy'],
          xlinkAttr = 'xlink:href',
          xLink = gradient.getAttribute(xlinkAttr).substr(1),
          referencedGradient = elementById(doc, xLink);
      if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
        recursivelyParseGradientsXlink(doc, referencedGradient);
      }
      gradientsAttrs.forEach(function(attr) {
        if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
          gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
        }
      });
      if (!gradient.children.length) {
        var referenceClone = referencedGradient.cloneNode(true);
        while (referenceClone.firstChild) {
          gradient.appendChild(referenceClone.firstChild);
        }
      }
      gradient.removeAttribute(xlinkAttr);
    }

    var reFontDeclaration = new RegExp(
      '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
      '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
        fabric.reNum +
      '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

    extend(fabric, {
      /**
       * Parses a short font declaration, building adding its properties to a style object
       * @static
       * @function
       * @memberOf fabric
       * @param {String} value font declaration
       * @param {Object} oStyle definition
       */
      parseFontDeclaration: function(value, oStyle) {
        var match = value.match(reFontDeclaration);

        if (!match) {
          return;
        }
        var fontStyle = match[1],
            // font variant is not used
            // fontVariant = match[2],
            fontWeight = match[3],
            fontSize = match[4],
            lineHeight = match[5],
            fontFamily = match[6];

        if (fontStyle) {
          oStyle.fontStyle = fontStyle;
        }
        if (fontWeight) {
          oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
        }
        if (fontSize) {
          oStyle.fontSize = parseUnit(fontSize);
        }
        if (fontFamily) {
          oStyle.fontFamily = fontFamily;
        }
        if (lineHeight) {
          oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
        }
      },

      /**
       * Parses an SVG document, returning all of the gradient declarations found in it
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
       */
      getGradientDefs: function(doc) {
        var tagArray = [
              'linearGradient',
              'radialGradient',
              'svg:linearGradient',
              'svg:radialGradient'],
            elList = _getMultipleNodes(doc, tagArray),
            el, j = 0, gradientDefs = { };
        j = elList.length;
        while (j--) {
          el = elList[j];
          if (el.getAttribute('xlink:href')) {
            recursivelyParseGradientsXlink(doc, el);
          }
          gradientDefs[el.getAttribute('id')] = el;
        }
        return gradientDefs;
      },

      /**
       * Returns an object of attributes' name/value, given element and an array of attribute names;
       * Parses parent "g" nodes recursively upwards.
       * @static
       * @memberOf fabric
       * @param {DOMElement} element Element to parse
       * @param {Array} attributes Array of attributes to parse
       * @return {Object} object containing parsed attributes' names/values
       */
      parseAttributes: function(element, attributes, svgUid) {

        if (!element) {
          return;
        }

        var value,
            parentAttributes = { },
            fontSize, parentFontSize;

        if (typeof svgUid === 'undefined') {
          svgUid = element.getAttribute('svgUid');
        }
        // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
        if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
          parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
        }

        var ownAttributes = attributes.reduce(function(memo, attr) {
          value = element.getAttribute(attr);
          if (value) { // eslint-disable-line
            memo[attr] = value;
          }
          return memo;
        }, { });
        // add values parsed from style, which take precedence over attributes
        // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
        var cssAttrs = extend(
          getGlobalStylesForElement(element, svgUid),
          fabric.parseStyleAttribute(element)
        );
        ownAttributes = extend(
          ownAttributes,
          cssAttrs
        );
        if (cssAttrs[cPath]) {
          element.setAttribute(cPath, cssAttrs[cPath]);
        }
        fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;
        if (ownAttributes[fSize]) {
          // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.
          ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);
        }

        var normalizedAttr, normalizedValue, normalizedStyle = {};
        for (var attr in ownAttributes) {
          normalizedAttr = normalizeAttr(attr);
          normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
          normalizedStyle[normalizedAttr] = normalizedValue;
        }
        if (normalizedStyle && normalizedStyle.font) {
          fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
        }
        var mergedAttrs = extend(parentAttributes, normalizedStyle);
        return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
      },

      /**
       * Transforms an array of svg elements to corresponding fabric.* instances
       * @static
       * @memberOf fabric
       * @param {Array} elements Array of elements to parse
       * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
       * @param {Object} [options] Options object
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       */
      parseElements: function(elements, callback, options, reviver, parsingOptions) {
        new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
      },

      /**
       * Parses "style" attribute, retuning an object with values
       * @static
       * @memberOf fabric
       * @param {SVGElement} element Element to parse
       * @return {Object} Objects with values parsed from style attribute of an element
       */
      parseStyleAttribute: function(element) {
        var oStyle = { },
            style = element.getAttribute('style');

        if (!style) {
          return oStyle;
        }

        if (typeof style === 'string') {
          parseStyleString(style, oStyle);
        }
        else {
          parseStyleObject(style, oStyle);
        }

        return oStyle;
      },

      /**
       * Parses "points" attribute, returning an array of values
       * @static
       * @memberOf fabric
       * @param {String} points points attribute string
       * @return {Array} array of points
       */
      parsePointsAttribute: function(points) {

        // points attribute is required and must not be empty
        if (!points) {
          return null;
        }

        // replace commas with whitespace and remove bookending whitespace
        points = points.replace(/,/g, ' ').trim();

        points = points.split(/\s+/);
        var parsedPoints = [], i, len;

        for (i = 0, len = points.length; i < len; i += 2) {
          parsedPoints.push({
            x: parseFloat(points[i]),
            y: parseFloat(points[i + 1])
          });
        }

        // odd number of points is an error
        // if (parsedPoints.length % 2 !== 0) {
        //   return null;
        // }

        return parsedPoints;
      },

      /**
       * Returns CSS rules for a given SVG document
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} CSS rules of this document
       */
      getCSSRules: function(doc) {
        var styles = doc.getElementsByTagName('style'), i, len,
            allRules = { }, rules;

        // very crude parsing of style contents
        for (i = 0, len = styles.length; i < len; i++) {
          // <style/> could produce `undefined`, covering this case with ''
          var styleContents = styles[i].textContent || '';

          // remove comments
          styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
          if (styleContents.trim() === '') {
            continue;
          }
          rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
          rules = rules.map(function(rule) { return rule.trim(); });
          // eslint-disable-next-line no-loop-func
          rules.forEach(function(rule) {

            var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
                ruleObj = { }, declaration = match[2].trim(),
                propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);

            for (i = 0, len = propertyValuePairs.length; i < len; i++) {
              var pair = propertyValuePairs[i].split(/\s*:\s*/),
                  property = pair[0],
                  value = pair[1];
              ruleObj[property] = value;
            }
            rule = match[1];
            rule.split(',').forEach(function(_rule) {
              _rule = _rule.replace(/^svg/i, '').trim();
              if (_rule === '') {
                return;
              }
              if (allRules[_rule]) {
                fabric.util.object.extend(allRules[_rule], ruleObj);
              }
              else {
                allRules[_rule] = fabric.util.object.clone(ruleObj);
              }
            });
          });
        }
        return allRules;
      },

      /**
       * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
       * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
       * @memberOf fabric
       * @param {String} url
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromURL: function(url, callback, reviver, options) {

        url = url.replace(/^\n\s*/, '').trim();
        new fabric.util.request(url, {
          method: 'get',
          onComplete: onComplete
        });

        function onComplete(r) {

          var xml = r.responseXML;
          if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.async = 'false';
            //IE chokes on DOCTYPE
            xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
          }
          if (!xml || !xml.documentElement) {
            callback && callback(null);
            return false;
          }

          fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
            callback && callback(results, _options, elements, allElements);
          }, reviver, options);
        }
      },

      /**
       * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
       * @memberOf fabric
       * @param {String} string
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromString: function(string, callback, reviver, options) {
        string = string.trim();
        var doc;
        if (typeof fabric.window.DOMParser !== 'undefined') {
          var parser = new fabric.window.DOMParser();
          if (parser && parser.parseFromString) {
            doc = parser.parseFromString(string, 'text/xml');
          }
        }
        else if (fabric.window.ActiveXObject) {
          doc = new ActiveXObject('Microsoft.XMLDOM');
          doc.async = 'false';
          // IE chokes on DOCTYPE
          doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
        }

        fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
          callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    });

  })( exports );


  fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {
    this.elements = elements;
    this.callback = callback;
    this.options = options;
    this.reviver = reviver;
    this.svgUid = (options && options.svgUid) || 0;
    this.parsingOptions = parsingOptions;
    this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
    this.doc = doc;
  };

  (function(proto) {
    proto.parse = function() {
      this.instances = new Array(this.elements.length);
      this.numElements = this.elements.length;
      this.createObjects();
    };

    proto.createObjects = function() {
      var _this = this;
      this.elements.forEach(function(element, i) {
        element.setAttribute('svgUid', _this.svgUid);
        _this.createObject(element, i);
      });
    };

    proto.findTag = function(el) {
      return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
    };

    proto.createObject = function(el, index) {
      var klass = this.findTag(el);
      if (klass && klass.fromElement) {
        try {
          klass.fromElement(el, this.createCallback(index, el), this.options);
        }
        catch (err) {
          fabric.log(err);
        }
      }
      else {
        this.checkIfDone();
      }
    };

    proto.createCallback = function(index, el) {
      var _this = this;
      return function(obj) {
        var _options;
        _this.resolveGradient(obj, el, 'fill');
        _this.resolveGradient(obj, el, 'stroke');
        if (obj instanceof fabric.Image && obj._originalElement) {
          _options = obj.parsePreserveAspectRatioAttribute(el);
        }
        obj._removeTransformMatrix(_options);
        _this.resolveClipPath(obj, el);
        _this.reviver && _this.reviver(el, obj);
        _this.instances[index] = obj;
        _this.checkIfDone();
      };
    };

    proto.extractPropertyDefinition = function(obj, property, storage) {
      var value = obj[property], regex = this.regexUrl;
      if (!regex.test(value)) {
        return;
      }
      regex.lastIndex = 0;
      var id = regex.exec(value)[1];
      regex.lastIndex = 0;
      return fabric[storage][this.svgUid][id];
    };

    proto.resolveGradient = function(obj, el, property) {
      var gradientDef = this.extractPropertyDefinition(obj, property, 'gradientDefs');
      if (gradientDef) {
        var opacityAttr = el.getAttribute(property + '-opacity');
        var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
        obj.set(property, gradient);
      }
    };

    proto.createClipPathCallback = function(obj, container) {
      return function(_newObj) {
        _newObj._removeTransformMatrix();
        _newObj.fillRule = _newObj.clipRule;
        container.push(_newObj);
      };
    };

    proto.resolveClipPath = function(obj, usingElement) {
      var clipPath = this.extractPropertyDefinition(obj, 'clipPath', 'clipPaths'),
          element, klass, objTransformInv, container, gTransform, options;
      if (clipPath) {
        container = [];
        objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
        // move the clipPath tag as sibling to the real element that is using it
        var clipPathTag = clipPath[0].parentNode;
        var clipPathOwner = usingElement;
        while (clipPathOwner.parentNode && clipPathOwner.getAttribute('clip-path') !== obj.clipPath) {
          clipPathOwner = clipPathOwner.parentNode;
        }
        clipPathOwner.parentNode.appendChild(clipPathTag);
        for (var i = 0; i < clipPath.length; i++) {
          element = clipPath[i];
          klass = this.findTag(element);
          klass.fromElement(
            element,
            this.createClipPathCallback(obj, container),
            this.options
          );
        }
        if (container.length === 1) {
          clipPath = container[0];
        }
        else {
          clipPath = new fabric.Group(container);
        }
        gTransform = fabric.util.multiplyTransformMatrices(
          objTransformInv,
          clipPath.calcTransformMatrix()
        );
        if (clipPath.clipPath) {
          this.resolveClipPath(clipPath, clipPathOwner);
        }
        var options = fabric.util.qrDecompose(gTransform);
        clipPath.flipX = false;
        clipPath.flipY = false;
        clipPath.set('scaleX', options.scaleX);
        clipPath.set('scaleY', options.scaleY);
        clipPath.angle = options.angle;
        clipPath.skewX = options.skewX;
        clipPath.skewY = 0;
        clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, 'center', 'center');
        obj.clipPath = clipPath;
      }
      else {
        // if clip-path does not resolve to any element, delete the property.
        delete obj.clipPath;
      }
    };

    proto.checkIfDone = function() {
      if (--this.numElements === 0) {
        this.instances = this.instances.filter(function(el) {
          // eslint-disable-next-line no-eq-null, eqeqeq
          return el != null;
        });
        this.callback(this.instances, this.elements);
      }
    };
  })(fabric.ElementsParser.prototype);


  (function(global) {

    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Point) {
      fabric.warn('fabric.Point is already defined');
      return;
    }

    fabric.Point = Point;

    /**
     * Point class
     * @class fabric.Point
     * @memberOf fabric
     * @constructor
     * @param {Number} x
     * @param {Number} y
     * @return {fabric.Point} thisArg
     */
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype = /** @lends fabric.Point.prototype */ {

      type: 'point',

      constructor: Point,

      /**
       * Adds another point to this one and returns another one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point instance with added values
       */
      add: function (that) {
        return new Point(this.x + that.x, this.y + that.y);
      },

      /**
       * Adds another point to this one
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      addEquals: function (that) {
        this.x += that.x;
        this.y += that.y;
        return this;
      },

      /**
       * Adds value to this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point} new Point with added value
       */
      scalarAdd: function (scalar) {
        return new Point(this.x + scalar, this.y + scalar);
      },

      /**
       * Adds value to this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarAddEquals: function (scalar) {
        this.x += scalar;
        this.y += scalar;
        return this;
      },

      /**
       * Subtracts another point from this point and returns a new one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point object with subtracted values
       */
      subtract: function (that) {
        return new Point(this.x - that.x, this.y - that.y);
      },

      /**
       * Subtracts another point from this point
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      subtractEquals: function (that) {
        this.x -= that.x;
        this.y -= that.y;
        return this;
      },

      /**
       * Subtracts value from this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      scalarSubtract: function (scalar) {
        return new Point(this.x - scalar, this.y - scalar);
      },

      /**
       * Subtracts value from this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarSubtractEquals: function (scalar) {
        this.x -= scalar;
        this.y -= scalar;
        return this;
      },

      /**
       * Multiplies this point by a value and returns a new one
       * TODO: rename in scalarMultiply in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      multiply: function (scalar) {
        return new Point(this.x * scalar, this.y * scalar);
      },

      /**
       * Multiplies this point by a value
       * TODO: rename in scalarMultiplyEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      multiplyEquals: function (scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      },

      /**
       * Divides this point by a value and returns a new one
       * TODO: rename in scalarDivide in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      divide: function (scalar) {
        return new Point(this.x / scalar, this.y / scalar);
      },

      /**
       * Divides this point by a value
       * TODO: rename in scalarDivideEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      divideEquals: function (scalar) {
        this.x /= scalar;
        this.y /= scalar;
        return this;
      },

      /**
       * Returns true if this point is equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      eq: function (that) {
        return (this.x === that.x && this.y === that.y);
      },

      /**
       * Returns true if this point is less than another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lt: function (that) {
        return (this.x < that.x && this.y < that.y);
      },

      /**
       * Returns true if this point is less than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lte: function (that) {
        return (this.x <= that.x && this.y <= that.y);
      },

      /**

       * Returns true if this point is greater another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      gt: function (that) {
        return (this.x > that.x && this.y > that.y);
      },

      /**
       * Returns true if this point is greater than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      gte: function (that) {
        return (this.x >= that.x && this.y >= that.y);
      },

      /**
       * Returns new point which is the result of linear interpolation with this one and another one
       * @param {fabric.Point} that
       * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
       * @return {fabric.Point}
       */
      lerp: function (that, t) {
        if (typeof t === 'undefined') {
          t = 0.5;
        }
        t = Math.max(Math.min(1, t), 0);
        return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
      },

      /**
       * Returns distance from this point and another one
       * @param {fabric.Point} that
       * @return {Number}
       */
      distanceFrom: function (that) {
        var dx = this.x - that.x,
            dy = this.y - that.y;
        return Math.sqrt(dx * dx + dy * dy);
      },

      /**
       * Returns the point between this point and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      midPointFrom: function (that) {
        return this.lerp(that);
      },

      /**
       * Returns a new point which is the min of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      min: function (that) {
        return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
      },

      /**
       * Returns a new point which is the max of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      max: function (that) {
        return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
      },

      /**
       * Returns string representation of this point
       * @return {String}
       */
      toString: function () {
        return this.x + ',' + this.y;
      },

      /**
       * Sets x/y of this point
       * @param {Number} x
       * @param {Number} y
       * @chainable
       */
      setXY: function (x, y) {
        this.x = x;
        this.y = y;
        return this;
      },

      /**
       * Sets x of this point
       * @param {Number} x
       * @chainable
       */
      setX: function (x) {
        this.x = x;
        return this;
      },

      /**
       * Sets y of this point
       * @param {Number} y
       * @chainable
       */
      setY: function (y) {
        this.y = y;
        return this;
      },

      /**
       * Sets x/y of this point from another point
       * @param {fabric.Point} that
       * @chainable
       */
      setFromPoint: function (that) {
        this.x = that.x;
        this.y = that.y;
        return this;
      },

      /**
       * Swaps x/y of this point and another point
       * @param {fabric.Point} that
       */
      swap: function (that) {
        var x = this.x,
            y = this.y;
        this.x = that.x;
        this.y = that.y;
        that.x = x;
        that.y = y;
      },

      /**
       * return a cloned instance of the point
       * @return {fabric.Point}
       */
      clone: function () {
        return new Point(this.x, this.y);
      }
    };

  })( exports );


  (function(global) {

    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Intersection) {
      fabric.warn('fabric.Intersection is already defined');
      return;
    }

    /**
     * Intersection class
     * @class fabric.Intersection
     * @memberOf fabric
     * @constructor
     */
    function Intersection(status) {
      this.status = status;
      this.points = [];
    }

    fabric.Intersection = Intersection;

    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

      constructor: Intersection,

      /**
       * Appends a point to intersection
       * @param {fabric.Point} point
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoint: function (point) {
        this.points.push(point);
        return this;
      },

      /**
       * Appends points to intersection
       * @param {Array} points
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoints: function (points) {
        this.points = this.points.concat(points);
        return this;
      }
    };

    /**
     * Checks if one line intersects another
     * TODO: rename in intersectSegmentSegment
     * @static
     * @param {fabric.Point} a1
     * @param {fabric.Point} a2
     * @param {fabric.Point} b1
     * @param {fabric.Point} b2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
      var result,
          uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
          ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
          uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
      if (uB !== 0) {
        var ua = uaT / uB,
            ub = ubT / uB;
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
          result = new Intersection('Intersection');
          result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
        }
        else {
          result = new Intersection();
        }
      }
      else {
        if (uaT === 0 || ubT === 0) {
          result = new Intersection('Coincident');
        }
        else {
          result = new Intersection('Parallel');
        }
      }
      return result;
    };

    /**
     * Checks if line intersects polygon
     * TODO: rename in intersectSegmentPolygon
     * fix detection of coincident
     * @static
     * @param {fabric.Point} a1
     * @param {fabric.Point} a2
     * @param {Array} points
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
      var result = new Intersection(),
          length = points.length,
          b1, b2, inter, i;

      for (i = 0; i < length; i++) {
        b1 = points[i];
        b2 = points[(i + 1) % length];
        inter = Intersection.intersectLineLine(a1, a2, b1, b2);

        result.appendPoints(inter.points);
      }
      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

    /**
     * Checks if polygon intersects another polygon
     * @static
     * @param {Array} points1
     * @param {Array} points2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
      var result = new Intersection(),
          length = points1.length, i;

      for (i = 0; i < length; i++) {
        var a1 = points1[i],
            a2 = points1[(i + 1) % length],
            inter = Intersection.intersectLinePolygon(a1, a2, points2);

        result.appendPoints(inter.points);
      }
      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

    /**
     * Checks if polygon intersects rectangle
     * @static
     * @param {Array} points
     * @param {fabric.Point} r1
     * @param {fabric.Point} r2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
      var min = r1.min(r2),
          max = r1.max(r2),
          topRight = new fabric.Point(max.x, min.y),
          bottomLeft = new fabric.Point(min.x, max.y),
          inter1 = Intersection.intersectLinePolygon(min, topRight, points),
          inter2 = Intersection.intersectLinePolygon(topRight, max, points),
          inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
          inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
          result = new Intersection();

      result.appendPoints(inter1.points);
      result.appendPoints(inter2.points);
      result.appendPoints(inter3.points);
      result.appendPoints(inter4.points);

      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Color) {
      fabric.warn('fabric.Color is already defined.');
      return;
    }

    /**
     * Color class
     * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
     * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
     *
     * @class fabric.Color
     * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
     * @return {fabric.Color} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
     */
    function Color(color) {
      if (!color) {
        this.setSource([0, 0, 0, 1]);
      }
      else {
        this._tryParsingColor(color);
      }
    }

    fabric.Color = Color;

    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

      /**
       * @private
       * @param {String|Array} color Color value to parse
       */
      _tryParsingColor: function(color) {
        var source;

        if (color in Color.colorNameMap) {
          color = Color.colorNameMap[color];
        }

        if (color === 'transparent') {
          source = [255, 255, 255, 0];
        }

        if (!source) {
          source = Color.sourceFromHex(color);
        }
        if (!source) {
          source = Color.sourceFromRgb(color);
        }
        if (!source) {
          source = Color.sourceFromHsl(color);
        }
        if (!source) {
          //if color is not recognize let's make black as canvas does
          source = [0, 0, 0, 1];
        }
        if (source) {
          this.setSource(source);
        }
      },

      /**
       * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
       * @private
       * @param {Number} r Red color value
       * @param {Number} g Green color value
       * @param {Number} b Blue color value
       * @return {Array} Hsl color
       */
      _rgbToHsl: function(r, g, b) {
        r /= 255; g /= 255; b /= 255;

        var h, s, l,
            max = fabric.util.array.max([r, g, b]),
            min = fabric.util.array.min([r, g, b]);

        l = (max + min) / 2;

        if (max === min) {
          h = s = 0; // achromatic
        }
        else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }

        return [
          Math.round(h * 360),
          Math.round(s * 100),
          Math.round(l * 100)
        ];
      },

      /**
       * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @return {Array}
       */
      getSource: function() {
        return this._source;
      },

      /**
       * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @param {Array} source
       */
      setSource: function(source) {
        this._source = source;
      },

      /**
       * Returns color representation in RGB format
       * @return {String} ex: rgb(0-255,0-255,0-255)
       */
      toRgb: function() {
        var source = this.getSource();
        return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
      },

      /**
       * Returns color representation in RGBA format
       * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
       */
      toRgba: function() {
        var source = this.getSource();
        return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
      },

      /**
       * Returns color representation in HSL format
       * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
       */
      toHsl: function() {
        var source = this.getSource(),
            hsl = this._rgbToHsl(source[0], source[1], source[2]);

        return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
      },

      /**
       * Returns color representation in HSLA format
       * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
       */
      toHsla: function() {
        var source = this.getSource(),
            hsl = this._rgbToHsl(source[0], source[1], source[2]);

        return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
      },

      /**
       * Returns color representation in HEX format
       * @return {String} ex: FF5555
       */
      toHex: function() {
        var source = this.getSource(), r, g, b;

        r = source[0].toString(16);
        r = (r.length === 1) ? ('0' + r) : r;

        g = source[1].toString(16);
        g = (g.length === 1) ? ('0' + g) : g;

        b = source[2].toString(16);
        b = (b.length === 1) ? ('0' + b) : b;

        return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
      },

      /**
       * Returns color representation in HEXA format
       * @return {String} ex: FF5555CC
       */
      toHexa: function() {
        var source = this.getSource(), a;

        a = Math.round(source[3] * 255);
        a = a.toString(16);
        a = (a.length === 1) ? ('0' + a) : a;

        return this.toHex() + a.toUpperCase();
      },

      /**
       * Gets value of alpha channel for this color
       * @return {Number} 0-1
       */
      getAlpha: function() {
        return this.getSource()[3];
      },

      /**
       * Sets value of alpha channel for this color
       * @param {Number} alpha Alpha value 0-1
       * @return {fabric.Color} thisArg
       */
      setAlpha: function(alpha) {
        var source = this.getSource();
        source[3] = alpha;
        this.setSource(source);
        return this;
      },

      /**
       * Transforms color to its grayscale representation
       * @return {fabric.Color} thisArg
       */
      toGrayscale: function() {
        var source = this.getSource(),
            average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
            currentAlpha = source[3];
        this.setSource([average, average, average, currentAlpha]);
        return this;
      },

      /**
       * Transforms color to its black and white representation
       * @param {Number} threshold
       * @return {fabric.Color} thisArg
       */
      toBlackWhite: function(threshold) {
        var source = this.getSource(),
            average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
            currentAlpha = source[3];

        threshold = threshold || 127;

        average = (Number(average) < Number(threshold)) ? 0 : 255;
        this.setSource([average, average, average, currentAlpha]);
        return this;
      },

      /**
       * Overlays color with another color
       * @param {String|fabric.Color} otherColor
       * @return {fabric.Color} thisArg
       */
      overlayWith: function(otherColor) {
        if (!(otherColor instanceof Color)) {
          otherColor = new Color(otherColor);
        }

        var result = [],
            alpha = this.getAlpha(),
            otherAlpha = 0.5,
            source = this.getSource(),
            otherSource = otherColor.getSource(), i;

        for (i = 0; i < 3; i++) {
          result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
        }

        result[3] = alpha;
        this.setSource(result);
        return this;
      }
    };

    /**
     * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
     * @static
     * @field
     * @memberOf fabric.Color
     */
    // eslint-disable-next-line max-len
    fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;

    /**
     * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
     * @static
     * @field
     * @memberOf fabric.Color
     */
    fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;

    /**
     * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
     * @static
     * @field
     * @memberOf fabric.Color
     */
    fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

    /**
     * Map of the 148 color names with HEX code
     * @static
     * @field
     * @memberOf fabric.Color
     * @see: https://www.w3.org/TR/css3-color/#svg-color
     */
    fabric.Color.colorNameMap = {
      aliceblue:            '#F0F8FF',
      antiquewhite:         '#FAEBD7',
      aqua:                 '#00FFFF',
      aquamarine:           '#7FFFD4',
      azure:                '#F0FFFF',
      beige:                '#F5F5DC',
      bisque:               '#FFE4C4',
      black:                '#000000',
      blanchedalmond:       '#FFEBCD',
      blue:                 '#0000FF',
      blueviolet:           '#8A2BE2',
      brown:                '#A52A2A',
      burlywood:            '#DEB887',
      cadetblue:            '#5F9EA0',
      chartreuse:           '#7FFF00',
      chocolate:            '#D2691E',
      coral:                '#FF7F50',
      cornflowerblue:       '#6495ED',
      cornsilk:             '#FFF8DC',
      crimson:              '#DC143C',
      cyan:                 '#00FFFF',
      darkblue:             '#00008B',
      darkcyan:             '#008B8B',
      darkgoldenrod:        '#B8860B',
      darkgray:             '#A9A9A9',
      darkgrey:             '#A9A9A9',
      darkgreen:            '#006400',
      darkkhaki:            '#BDB76B',
      darkmagenta:          '#8B008B',
      darkolivegreen:       '#556B2F',
      darkorange:           '#FF8C00',
      darkorchid:           '#9932CC',
      darkred:              '#8B0000',
      darksalmon:           '#E9967A',
      darkseagreen:         '#8FBC8F',
      darkslateblue:        '#483D8B',
      darkslategray:        '#2F4F4F',
      darkslategrey:        '#2F4F4F',
      darkturquoise:        '#00CED1',
      darkviolet:           '#9400D3',
      deeppink:             '#FF1493',
      deepskyblue:          '#00BFFF',
      dimgray:              '#696969',
      dimgrey:              '#696969',
      dodgerblue:           '#1E90FF',
      firebrick:            '#B22222',
      floralwhite:          '#FFFAF0',
      forestgreen:          '#228B22',
      fuchsia:              '#FF00FF',
      gainsboro:            '#DCDCDC',
      ghostwhite:           '#F8F8FF',
      gold:                 '#FFD700',
      goldenrod:            '#DAA520',
      gray:                 '#808080',
      grey:                 '#808080',
      green:                '#008000',
      greenyellow:          '#ADFF2F',
      honeydew:             '#F0FFF0',
      hotpink:              '#FF69B4',
      indianred:            '#CD5C5C',
      indigo:               '#4B0082',
      ivory:                '#FFFFF0',
      khaki:                '#F0E68C',
      lavender:             '#E6E6FA',
      lavenderblush:        '#FFF0F5',
      lawngreen:            '#7CFC00',
      lemonchiffon:         '#FFFACD',
      lightblue:            '#ADD8E6',
      lightcoral:           '#F08080',
      lightcyan:            '#E0FFFF',
      lightgoldenrodyellow: '#FAFAD2',
      lightgray:            '#D3D3D3',
      lightgrey:            '#D3D3D3',
      lightgreen:           '#90EE90',
      lightpink:            '#FFB6C1',
      lightsalmon:          '#FFA07A',
      lightseagreen:        '#20B2AA',
      lightskyblue:         '#87CEFA',
      lightslategray:       '#778899',
      lightslategrey:       '#778899',
      lightsteelblue:       '#B0C4DE',
      lightyellow:          '#FFFFE0',
      lime:                 '#00FF00',
      limegreen:            '#32CD32',
      linen:                '#FAF0E6',
      magenta:              '#FF00FF',
      maroon:               '#800000',
      mediumaquamarine:     '#66CDAA',
      mediumblue:           '#0000CD',
      mediumorchid:         '#BA55D3',
      mediumpurple:         '#9370DB',
      mediumseagreen:       '#3CB371',
      mediumslateblue:      '#7B68EE',
      mediumspringgreen:    '#00FA9A',
      mediumturquoise:      '#48D1CC',
      mediumvioletred:      '#C71585',
      midnightblue:         '#191970',
      mintcream:            '#F5FFFA',
      mistyrose:            '#FFE4E1',
      moccasin:             '#FFE4B5',
      navajowhite:          '#FFDEAD',
      navy:                 '#000080',
      oldlace:              '#FDF5E6',
      olive:                '#808000',
      olivedrab:            '#6B8E23',
      orange:               '#FFA500',
      orangered:            '#FF4500',
      orchid:               '#DA70D6',
      palegoldenrod:        '#EEE8AA',
      palegreen:            '#98FB98',
      paleturquoise:        '#AFEEEE',
      palevioletred:        '#DB7093',
      papayawhip:           '#FFEFD5',
      peachpuff:            '#FFDAB9',
      peru:                 '#CD853F',
      pink:                 '#FFC0CB',
      plum:                 '#DDA0DD',
      powderblue:           '#B0E0E6',
      purple:               '#800080',
      rebeccapurple:        '#663399',
      red:                  '#FF0000',
      rosybrown:            '#BC8F8F',
      royalblue:            '#4169E1',
      saddlebrown:          '#8B4513',
      salmon:               '#FA8072',
      sandybrown:           '#F4A460',
      seagreen:             '#2E8B57',
      seashell:             '#FFF5EE',
      sienna:               '#A0522D',
      silver:               '#C0C0C0',
      skyblue:              '#87CEEB',
      slateblue:            '#6A5ACD',
      slategray:            '#708090',
      slategrey:            '#708090',
      snow:                 '#FFFAFA',
      springgreen:          '#00FF7F',
      steelblue:            '#4682B4',
      tan:                  '#D2B48C',
      teal:                 '#008080',
      thistle:              '#D8BFD8',
      tomato:               '#FF6347',
      turquoise:            '#40E0D0',
      violet:               '#EE82EE',
      wheat:                '#F5DEB3',
      white:                '#FFFFFF',
      whitesmoke:           '#F5F5F5',
      yellow:               '#FFFF00',
      yellowgreen:          '#9ACD32'
    };

    /**
     * @private
     * @param {Number} p
     * @param {Number} q
     * @param {Number} t
     * @return {Number}
     */
    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }

    /**
     * Returns new color object, when given a color in RGB format
     * @memberOf fabric.Color
     * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
     * @return {fabric.Color}
     */
    fabric.Color.fromRgb = function(color) {
      return Color.fromSource(Color.sourceFromRgb(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
     * @memberOf fabric.Color
     * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
     * @return {Array} source
     */
    fabric.Color.sourceFromRgb = function(color) {
      var match = color.match(Color.reRGBa);
      if (match) {
        var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
            g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
            b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

        return [
          parseInt(r, 10),
          parseInt(g, 10),
          parseInt(b, 10),
          match[4] ? parseFloat(match[4]) : 1
        ];
      }
    };

    /**
     * Returns new color object, when given a color in RGBA format
     * @static
     * @function
     * @memberOf fabric.Color
     * @param {String} color
     * @return {fabric.Color}
     */
    fabric.Color.fromRgba = Color.fromRgb;

    /**
     * Returns new color object, when given a color in HSL format
     * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
     * @memberOf fabric.Color
     * @return {fabric.Color}
     */
    fabric.Color.fromHsl = function(color) {
      return Color.fromSource(Color.sourceFromHsl(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @memberOf fabric.Color
     * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
     * @return {Array} source
     * @see http://http://www.w3.org/TR/css3-color/#hsl-color
     */
    fabric.Color.sourceFromHsl = function(color) {
      var match = color.match(Color.reHSLa);
      if (!match) {
        return;
      }

      var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
          s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
          l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
          r, g, b;

      if (s === 0) {
        r = g = b = l;
      }
      else {
        var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            p = l * 2 - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        match[4] ? parseFloat(match[4]) : 1
      ];
    };

    /**
     * Returns new color object, when given a color in HSLA format
     * @static
     * @function
     * @memberOf fabric.Color
     * @param {String} color
     * @return {fabric.Color}
     */
    fabric.Color.fromHsla = Color.fromHsl;

    /**
     * Returns new color object, when given a color in HEX format
     * @static
     * @memberOf fabric.Color
     * @param {String} color Color value ex: FF5555
     * @return {fabric.Color}
     */
    fabric.Color.fromHex = function(color) {
      return Color.fromSource(Color.sourceFromHex(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
     * @static
     * @memberOf fabric.Color
     * @param {String} color ex: FF5555 or FF5544CC (RGBa)
     * @return {Array} source
     */
    fabric.Color.sourceFromHex = function(color) {
      if (color.match(Color.reHex)) {
        var value = color.slice(color.indexOf('#') + 1),
            isShortNotation = (value.length === 3 || value.length === 4),
            isRGBa = (value.length === 8 || value.length === 4),
            r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
            g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
            b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
            a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

        return [
          parseInt(r, 16),
          parseInt(g, 16),
          parseInt(b, 16),
          parseFloat((parseInt(a, 16) / 255).toFixed(2))
        ];
      }
    };

    /**
     * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
     * @static
     * @memberOf fabric.Color
     * @param {Array} source
     * @return {fabric.Color}
     */
    fabric.Color.fromSource = function(source) {
      var oColor = new Color();
      oColor.setSource(source);
      return oColor;
    };

  })( exports );


  (function() {

    /* _FROM_SVG_START_ */
    function getColorStop(el, multiplier) {
      var style = el.getAttribute('style'),
          offset = el.getAttribute('offset') || 0,
          color, colorAlpha, opacity, i;

      // convert percents to absolute values
      offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
      offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
      if (style) {
        var keyValuePairs = style.split(/\s*;\s*/);

        if (keyValuePairs[keyValuePairs.length - 1] === '') {
          keyValuePairs.pop();
        }

        for (i = keyValuePairs.length; i--; ) {

          var split = keyValuePairs[i].split(/\s*:\s*/),
              key = split[0].trim(),
              value = split[1].trim();

          if (key === 'stop-color') {
            color = value;
          }
          else if (key === 'stop-opacity') {
            opacity = value;
          }
        }
      }

      if (!color) {
        color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
      }
      if (!opacity) {
        opacity = el.getAttribute('stop-opacity');
      }

      color = new fabric.Color(color);
      colorAlpha = color.getAlpha();
      opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
      opacity *= colorAlpha * multiplier;

      return {
        offset: offset,
        color: color.toRgb(),
        opacity: opacity
      };
    }

    function getLinearCoords(el) {
      return {
        x1: el.getAttribute('x1') || 0,
        y1: el.getAttribute('y1') || 0,
        x2: el.getAttribute('x2') || '100%',
        y2: el.getAttribute('y2') || 0
      };
    }

    function getRadialCoords(el) {
      return {
        x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
        y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
        r1: 0,
        x2: el.getAttribute('cx') || '50%',
        y2: el.getAttribute('cy') || '50%',
        r2: el.getAttribute('r') || '50%'
      };
    }
    /* _FROM_SVG_END_ */

    var clone = fabric.util.object.clone;

    /**
     * Gradient class
     * @class fabric.Gradient
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
     * @see {@link fabric.Gradient#initialize} for constructor definition
     */
    fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

      /**
       * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
       * @type Number
       * @default 0
       */
      offsetX: 0,

      /**
       * Vertical offset for aligning gradients coming from SVG when outside pathgroups
       * @type Number
       * @default 0
       */
      offsetY: 0,

      /**
       * A transform matrix to apply to the gradient before painting.
       * Imported from svg gradients, is not applied with the current transform in the center.
       * Before this transform is applied, the origin point is at the top left corner of the object
       * plus the addition of offsetY and offsetX.
       * @type Number[]
       * @default null
       */
      gradientTransform: null,

      /**
       * coordinates units for coords.
       * If `pixels`, the number of coords are in the same unit of width / height.
       * If set as `percentage` the coords are still a number, but 1 means 100% of width
       * for the X and 100% of the height for the y. It can be bigger than 1 and negative.
       * allowed values pixels or percentage.
       * @type String
       * @default 'pixels'
       */
      gradientUnits: 'pixels',

      /**
       * Gradient type linear or radial
       * @type String
       * @default 'pixels'
       */
      type: 'linear',

      /**
       * Constructor
       * @param {Object} options Options object with type, coords, gradientUnits and colorStops
       * @param {Object} [options.type] gradient type linear or radial
       * @param {Object} [options.gradientUnits] gradient units
       * @param {Object} [options.offsetX] SVG import compatibility
       * @param {Object} [options.offsetY] SVG import compatibility
       * @param {Object[]} options.colorStops contains the colorstops.
       * @param {Object} options.coords contains the coords of the gradient
       * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial
       * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial
       * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial
       * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial
       * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle
       * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle
       * @return {fabric.Gradient} thisArg
       */
      initialize: function(options) {
        options || (options = { });
        options.coords || (options.coords = { });

        var coords, _this = this;

        // sets everything, then coords and colorstops get sets again
        Object.keys(options).forEach(function(option) {
          _this[option] = options[option];
        });

        if (this.id) {
          this.id += '_' + fabric.Object.__uid++;
        }
        else {
          this.id = fabric.Object.__uid++;
        }

        coords = {
          x1: options.coords.x1 || 0,
          y1: options.coords.y1 || 0,
          x2: options.coords.x2 || 0,
          y2: options.coords.y2 || 0
        };

        if (this.type === 'radial') {
          coords.r1 = options.coords.r1 || 0;
          coords.r2 = options.coords.r2 || 0;
        }

        this.coords = coords;
        this.colorStops = options.colorStops.slice();
      },

      /**
       * Adds another colorStop
       * @param {Object} colorStop Object with offset and color
       * @return {fabric.Gradient} thisArg
       */
      addColorStop: function(colorStops) {
        for (var position in colorStops) {
          var color = new fabric.Color(colorStops[position]);
          this.colorStops.push({
            offset: parseFloat(position),
            color: color.toRgb(),
            opacity: color.getAlpha()
          });
        }
        return this;
      },

      /**
       * Returns object representation of a gradient
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object}
       */
      toObject: function(propertiesToInclude) {
        var object = {
          type: this.type,
          coords: this.coords,
          colorStops: this.colorStops,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          gradientUnits: this.gradientUnits,
          gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
        };
        fabric.util.populateWithProperties(this, object, propertiesToInclude);

        return object;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an gradient
       * @param {Object} object Object to create a gradient for
       * @return {String} SVG representation of an gradient (linear/radial)
       */
      toSVG: function(object, options) {
        var coords = clone(this.coords, true), i, len, options = options || {},
            markup, commonAttributes, colorStops = clone(this.colorStops, true),
            needsSwap = coords.r1 > coords.r2,
            transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(),
            offsetX = -this.offsetX, offsetY = -this.offsetY,
            withViewport = !!options.additionalTransform,
            gradientUnits = this.gradientUnits === 'pixels' ? 'userSpaceOnUse' : 'objectBoundingBox';
        // colorStops must be sorted ascending
        colorStops.sort(function(a, b) {
          return a.offset - b.offset;
        });

        if (gradientUnits === 'objectBoundingBox') {
          offsetX /= object.width;
          offsetY /= object.height;
        }
        else {
          offsetX += object.width / 2;
          offsetY += object.height / 2;
        }
        if (object.type === 'path') {
          offsetX -= object.pathOffset.x;
          offsetY -= object.pathOffset.y;
        }


        transform[4] -= offsetX;
        transform[5] -= offsetY;

        commonAttributes = 'id="SVGID_' + this.id +
                       '" gradientUnits="' + gradientUnits + '"';
        commonAttributes += ' gradientTransform="' + (withViewport ?
          options.additionalTransform + ' ' : '') + fabric.util.matrixToSVG(transform) + '" ';

        if (this.type === 'linear') {
          markup = [
            '<linearGradient ',
            commonAttributes,
            ' x1="', coords.x1,
            '" y1="', coords.y1,
            '" x2="', coords.x2,
            '" y2="', coords.y2,
            '">\n'
          ];
        }
        else if (this.type === 'radial') {
          // svg radial gradient has just 1 radius. the biggest.
          markup = [
            '<radialGradient ',
            commonAttributes,
            ' cx="', needsSwap ? coords.x1 : coords.x2,
            '" cy="', needsSwap ? coords.y1 : coords.y2,
            '" r="', needsSwap ? coords.r1 : coords.r2,
            '" fx="', needsSwap ? coords.x2 : coords.x1,
            '" fy="', needsSwap ? coords.y2 : coords.y1,
            '">\n'
          ];
        }

        if (this.type === 'radial') {
          if (needsSwap) {
            // svg goes from internal to external radius. if radius are inverted, swap color stops.
            colorStops = colorStops.concat();
            colorStops.reverse();
            for (i = 0, len = colorStops.length; i < len; i++) {
              colorStops[i].offset = 1 - colorStops[i].offset;
            }
          }
          var minRadius = Math.min(coords.r1, coords.r2);
          if (minRadius > 0) {
            // i have to shift all colorStops and add new one in 0.
            var maxRadius = Math.max(coords.r1, coords.r2),
                percentageShift = minRadius / maxRadius;
            for (i = 0, len = colorStops.length; i < len; i++) {
              colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
            }
          }
        }

        for (i = 0, len = colorStops.length; i < len; i++) {
          var colorStop = colorStops[i];
          markup.push(
            '<stop ',
            'offset="', (colorStop.offset * 100) + '%',
            '" style="stop-color:', colorStop.color,
            (typeof colorStop.opacity !== 'undefined' ? ';stop-opacity: ' + colorStop.opacity : ';'),
            '"/>\n'
          );
        }

        markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

        return markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns an instance of CanvasGradient
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {fabric.Object} object the fabric.Object for which the gradient is
       * @return {CanvasGradient}
       */
      toLive: function(ctx, object) {
        var gradient, coords = fabric.util.object.clone(this.coords), i, len,
            x1 = coords.x1, y1 = coords.y1, x2 = coords.x2, y2 = coords.y2,
            stops = this.colorStops;

        if (!this.type) {
          return;
        }

        if (object instanceof fabric.Text && this.gradientUnits === 'percentage') {
          x1 *= object.width;
          y1 *= object.height;
          x2 *= object.width;
          y2 *= object.height;
        }
        if (this.type === 'linear') {
          gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        else if (this.type === 'radial') {
          gradient = ctx.createRadialGradient(x1, y1, coords.r1, x2, y2, coords.r2);
        }
        for (i = 0, len = stops.length; i < len; i++) {
          var color = stops[i].color,
              opacity = stops[i].opacity,
              offset = stops[i].offset;

          if (typeof opacity !== 'undefined') {
            color = new fabric.Color(color).setAlpha(opacity).toRgba();
          }
          gradient.addColorStop(offset, color);
        }

        return gradient;
      }
    });

    fabric.util.object.extend(fabric.Gradient, {

      /* _FROM_SVG_START_ */
      /**
       * Returns {@link fabric.Gradient} instance from an SVG element
       * @static
       * @memberOf fabric.Gradient
       * @param {SVGGradientElement} el SVG gradient element
       * @param {fabric.Object} instance
       * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.
       * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly graidents
       * that uses gradientUnits as 'userSpaceOnUse' and percentages.
       * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg
       * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg
       * @param {Object.number} width width part of the svg tag if viewBox is not specified
       * @param {Object.number} height height part of the svg tag if viewBox is not specified
       * @return {fabric.Gradient} Gradient instance
       * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
       * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
       */
      fromElement: function(el, instance, opacityAttr, svgOptions) {
        /**
         *  @example:
         *
         *  <linearGradient id="linearGrad1">
         *    <stop offset="0%" stop-color="white"/>
         *    <stop offset="100%" stop-color="black"/>
         *  </linearGradient>
         *
         *  OR
         *
         *  <linearGradient id="linearGrad2">
         *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
         *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
         *  </linearGradient>
         *
         *  OR
         *
         *  <radialGradient id="radialGrad1">
         *    <stop offset="0%" stop-color="white" stop-opacity="1" />
         *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
         *    <stop offset="100%" stop-color="white" stop-opacity="1" />
         *  </radialGradient>
         *
         *  OR
         *
         *  <radialGradient id="radialGrad2">
         *    <stop offset="0" stop-color="rgb(255,255,255)" />
         *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
         *    <stop offset="1" stop-color="rgb(255,255,255)" />
         *  </radialGradient>
         *
         */

        var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);
        multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;
        if (isNaN(multiplier)) {
          multiplier = 1;
        }

        var colorStopEls = el.getElementsByTagName('stop'),
            type,
            gradientUnits = el.getAttribute('gradientUnits') === 'userSpaceOnUse' ?
              'pixels' : 'percentage',
            gradientTransform = el.getAttribute('gradientTransform') || '',
            colorStops = [],
            coords, i, offsetX = 0, offsetY = 0,
            transformMatrix;
        if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
          type = 'linear';
          coords = getLinearCoords(el);
        }
        else {
          type = 'radial';
          coords = getRadialCoords(el);
        }

        for (i = colorStopEls.length; i--; ) {
          colorStops.push(getColorStop(colorStopEls[i], multiplier));
        }

        transformMatrix = fabric.parseTransformAttribute(gradientTransform);

        __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);

        if (gradientUnits === 'pixels') {
          offsetX = -instance.left;
          offsetY = -instance.top;
        }

        var gradient = new fabric.Gradient({
          id: el.getAttribute('id'),
          type: type,
          coords: coords,
          colorStops: colorStops,
          gradientUnits: gradientUnits,
          gradientTransform: transformMatrix,
          offsetX: offsetX,
          offsetY: offsetY,
        });

        return gradient;
      },
      /* _FROM_SVG_END_ */

      /**
       * Returns {@link fabric.Gradient} instance from its object representation
       * this function is uniquely used by Object.setGradient and is deprecated with it.
       * @static
       * @deprecated since 3.4.0
       * @memberOf fabric.Gradient
       * @param {Object} obj
       * @param {Object} [options] Options object
       */
      forObject: function(obj, options) {
        options || (options = { });
        __convertPercentUnitsToValues(obj, options.coords, options.gradientUnits, {
          // those values are to avoid errors. this function is uniquely used by
          viewBoxWidth: 100,
          viewBoxHeight: 100,
        });
        return new fabric.Gradient(options);
      }
    });

    /**
     * @private
     */
    function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {
      var propValue, finalValue;
      Object.keys(options).forEach(function(prop) {
        propValue = options[prop];
        if (propValue === 'Infinity') {
          finalValue = 1;
        }
        else if (propValue === '-Infinity') {
          finalValue = 0;
        }
        else {
          finalValue = parseFloat(options[prop], 10);
          if (typeof propValue === 'string' && /^(\d+\.\d+)%|(\d+)%$/.test(propValue)) {
            finalValue *= 0.01;
            if (gradientUnits === 'pixels') {
              // then we need to fix those percentages here in svg parsing
              if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
                finalValue *= svgOptions.viewBoxWidth || svgOptions.width;
              }
              if (prop === 'y1' || prop === 'y2') {
                finalValue *= svgOptions.viewBoxHeight || svgOptions.height;
              }
            }
          }
        }
        options[prop] = finalValue;
      });
    }
  })();


  (function() {

    var toFixed = fabric.util.toFixed;

    /**
     * Pattern class
     * @class fabric.Pattern
     * @see {@link http://fabricjs.com/patterns|Pattern demo}
     * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
     * @see {@link fabric.Pattern#initialize} for constructor definition
     */


    fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

      /**
       * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
       * @type String
       * @default
       */
      repeat: 'repeat',

      /**
       * Pattern horizontal offset from object's left/top corner
       * @type Number
       * @default
       */
      offsetX: 0,

      /**
       * Pattern vertical offset from object's left/top corner
       * @type Number
       * @default
       */
      offsetY: 0,

      /**
       * crossOrigin value (one of "", "anonymous", "use-credentials")
       * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
       * @type String
       * @default
       */
      crossOrigin: '',

      /**
       * transform matrix to change the pattern, imported from svgs.
       * @type Array
       * @default
       */
      patternTransform: null,

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @param {Function} [callback] function to invoke after callback init.
       * @return {fabric.Pattern} thisArg
       */
      initialize: function(options, callback) {
        options || (options = { });

        this.id = fabric.Object.__uid++;
        this.setOptions(options);
        if (!options.source || (options.source && typeof options.source !== 'string')) {
          callback && callback(this);
          return;
        }
        // function string
        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
          this.source = new Function(fabric.util.getFunctionBody(options.source));
          callback && callback(this);
        }
        else {
          // img src string
          var _this = this;
          this.source = fabric.util.createImage();
          fabric.util.loadImage(options.source, function(img) {
            _this.source = img;
            callback && callback(_this);
          }, null, this.crossOrigin);
        }
      },

      /**
       * Returns object representation of a pattern
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of a pattern instance
       */
      toObject: function(propertiesToInclude) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
            source, object;

        // callback
        if (typeof this.source === 'function') {
          source = String(this.source);
        }
        // <img> element
        else if (typeof this.source.src === 'string') {
          source = this.source.src;
        }
        // <canvas> element
        else if (typeof this.source === 'object' && this.source.toDataURL) {
          source = this.source.toDataURL();
        }

        object = {
          type: 'pattern',
          source: source,
          repeat: this.repeat,
          crossOrigin: this.crossOrigin,
          offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
          offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
          patternTransform: this.patternTransform ? this.patternTransform.concat() : null
        };
        fabric.util.populateWithProperties(this, object, propertiesToInclude);

        return object;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of a pattern
       * @param {fabric.Object} object
       * @return {String} SVG representation of a pattern
       */
      toSVG: function(object) {
        var patternSource = typeof this.source === 'function' ? this.source() : this.source,
            patternWidth = patternSource.width / object.width,
            patternHeight = patternSource.height / object.height,
            patternOffsetX = this.offsetX / object.width,
            patternOffsetY = this.offsetY / object.height,
            patternImgSrc = '';
        if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
          patternHeight = 1;
          if (patternOffsetY) {
            patternHeight += Math.abs(patternOffsetY);
          }
        }
        if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
          patternWidth = 1;
          if (patternOffsetX) {
            patternWidth += Math.abs(patternOffsetX);
          }

        }
        if (patternSource.src) {
          patternImgSrc = patternSource.src;
        }
        else if (patternSource.toDataURL) {
          patternImgSrc = patternSource.toDataURL();
        }

        return '<pattern id="SVGID_' + this.id +
                      '" x="' + patternOffsetX +
                      '" y="' + patternOffsetY +
                      '" width="' + patternWidth +
                      '" height="' + patternHeight + '">\n' +
                 '<image x="0" y="0"' +
                        ' width="' + patternSource.width +
                        '" height="' + patternSource.height +
                        '" xlink:href="' + patternImgSrc +
                 '"></image>\n' +
               '</pattern>\n';
      },
      /* _TO_SVG_END_ */

      setOptions: function(options) {
        for (var prop in options) {
          this[prop] = options[prop];
        }
      },

      /**
       * Returns an instance of CanvasPattern
       * @param {CanvasRenderingContext2D} ctx Context to create pattern
       * @return {CanvasPattern}
       */
      toLive: function(ctx) {
        var source = typeof this.source === 'function' ? this.source() : this.source;

        // if the image failed to load, return, and allow rest to continue loading
        if (!source) {
          return '';
        }

        // if an image
        if (typeof source.src !== 'undefined') {
          if (!source.complete) {
            return '';
          }
          if (source.naturalWidth === 0 || source.naturalHeight === 0) {
            return '';
          }
        }
        return ctx.createPattern(source, this.repeat);
      }
    });
  })();


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        toFixed = fabric.util.toFixed;

    if (fabric.Shadow) {
      fabric.warn('fabric.Shadow is already defined.');
      return;
    }

    /**
     * Shadow class
     * @class fabric.Shadow
     * @see {@link http://fabricjs.com/shadows|Shadow demo}
     * @see {@link fabric.Shadow#initialize} for constructor definition
     */
    fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

      /**
       * Shadow color
       * @type String
       * @default
       */
      color: 'rgb(0,0,0)',

      /**
       * Shadow blur
       * @type Number
       */
      blur: 0,

      /**
       * Shadow horizontal offset
       * @type Number
       * @default
       */
      offsetX: 0,

      /**
       * Shadow vertical offset
       * @type Number
       * @default
       */
      offsetY: 0,

      /**
       * Whether the shadow should affect stroke operations
       * @type Boolean
       * @default
       */
      affectStroke: false,

      /**
       * Indicates whether toObject should include default values
       * @type Boolean
       * @default
       */
      includeDefaultValues: true,

      /**
       * When `false`, the shadow will scale with the object.
       * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.
       * default to false
       * @type Boolean
       * @default
       */
      nonScaling: false,

      /**
       * Constructor
       * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
       * @return {fabric.Shadow} thisArg
       */
      initialize: function(options) {

        if (typeof options === 'string') {
          options = this._parseShadow(options);
        }

        for (var prop in options) {
          this[prop] = options[prop];
        }

        this.id = fabric.Object.__uid++;
      },

      /**
       * @private
       * @param {String} shadow Shadow value to parse
       * @return {Object} Shadow object with color, offsetX, offsetY and blur
       */
      _parseShadow: function(shadow) {
        var shadowStr = shadow.trim(),
            offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
            color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

        return {
          color: color.trim(),
          offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
          offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
          blur: parseInt(offsetsAndBlur[3], 10) || 0
        };
      },

      /**
       * Returns a string representation of an instance
       * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
       * @return {String} Returns CSS3 text-shadow declaration
       */
      toString: function() {
        return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of a shadow
       * @param {fabric.Object} object
       * @return {String} SVG representation of a shadow
       */
      toSVG: function(object) {
        var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
            offset = fabric.util.rotateVector(
              { x: this.offsetX, y: this.offsetY },
              fabric.util.degreesToRadians(-object.angle)),
            BLUR_BOX = 20, color = new fabric.Color(this.color);

        if (object.width && object.height) {
          //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
          // we add some extra space to filter box to contain the blur ( 20 )
          fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
          fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        }
        if (object.flipX) {
          offset.x *= -1;
        }
        if (object.flipY) {
          offset.y *= -1;
        }

        return (
          '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
            'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
            '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
              toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
            '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
            '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
            '\t<feFlood flood-color="' + color.toRgb() + '" flood-opacity="' + color.getAlpha() + '"/>\n' +
            '\t<feComposite in2="oBlur" operator="in" />\n' +
            '\t<feMerge>\n' +
              '\t\t<feMergeNode></feMergeNode>\n' +
              '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
            '\t</feMerge>\n' +
          '</filter>\n');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns object representation of a shadow
       * @return {Object} Object representation of a shadow instance
       */
      toObject: function() {
        if (this.includeDefaultValues) {
          return {
            color: this.color,
            blur: this.blur,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            affectStroke: this.affectStroke,
            nonScaling: this.nonScaling
          };
        }
        var obj = { }, proto = fabric.Shadow.prototype;

        ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke', 'nonScaling'].forEach(function(prop) {
          if (this[prop] !== proto[prop]) {
            obj[prop] = this[prop];
          }
        }, this);

        return obj;
      }
    });

    /**
     * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
     * @static
     * @field
     * @memberOf fabric.Shadow
     */
    // eslint-disable-next-line max-len
    fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;

  })( exports );


  (function () {

    if (fabric.StaticCanvas) {
      fabric.warn('fabric.StaticCanvas is already defined.');
      return;
    }

    // aliases for faster resolution
    var extend = fabric.util.object.extend,
        getElementOffset = fabric.util.getElementOffset,
        removeFromArray = fabric.util.removeFromArray,
        toFixed = fabric.util.toFixed,
        transformPoint = fabric.util.transformPoint,
        invertTransform = fabric.util.invertTransform,
        getNodeCanvas = fabric.util.getNodeCanvas,
        createCanvasElement = fabric.util.createCanvasElement,

        CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

    /**
     * Static canvas class
     * @class fabric.StaticCanvas
     * @mixes fabric.Collection
     * @mixes fabric.Observable
     * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
     * @see {@link fabric.StaticCanvas#initialize} for constructor definition
     * @fires before:render
     * @fires after:render
     * @fires canvas:cleared
     * @fires object:added
     * @fires object:removed
     */
    fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

      /**
       * Constructor
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(el, options) {
        options || (options = { });
        this.renderAndResetBound = this.renderAndReset.bind(this);
        this.requestRenderAllBound = this.requestRenderAll.bind(this);
        this._initStatic(el, options);
      },

      /**
       * Background color of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
       * @type {(String|fabric.Pattern)}
       * @default
       */
      backgroundColor: '',

      /**
       * Background image of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
       * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
       * and "backgroundImageStretch" properties are deprecated since 1.3.9.
       * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
       * since 2.4.0 image caching is active, please when putting an image as background, add to the
       * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
       * vale. As an alternative you can disable image objectCaching
       * @type fabric.Image
       * @default
       */
      backgroundImage: null,

      /**
       * Overlay color of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
       * @since 1.3.9
       * @type {(String|fabric.Pattern)}
       * @default
       */
      overlayColor: '',

      /**
       * Overlay image of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
       * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
       * and "overlayImageTop" properties are deprecated since 1.3.9.
       * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
       * since 2.4.0 image caching is active, please when putting an image as overlay, add to the
       * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
       * vale. As an alternative you can disable image objectCaching
       * @type fabric.Image
       * @default
       */
      overlayImage: null,

      /**
       * Indicates whether toObject/toDatalessObject should include default values
       * if set to false, takes precedence over the object value.
       * @type Boolean
       * @default
       */
      includeDefaultValues: true,

      /**
       * Indicates whether objects' state should be saved
       * @type Boolean
       * @default
       */
      stateful: false,

      /**
       * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
       * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
       * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
       * since the renders are quequed and executed one per frame.
       * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
       * Left default to true to do not break documentation and old app, fiddles.
       * @type Boolean
       * @default
       */
      renderOnAddRemove: true,

      /**
       * Function that determines clipping of entire canvas area
       * Being passed context as first argument.
       * If you are using code minification, ctx argument can be minified/manglied you should use
       * as a workaround `var ctx = arguments[0];` in the function;
       * See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
       * @deprecated since 2.0.0
       * @type Function
       * @default
       */
      clipTo: null,

      /**
       * Indicates whether object controls (borders/controls) are rendered above overlay image
       * @type Boolean
       * @default
       */
      controlsAboveOverlay: false,

      /**
       * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
       * @type Boolean
       * @default
       */
      allowTouchScrolling: false,

      /**
       * Indicates whether this canvas will use image smoothing, this is on by default in browsers
       * @type Boolean
       * @default
       */
      imageSmoothingEnabled: true,

      /**
       * The transformation (in the format of Canvas transform) which focuses the viewport
       * @type Array
       * @default
       */
      viewportTransform: fabric.iMatrix.concat(),

      /**
       * if set to false background image is not affected by viewport transform
       * @since 1.6.3
       * @type Boolean
       * @default
       */
      backgroundVpt: true,

      /**
       * if set to false overlya image is not affected by viewport transform
       * @since 1.6.3
       * @type Boolean
       * @default
       */
      overlayVpt: true,

      /**
       * Callback; invoked right before object is about to be scaled/rotated
       * @deprecated since 2.3.0
       * Use before:transform event
       */
      onBeforeScaleRotate: function () {
        /* NOOP */
      },

      /**
       * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
       * @type Boolean
       * @default
       */
      enableRetinaScaling: true,

      /**
       * Describe canvas element extension over design
       * properties are tl,tr,bl,br.
       * if canvas is not zoomed/panned those points are the four corner of canvas
       * if canvas is viewportTransformed you those points indicate the extension
       * of canvas element in plain untrasformed coordinates
       * The coordinates get updated with @method calcViewportBoundaries.
       * @memberOf fabric.StaticCanvas.prototype
       */
      vptCoords: { },

      /**
       * Based on vptCoords and object.aCoords, skip rendering of objects that
       * are not included in current viewport.
       * May greatly help in applications with crowded canvas and use of zoom/pan
       * If One of the corner of the bounding box of the object is on the canvas
       * the objects get rendered.
       * @memberOf fabric.StaticCanvas.prototype
       * @type Boolean
       * @default
       */
      skipOffscreen: true,

      /**
       * a fabricObject that, without stroke define a clipping area with their shape. filled in black
       * the clipPath object gets used when the canvas has rendered, and the context is placed in the
       * top left corner of the canvas.
       * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true
       * @type fabric.Object
       */
      clipPath: undefined,

      /**
       * @private
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       */
      _initStatic: function(el, options) {
        var cb = this.requestRenderAllBound;
        this._objects = [];
        this._createLowerCanvas(el);
        this._initOptions(options);
        this._setImageSmoothing();
        // only initialize retina scaling once
        if (!this.interactive) {
          this._initRetinaScaling();
        }

        if (options.overlayImage) {
          this.setOverlayImage(options.overlayImage, cb);
        }
        if (options.backgroundImage) {
          this.setBackgroundImage(options.backgroundImage, cb);
        }
        if (options.backgroundColor) {
          this.setBackgroundColor(options.backgroundColor, cb);
        }
        if (options.overlayColor) {
          this.setOverlayColor(options.overlayColor, cb);
        }
        this.calcOffset();
      },

      /**
       * @private
       */
      _isRetinaScaling: function() {
        return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
      },

      /**
       * @private
       * @return {Number} retinaScaling if applied, otherwise 1;
       */
      getRetinaScaling: function() {
        return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
      },

      /**
       * @private
       */
      _initRetinaScaling: function() {
        if (!this._isRetinaScaling()) {
          return;
        }
        var scaleRatio = fabric.devicePixelRatio;
        this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);
        if (this.upperCanvasEl) {
          this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);
        }
      },

      __initRetinaScaling: function(scaleRatio, canvas, context) {
        canvas.setAttribute('width', this.width * scaleRatio);
        canvas.setAttribute('height', this.height * scaleRatio);
        context.scale(scaleRatio, scaleRatio);
      },


      /**
       * Calculates canvas element offset relative to the document
       * This method is also attached as "resize" event handler of window
       * @return {fabric.Canvas} instance
       * @chainable
       */
      calcOffset: function () {
        this._offset = getElementOffset(this.lowerCanvasEl);
        return this;
      },

      /**
       * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
       * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
       * @param {Function} callback callback to invoke when image is loaded and set as an overlay
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
       * @example <caption>Normal overlayImage with left/top = 0</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   // Needed to position overlayImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>overlayImage with different properties</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
       * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
       *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
       *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
       * });
       * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   width: canvas.width,
       *   height: canvas.height,
       *   // Needed to position overlayImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>overlayImage loaded from cross-origin</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top',
       *   crossOrigin: 'anonymous'
       * });
       */
      setOverlayImage: function (image, callback, options) {
        return this.__setBgOverlayImage('overlayImage', image, callback, options);
      },

      /**
       * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
       * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
       * @param {Function} callback Callback to invoke when image is loaded and set as background
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
       * @example <caption>Normal backgroundImage with left/top = 0</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   // Needed to position backgroundImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>backgroundImage with different properties</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
       * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
       *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
       *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
       * });
       * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   width: canvas.width,
       *   height: canvas.height,
       *   // Needed to position backgroundImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>backgroundImage loaded from cross-origin</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top',
       *   crossOrigin: 'anonymous'
       * });
       */
      // TODO: fix stretched examples
      setBackgroundImage: function (image, callback, options) {
        return this.__setBgOverlayImage('backgroundImage', image, callback, options);
      },

      /**
       * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
       * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
       * @param {Function} callback Callback to invoke when foreground color is set
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
       * @example <caption>Normal overlayColor - color value</caption>
       * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as overlayColor</caption>
       * canvas.setOverlayColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
       * }, canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
       * canvas.setOverlayColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
       *   repeat: 'repeat',
       *   offsetX: 200,
       *   offsetY: 100
       * }, canvas.renderAll.bind(canvas));
       */
      setOverlayColor: function(overlayColor, callback) {
        return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
      },

      /**
       * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
       * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
       * @param {Function} callback Callback to invoke when background color is set
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
       * @example <caption>Normal backgroundColor - color value</caption>
       * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as backgroundColor</caption>
       * canvas.setBackgroundColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
       * }, canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
       * canvas.setBackgroundColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
       *   repeat: 'repeat',
       *   offsetX: 200,
       *   offsetY: 100
       * }, canvas.renderAll.bind(canvas));
       */
      setBackgroundColor: function(backgroundColor, callback) {
        return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
      },

      /**
       * @private
       * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
       */
      _setImageSmoothing: function() {
        var ctx = this.getContext();

        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
          || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
        ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
      },

      /**
       * @private
       * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
       * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
       * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
       * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
       */
      __setBgOverlayImage: function(property, image, callback, options) {
        if (typeof image === 'string') {
          fabric.util.loadImage(image, function(img) {
            if (img) {
              var instance = new fabric.Image(img, options);
              this[property] = instance;
              instance.canvas = this;
            }
            callback && callback(img);
          }, this, options && options.crossOrigin);
        }
        else {
          options && image.setOptions(options);
          this[property] = image;
          image && (image.canvas = this);
          callback && callback(image);
        }

        return this;
      },

      /**
       * @private
       * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
       * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
       * @param {(Object|String|null)} color Object with pattern information, color value or null
       * @param {Function} [callback] Callback is invoked when color is set
       */
      __setBgOverlayColor: function(property, color, callback) {
        this[property] = color;
        this._initGradient(color, property);
        this._initPattern(color, property, callback);
        return this;
      },

      /**
       * @private
       */
      _createCanvasElement: function() {
        var element = createCanvasElement();
        if (!element) {
          throw CANVAS_INIT_ERROR;
        }
        if (!element.style) {
          element.style = { };
        }
        if (typeof element.getContext === 'undefined') {
          throw CANVAS_INIT_ERROR;
        }
        return element;
      },

      /**
       * @private
       * @param {Object} [options] Options object
       */
      _initOptions: function (options) {
        var lowerCanvasEl = this.lowerCanvasEl;
        this._setOptions(options);

        this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;
        this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;

        if (!this.lowerCanvasEl.style) {
          return;
        }

        lowerCanvasEl.width = this.width;
        lowerCanvasEl.height = this.height;

        lowerCanvasEl.style.width = this.width + 'px';
        lowerCanvasEl.style.height = this.height + 'px';

        this.viewportTransform = this.viewportTransform.slice();
      },

      /**
       * Creates a bottom canvas
       * @private
       * @param {HTMLElement} [canvasEl]
       */
      _createLowerCanvas: function (canvasEl) {
        // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
        if (canvasEl && canvasEl.getContext) {
          this.lowerCanvasEl = canvasEl;
        }
        else {
          this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
        }

        fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');

        if (this.interactive) {
          this._applyCanvasStyle(this.lowerCanvasEl);
        }

        this.contextContainer = this.lowerCanvasEl.getContext('2d');
      },

      /**
       * Returns canvas width (in px)
       * @return {Number}
       */
      getWidth: function () {
        return this.width;
      },

      /**
       * Returns canvas height (in px)
       * @return {Number}
       */
      getHeight: function () {
        return this.height;
      },

      /**
       * Sets width of this canvas instance
       * @param {Number|String} value                         Value to set width to
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setWidth: function (value, options) {
        return this.setDimensions({ width: value }, options);
      },

      /**
       * Sets height of this canvas instance
       * @param {Number|String} value                         Value to set height to
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setHeight: function (value, options) {
        return this.setDimensions({ height: value }, options);
      },

      /**
       * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
       * @param {Object}        dimensions                    Object with width/height properties
       * @param {Number|String} [dimensions.width]            Width of canvas element
       * @param {Number|String} [dimensions.height]           Height of canvas element
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      setDimensions: function (dimensions, options) {
        var cssValue;

        options = options || {};

        for (var prop in dimensions) {
          cssValue = dimensions[prop];

          if (!options.cssOnly) {
            this._setBackstoreDimension(prop, dimensions[prop]);
            cssValue += 'px';
            this.hasLostContext = true;
          }

          if (!options.backstoreOnly) {
            this._setCssDimension(prop, cssValue);
          }
        }
        if (this._isCurrentlyDrawing) {
          this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles();
        }
        this._initRetinaScaling();
        this._setImageSmoothing();
        this.calcOffset();

        if (!options.cssOnly) {
          this.requestRenderAll();
        }

        return this;
      },

      /**
       * Helper for setting width/height
       * @private
       * @param {String} prop property (width|height)
       * @param {Number} value value to set property to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      _setBackstoreDimension: function (prop, value) {
        this.lowerCanvasEl[prop] = value;

        if (this.upperCanvasEl) {
          this.upperCanvasEl[prop] = value;
        }

        if (this.cacheCanvasEl) {
          this.cacheCanvasEl[prop] = value;
        }

        this[prop] = value;

        return this;
      },

      /**
       * Helper for setting css width/height
       * @private
       * @param {String} prop property (width|height)
       * @param {String} value value to set property to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      _setCssDimension: function (prop, value) {
        this.lowerCanvasEl.style[prop] = value;

        if (this.upperCanvasEl) {
          this.upperCanvasEl.style[prop] = value;
        }

        if (this.wrapperEl) {
          this.wrapperEl.style[prop] = value;
        }

        return this;
      },

      /**
       * Returns canvas zoom level
       * @return {Number}
       */
      getZoom: function () {
        return this.viewportTransform[0];
      },

      /**
       * Sets viewport transform of this canvas instance
       * @param {Array} vpt the transform in the form of context.transform
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setViewportTransform: function (vpt) {
        var activeObject = this._activeObject, object, ignoreVpt = false, skipAbsolute = true, i, len;
        this.viewportTransform = vpt;
        for (i = 0, len = this._objects.length; i < len; i++) {
          object = this._objects[i];
          object.group || object.setCoords(ignoreVpt, skipAbsolute);
        }
        if (activeObject && activeObject.type === 'activeSelection') {
          activeObject.setCoords(ignoreVpt, skipAbsolute);
        }
        this.calcViewportBoundaries();
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Sets zoom level of this canvas instance, zoom centered around point
       * @param {fabric.Point} point to zoom with respect to
       * @param {Number} value to set zoom to, less than 1 zooms out
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      zoomToPoint: function (point, value) {
        // TODO: just change the scale, preserve other transformations
        var before = point, vpt = this.viewportTransform.slice(0);
        point = transformPoint(point, invertTransform(this.viewportTransform));
        vpt[0] = value;
        vpt[3] = value;
        var after = transformPoint(point, vpt);
        vpt[4] += before.x - after.x;
        vpt[5] += before.y - after.y;
        return this.setViewportTransform(vpt);
      },

      /**
       * Sets zoom level of this canvas instance
       * @param {Number} value to set zoom to, less than 1 zooms out
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setZoom: function (value) {
        this.zoomToPoint(new fabric.Point(0, 0), value);
        return this;
      },

      /**
       * Pan viewport so as to place point at top left corner of canvas
       * @param {fabric.Point} point to move to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      absolutePan: function (point) {
        var vpt = this.viewportTransform.slice(0);
        vpt[4] = -point.x;
        vpt[5] = -point.y;
        return this.setViewportTransform(vpt);
      },

      /**
       * Pans viewpoint relatively
       * @param {fabric.Point} point (position vector) to move by
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      relativePan: function (point) {
        return this.absolutePan(new fabric.Point(
          -point.x - this.viewportTransform[4],
          -point.y - this.viewportTransform[5]
        ));
      },

      /**
       * Returns &lt;canvas> element corresponding to this instance
       * @return {HTMLCanvasElement}
       */
      getElement: function () {
        return this.lowerCanvasEl;
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was added
       */
      _onObjectAdded: function(obj) {
        this.stateful && obj.setupState();
        obj._set('canvas', this);
        obj.setCoords();
        this.fire('object:added', { target: obj });
        obj.fire('added');
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was removed
       */
      _onObjectRemoved: function(obj) {
        this.fire('object:removed', { target: obj });
        obj.fire('removed');
        delete obj.canvas;
      },

      /**
       * Clears specified context of canvas element
       * @param {CanvasRenderingContext2D} ctx Context to clear
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clearContext: function(ctx) {
        ctx.clearRect(0, 0, this.width, this.height);
        return this;
      },

      /**
       * Returns context of canvas where objects are drawn
       * @return {CanvasRenderingContext2D}
       */
      getContext: function () {
        return this.contextContainer;
      },

      /**
       * Clears all contexts (background, main, top) of an instance
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clear: function () {
        this._objects.length = 0;
        this.backgroundImage = null;
        this.overlayImage = null;
        this.backgroundColor = '';
        this.overlayColor = '';
        if (this._hasITextHandlers) {
          this.off('mouse:up', this._mouseUpITextHandler);
          this._iTextInstances = null;
          this._hasITextHandlers = false;
        }
        this.clearContext(this.contextContainer);
        this.fire('canvas:cleared');
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Renders the canvas
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAll: function () {
        var canvasToDrawOn = this.contextContainer;
        this.renderCanvas(canvasToDrawOn, this._objects);
        return this;
      },

      /**
       * Function created to be instance bound at initialization
       * used in requestAnimationFrame rendering
       * Let the fabricJS call it. If you call it manually you could have more
       * animationFrame stacking on to of each other
       * for an imperative rendering, use canvas.renderAll
       * @private
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAndReset: function() {
        this.isRendering = 0;
        this.renderAll();
      },

      /**
       * Append a renderAll request to next animation frame.
       * unless one is already in progress, in that case nothing is done
       * a boolean flag will avoid appending more.
       * @return {fabric.Canvas} instance
       * @chainable
       */
      requestRenderAll: function () {
        if (!this.isRendering) {
          this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
        }
        return this;
      },

      /**
       * Calculate the position of the 4 corner of canvas with current viewportTransform.
       * helps to determinate when an object is in the current rendering viewport using
       * object absolute coordinates ( aCoords )
       * @return {Object} points.tl
       * @chainable
       */
      calcViewportBoundaries: function() {
        var points = { }, width = this.width, height = this.height,
            iVpt = invertTransform(this.viewportTransform);
        points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
        points.br = transformPoint({ x: width, y: height }, iVpt);
        points.tr = new fabric.Point(points.br.x, points.tl.y);
        points.bl = new fabric.Point(points.tl.x, points.br.y);
        this.vptCoords = points;
        return points;
      },

      cancelRequestedRender: function() {
        if (this.isRendering) {
          fabric.util.cancelAnimFrame(this.isRendering);
          this.isRendering = 0;
        }
      },

      /**
       * Renders background, objects, overlay and controls.
       * @param {CanvasRenderingContext2D} ctx
       * @param {Array} objects to render
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderCanvas: function(ctx, objects) {
        var v = this.viewportTransform, path = this.clipPath;
        this.cancelRequestedRender();
        this.calcViewportBoundaries();
        this.clearContext(ctx);
        this.fire('before:render', { ctx: ctx, });
        if (this.clipTo) {
          fabric.util.clipContext(this, ctx);
        }
        this._renderBackground(ctx);

        ctx.save();
        //apply viewport transform once for all rendering process
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        this._renderObjects(ctx, objects);
        ctx.restore();
        if (!this.controlsAboveOverlay && this.interactive) {
          this.drawControls(ctx);
        }
        if (this.clipTo) {
          ctx.restore();
        }
        if (path) {
          path.canvas = this;
          // needed to setup a couple of variables
          path.shouldCache();
          path._transformDone = true;
          path.renderCache({ forClipping: true });
          this.drawClipPathOnCanvas(ctx);
        }
        this._renderOverlay(ctx);
        if (this.controlsAboveOverlay && this.interactive) {
          this.drawControls(ctx);
        }
        this.fire('after:render', { ctx: ctx, });
      },

      /**
       * Paint the cached clipPath on the lowerCanvasEl
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawClipPathOnCanvas: function(ctx) {
        var v = this.viewportTransform, path = this.clipPath;
        ctx.save();
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        // DEBUG: uncomment this line, comment the following
        // ctx.globalAlpha = 0.4;
        ctx.globalCompositeOperation = 'destination-in';
        path.transform(ctx);
        ctx.scale(1 / path.zoomX, 1 / path.zoomY);
        ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Array} objects to render
       */
      _renderObjects: function(ctx, objects) {
        var i, len;
        for (i = 0, len = objects.length; i < len; ++i) {
          objects[i] && objects[i].render(ctx);
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {string} property 'background' or 'overlay'
       */
      _renderBackgroundOrOverlay: function(ctx, property) {
        var fill = this[property + 'Color'], object = this[property + 'Image'],
            v = this.viewportTransform, needsVpt = this[property + 'Vpt'];
        if (!fill && !object) {
          return;
        }
        if (fill) {
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(this.width, 0);
          ctx.lineTo(this.width, this.height);
          ctx.lineTo(0, this.height);
          ctx.closePath();
          ctx.fillStyle = fill.toLive
            ? fill.toLive(ctx, this)
            : fill;
          if (needsVpt) {
            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
          }
          ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);
          var m = fill.gradientTransform || fill.patternTransform;
          m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          ctx.fill();
          ctx.restore();
        }
        if (object) {
          ctx.save();
          if (needsVpt) {
            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
          }
          object.render(ctx);
          ctx.restore();
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderBackground: function(ctx) {
        this._renderBackgroundOrOverlay(ctx, 'background');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderOverlay: function(ctx) {
        this._renderBackgroundOrOverlay(ctx, 'overlay');
      },

      /**
       * Returns coordinates of a center of canvas.
       * Returned value is an object with top and left properties
       * @return {Object} object with "top" and "left" number values
       */
      getCenter: function () {
        return {
          top: this.height / 2,
          left: this.width / 2
        };
      },

      /**
       * Centers object horizontally in the canvas
       * @param {fabric.Object} object Object to center horizontally
       * @return {fabric.Canvas} thisArg
       */
      centerObjectH: function (object) {
        return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
      },

      /**
       * Centers object vertically in the canvas
       * @param {fabric.Object} object Object to center vertically
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      centerObjectV: function (object) {
        return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
      },

      /**
       * Centers object vertically and horizontally in the canvas
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      centerObject: function(object) {
        var center = this.getCenter();

        return this._centerObject(object, new fabric.Point(center.left, center.top));
      },

      /**
       * Centers object vertically and horizontally in the viewport
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObject: function(object) {
        var vpCenter = this.getVpCenter();

        return this._centerObject(object, vpCenter);
      },

      /**
       * Centers object horizontally in the viewport, object.top is unchanged
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObjectH: function(object) {
        var vpCenter = this.getVpCenter();
        this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
        return this;
      },

      /**
       * Centers object Vertically in the viewport, object.top is unchanged
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObjectV: function(object) {
        var vpCenter = this.getVpCenter();

        return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
      },

      /**
       * Calculate the point in canvas that correspond to the center of actual viewport.
       * @return {fabric.Point} vpCenter, viewport center
       * @chainable
       */
      getVpCenter: function() {
        var center = this.getCenter(),
            iVpt = invertTransform(this.viewportTransform);
        return transformPoint({ x: center.left, y: center.top }, iVpt);
      },

      /**
       * @private
       * @param {fabric.Object} object Object to center
       * @param {fabric.Point} center Center point
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      _centerObject: function(object, center) {
        object.setPositionByOrigin(center, 'center', 'center');
        object.setCoords();
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Returs dataless JSON representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {String} json string
       */
      toDatalessJSON: function (propertiesToInclude) {
        return this.toDatalessObject(propertiesToInclude);
      },

      /**
       * Returns object representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function (propertiesToInclude) {
        return this._toObjectMethod('toObject', propertiesToInclude);
      },

      /**
       * Returns dataless object representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function (propertiesToInclude) {
        return this._toObjectMethod('toDatalessObject', propertiesToInclude);
      },

      /**
       * @private
       */
      _toObjectMethod: function (methodName, propertiesToInclude) {

        var clipPath = this.clipPath, data = {
          version: fabric.version,
          objects: this._toObjects(methodName, propertiesToInclude),
        };
        if (clipPath) {
          data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);
        }
        extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

        fabric.util.populateWithProperties(this, data, propertiesToInclude);

        return data;
      },

      /**
       * @private
       */
      _toObjects: function(methodName, propertiesToInclude) {
        return this._objects.filter(function(object) {
          return !object.excludeFromExport;
        }).map(function(instance) {
          return this._toObject(instance, methodName, propertiesToInclude);
        }, this);
      },

      /**
       * @private
       */
      _toObject: function(instance, methodName, propertiesToInclude) {
        var originalValue;

        if (!this.includeDefaultValues) {
          originalValue = instance.includeDefaultValues;
          instance.includeDefaultValues = false;
        }

        var object = instance[methodName](propertiesToInclude);
        if (!this.includeDefaultValues) {
          instance.includeDefaultValues = originalValue;
        }
        return object;
      },

      /**
       * @private
       */
      __serializeBgOverlay: function(methodName, propertiesToInclude) {
        var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;

        if (this.backgroundColor) {
          data.background = this.backgroundColor.toObject
            ? this.backgroundColor.toObject(propertiesToInclude)
            : this.backgroundColor;
        }

        if (this.overlayColor) {
          data.overlay = this.overlayColor.toObject
            ? this.overlayColor.toObject(propertiesToInclude)
            : this.overlayColor;
        }
        if (bgImage && !bgImage.excludeFromExport) {
          data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
        }
        if (overlay && !overlay.excludeFromExport) {
          data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);
        }

        return data;
      },

      /* _TO_SVG_START_ */
      /**
       * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
       * a zoomed canvas will then produce zoomed SVG output.
       * @type Boolean
       * @default
       */
      svgViewportTransformation: true,

      /**
       * Returns SVG representation of canvas
       * @function
       * @param {Object} [options] Options object for SVG output
       * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
       * @param {Object} [options.viewBox] SVG viewbox object
       * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
       * @param {Number} [options.viewBox.y] y-coordinate of viewbox
       * @param {Number} [options.viewBox.width] Width of viewbox
       * @param {Number} [options.viewBox.height] Height of viewbox
       * @param {String} [options.encoding=UTF-8] Encoding of SVG output
       * @param {String} [options.width] desired width of svg with or without units
       * @param {String} [options.height] desired height of svg with or without units
       * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
       * @return {String} SVG string
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
       * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
       * @example <caption>Normal SVG output</caption>
       * var svg = canvas.toSVG();
       * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
       * var svg = canvas.toSVG({suppressPreamble: true});
       * @example <caption>SVG output with viewBox attribute</caption>
       * var svg = canvas.toSVG({
       *   viewBox: {
       *     x: 100,
       *     y: 100,
       *     width: 200,
       *     height: 300
       *   }
       * });
       * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
       * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
       * @example <caption>Modify SVG output with reviver function</caption>
       * var svg = canvas.toSVG(null, function(svg) {
       *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
       * });
       */
      toSVG: function(options, reviver) {
        options || (options = { });
        options.reviver = reviver;
        var markup = [];

        this._setSVGPreamble(markup, options);
        this._setSVGHeader(markup, options);
        if (this.clipPath) {
          markup.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n');
        }
        this._setSVGBgOverlayColor(markup, 'background');
        this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);
        this._setSVGObjects(markup, reviver);
        if (this.clipPath) {
          markup.push('</g>\n');
        }
        this._setSVGBgOverlayColor(markup, 'overlay');
        this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

        markup.push('</svg>');

        return markup.join('');
      },

      /**
       * @private
       */
      _setSVGPreamble: function(markup, options) {
        if (options.suppressPreamble) {
          return;
        }
        markup.push(
          '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
          '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
          '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
        );
      },

      /**
       * @private
       */
      _setSVGHeader: function(markup, options) {
        var width = options.width || this.width,
            height = options.height || this.height,
            vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

        if (options.viewBox) {
          viewBox = 'viewBox="' +
                  options.viewBox.x + ' ' +
                  options.viewBox.y + ' ' +
                  options.viewBox.width + ' ' +
                  options.viewBox.height + '" ';
        }
        else {
          if (this.svgViewportTransformation) {
            vpt = this.viewportTransform;
            viewBox = 'viewBox="' +
                    toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
          }
        }

        markup.push(
          '<svg ',
          'xmlns="http://www.w3.org/2000/svg" ',
          'xmlns:xlink="http://www.w3.org/1999/xlink" ',
          'version="1.1" ',
          'width="', width, '" ',
          'height="', height, '" ',
          viewBox,
          'xml:space="preserve">\n',
          '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
          '<defs>\n',
          this.createSVGFontFacesMarkup(),
          this.createSVGRefElementsMarkup(),
          this.createSVGClipPathMarkup(options),
          '</defs>\n'
        );
      },

      createSVGClipPathMarkup: function(options) {
        var clipPath = this.clipPath;
        if (clipPath) {
          clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
          return  '<clipPath id="' + clipPath.clipPathId + '" >\n' +
            this.clipPath.toClipPathSVG(options.reviver) +
            '</clipPath>\n';
        }
        return '';
      },

      /**
       * Creates markup containing SVG referenced elements like patterns, gradients etc.
       * @return {String}
       */
      createSVGRefElementsMarkup: function() {
        var _this = this,
            markup = ['background', 'overlay'].map(function(prop) {
              var fill = _this[prop + 'Color'];
              if (fill && fill.toLive) {
                var shouldTransform = _this[prop + 'Vpt'], vpt = _this.viewportTransform,
                    object = {
                      width: _this.width / (shouldTransform ? vpt[0] : 1),
                      height: _this.height / (shouldTransform ? vpt[3] : 1)
                    };
                return fill.toSVG(
                  object,
                  { additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : '' }
                );
              }
            });
        return markup.join('');
      },

      /**
       * Creates markup containing SVG font faces,
       * font URLs for font faces must be collected by developers
       * and are not extracted from the DOM by fabricjs
       * @param {Array} objects Array of fabric objects
       * @return {String}
       */
      createSVGFontFacesMarkup: function() {
        var markup = '', fontList = { }, obj, fontFamily,
            style, row, rowIndex, _char, charIndex, i, len,
            fontPaths = fabric.fontPaths, objects = [];

        this._objects.forEach(function add(object) {
          objects.push(object);
          if (object._objects) {
            object._objects.forEach(add);
          }
        });

        for (i = 0, len = objects.length; i < len; i++) {
          obj = objects[i];
          fontFamily = obj.fontFamily;
          if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
            continue;
          }
          fontList[fontFamily] = true;
          if (!obj.styles) {
            continue;
          }
          style = obj.styles;
          for (rowIndex in style) {
            row = style[rowIndex];
            for (charIndex in row) {
              _char = row[charIndex];
              fontFamily = _char.fontFamily;
              if (!fontList[fontFamily] && fontPaths[fontFamily]) {
                fontList[fontFamily] = true;
              }
            }
          }
        }

        for (var j in fontList) {
          markup += [
            '\t\t@font-face {\n',
            '\t\t\tfont-family: \'', j, '\';\n',
            '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
            '\t\t}\n'
          ].join('');
        }

        if (markup) {
          markup = [
            '\t<style type="text/css">',
            '<![CDATA[\n',
            markup,
            ']]>',
            '</style>\n'
          ].join('');
        }

        return markup;
      },

      /**
       * @private
       */
      _setSVGObjects: function(markup, reviver) {
        var instance, i, len, objects = this._objects;
        for (i = 0, len = objects.length; i < len; i++) {
          instance = objects[i];
          if (instance.excludeFromExport) {
            continue;
          }
          this._setSVGObject(markup, instance, reviver);
        }
      },

      /**
       * @private
       */
      _setSVGObject: function(markup, instance, reviver) {
        markup.push(instance.toSVG(reviver));
      },

      /**
       * @private
       */
      _setSVGBgOverlayImage: function(markup, property, reviver) {
        if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {
          markup.push(this[property].toSVG(reviver));
        }
      },

      /**
       * @private
       */
      _setSVGBgOverlayColor: function(markup, property) {
        var filler = this[property + 'Color'], vpt = this.viewportTransform, finalWidth = this.width,
            finalHeight = this.height;
        if (!filler) {
          return;
        }
        if (filler.toLive) {
          var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + 'Vpt'],
              additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : '';
          markup.push(
            '<rect transform="' + additionalTransform + ' translate(', finalWidth / 2, ',', finalHeight / 2, ')"',
            ' x="', filler.offsetX - finalWidth / 2,
            '" y="', filler.offsetY - finalHeight / 2, '" ',
            'width="',
            (repeat === 'repeat-y' || repeat === 'no-repeat'
              ? filler.source.width
              : finalWidth ),
            '" height="',
            (repeat === 'repeat-x' || repeat === 'no-repeat'
              ? filler.source.height
              : finalHeight),
            '" fill="url(#SVGID_' + filler.id + ')"',
            '></rect>\n'
          );
        }
        else {
          markup.push(
            '<rect x="0" y="0" width="100%" height="100%" ',
            'fill="', filler, '"',
            '></rect>\n'
          );
        }
      },
      /* _TO_SVG_END_ */

      /**
       * Moves an object or the objects of a multiple selection
       * to the bottom of the stack of drawn objects
       * @param {fabric.Object} object Object to send to back
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      sendToBack: function (object) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, objs;
        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = objs.length; i--;) {
            obj = objs[i];
            removeFromArray(this._objects, obj);
            this._objects.unshift(obj);
          }
        }
        else {
          removeFromArray(this._objects, object);
          this._objects.unshift(object);
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Moves an object or the objects of a multiple selection
       * to the top of the stack of drawn objects
       * @param {fabric.Object} object Object to send
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      bringToFront: function (object) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, objs;
        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = 0; i < objs.length; i++) {
            obj = objs[i];
            removeFromArray(this._objects, obj);
            this._objects.push(obj);
          }
        }
        else {
          removeFromArray(this._objects, object);
          this._objects.push(object);
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Moves an object or a selection down in stack of drawn objects
       * An optional paramter, intersecting allowes to move the object in behind
       * the first intersecting object. Where intersection is calculated with
       * bounding box. If no intersection is found, there will not be change in the
       * stack.
       * @param {fabric.Object} object Object to send
       * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      sendBackwards: function (object, intersecting) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, idx, newIdx, objs, objsMoved = 0;

        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = 0; i < objs.length; i++) {
            obj = objs[i];
            idx = this._objects.indexOf(obj);
            if (idx > 0 + objsMoved) {
              newIdx = idx - 1;
              removeFromArray(this._objects, obj);
              this._objects.splice(newIdx, 0, obj);
            }
            objsMoved++;
          }
        }
        else {
          idx = this._objects.indexOf(object);
          if (idx !== 0) {
            // if object is not on the bottom of stack
            newIdx = this._findNewLowerIndex(object, idx, intersecting);
            removeFromArray(this._objects, object);
            this._objects.splice(newIdx, 0, object);
          }
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * @private
       */
      _findNewLowerIndex: function(object, idx, intersecting) {
        var newIdx, i;

        if (intersecting) {
          newIdx = idx;

          // traverse down the stack looking for the nearest intersecting object
          for (i = idx - 1; i >= 0; --i) {

            var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                                 object.isContainedWithinObject(this._objects[i]) ||
                                 this._objects[i].isContainedWithinObject(object);

            if (isIntersecting) {
              newIdx = i;
              break;
            }
          }
        }
        else {
          newIdx = idx - 1;
        }

        return newIdx;
      },

      /**
       * Moves an object or a selection up in stack of drawn objects
       * An optional paramter, intersecting allowes to move the object in front
       * of the first intersecting object. Where intersection is calculated with
       * bounding box. If no intersection is found, there will not be change in the
       * stack.
       * @param {fabric.Object} object Object to send
       * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      bringForward: function (object, intersecting) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, idx, newIdx, objs, objsMoved = 0;

        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = objs.length; i--;) {
            obj = objs[i];
            idx = this._objects.indexOf(obj);
            if (idx < this._objects.length - 1 - objsMoved) {
              newIdx = idx + 1;
              removeFromArray(this._objects, obj);
              this._objects.splice(newIdx, 0, obj);
            }
            objsMoved++;
          }
        }
        else {
          idx = this._objects.indexOf(object);
          if (idx !== this._objects.length - 1) {
            // if object is not on top of stack (last item in an array)
            newIdx = this._findNewUpperIndex(object, idx, intersecting);
            removeFromArray(this._objects, object);
            this._objects.splice(newIdx, 0, object);
          }
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * @private
       */
      _findNewUpperIndex: function(object, idx, intersecting) {
        var newIdx, i, len;

        if (intersecting) {
          newIdx = idx;

          // traverse up the stack looking for the nearest intersecting object
          for (i = idx + 1, len = this._objects.length; i < len; ++i) {

            var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                                 object.isContainedWithinObject(this._objects[i]) ||
                                 this._objects[i].isContainedWithinObject(object);

            if (isIntersecting) {
              newIdx = i;
              break;
            }
          }
        }
        else {
          newIdx = idx + 1;
        }

        return newIdx;
      },

      /**
       * Moves an object to specified level in stack of drawn objects
       * @param {fabric.Object} object Object to send
       * @param {Number} index Position to move to
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      moveTo: function (object, index) {
        removeFromArray(this._objects, object);
        this._objects.splice(index, 0, object);
        return this.renderOnAddRemove && this.requestRenderAll();
      },

      /**
       * Clears a canvas element and dispose objects
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      dispose: function () {
        // cancel eventually ongoing renders
        if (this.isRendering) {
          fabric.util.cancelAnimFrame(this.isRendering);
          this.isRendering = 0;
        }
        this.forEachObject(function(object) {
          object.dispose && object.dispose();
        });
        this._objects = [];
        if (this.backgroundImage && this.backgroundImage.dispose) {
          this.backgroundImage.dispose();
        }
        this.backgroundImage = null;
        if (this.overlayImage && this.overlayImage.dispose) {
          this.overlayImage.dispose();
        }
        this.overlayImage = null;
        this._iTextInstances = null;
        this.contextContainer = null;
        fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);
        this.lowerCanvasEl = undefined;
        return this;
      },

      /**
       * Returns a string representation of an instance
       * @return {String} string representation of an instance
       */
      toString: function () {
        return '#<fabric.Canvas (' + this.complexity() + '): ' +
                 '{ objects: ' + this._objects.length + ' }>';
      }
    });

    extend(fabric.StaticCanvas.prototype, fabric.Observable);
    extend(fabric.StaticCanvas.prototype, fabric.Collection);
    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

      /**
       * @static
       * @type String
       * @default
       */
      EMPTY_JSON: '{"objects": [], "background": "white"}',

      /**
       * Provides a way to check support of some of the canvas methods
       * (either those of HTMLCanvasElement itself, or rendering context)
       *
       * @param {String} methodName Method to check support for;
       *                            Could be one of "setLineDash"
       * @return {Boolean | null} `true` if method is supported (or at least exists),
       *                          `null` if canvas element or context can not be initialized
       */
      supports: function (methodName) {
        var el = createCanvasElement();

        if (!el || !el.getContext) {
          return null;
        }

        var ctx = el.getContext('2d');
        if (!ctx) {
          return null;
        }

        switch (methodName) {

          case 'setLineDash':
            return typeof ctx.setLineDash !== 'undefined';

          default:
            return null;
        }
      }
    });

    /**
     * Returns JSON representation of canvas
     * @function
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} JSON string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
     * @example <caption>JSON without additional properties</caption>
     * var json = canvas.toJSON();
     * @example <caption>JSON with additional properties included</caption>
     * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
     * @example <caption>JSON without default values</caption>
     * canvas.includeDefaultValues = false;
     * var json = canvas.toJSON();
     */
    fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

    if (fabric.isLikelyNode) {
      fabric.StaticCanvas.prototype.createPNGStream = function() {
        var impl = getNodeCanvas(this.lowerCanvasEl);
        return impl && impl.createPNGStream();
      };
      fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
        var impl = getNodeCanvas(this.lowerCanvasEl);
        return impl && impl.createJPEGStream(opts);
      };
    }
  })();


  /**
   * BaseBrush class
   * @class fabric.BaseBrush
   * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
   */
  fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

    /**
     * Color of a brush
     * @type String
     * @default
     */
    color: 'rgb(0, 0, 0)',

    /**
     * Width of a brush, has to be a Number, no string literals
     * @type Number
     * @default
     */
    width: 1,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
     * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
     * @type fabric.Shadow
     * @default
     */
    shadow: null,

    /**
     * Line endings style of a brush (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap: 'round',

    /**
     * Corner style of a brush (one of "bevel", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin: 'round',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
     * @type Number
     * @default
     */
    strokeMiterLimit:         10,

    /**
     * Stroke Dash Array.
     * @type Array
     * @default
     */
    strokeDashArray: null,

    /**
     * Sets shadow of an object
     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setShadow: function(options) {
      this.shadow = new fabric.Shadow(options);
      return this;
    },

    /**
     * Sets brush styles
     * @private
     */
    _setBrushStyles: function() {
      var ctx = this.canvas.contextTop;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = this.width;
      ctx.lineCap = this.strokeLineCap;
      ctx.miterLimit = this.strokeMiterLimit;
      ctx.lineJoin = this.strokeLineJoin;
      if (fabric.StaticCanvas.supports('setLineDash')) {
        ctx.setLineDash(this.strokeDashArray || []);
      }
    },

    /**
     * Sets the transformation on given context
     * @param {RenderingContext2d} ctx context to render on
     * @private
     */
    _saveAndTransform: function(ctx) {
      var v = this.canvas.viewportTransform;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
    },

    /**
     * Sets brush shadow styles
     * @private
     */
    _setShadow: function() {
      if (!this.shadow) {
        return;
      }

      var canvas = this.canvas,
          shadow = this.shadow,
          ctx = canvas.contextTop,
          zoom = canvas.getZoom();
      if (canvas && canvas._isRetinaScaling()) {
        zoom *= fabric.devicePixelRatio;
      }

      ctx.shadowColor = shadow.color;
      ctx.shadowBlur = shadow.blur * zoom;
      ctx.shadowOffsetX = shadow.offsetX * zoom;
      ctx.shadowOffsetY = shadow.offsetY * zoom;
    },

    needsFullRender: function() {
      var color = new fabric.Color(this.color);
      return color.getAlpha() < 1 || !!this.shadow;
    },

    /**
     * Removes brush shadow styles
     * @private
     */
    _resetShadow: function() {
      var ctx = this.canvas.contextTop;

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    }
  });


  (function() {
    /**
     * PencilBrush class
     * @class fabric.PencilBrush
     * @extends fabric.BaseBrush
     */
    fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

      /**
       * Discard points that are less than `decimate` pixel distant from each other
       * @type Number
       * @default 0.4
       */
      decimate: 0.4,

      /**
       * Constructor
       * @param {fabric.Canvas} canvas
       * @return {fabric.PencilBrush} Instance of a pencil brush
       */
      initialize: function(canvas) {
        this.canvas = canvas;
        this._points = [];
      },

      /**
       * Invoked inside on mouse down and mouse move
       * @param {Object} pointer
       */
      _drawSegment: function (ctx, p1, p2) {
        var midPoint = p1.midPointFrom(p2);
        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
        return midPoint;
      },

      /**
       * Inovoked on mouse down
       * @param {Object} pointer
       */
      onMouseDown: function(pointer, options) {
        if (!this.canvas._isMainEvent(options.e)) {
          return;
        }
        this._prepareForDrawing(pointer);
        // capture coordinates immediately
        // this allows to draw dots (when movement never occurs)
        this._captureDrawingPath(pointer);
        this._render();
      },

      /**
       * Inovoked on mouse move
       * @param {Object} pointer
       */
      onMouseMove: function(pointer, options) {
        if (!this.canvas._isMainEvent(options.e)) {
          return;
        }
        if (this._captureDrawingPath(pointer) && this._points.length > 1) {
          if (this.needsFullRender()) {
            // redraw curve
            // clear top canvas
            this.canvas.clearContext(this.canvas.contextTop);
            this._render();
          }
          else {
            var points = this._points, length = points.length, ctx = this.canvas.contextTop;
            // draw the curve update
            this._saveAndTransform(ctx);
            if (this.oldEnd) {
              ctx.beginPath();
              ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
            }
            this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
            ctx.stroke();
            ctx.restore();
          }
        }
      },

      /**
       * Invoked on mouse up
       */
      onMouseUp: function(options) {
        if (!this.canvas._isMainEvent(options.e)) {
          return true;
        }
        this.oldEnd = undefined;
        this._finalizeAndAddPath();
        return false;
      },

      /**
       * @private
       * @param {Object} pointer Actual mouse position related to the canvas.
       */
      _prepareForDrawing: function(pointer) {

        var p = new fabric.Point(pointer.x, pointer.y);

        this._reset();
        this._addPoint(p);
        this.canvas.contextTop.moveTo(p.x, p.y);
      },

      /**
       * @private
       * @param {fabric.Point} point Point to be added to points array
       */
      _addPoint: function(point) {
        if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
          return false;
        }
        this._points.push(point);
        return true;
      },

      /**
       * Clear points array and set contextTop canvas style.
       * @private
       */
      _reset: function() {
        this._points = [];
        this._setBrushStyles();
        this._setShadow();
      },

      /**
       * @private
       * @param {Object} pointer Actual mouse position related to the canvas.
       */
      _captureDrawingPath: function(pointer) {
        var pointerPoint = new fabric.Point(pointer.x, pointer.y);
        return this._addPoint(pointerPoint);
      },

      /**
       * Draw a smooth path on the topCanvas using quadraticCurveTo
       * @private
       */
      _render: function() {
        var ctx  = this.canvas.contextTop, i, len,
            p1 = this._points[0],
            p2 = this._points[1];

        this._saveAndTransform(ctx);
        ctx.beginPath();
        //if we only have 2 points in the path and they are the same
        //it means that the user only clicked the canvas without moving the mouse
        //then we should be drawing a dot. A path isn't drawn between two identical dots
        //that's why we set them apart a bit
        if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
          var width = this.width / 1000;
          p1 = new fabric.Point(p1.x, p1.y);
          p2 = new fabric.Point(p2.x, p2.y);
          p1.x -= width;
          p2.x += width;
        }
        ctx.moveTo(p1.x, p1.y);

        for (i = 1, len = this._points.length; i < len; i++) {
          // we pick the point between pi + 1 & pi + 2 as the
          // end point and p1 as our control point.
          this._drawSegment(ctx, p1, p2);
          p1 = this._points[i];
          p2 = this._points[i + 1];
        }
        // Draw last line as a straight line while
        // we wait for the next point to be able to calculate
        // the bezier control point
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
        ctx.restore();
      },

      /**
       * Converts points to SVG path
       * @param {Array} points Array of points
       * @return {String} SVG path
       */
      convertPointsToSVGPath: function(points) {
        var path = [], i, width = this.width / 1000,
            p1 = new fabric.Point(points[0].x, points[0].y),
            p2 = new fabric.Point(points[1].x, points[1].y),
            len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;

        if (manyPoints) {
          multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
          multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
        }
        path.push('M ', p1.x - multSignX * width, ' ', p1.y - multSignY * width, ' ');
        for (i = 1; i < len; i++) {
          if (!p1.eq(p2)) {
            var midPoint = p1.midPointFrom(p2);
            // p1 is our bezier control point
            // midpoint is our endpoint
            // start point is p(i-1) value.
            path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
          }
          p1 = points[i];
          if ((i + 1) < points.length) {
            p2 = points[i + 1];
          }
        }
        if (manyPoints) {
          multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
          multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
        }
        path.push('L ', p1.x + multSignX * width, ' ', p1.y + multSignY * width);
        return path;
      },

      /**
       * Creates fabric.Path object to add on canvas
       * @param {String} pathData Path data
       * @return {fabric.Path} Path to add on canvas
       */
      createPath: function(pathData) {
        var path = new fabric.Path(pathData, {
          fill: null,
          stroke: this.color,
          strokeWidth: this.width,
          strokeLineCap: this.strokeLineCap,
          strokeMiterLimit: this.strokeMiterLimit,
          strokeLineJoin: this.strokeLineJoin,
          strokeDashArray: this.strokeDashArray,
        });
        if (this.shadow) {
          this.shadow.affectStroke = true;
          path.setShadow(this.shadow);
        }

        return path;
      },

      /**
       * Decimate poins array with the decimate value
       */
      decimatePoints: function(points, distance) {
        if (points.length <= 2) {
          return points;
        }
        var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2),
            i, l = points.length - 1, lastPoint = points[0], newPoints = [lastPoint],
            cDistance;
        for (i = 1; i < l; i++) {
          cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);
          if (cDistance >= adjustedDistance) {
            lastPoint = points[i];
            newPoints.push(lastPoint);
          }
        }
        if (newPoints.length === 1) {
          newPoints.push(new fabric.Point(newPoints[0].x, newPoints[0].y));
        }
        return newPoints;
      },

      /**
       * On mouseup after drawing the path on contextTop canvas
       * we use the points captured to create an new fabric path object
       * and add it to the fabric canvas.
       */
      _finalizeAndAddPath: function() {
        var ctx = this.canvas.contextTop;
        ctx.closePath();
        if (this.decimate) {
          this._points = this.decimatePoints(this._points, this.decimate);
        }
        var pathData = this.convertPointsToSVGPath(this._points).join('');
        if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
          // do not create 0 width/height paths, as they are
          // rendered inconsistently across browsers
          // Firefox 4, for example, renders a dot,
          // whereas Chrome 10 renders nothing
          this.canvas.requestRenderAll();
          return;
        }

        var path = this.createPath(pathData);
        this.canvas.clearContext(this.canvas.contextTop);
        this.canvas.add(path);
        this.canvas.requestRenderAll();
        path.setCoords();
        this._resetShadow();


        // fire event 'path' created
        this.canvas.fire('path:created', { path: path });
      }
    });
  })();


  /**
   * CircleBrush class
   * @class fabric.CircleBrush
   */
  fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

    /**
     * Width of a brush
     * @type Number
     * @default
     */
    width: 10,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.CircleBrush} Instance of a circle brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this.points = [];
    },

    /**
     * Invoked inside on mouse down and mouse move
     * @param {Object} pointer
     */
    drawDot: function(pointer) {
      var point = this.addPoint(pointer),
          ctx = this.canvas.contextTop;
      this._saveAndTransform(ctx);
      this.dot(ctx, point);
      ctx.restore();
    },

    dot: function(ctx, point) {
      ctx.fillStyle = point.fill;
      ctx.beginPath();
      ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
      ctx.closePath();
      ctx.fill();
    },

    /**
     * Invoked on mouse down
     */
    onMouseDown: function(pointer) {
      this.points.length = 0;
      this.canvas.clearContext(this.canvas.contextTop);
      this._setShadow();
      this.drawDot(pointer);
    },

    /**
     * Render the full state of the brush
     * @private
     */
    _render: function() {
      var ctx  = this.canvas.contextTop, i, len,
          points = this.points;
      this._saveAndTransform(ctx);
      for (i = 0, len = points.length; i < len; i++) {
        this.dot(ctx, points[i]);
      }
      ctx.restore();
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      if (this.needsFullRender()) {
        this.canvas.clearContext(this.canvas.contextTop);
        this.addPoint(pointer);
        this._render();
      }
      else {
        this.drawDot(pointer);
      }
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
      this.canvas.renderOnAddRemove = false;

      var circles = [];

      for (i = 0, len = this.points.length; i < len; i++) {
        var point = this.points[i],
            circle = new fabric.Circle({
              radius: point.radius,
              left: point.x,
              top: point.y,
              originX: 'center',
              originY: 'center',
              fill: point.fill
            });

        this.shadow && circle.setShadow(this.shadow);

        circles.push(circle);
      }
      var group = new fabric.Group(circles);
      group.canvas = this.canvas;

      this.canvas.add(group);
      this.canvas.fire('path:created', { path: group });

      this.canvas.clearContext(this.canvas.contextTop);
      this._resetShadow();
      this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
      this.canvas.requestRenderAll();
    },

    /**
     * @param {Object} pointer
     * @return {fabric.Point} Just added pointer point
     */
    addPoint: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y),

          circleRadius = fabric.util.getRandomInt(
            Math.max(0, this.width - 20), this.width + 20) / 2,

          circleColor = new fabric.Color(this.color)
            .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
            .toRgba();

      pointerPoint.radius = circleRadius;
      pointerPoint.fill = circleColor;

      this.points.push(pointerPoint);

      return pointerPoint;
    }
  });


  /**
   * SprayBrush class
   * @class fabric.SprayBrush
   */
  fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

    /**
     * Width of a spray
     * @type Number
     * @default
     */
    width:              10,

    /**
     * Density of a spray (number of dots per chunk)
     * @type Number
     * @default
     */
    density:            20,

    /**
     * Width of spray dots
     * @type Number
     * @default
     */
    dotWidth:           1,

    /**
     * Width variance of spray dots
     * @type Number
     * @default
     */
    dotWidthVariance:   1,

    /**
     * Whether opacity of a dot should be random
     * @type Boolean
     * @default
     */
    randomOpacity:        false,

    /**
     * Whether overlapping dots (rectangles) should be removed (for performance reasons)
     * @type Boolean
     * @default
     */
    optimizeOverlapping:  true,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.SprayBrush} Instance of a spray brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this.sprayChunks = [];
    },

    /**
     * Invoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer) {
      this.sprayChunks.length = 0;
      this.canvas.clearContext(this.canvas.contextTop);
      this._setShadow();

      this.addSprayChunk(pointer);
      this.render(this.sprayChunkPoints);
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      this.addSprayChunk(pointer);
      this.render(this.sprayChunkPoints);
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
      this.canvas.renderOnAddRemove = false;

      var rects = [];

      for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
        var sprayChunk = this.sprayChunks[i];

        for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

          var rect = new fabric.Rect({
            width: sprayChunk[j].width,
            height: sprayChunk[j].width,
            left: sprayChunk[j].x + 1,
            top: sprayChunk[j].y + 1,
            originX: 'center',
            originY: 'center',
            fill: this.color
          });
          rects.push(rect);
        }
      }

      if (this.optimizeOverlapping) {
        rects = this._getOptimizedRects(rects);
      }

      var group = new fabric.Group(rects);
      this.shadow && group.setShadow(this.shadow);
      this.canvas.add(group);
      this.canvas.fire('path:created', { path: group });

      this.canvas.clearContext(this.canvas.contextTop);
      this._resetShadow();
      this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
      this.canvas.requestRenderAll();
    },

    /**
     * @private
     * @param {Array} rects
     */
    _getOptimizedRects: function(rects) {

      // avoid creating duplicate rects at the same coordinates
      var uniqueRects = { }, key, i, len;

      for (i = 0, len = rects.length; i < len; i++) {
        key = rects[i].left + '' + rects[i].top;
        if (!uniqueRects[key]) {
          uniqueRects[key] = rects[i];
        }
      }
      var uniqueRectsArray = [];
      for (key in uniqueRects) {
        uniqueRectsArray.push(uniqueRects[key]);
      }

      return uniqueRectsArray;
    },

    /**
     * Render new chunk of spray brush
     */
    render: function(sprayChunk) {
      var ctx = this.canvas.contextTop, i, len;
      ctx.fillStyle = this.color;

      this._saveAndTransform(ctx);

      for (i = 0, len = sprayChunk.length; i < len; i++) {
        var point = sprayChunk[i];
        if (typeof point.opacity !== 'undefined') {
          ctx.globalAlpha = point.opacity;
        }
        ctx.fillRect(point.x, point.y, point.width, point.width);
      }
      ctx.restore();
    },

    /**
     * Render all spray chunks
     */
    _render: function() {
      var ctx = this.canvas.contextTop, i, ilen;
      ctx.fillStyle = this.color;

      this._saveAndTransform(ctx);

      for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
        this.render(this.sprayChunks[i]);
      }
      ctx.restore();
    },

    /**
     * @param {Object} pointer
     */
    addSprayChunk: function(pointer) {
      this.sprayChunkPoints = [];

      var x, y, width, radius = this.width / 2, i;

      for (i = 0; i < this.density; i++) {

        x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
        y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

        if (this.dotWidthVariance) {
          width = fabric.util.getRandomInt(
            // bottom clamp width to 1
            Math.max(1, this.dotWidth - this.dotWidthVariance),
            this.dotWidth + this.dotWidthVariance);
        }
        else {
          width = this.dotWidth;
        }

        var point = new fabric.Point(x, y);
        point.width = width;

        if (this.randomOpacity) {
          point.opacity = fabric.util.getRandomInt(0, 100) / 100;
        }

        this.sprayChunkPoints.push(point);
      }

      this.sprayChunks.push(this.sprayChunkPoints);
    }
  });


  /**
   * PatternBrush class
   * @class fabric.PatternBrush
   * @extends fabric.BaseBrush
   */
  fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

    getPatternSrc: function() {

      var dotWidth = 20,
          dotDistance = 5,
          patternCanvas = fabric.util.createCanvasElement(),
          patternCtx = patternCanvas.getContext('2d');

      patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

      patternCtx.fillStyle = this.color;
      patternCtx.beginPath();
      patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
      patternCtx.closePath();
      patternCtx.fill();

      return patternCanvas;
    },

    getPatternSrcFunction: function() {
      return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
    },

    /**
     * Creates "pattern" instance property
     */
    getPattern: function() {
      return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
    },

    /**
     * Sets brush styles
     */
    _setBrushStyles: function() {
      this.callSuper('_setBrushStyles');
      this.canvas.contextTop.strokeStyle = this.getPattern();
    },

    /**
     * Creates path
     */
    createPath: function(pathData) {
      var path = this.callSuper('createPath', pathData),
          topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

      path.stroke = new fabric.Pattern({
        source: this.source || this.getPatternSrcFunction(),
        offsetX: -topLeft.x,
        offsetY: -topLeft.y
      });
      return path;
    }
  });


  (function() {

    var getPointer = fabric.util.getPointer,
        degreesToRadians = fabric.util.degreesToRadians,
        radiansToDegrees = fabric.util.radiansToDegrees,
        atan2 = Math.atan2,
        abs = Math.abs,
        supportLineDash = fabric.StaticCanvas.supports('setLineDash'),

        STROKE_OFFSET = 0.5;

    /**
     * Canvas class
     * @class fabric.Canvas
     * @extends fabric.StaticCanvas
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
     * @see {@link fabric.Canvas#initialize} for constructor definition
     *
     * @fires object:modified at the end of a transform or any change when statefull is true
     * @fires object:rotated at the end of a rotation transform
     * @fires object:scaled at the end of a scale transform
     * @fires object:moved at the end of translation transform
     * @fires object:skewed at the end of a skew transform
     * @fires object:rotating while an object is being rotated from the control
     * @fires object:scaling while an object is being scaled by controls
     * @fires object:moving while an object is being dragged
     * @fires object:skewing while an object is being skewed from the controls
     * @fires object:selected this event is deprecated. use selection:created
     *
     * @fires before:transform before a transform is is started
     * @fires before:selection:cleared
     * @fires selection:cleared
     * @fires selection:updated
     * @fires selection:created
     *
     * @fires path:created after a drawing operation ends and the path is added
     * @fires mouse:down
     * @fires mouse:move
     * @fires mouse:up
     * @fires mouse:down:before  on mouse down, before the inner fabric logic runs
     * @fires mouse:move:before on mouse move, before the inner fabric logic runs
     * @fires mouse:up:before on mouse up, before the inner fabric logic runs
     * @fires mouse:over
     * @fires mouse:out
     * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.
     *
     * @fires dragover
     * @fires dragenter
     * @fires dragleave
     * @fires drop
     * @fires after:render at the end of the render process, receives the context in the callback
     * @fires before:render at start the render process, receives the context in the callback
     *
     */
    fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

      /**
       * Constructor
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(el, options) {
        options || (options = { });
        this.renderAndResetBound = this.renderAndReset.bind(this);
        this.requestRenderAllBound = this.requestRenderAll.bind(this);
        this._initStatic(el, options);
        this._initInteractive();
        this._createCacheCanvas();
      },

      /**
       * When true, objects can be transformed by one side (unproportionally)
       * @type Boolean
       * @default
       */
      uniScaleTransform:      false,

      /**
       * Indicates which key enable unproportional scaling
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      uniScaleKey:           'shiftKey',

      /**
       * When true, objects use center point as the origin of scale transformation.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredScaling:        false,

      /**
       * When true, objects use center point as the origin of rotate transformation.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredRotation:       false,

      /**
       * Indicates which key enable centered Transform
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      centeredKey:           'altKey',

      /**
       * Indicates which key enable alternate action on corner
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      altActionKey:           'shiftKey',

      /**
       * Indicates that canvas is interactive. This property should not be changed.
       * @type Boolean
       * @default
       */
      interactive:            true,

      /**
       * Indicates whether group selection should be enabled
       * @type Boolean
       * @default
       */
      selection:              true,

      /**
       * Indicates which key or keys enable multiple click selection
       * Pass value as a string or array of strings
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or empty or containing any other string that is not a modifier key
       * feature is disabled.
       * @since 1.6.2
       * @type String|Array
       * @default
       */
      selectionKey:           'shiftKey',

      /**
       * Indicates which key enable alternative selection
       * in case of target overlapping with active object
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * For a series of reason that come from the general expectations on how
       * things should work, this feature works only for preserveObjectStacking true.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled.
       * @since 1.6.5
       * @type null|String
       * @default
       */
      altSelectionKey:           null,

      /**
       * Color of selection
       * @type String
       * @default
       */
      selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

      /**
       * Default dash array pattern
       * If not empty the selection border is dashed
       * @type Array
       */
      selectionDashArray:     [],

      /**
       * Color of the border of selection (usually slightly darker than color of selection itself)
       * @type String
       * @default
       */
      selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

      /**
       * Width of a line used in object/group selection
       * @type Number
       * @default
       */
      selectionLineWidth:     1,

      /**
       * Select only shapes that are fully contained in the dragged selection rectangle.
       * @type Boolean
       * @default
       */
      selectionFullyContained: false,

      /**
       * Default cursor value used when hovering over an object on canvas
       * @type String
       * @default
       */
      hoverCursor:            'move',

      /**
       * Default cursor value used when moving an object on canvas
       * @type String
       * @default
       */
      moveCursor:             'move',

      /**
       * Default cursor value used for the entire canvas
       * @type String
       * @default
       */
      defaultCursor:          'default',

      /**
       * Cursor value used during free drawing
       * @type String
       * @default
       */
      freeDrawingCursor:      'crosshair',

      /**
       * Cursor value used for rotation point
       * @type String
       * @default
       */
      rotationCursor:         'crosshair',

      /**
       * Cursor value used for disabled elements ( corners with disabled action )
       * @type String
       * @since 2.0.0
       * @default
       */
      notAllowedCursor:         'not-allowed',

      /**
       * Default element class that's given to wrapper (div) element of canvas
       * @type String
       * @default
       */
      containerClass:         'canvas-container',

      /**
       * When true, object detection happens on per-pixel basis rather than on per-bounding-box
       * @type Boolean
       * @default
       */
      perPixelTargetFind:     false,

      /**
       * Number of pixels around target pixel to tolerate (consider active) during object detection
       * @type Number
       * @default
       */
      targetFindTolerance:    0,

      /**
       * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
       * @type Boolean
       * @default
       */
      skipTargetFind:         false,

      /**
       * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
       * After mousedown, mousemove creates a shape,
       * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
       * @type Boolean
       * @default
       */
      isDrawingMode:          false,

      /**
       * Indicates whether objects should remain in current stack position when selected.
       * When false objects are brought to top and rendered as part of the selection group
       * @type Boolean
       * @default
       */
      preserveObjectStacking: false,

      /**
       * Indicates the angle that an object will lock to while rotating.
       * @type Number
       * @since 1.6.7
       * @default
       */
      snapAngle: 0,

      /**
       * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
       * When `null`, the snapThreshold will default to the snapAngle.
       * @type null|Number
       * @since 1.6.7
       * @default
       */
      snapThreshold: null,

      /**
       * Indicates if the right click on canvas can output the context menu or not
       * @type Boolean
       * @since 1.6.5
       * @default
       */
      stopContextMenu: false,

      /**
       * Indicates if the canvas can fire right click events
       * @type Boolean
       * @since 1.6.5
       * @default
       */
      fireRightClick: false,

      /**
       * Indicates if the canvas can fire middle click events
       * @type Boolean
       * @since 1.7.8
       * @default
       */
      fireMiddleClick: false,

      /**
       * Keep track of the subTargets for Mouse Events
       * @type fabric.Object[]
       */
      targets: [],

      /**
       * Keep track of the hovered target
       * @type fabric.Object
       * @private
       */
      _hoveredTarget: null,

      /**
       * hold the list of nested targets hovered
       * @type fabric.Object[]
       * @private
       */
      _hoveredTargets: [],

      /**
       * @private
       */
      _initInteractive: function() {
        this._currentTransform = null;
        this._groupSelector = null;
        this._initWrapperElement();
        this._createUpperCanvas();
        this._initEventListeners();

        this._initRetinaScaling();

        this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

        this.calcOffset();
      },

      /**
       * Divides objects in two groups, one to render immediately
       * and one to render as activeGroup.
       * @return {Array} objects to render immediately and pushes the other in the activeGroup.
       */
      _chooseObjectsToRender: function() {
        var activeObjects = this.getActiveObjects(),
            object, objsToRender, activeGroupObjects;

        if (activeObjects.length > 0 && !this.preserveObjectStacking) {
          objsToRender = [];
          activeGroupObjects = [];
          for (var i = 0, length = this._objects.length; i < length; i++) {
            object = this._objects[i];
            if (activeObjects.indexOf(object) === -1 ) {
              objsToRender.push(object);
            }
            else {
              activeGroupObjects.push(object);
            }
          }
          if (activeObjects.length > 1) {
            this._activeObject._objects = activeGroupObjects;
          }
          objsToRender.push.apply(objsToRender, activeGroupObjects);
        }
        else {
          objsToRender = this._objects;
        }
        return objsToRender;
      },

      /**
       * Renders both the top canvas and the secondary container canvas.
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAll: function () {
        if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
          this.clearContext(this.contextTop);
          this.contextTopDirty = false;
        }
        if (this.hasLostContext) {
          this.renderTopLayer(this.contextTop);
        }
        var canvasToDrawOn = this.contextContainer;
        this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
        return this;
      },

      renderTopLayer: function(ctx) {
        ctx.save();
        if (this.isDrawingMode && this._isCurrentlyDrawing) {
          this.freeDrawingBrush && this.freeDrawingBrush._render();
          this.contextTopDirty = true;
        }
        // we render the top context - last object
        if (this.selection && this._groupSelector) {
          this._drawSelection(ctx);
          this.contextTopDirty = true;
        }
        ctx.restore();
      },

      /**
       * Method to render only the top canvas.
       * Also used to render the group selection box.
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      renderTop: function () {
        var ctx = this.contextTop;
        this.clearContext(ctx);
        this.renderTopLayer(ctx);
        this.fire('after:render');
        return this;
      },

      /**
       * Resets the current transform to its original values and chooses the type of resizing based on the event
       * @private
       */
      _resetCurrentTransform: function() {
        var t = this._currentTransform;

        t.target.set({
          scaleX: t.original.scaleX,
          scaleY: t.original.scaleY,
          skewX: t.original.skewX,
          skewY: t.original.skewY,
          left: t.original.left,
          top: t.original.top
        });

        if (this._shouldCenterTransform(t.target)) {
          if (t.originX !== 'center') {
            if (t.originX === 'right') {
              t.mouseXSign = -1;
            }
            else {
              t.mouseXSign = 1;
            }
          }
          if (t.originY !== 'center') {
            if (t.originY === 'bottom') {
              t.mouseYSign = -1;
            }
            else {
              t.mouseYSign = 1;
            }
          }

          t.originX = 'center';
          t.originY = 'center';
        }
        else {
          t.originX = t.original.originX;
          t.originY = t.original.originY;
        }
      },

      /**
       * Checks if point is contained within an area of given object
       * @param {Event} e Event object
       * @param {fabric.Object} target Object to test against
       * @param {Object} [point] x,y object of point coordinates we want to check.
       * @return {Boolean} true if point is contained within an area of given object
       */
      containsPoint: function (e, target, point) {
        var ignoreZoom = true,
            pointer = point || this.getPointer(e, ignoreZoom),
            xy;

        if (target.group && target.group === this._activeObject && target.group.type === 'activeSelection') {
          xy = this._normalizePointer(target.group, pointer);
        }
        else {
          xy = { x: pointer.x, y: pointer.y };
        }
        // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
        // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
        return (target.containsPoint(xy) || target._findTargetCorner(pointer));
      },

      /**
       * @private
       */
      _normalizePointer: function (object, pointer) {
        var m = object.calcTransformMatrix(),
            invertedM = fabric.util.invertTransform(m),
            vptPointer = this.restorePointerVpt(pointer);
        return fabric.util.transformPoint(vptPointer, invertedM);
      },

      /**
       * Returns true if object is transparent at a certain location
       * @param {fabric.Object} target Object to check
       * @param {Number} x Left coordinate
       * @param {Number} y Top coordinate
       * @return {Boolean}
       */
      isTargetTransparent: function (target, x, y) {
        // in case the target is the activeObject, we cannot execute this optimization
        // because we need to draw controls too.
        if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {
          var normalizedPointer = this._normalizePointer(target, {x: x, y: y}),
              targetRelativeX = Math.max(target.cacheTranslationX + (normalizedPointer.x * target.zoomX), 0),
              targetRelativeY = Math.max(target.cacheTranslationY + (normalizedPointer.y * target.zoomY), 0);

          var isTransparent = fabric.util.isTransparent(
            target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);

          return isTransparent;
        }

        var ctx = this.contextCache,
            originalColor = target.selectionBackgroundColor, v = this.viewportTransform;

        target.selectionBackgroundColor = '';

        this.clearContext(ctx);

        ctx.save();
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        target.render(ctx);
        ctx.restore();

        target === this._activeObject && target._renderControls(ctx, {
          hasBorders: false,
          transparentCorners: false
        }, {
          hasBorders: false,
        });

        target.selectionBackgroundColor = originalColor;

        var isTransparent = fabric.util.isTransparent(
          ctx, x, y, this.targetFindTolerance);

        return isTransparent;
      },

      /**
       * takes an event and determins if selection key has been pressed
       * @private
       * @param {Event} e Event object
       */
      _isSelectionKeyPressed: function(e) {
        var selectionKeyPressed = false;

        if (Object.prototype.toString.call(this.selectionKey) === '[object Array]') {
          selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });
        }
        else {
          selectionKeyPressed = e[this.selectionKey];
        }

        return selectionKeyPressed;
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _shouldClearSelection: function (e, target) {
        var activeObjects = this.getActiveObjects(),
            activeObject = this._activeObject;

        return (
          !target
          ||
          (target &&
            activeObject &&
            activeObjects.length > 1 &&
            activeObjects.indexOf(target) === -1 &&
            activeObject !== target &&
            !this._isSelectionKeyPressed(e))
          ||
          (target && !target.evented)
          ||
          (target &&
            !target.selectable &&
            activeObject &&
            activeObject !== target)
        );
      },

      /**
       * centeredScaling from object can't override centeredScaling from canvas.
       * this should be fixed, since object setting should take precedence over canvas.
       * @private
       * @param {fabric.Object} target
       */
      _shouldCenterTransform: function (target) {
        if (!target) {
          return;
        }

        var t = this._currentTransform,
            centerTransform;

        if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
          centerTransform = this.centeredScaling || target.centeredScaling;
        }
        else if (t.action === 'rotate') {
          centerTransform = this.centeredRotation || target.centeredRotation;
        }

        return centerTransform ? !t.altKey : t.altKey;
      },

      /**
       * @private
       */
      _getOriginFromCorner: function(target, corner) {
        var origin = {
          x: target.originX,
          y: target.originY
        };

        if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
          origin.x = 'right';
        }
        else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
          origin.x = 'left';
        }

        if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
          origin.y = 'bottom';
        }
        else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
          origin.y = 'top';
        }

        return origin;
      },

      /**
       * @private
       * @param {Boolean} alreadySelected true if target is already selected
       * @param {String} corner a string representing the corner ml, mr, tl ...
       * @param {Event} e Event object
       * @param {fabric.Object} [target] inserted back to help overriding. Unused
       */
      _getActionFromCorner: function(alreadySelected, corner, e /* target */) {
        if (!corner || !alreadySelected) {
          return 'drag';
        }

        switch (corner) {
          case 'mtr':
            return 'rotate';
          case 'ml':
          case 'mr':
            return e[this.altActionKey] ? 'skewY' : 'scaleX';
          case 'mt':
          case 'mb':
            return e[this.altActionKey] ? 'skewX' : 'scaleY';
          default:
            return 'scale';
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _setupCurrentTransform: function (e, target, alreadySelected) {
        if (!target) {
          return;
        }

        var pointer = this.getPointer(e),
            corner = target._findTargetCorner(this.getPointer(e, true)),
            action = this._getActionFromCorner(alreadySelected, corner, e, target),
            origin = this._getOriginFromCorner(target, corner);

        this._currentTransform = {
          target: target,
          action: action,
          corner: corner,
          scaleX: target.scaleX,
          scaleY: target.scaleY,
          skewX: target.skewX,
          skewY: target.skewY,
          // used by transation
          offsetX: pointer.x - target.left,
          offsetY: pointer.y - target.top,
          originX: origin.x,
          originY: origin.y,
          ex: pointer.x,
          ey: pointer.y,
          lastX: pointer.x,
          lastY: pointer.y,
          // unsure they are usefull anymore.
          // left: target.left,
          // top: target.top,
          theta: degreesToRadians(target.angle),
          // end of unsure
          width: target.width * target.scaleX,
          mouseXSign: 1,
          mouseYSign: 1,
          shiftKey: e.shiftKey,
          altKey: e[this.centeredKey],
          original: fabric.util.saveObjectTransform(target),
        };

        this._currentTransform.original.originX = origin.x;
        this._currentTransform.original.originY = origin.y;

        this._resetCurrentTransform();
        this._beforeTransform(e);
      },

      /**
       * Translates object by "setting" its left/top
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @return {Boolean} true if the translation occurred
       */
      _translateObject: function (x, y) {
        var transform = this._currentTransform,
            target = transform.target,
            newLeft = x - transform.offsetX,
            newTop = y - transform.offsetY,
            moveX = !target.get('lockMovementX') && target.left !== newLeft,
            moveY = !target.get('lockMovementY') && target.top !== newTop;

        moveX && target.set('left', newLeft);
        moveY && target.set('top', newTop);
        return moveX || moveY;
      },

      /**
       * Check if we are increasing a positive skew or lower it,
       * checking mouse direction and pressed corner.
       * @private
       */
      _changeSkewTransformOrigin: function(mouseMove, t, by) {
        var property = 'originX', origins = { 0: 'center' },
            skew = t.target.skewX, originA = 'left', originB = 'right',
            corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,
            flipSign = 1;

        mouseMove = mouseMove > 0 ? 1 : -1;
        if (by === 'y') {
          skew = t.target.skewY;
          originA = 'top';
          originB = 'bottom';
          property = 'originY';
        }
        origins[-1] = originA;
        origins[1] = originB;

        t.target.flipX && (flipSign *= -1);
        t.target.flipY && (flipSign *= -1);

        if (skew === 0) {
          t.skewSign = -corner * mouseMove * flipSign;
          t[property] = origins[-mouseMove];
        }
        else {
          skew = skew > 0 ? 1 : -1;
          t.skewSign = skew;
          t[property] = origins[skew * corner * flipSign];
        }
      },

      /**
       * Skew object by mouse events
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @param {String} by Either 'x' or 'y'
       * @return {Boolean} true if the skewing occurred
       */
      _skewObject: function (x, y, by) {
        var t = this._currentTransform,
            target = t.target, skewed = false,
            lockSkewingX = target.get('lockSkewingX'),
            lockSkewingY = target.get('lockSkewingY');

        if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {
          return false;
        }

        // Get the constraint point
        var center = target.getCenterPoint(),
            actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],
            lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],
            actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();

        this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);
        actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];
        constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);
        // Actually skew the object
        skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);
        t.lastX = x;
        t.lastY = y;
        // Make sure the constraints apply
        target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        return skewed;
      },

      /**
       * Set object skew
       * @private
       * @return {Boolean} true if the skewing occurred
       */
      _setObjectSkew: function(localMouse, transform, by, _dim) {
        var target = transform.target, newValue, skewed = false,
            skewSign = transform.skewSign, newDim, dimNoSkew,
            otherBy, _otherBy, _by, newDimMouse, skewX, skewY;

        if (by === 'x') {
          otherBy = 'y';
          _otherBy = 'Y';
          _by = 'X';
          skewX = 0;
          skewY = target.skewY;
        }
        else {
          otherBy = 'x';
          _otherBy = 'X';
          _by = 'Y';
          skewX = target.skewX;
          skewY = 0;
        }

        dimNoSkew = target._getTransformedDimensions(skewX, skewY);
        newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];
        if (newDimMouse <= 2) {
          newValue = 0;
        }
        else {
          newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /
                                          (dimNoSkew[otherBy] / target['scale' + _otherBy]));
          newValue = fabric.util.radiansToDegrees(newValue);
        }
        skewed = target['skew' + _by] !== newValue;
        target.set('skew' + _by, newValue);
        if (target['skew' + _otherBy] !== 0) {
          newDim = target._getTransformedDimensions();
          newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];
          target.set('scale' + _otherBy, newValue);
        }
        return skewed;
      },

      /**
       * Scales object by invoking its scaleX/scaleY methods
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
       *                    When not provided, an object is scaled by both dimensions equally
       * @return {Boolean} true if the scaling occurred
       */
      _scaleObject: function (x, y, by) {
        var t = this._currentTransform,
            target = t.target,
            lockScalingX = target.lockScalingX,
            lockScalingY = target.lockScalingY,
            lockScalingFlip = target.lockScalingFlip;

        if (lockScalingX && lockScalingY) {
          return false;
        }

        // Get the constraint point
        var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
            localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),
            dim = target._getTransformedDimensions(), scaled = false;

        this._setLocalMouse(localMouse, t);

        // Actually scale the object
        scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);

        // Make sure the constraints apply
        target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        return scaled;
      },

      /**
       * @private
       * @return {Boolean} true if the scaling occurred
       */
      _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
        var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,
            scaleX = localMouse.x * target.scaleX / _dim.x,
            scaleY = localMouse.y * target.scaleY / _dim.y,
            changeX = target.scaleX !== scaleX,
            changeY = target.scaleY !== scaleY;

        transform.newScaleX = scaleX;
        transform.newScaleY = scaleY;
        if (fabric.Textbox && by === 'x' && target instanceof fabric.Textbox) {
          var w = target.width * (localMouse.x / _dim.x);
          if (w >= target.getMinWidth()) {
            scaled = w !== target.width;
            target.set('width', w);
            return scaled;
          }
          return false;
        }

        if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {
          forbidScalingX = true;
          localMouse.x = 0;
        }

        if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {
          forbidScalingY = true;
          localMouse.y = 0;
        }

        if (by === 'equally' && !lockScalingX && !lockScalingY) {
          scaled = this._scaleObjectEqually(localMouse, target, transform, _dim);
        }
        else if (!by) {
          forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
          forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
        }
        else if (by === 'x' && !target.get('lockUniScaling')) {
          forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = changeX));
        }
        else if (by === 'y' && !target.get('lockUniScaling')) {
          forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = changeY));
        }
        forbidScalingX || forbidScalingY || this._flipObject(transform, by);
        return scaled;
      },

      /**
       * @private
       * @return {Boolean} true if the scaling occurred
       */
      _scaleObjectEqually: function(localMouse, target, transform, _dim) {

        var dist = localMouse.y + localMouse.x,
            lastDist = _dim.y * transform.original.scaleY / target.scaleY +
                       _dim.x * transform.original.scaleX / target.scaleX,
            scaled, signX = localMouse.x < 0 ? -1 : 1,
            signY = localMouse.y < 0 ? -1 : 1, newScaleX, newScaleY;

        // We use transform.scaleX/Y instead of target.scaleX/Y
        // because the object may have a min scale and we'll loose the proportions
        newScaleX = signX * Math.abs(transform.original.scaleX * dist / lastDist);
        newScaleY = signY * Math.abs(transform.original.scaleY * dist / lastDist);
        scaled = newScaleX !== target.scaleX || newScaleY !== target.scaleY;
        target.set('scaleX', newScaleX);
        target.set('scaleY', newScaleY);
        return scaled;
      },

      /**
       * @private
       */
      _flipObject: function(transform, by) {
        if (transform.newScaleX < 0 && by !== 'y') {
          if (transform.originX === 'left') {
            transform.originX = 'right';
          }
          else if (transform.originX === 'right') {
            transform.originX = 'left';
          }
        }

        if (transform.newScaleY < 0 && by !== 'x') {
          if (transform.originY === 'top') {
            transform.originY = 'bottom';
          }
          else if (transform.originY === 'bottom') {
            transform.originY = 'top';
          }
        }
      },

      /**
       * @private
       */
      _setLocalMouse: function(localMouse, t) {
        var target = t.target, zoom = this.getZoom(),
            padding = target.padding / zoom;

        if (t.originX === 'right') {
          localMouse.x *= -1;
        }
        else if (t.originX === 'center') {
          localMouse.x *= t.mouseXSign * 2;
          if (localMouse.x < 0) {
            t.mouseXSign = -t.mouseXSign;
          }
        }

        if (t.originY === 'bottom') {
          localMouse.y *= -1;
        }
        else if (t.originY === 'center') {
          localMouse.y *= t.mouseYSign * 2;
          if (localMouse.y < 0) {
            t.mouseYSign = -t.mouseYSign;
          }
        }

        // adjust the mouse coordinates when dealing with padding
        if (abs(localMouse.x) > padding) {
          if (localMouse.x < 0) {
            localMouse.x += padding;
          }
          else {
            localMouse.x -= padding;
          }
        }
        else { // mouse is within the padding, set to 0
          localMouse.x = 0;
        }

        if (abs(localMouse.y) > padding) {
          if (localMouse.y < 0) {
            localMouse.y += padding;
          }
          else {
            localMouse.y -= padding;
          }
        }
        else {
          localMouse.y = 0;
        }
      },

      /**
       * Rotates object by invoking its rotate method
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @return {Boolean} true if the rotation occurred
       */
      _rotateObject: function (x, y) {

        var t = this._currentTransform,
            target = t.target, constraintPosition,
            constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);

        if (target.lockRotation) {
          return false;
        }

        var lastAngle = atan2(t.ey - constraintPosition.y, t.ex - constraintPosition.x),
            curAngle = atan2(y - constraintPosition.y, x - constraintPosition.x),
            angle = radiansToDegrees(curAngle - lastAngle + t.theta),
            hasRotated = true;

        if (target.snapAngle > 0) {
          var snapAngle  = target.snapAngle,
              snapThreshold  = target.snapThreshold || snapAngle,
              rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
              leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

          if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
            angle = leftAngleLocked;
          }
          else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
            angle = rightAngleLocked;
          }
        }

        // normalize angle to positive value
        if (angle < 0) {
          angle = 360 + angle;
        }
        angle %= 360;

        if (target.angle === angle) {
          hasRotated = false;
        }
        else {
          // rotation only happen here
          target.angle = angle;
          // Make sure the constraints apply
          target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        }

        return hasRotated;
      },

      /**
       * Set the cursor type of the canvas element
       * @param {String} value Cursor type of the canvas element.
       * @see http://www.w3.org/TR/css3-ui/#cursor
       */
      setCursor: function (value) {
        this.upperCanvasEl.style.cursor = value;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx to draw the selection on
       */
      _drawSelection: function (ctx) {
        var groupSelector = this._groupSelector,
            left = groupSelector.left,
            top = groupSelector.top,
            aleft = abs(left),
            atop = abs(top);

        if (this.selectionColor) {
          ctx.fillStyle = this.selectionColor;

          ctx.fillRect(
            groupSelector.ex - ((left > 0) ? 0 : -left),
            groupSelector.ey - ((top > 0) ? 0 : -top),
            aleft,
            atop
          );
        }

        if (!this.selectionLineWidth || !this.selectionBorderColor) {
          return;
        }
        ctx.lineWidth = this.selectionLineWidth;
        ctx.strokeStyle = this.selectionBorderColor;

        // selection border
        if (this.selectionDashArray.length > 1 && !supportLineDash) {

          var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
              py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);

          ctx.beginPath();

          fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);

          ctx.closePath();
          ctx.stroke();
        }
        else {
          fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
          ctx.strokeRect(
            groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
            groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
            aleft,
            atop
          );
        }
      },

      /**
       * Method that determines what object we are clicking on
       * the skipGroup parameter is for internal use, is needed for shift+click action
       * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target
       * or the outside part of the corner.
       * @param {Event} e mouse event
       * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
       * @return {fabric.Object} the target found
       */
      findTarget: function (e, skipGroup) {
        if (this.skipTargetFind) {
          return;
        }

        var ignoreZoom = true,
            pointer = this.getPointer(e, ignoreZoom),
            activeObject = this._activeObject,
            aObjects = this.getActiveObjects(),
            activeTarget, activeTargetSubs;

        // first check current group (if one exists)
        // active group does not check sub targets like normal groups.
        // if active group just exits.
        this.targets = [];

        if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
          return activeObject;
        }
        // if we hit the corner of an activeObject, let's return that.
        if (aObjects.length === 1 && activeObject._findTargetCorner(pointer)) {
          return activeObject;
        }
        if (aObjects.length === 1 &&
          activeObject === this._searchPossibleTargets([activeObject], pointer)) {
          if (!this.preserveObjectStacking) {
            return activeObject;
          }
          else {
            activeTarget = activeObject;
            activeTargetSubs = this.targets;
            this.targets = [];
          }
        }
        var target = this._searchPossibleTargets(this._objects, pointer);
        if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
          target = activeTarget;
          this.targets = activeTargetSubs;
        }
        return target;
      },

      /**
       * Checks point is inside the object.
       * @param {Object} [pointer] x,y object of point coordinates we want to check.
       * @param {fabric.Object} obj Object to test against
       * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.
       * @return {Boolean} true if point is contained within an area of given object
       * @private
       */
      _checkTarget: function(pointer, obj, globalPointer) {
        if (obj &&
            obj.visible &&
            obj.evented &&
            this.containsPoint(null, obj, pointer)){
          if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
            var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);
            if (!isTransparent) {
              return true;
            }
          }
          else {
            return true;
          }
        }
      },

      /**
       * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted
       * @param {Array} [objects] objects array to look into
       * @param {Object} [pointer] x,y object of point coordinates we want to check.
       * @return {fabric.Object} object that contains pointer
       * @private
       */
      _searchPossibleTargets: function(objects, pointer) {
        // Cache all targets where their bounding box contains point.
        var target, i = objects.length, subTarget;
        // Do not check for currently grouped objects, since we check the parent group itself.
        // until we call this function specifically to search inside the activeGroup
        while (i--) {
          var objToCheck = objects[i];
          var pointerToUse = objToCheck.group && objToCheck.group.type !== 'activeSelection' ?
            this._normalizePointer(objToCheck.group, pointer) : pointer;
          if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
            target = objects[i];
            if (target.subTargetCheck && target instanceof fabric.Group) {
              subTarget = this._searchPossibleTargets(target._objects, pointer);
              subTarget && this.targets.push(subTarget);
            }
            break;
          }
        }
        return target;
      },

      /**
       * Returns pointer coordinates without the effect of the viewport
       * @param {Object} pointer with "x" and "y" number values
       * @return {Object} object with "x" and "y" number values
       */
      restorePointerVpt: function(pointer) {
        return fabric.util.transformPoint(
          pointer,
          fabric.util.invertTransform(this.viewportTransform)
        );
      },

      /**
       * Returns pointer coordinates relative to canvas.
       * Can return coordinates with or without viewportTransform.
       * ignoreZoom false gives back coordinates that represent
       * the point clicked on canvas element.
       * ignoreZoom true gives back coordinates after being processed
       * by the viewportTransform ( sort of coordinates of what is displayed
       * on the canvas where you are clicking.
       * ignoreZoom true = HTMLElement coordinates relative to top,left
       * ignoreZoom false, default = fabric space coordinates, the same used for shape position
       * To interact with your shapes top and left you want to use ignoreZoom true
       * most of the time, while ignoreZoom false will give you coordinates
       * compatible with the object.oCoords system.
       * of the time.
       * @param {Event} e
       * @param {Boolean} ignoreZoom
       * @return {Object} object with "x" and "y" number values
       */
      getPointer: function (e, ignoreZoom) {
        // return cached values if we are in the event processing chain
        if (this._absolutePointer && !ignoreZoom) {
          return this._absolutePointer;
        }
        if (this._pointer && ignoreZoom) {
          return this._pointer;
        }

        var pointer = getPointer(e),
            upperCanvasEl = this.upperCanvasEl,
            bounds = upperCanvasEl.getBoundingClientRect(),
            boundsWidth = bounds.width || 0,
            boundsHeight = bounds.height || 0,
            cssScale;

        if (!boundsWidth || !boundsHeight ) {
          if ('top' in bounds && 'bottom' in bounds) {
            boundsHeight = Math.abs( bounds.top - bounds.bottom );
          }
          if ('right' in bounds && 'left' in bounds) {
            boundsWidth = Math.abs( bounds.right - bounds.left );
          }
        }

        this.calcOffset();
        pointer.x = pointer.x - this._offset.left;
        pointer.y = pointer.y - this._offset.top;
        if (!ignoreZoom) {
          pointer = this.restorePointerVpt(pointer);
        }

        var retinaScaling = this.getRetinaScaling();
        if (retinaScaling !== 1) {
          pointer.x /= retinaScaling;
          pointer.y /= retinaScaling;
        }

        if (boundsWidth === 0 || boundsHeight === 0) {
          // If bounds are not available (i.e. not visible), do not apply scale.
          cssScale = { width: 1, height: 1 };
        }
        else {
          cssScale = {
            width: upperCanvasEl.width / boundsWidth,
            height: upperCanvasEl.height / boundsHeight
          };
        }

        return {
          x: pointer.x * cssScale.width,
          y: pointer.y * cssScale.height
        };
      },

      /**
       * @private
       * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
       */
      _createUpperCanvas: function () {
        var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ''),
            lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;

        // there is no need to create a new upperCanvas element if we have already one.
        if (upperCanvasEl) {
          upperCanvasEl.className = '';
        }
        else {
          upperCanvasEl = this._createCanvasElement();
          this.upperCanvasEl = upperCanvasEl;
        }
        fabric.util.addClass(upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

        this.wrapperEl.appendChild(upperCanvasEl);

        this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);
        this._applyCanvasStyle(upperCanvasEl);
        this.contextTop = upperCanvasEl.getContext('2d');
      },

      /**
       * @private
       */
      _createCacheCanvas: function () {
        this.cacheCanvasEl = this._createCanvasElement();
        this.cacheCanvasEl.setAttribute('width', this.width);
        this.cacheCanvasEl.setAttribute('height', this.height);
        this.contextCache = this.cacheCanvasEl.getContext('2d');
      },

      /**
       * @private
       */
      _initWrapperElement: function () {
        this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
          'class': this.containerClass
        });
        fabric.util.setStyle(this.wrapperEl, {
          width: this.width + 'px',
          height: this.height + 'px',
          position: 'relative'
        });
        fabric.util.makeElementUnselectable(this.wrapperEl);
      },

      /**
       * @private
       * @param {HTMLElement} element canvas element to apply styles on
       */
      _applyCanvasStyle: function (element) {
        var width = this.width || element.width,
            height = this.height || element.height;

        fabric.util.setStyle(element, {
          position: 'absolute',
          width: width + 'px',
          height: height + 'px',
          left: 0,
          top: 0,
          'touch-action': this.allowTouchScrolling ? 'manipulation' : 'none',
          '-ms-touch-action': this.allowTouchScrolling ? 'manipulation' : 'none'
        });
        element.width = width;
        element.height = height;
        fabric.util.makeElementUnselectable(element);
      },

      /**
       * Copy the entire inline style from one element (fromEl) to another (toEl)
       * @private
       * @param {Element} fromEl Element style is copied from
       * @param {Element} toEl Element copied style is applied to
       */
      _copyCanvasStyle: function (fromEl, toEl) {
        toEl.style.cssText = fromEl.style.cssText;
      },

      /**
       * Returns context of canvas where object selection is drawn
       * @return {CanvasRenderingContext2D}
       */
      getSelectionContext: function() {
        return this.contextTop;
      },

      /**
       * Returns &lt;canvas> element on which object selection is drawn
       * @return {HTMLCanvasElement}
       */
      getSelectionElement: function () {
        return this.upperCanvasEl;
      },

      /**
       * Returns currently active object
       * @return {fabric.Object} active object
       */
      getActiveObject: function () {
        return this._activeObject;
      },

      /**
       * Returns an array with the current selected objects
       * @return {fabric.Object} active object
       */
      getActiveObjects: function () {
        var active = this._activeObject;
        if (active) {
          if (active.type === 'activeSelection' && active._objects) {
            return active._objects.slice(0);
          }
          else {
            return [active];
          }
        }
        return [];
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was removed
       */
      _onObjectRemoved: function(obj) {
        // removing active object should fire "selection:cleared" events
        if (obj === this._activeObject) {
          this.fire('before:selection:cleared', { target: obj });
          this._discardActiveObject();
          this.fire('selection:cleared', { target: obj });
          obj.fire('deselected');
        }
        if (obj === this._hoveredTarget){
          this._hoveredTarget = null;
          this._hoveredTargets = [];
        }
        this.callSuper('_onObjectRemoved', obj);
      },

      /**
       * @private
       * Compares the old activeObject with the current one and fires correct events
       * @param {fabric.Object} obj old activeObject
       */
      _fireSelectionEvents: function(oldObjects, e) {
        var somethingChanged = false, objects = this.getActiveObjects(),
            added = [], removed = [], opt = { e: e };
        oldObjects.forEach(function(oldObject) {
          if (objects.indexOf(oldObject) === -1) {
            somethingChanged = true;
            oldObject.fire('deselected', opt);
            removed.push(oldObject);
          }
        });
        objects.forEach(function(object) {
          if (oldObjects.indexOf(object) === -1) {
            somethingChanged = true;
            object.fire('selected', opt);
            added.push(object);
          }
        });
        if (oldObjects.length > 0 && objects.length > 0) {
          opt.selected = added;
          opt.deselected = removed;
          // added for backward compatibility
          opt.updated = added[0] || removed[0];
          opt.target = this._activeObject;
          somethingChanged && this.fire('selection:updated', opt);
        }
        else if (objects.length > 0) {
          // deprecated event
          if (objects.length === 1) {
            opt.target = added[0];
            this.fire('object:selected', opt);
          }
          opt.selected = added;
          // added for backward compatibility
          opt.target = this._activeObject;
          this.fire('selection:created', opt);
        }
        else if (oldObjects.length > 0) {
          opt.deselected = removed;
          this.fire('selection:cleared', opt);
        }
      },

      /**
       * Sets given object as the only active object on canvas
       * @param {fabric.Object} object Object to set as an active one
       * @param {Event} [e] Event (passed along when firing "object:selected")
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      setActiveObject: function (object, e) {
        var currentActives = this.getActiveObjects();
        this._setActiveObject(object, e);
        this._fireSelectionEvents(currentActives, e);
        return this;
      },

      /**
       * @private
       * @param {Object} object to set as active
       * @param {Event} [e] Event (passed along when firing "object:selected")
       * @return {Boolean} true if the selection happened
       */
      _setActiveObject: function(object, e) {
        if (this._activeObject === object) {
          return false;
        }
        if (!this._discardActiveObject(e, object)) {
          return false;
        }
        if (object.onSelect({ e: e })) {
          return false;
        }
        this._activeObject = object;
        return true;
      },

      /**
       * @private
       */
      _discardActiveObject: function(e, object) {
        var obj = this._activeObject;
        if (obj) {
          // onDeselect return TRUE to cancel selection;
          if (obj.onDeselect({ e: e, object: object })) {
            return false;
          }
          this._activeObject = null;
        }
        return true;
      },

      /**
       * Discards currently active object and fire events. If the function is called by fabric
       * as a consequence of a mouse event, the event is passed as a parameter and
       * sent to the fire function for the custom events. When used as a method the
       * e param does not have any application.
       * @param {event} e
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      discardActiveObject: function (e) {
        var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();
        if (currentActives.length) {
          this.fire('before:selection:cleared', { target: activeObject, e: e });
        }
        this._discardActiveObject(e);
        this._fireSelectionEvents(currentActives, e);
        return this;
      },

      /**
       * Clears a canvas element and removes all event listeners
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      dispose: function () {
        var wrapper = this.wrapperEl;
        this.removeListeners();
        wrapper.removeChild(this.upperCanvasEl);
        wrapper.removeChild(this.lowerCanvasEl);
        this.contextCache = null;
        this.contextTop = null;
        ['upperCanvasEl', 'cacheCanvasEl'].forEach((function(element) {
          fabric.util.cleanUpJsdomNode(this[element]);
          this[element] = undefined;
        }).bind(this));
        if (wrapper.parentNode) {
          wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
        }
        delete this.wrapperEl;
        fabric.StaticCanvas.prototype.dispose.call(this);
        return this;
      },

      /**
       * Clears all contexts (background, main, top) of an instance
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clear: function () {
        // this.discardActiveGroup();
        this.discardActiveObject();
        this.clearContext(this.contextTop);
        return this.callSuper('clear');
      },

      /**
       * Draws objects' controls (borders/controls)
       * @param {CanvasRenderingContext2D} ctx Context to render controls on
       */
      drawControls: function(ctx) {
        var activeObject = this._activeObject;

        if (activeObject) {
          activeObject._renderControls(ctx);
        }
      },

      /**
       * @private
       */
      _toObject: function(instance, methodName, propertiesToInclude) {
        //If the object is part of the current selection group, it should
        //be transformed appropriately
        //i.e. it should be serialised as it would appear if the selection group
        //were to be destroyed.
        var originalProperties = this._realizeGroupTransformOnObject(instance),
            object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
        //Undo the damage we did by changing all of its properties
        this._unwindGroupTransformOnObject(instance, originalProperties);
        return object;
      },

      /**
       * Realises an object's group transformation on it
       * @private
       * @param {fabric.Object} [instance] the object to transform (gets mutated)
       * @returns the original values of instance which were changed
       */
      _realizeGroupTransformOnObject: function(instance) {
        if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
          var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
          //Copy all the positionally relevant properties across now
          var originalValues = {};
          layoutProps.forEach(function(prop) {
            originalValues[prop] = instance[prop];
          });
          this._activeObject.realizeTransform(instance);
          return originalValues;
        }
        else {
          return null;
        }
      },

      /**
       * Restores the changed properties of instance
       * @private
       * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
       * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
       */
      _unwindGroupTransformOnObject: function(instance, originalValues) {
        if (originalValues) {
          instance.set(originalValues);
        }
      },

      /**
       * @private
       */
      _setSVGObject: function(markup, instance, reviver) {
        //If the object is in a selection group, simulate what would happen to that
        //object when the group is deselected
        var originalProperties = this._realizeGroupTransformOnObject(instance);
        this.callSuper('_setSVGObject', markup, instance, reviver);
        this._unwindGroupTransformOnObject(instance, originalProperties);
      },

      setViewportTransform: function (vpt) {
        if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
          this._activeObject.clearContextTop();
        }
        fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
      }
    });

    // copying static properties manually to work around Opera's bug,
    // where "prototype" property is enumerable and overrides existing prototype
    for (var prop in fabric.StaticCanvas) {
      if (prop !== 'prototype') {
        fabric.Canvas[prop] = fabric.StaticCanvas[prop];
      }
    }
  })();


  (function() {

    var cursorOffset = {
          mt: 0, // n
          tr: 1, // ne
          mr: 2, // e
          br: 3, // se
          mb: 4, // s
          bl: 5, // sw
          ml: 6, // w
          tl: 7 // nw
        },
        addListener = fabric.util.addListener,
        removeListener = fabric.util.removeListener,
        RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1,
        addEventOptions = { passive: false };

    function checkClick(e, value) {
      return e.button && (e.button === value - 1);
    }

    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

      /**
       * Map of cursor style values for each of the object controls
       * @private
       */
      cursorMap: [
        'n-resize',
        'ne-resize',
        'e-resize',
        'se-resize',
        's-resize',
        'sw-resize',
        'w-resize',
        'nw-resize'
      ],

      /**
       * Contains the id of the touch event that owns the fabric transform
       * @type Number
       * @private
       */
      mainTouchId: null,

      /**
       * Adds mouse listeners to canvas
       * @private
       */
      _initEventListeners: function () {
        // in case we initialized the class twice. This should not happen normally
        // but in some kind of applications where the canvas element may be changed
        // this is a workaround to having double listeners.
        this.removeListeners();
        this._bindEvents();
        this.addOrRemove(addListener, 'add');
      },

      /**
       * return an event prefix pointer or mouse.
       * @private
       */
      _getEventPrefix: function () {
        return this.enablePointerEvents ? 'pointer' : 'mouse';
      },

      addOrRemove: function(functor, eventjsFunctor) {
        var canvasElement = this.upperCanvasEl,
            eventTypePrefix = this._getEventPrefix();
        functor(fabric.window, 'resize', this._onResize);
        functor(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
        functor(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
        functor(canvasElement, eventTypePrefix + 'out', this._onMouseOut);
        functor(canvasElement, eventTypePrefix + 'enter', this._onMouseEnter);
        functor(canvasElement, 'wheel', this._onMouseWheel);
        functor(canvasElement, 'contextmenu', this._onContextMenu);
        functor(canvasElement, 'dblclick', this._onDoubleClick);
        functor(canvasElement, 'dragover', this._onDragOver);
        functor(canvasElement, 'dragenter', this._onDragEnter);
        functor(canvasElement, 'dragleave', this._onDragLeave);
        functor(canvasElement, 'drop', this._onDrop);
        if (!this.enablePointerEvents) {
          functor(canvasElement, 'touchstart', this._onTouchStart, addEventOptions);
        }
        if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {
          eventjs[eventjsFunctor](canvasElement, 'gesture', this._onGesture);
          eventjs[eventjsFunctor](canvasElement, 'drag', this._onDrag);
          eventjs[eventjsFunctor](canvasElement, 'orientation', this._onOrientationChange);
          eventjs[eventjsFunctor](canvasElement, 'shake', this._onShake);
          eventjs[eventjsFunctor](canvasElement, 'longpress', this._onLongPress);
        }
      },

      /**
       * Removes all event listeners
       */
      removeListeners: function() {
        this.addOrRemove(removeListener, 'remove');
        // if you dispose on a mouseDown, before mouse up, you need to clean document to...
        var eventTypePrefix = this._getEventPrefix();
        removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
        removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
        removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
        removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      },

      /**
       * @private
       */
      _bindEvents: function() {
        if (this.eventsBound) {
          // for any reason we pass here twice we do not want to bind events twice.
          return;
        }
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onTouchStart = this._onTouchStart.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._onTouchEnd = this._onTouchEnd.bind(this);
        this._onResize = this._onResize.bind(this);
        this._onGesture = this._onGesture.bind(this);
        this._onDrag = this._onDrag.bind(this);
        this._onShake = this._onShake.bind(this);
        this._onLongPress = this._onLongPress.bind(this);
        this._onOrientationChange = this._onOrientationChange.bind(this);
        this._onMouseWheel = this._onMouseWheel.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onMouseEnter = this._onMouseEnter.bind(this);
        this._onContextMenu = this._onContextMenu.bind(this);
        this._onDoubleClick = this._onDoubleClick.bind(this);
        this._onDragOver = this._onDragOver.bind(this);
        this._onDragEnter = this._simpleEventHandler.bind(this, 'dragenter');
        this._onDragLeave = this._simpleEventHandler.bind(this, 'dragleave');
        this._onDrop = this._simpleEventHandler.bind(this, 'drop');
        this.eventsBound = true;
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js gesture
       * @param {Event} [self] Inner Event object
       */
      _onGesture: function(e, self) {
        this.__onTransformGesture && this.__onTransformGesture(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js drag
       * @param {Event} [self] Inner Event object
       */
      _onDrag: function(e, self) {
        this.__onDrag && this.__onDrag(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on wheel event
       */
      _onMouseWheel: function(e) {
        this.__onMouseWheel(e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseOut: function(e) {
        var target = this._hoveredTarget;
        this.fire('mouse:out', { target: target, e: e });
        this._hoveredTarget = null;
        target && target.fire('mouseout', { e: e });

        var _this = this;
        this._hoveredTargets.forEach(function(_target){
          _this.fire('mouse:out', { target: target, e: e });
          _target && target.fire('mouseout', { e: e });
        });
        this._hoveredTargets = [];

        if (this._iTextInstances) {
          this._iTextInstances.forEach(function(obj) {
            if (obj.isEditing) {
              obj.hiddenTextarea.focus();
            }
          });
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseenter
       */
      _onMouseEnter: function(e) {
        // This find target and consequent 'mouse:over' is used to
        // clear old instances on hovered target.
        // calling findTarget has the side effect of killing target.__corner.
        // as a short term fix we are not firing this if we are currently transforming.
        // as a long term fix we need to separate the action of finding a target with the
        // side effects we added to it.
        if (!this.currentTransform && !this.findTarget(e)) {
          this.fire('mouse:over', { target: null, e: e });
          this._hoveredTarget = null;
          this._hoveredTargets = [];
        }
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js orientation change
       * @param {Event} [self] Inner Event object
       */
      _onOrientationChange: function(e, self) {
        this.__onOrientationChange && this.__onOrientationChange(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       * @param {Event} [self] Inner Event object
       */
      _onShake: function(e, self) {
        this.__onShake && this.__onShake(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       * @param {Event} [self] Inner Event object
       */
      _onLongPress: function(e, self) {
        this.__onLongPress && this.__onLongPress(e, self);
      },

      /**
       * prevent default to allow drop event to be fired
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       */
      _onDragOver: function(e) {
        e.preventDefault();
        var target = this._simpleEventHandler('dragover', e);
        this._fireEnterLeaveEvents(target, e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onContextMenu: function (e) {
        if (this.stopContextMenu) {
          e.stopPropagation();
          e.preventDefault();
        }
        return false;
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onDoubleClick: function (e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'dblclick');
        this._resetTransformEventData(e);
      },

      /**
       * Return a the id of an event.
       * returns either the pointerId or the identifier or 0 for the mouse event
       * @private
       * @param {Event} evt Event object
       */
      getPointerId: function(evt) {
        var changedTouches = evt.changedTouches;

        if (changedTouches) {
          return changedTouches[0] && changedTouches[0].identifier;
        }

        if (this.enablePointerEvents) {
          return evt.pointerId;
        }

        return -1;
      },

      /**
       * Determines if an event has the id of the event that is considered main
       * @private
       * @param {evt} event Event object
       */
      _isMainEvent: function(evt) {
        if (evt.isPrimary === true) {
          return true;
        }
        if (evt.isPrimary === false) {
          return false;
        }
        if (evt.type === 'touchend' && evt.touches.length === 0) {
          return true;
        }
        if (evt.changedTouches) {
          return evt.changedTouches[0].identifier === this.mainTouchId;
        }
        return true;
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onTouchStart: function(e) {
        e.preventDefault();
        if (this.mainTouchId === null) {
          this.mainTouchId = this.getPointerId(e);
        }
        this.__onMouseDown(e);
        this._resetTransformEventData();
        var canvasElement = this.upperCanvasEl,
            eventTypePrefix = this._getEventPrefix();
        addListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
        addListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
        // Unbind mousedown to prevent double triggers from touch devices
        removeListener(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseDown: function (e) {
        this.__onMouseDown(e);
        this._resetTransformEventData();
        var canvasElement = this.upperCanvasEl,
            eventTypePrefix = this._getEventPrefix();
        removeListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
        addListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
        addListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onTouchEnd: function(e) {
        if (e.touches.length > 0) {
          // if there are still touches stop here
          return;
        }
        this.__onMouseUp(e);
        this._resetTransformEventData();
        this.mainTouchId = null;
        var eventTypePrefix = this._getEventPrefix();
        removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
        removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
        var _this = this;
        if (this._willAddMouseDown) {
          clearTimeout(this._willAddMouseDown);
        }
        this._willAddMouseDown = setTimeout(function() {
          // Wait 400ms before rebinding mousedown to prevent double triggers
          // from touch devices
          addListener(_this.upperCanvasEl, eventTypePrefix + 'down', _this._onMouseDown);
          _this._willAddMouseDown = 0;
        }, 400);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      _onMouseUp: function (e) {
        this.__onMouseUp(e);
        this._resetTransformEventData();
        var canvasElement = this.upperCanvasEl,
            eventTypePrefix = this._getEventPrefix();
        if (this._isMainEvent(e)) {
          removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
          removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
          addListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      _onMouseMove: function (e) {
        !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
        this.__onMouseMove(e);
      },

      /**
       * @private
       */
      _onResize: function () {
        this.calcOffset();
      },

      /**
       * Decides whether the canvas should be redrawn in mouseup and mousedown events.
       * @private
       * @param {Object} target
       */
      _shouldRender: function(target) {
        var activeObject = this._activeObject;

        if (
          !!activeObject !== !!target ||
          (activeObject && target && (activeObject !== target))
        ) {
          // this covers: switch of target, from target to no target, selection of target
          // multiSelection with key and mouse
          return true;
        }
        else if (activeObject && activeObject.isEditing) {
          // if we mouse up/down over a editing textbox a cursor change,
          // there is no need to re render
          return false;
        }
        return false;
      },

      /**
       * Method that defines the actions when mouse is released on canvas.
       * The method resets the currentTransform parameters, store the image corner
       * position in the image object and render the canvas on top.
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      __onMouseUp: function (e) {
        var target, transform = this._currentTransform,
            groupSelector = this._groupSelector, shouldRender = false,
            isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
        this._cacheTransformEventData(e);
        target = this._target;
        this._handleEvent(e, 'up:before');
        // if right/middle click just fire events and return
        // target undefined will make the _handleEvent search the target
        if (checkClick(e, RIGHT_CLICK)) {
          if (this.fireRightClick) {
            this._handleEvent(e, 'up', RIGHT_CLICK, isClick);
          }
          return;
        }

        if (checkClick(e, MIDDLE_CLICK)) {
          if (this.fireMiddleClick) {
            this._handleEvent(e, 'up', MIDDLE_CLICK, isClick);
          }
          this._resetTransformEventData();
          return;
        }

        if (this.isDrawingMode && this._isCurrentlyDrawing) {
          this._onMouseUpInDrawingMode(e);
          return;
        }

        if (!this._isMainEvent(e)) {
          return;
        }
        if (transform) {
          this._finalizeCurrentTransform(e);
          shouldRender = transform.actionPerformed;
        }

        if (!isClick) {
          this._maybeGroupObjects(e);
          shouldRender || (shouldRender = this._shouldRender(target));
        }
        if (target) {
          target.isMoving = false;
        }
        this._setCursorFromEvent(e, target);
        this._handleEvent(e, 'up', LEFT_CLICK, isClick);
        this._groupSelector = null;
        this._currentTransform = null;
        // reset the target information about which corner is selected
        target && (target.__corner = 0);
        if (shouldRender) {
          this.requestRenderAll();
        }
        else if (!isClick) {
          this.renderTop();
        }
      },

      /**
       * @private
       * Handle event firing for target and subtargets
       * @param {Event} e event from mouse
       * @param {String} eventType event to fire (up, down or move)
       * @return {Fabric.Object} target return the the target found, for internal reasons.
       */
      _simpleEventHandler: function(eventType, e) {
        var target = this.findTarget(e),
            targets = this.targets,
            options = {
              e: e,
              target: target,
              subTargets: targets,
            };
        this.fire(eventType, options);
        target && target.fire(eventType, options);
        if (!targets) {
          return target;
        }
        for (var i = 0; i < targets.length; i++) {
          targets[i].fire(eventType, options);
        }
        return target;
      },

      /**
       * @private
       * Handle event firing for target and subtargets
       * @param {Event} e event from mouse
       * @param {String} eventType event to fire (up, down or move)
       * @param {fabric.Object} targetObj receiving event
       * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
       * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
       */
      _handleEvent: function(e, eventType, button, isClick) {
        var target = this._target,
            targets = this.targets || [],
            options = {
              e: e,
              target: target,
              subTargets: targets,
              button: button || LEFT_CLICK,
              isClick: isClick || false,
              pointer: this._pointer,
              absolutePointer: this._absolutePointer,
              transform: this._currentTransform
            };
        this.fire('mouse:' + eventType, options);
        target && target.fire('mouse' + eventType, options);
        for (var i = 0; i < targets.length; i++) {
          targets[i].fire('mouse' + eventType, options);
        }
      },

      /**
       * @private
       * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
       */
      _finalizeCurrentTransform: function(e) {

        var transform = this._currentTransform,
            target = transform.target,
            eventName,
            options = {
              e: e,
              target: target,
              transform: transform,
            };

        if (target._scaling) {
          target._scaling = false;
        }

        target.setCoords();

        if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
          if (transform.actionPerformed) {
            eventName = this._addEventOptions(options, transform);
            this._fire(eventName, options);
          }
          this._fire('modified', options);
        }
      },

      /**
       * Mutate option object in order to add by property and give back the event name.
       * @private
       * @param {Object} options to mutate
       * @param {Object} transform to inspect action from
       */
      _addEventOptions: function(options, transform) {
        // we can probably add more details at low cost
        // scale change, rotation changes, translation changes
        var eventName, by;
        switch (transform.action) {
          case 'scaleX':
            eventName = 'scaled';
            by = 'x';
            break;
          case 'scaleY':
            eventName = 'scaled';
            by = 'y';
            break;
          case 'skewX':
            eventName = 'skewed';
            by = 'x';
            break;
          case 'skewY':
            eventName = 'skewed';
            by = 'y';
            break;
          case 'scale':
            eventName = 'scaled';
            by = 'equally';
            break;
          case 'rotate':
            eventName = 'rotated';
            break;
          case 'drag':
            eventName = 'moved';
            break;
        }
        options.by = by;
        return eventName;
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseDownInDrawingMode: function(e) {
        this._isCurrentlyDrawing = true;
        if (this.getActiveObject()) {
          this.discardActiveObject(e).requestRenderAll();
        }
        if (this.clipTo) {
          fabric.util.clipContext(this, this.contextTop);
        }
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseDown(pointer, { e: e, pointer: pointer });
        this._handleEvent(e, 'down');
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      _onMouseMoveInDrawingMode: function(e) {
        if (this._isCurrentlyDrawing) {
          var pointer = this.getPointer(e);
          this.freeDrawingBrush.onMouseMove(pointer, { e: e, pointer: pointer });
        }
        this.setCursor(this.freeDrawingCursor);
        this._handleEvent(e, 'move');
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      _onMouseUpInDrawingMode: function(e) {
        if (this.clipTo) {
          this.contextTop.restore();
        }
        var pointer = this.getPointer(e);
        this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: e, pointer: pointer });
        this._handleEvent(e, 'up');
      },

      /**
       * Method that defines the actions when mouse is clicked on canvas.
       * The method inits the currentTransform parameters and renders all the
       * canvas so the current image can be placed on the top canvas and the rest
       * in on the container one.
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      __onMouseDown: function (e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'down:before');
        var target = this._target;
        // if right click just fire events
        if (checkClick(e, RIGHT_CLICK)) {
          if (this.fireRightClick) {
            this._handleEvent(e, 'down', RIGHT_CLICK);
          }
          return;
        }

        if (checkClick(e, MIDDLE_CLICK)) {
          if (this.fireMiddleClick) {
            this._handleEvent(e, 'down', MIDDLE_CLICK);
          }
          return;
        }

        if (this.isDrawingMode) {
          this._onMouseDownInDrawingMode(e);
          return;
        }

        if (!this._isMainEvent(e)) {
          return;
        }

        // ignore if some object is being transformed at this moment
        if (this._currentTransform) {
          return;
        }

        var pointer = this._pointer;
        // save pointer for check in __onMouseUp event
        this._previousPointer = pointer;
        var shouldRender = this._shouldRender(target),
            shouldGroup = this._shouldGroup(e, target);
        if (this._shouldClearSelection(e, target)) {
          this.discardActiveObject(e);
        }
        else if (shouldGroup) {
          this._handleGrouping(e, target);
          target = this._activeObject;
        }

        if (this.selection && (!target ||
          (!target.selectable && !target.isEditing && target !== this._activeObject))) {
          this._groupSelector = {
            ex: pointer.x,
            ey: pointer.y,
            top: 0,
            left: 0
          };
        }

        if (target) {
          var alreadySelected = target === this._activeObject;
          if (target.selectable) {
            this.setActiveObject(target, e);
          }
          if (target === this._activeObject && (target.__corner || !shouldGroup)) {
            this._setupCurrentTransform(e, target, alreadySelected);
          }
        }
        this._handleEvent(e, 'down');
        // we must renderAll so that we update the visuals
        (shouldRender || shouldGroup) && this.requestRenderAll();
      },

      /**
       * reset cache form common information needed during event processing
       * @private
       */
      _resetTransformEventData: function() {
        this._target = null;
        this._pointer = null;
        this._absolutePointer = null;
      },

      /**
       * Cache common information needed during event processing
       * @private
       * @param {Event} e Event object fired on event
       */
      _cacheTransformEventData: function(e) {
        // reset in order to avoid stale caching
        this._resetTransformEventData();
        this._pointer = this.getPointer(e, true);
        this._absolutePointer = this.restorePointerVpt(this._pointer);
        this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;
      },

      /**
       * @private
       */
      _beforeTransform: function(e) {
        var t = this._currentTransform;
        this.stateful && t.target.saveState();
        this.fire('before:transform', {
          e: e,
          transform: t,
        });
        // determine if it's a drag or rotate case
        if (t.corner) {
          this.onBeforeScaleRotate(t.target);
        }
      },

      /**
       * Method that defines the actions when mouse is hovering the canvas.
       * The currentTransform parameter will define whether the user is rotating/scaling/translating
       * an image or neither of them (only hovering). A group selection is also possible and would cancel
       * all any other type of action.
       * In case of an image transformation only the top canvas will be rendered.
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      __onMouseMove: function (e) {
        this._handleEvent(e, 'move:before');
        this._cacheTransformEventData(e);
        var target, pointer;

        if (this.isDrawingMode) {
          this._onMouseMoveInDrawingMode(e);
          return;
        }

        if (!this._isMainEvent(e)) {
          return;
        }

        var groupSelector = this._groupSelector;

        // We initially clicked in an empty area, so we draw a box for multiple selection
        if (groupSelector) {
          pointer = this._pointer;

          groupSelector.left = pointer.x - groupSelector.ex;
          groupSelector.top = pointer.y - groupSelector.ey;

          this.renderTop();
        }
        else if (!this._currentTransform) {
          target = this.findTarget(e) || null;
          this._setCursorFromEvent(e, target);
          this._fireOverOutEvents(target, e);
        }
        else {
          this._transformObject(e);
        }
        this._handleEvent(e, 'move');
        this._resetTransformEventData();
      },

      /**
       * Manage the mouseout, mouseover events for the fabric object on the canvas
       * @param {Fabric.Object} target the target where the target from the mousemove event
       * @param {Event} e Event object fired on mousemove
       * @private
       */
      _fireOverOutEvents: function(target, e) {
        var _hoveredTarget = this._hoveredTarget,
            _hoveredTargets = this._hoveredTargets, targets = this.targets,
            length = Math.max(_hoveredTargets.length, targets.length);

        this.fireSyntheticInOutEvents(target, e, {
          oldTarget: _hoveredTarget,
          evtOut: 'mouseout',
          canvasEvtOut: 'mouse:out',
          evtIn: 'mouseover',
          canvasEvtIn: 'mouse:over',
        });
        for (var i = 0; i < length; i++){
          this.fireSyntheticInOutEvents(targets[i], e, {
            oldTarget: _hoveredTargets[i],
            evtOut: 'mouseout',
            evtIn: 'mouseover',
          });
        }
        this._hoveredTarget = target;
        this._hoveredTargets = this.targets.concat();
      },

      /**
       * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
       * @param {Fabric.Object} target the target where the target from the onDrag event
       * @param {Event} e Event object fired on ondrag
       * @private
       */
      _fireEnterLeaveEvents: function(target, e) {
        var _draggedoverTarget = this._draggedoverTarget,
            _hoveredTargets = this._hoveredTargets, targets = this.targets,
            length = Math.max(_hoveredTargets.length, targets.length);

        this.fireSyntheticInOutEvents(target, e, {
          oldTarget: _draggedoverTarget,
          evtOut: 'dragleave',
          evtIn: 'dragenter',
        });
        for (var i = 0; i < length; i++) {
          this.fireSyntheticInOutEvents(targets[i], e, {
            oldTarget: _hoveredTargets[i],
            evtOut: 'dragleave',
            evtIn: 'dragenter',
          });
        }
        this._draggedoverTarget = target;
      },

      /**
       * Manage the synthetic in/out events for the fabric objects on the canvas
       * @param {Fabric.Object} target the target where the target from the supported events
       * @param {Event} e Event object fired
       * @param {Object} config configuration for the function to work
       * @param {String} config.targetName property on the canvas where the old target is stored
       * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
       * @param {String} config.evtOut name of the event to fire for out
       * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
       * @param {String} config.evtIn name of the event to fire for in
       * @private
       */
      fireSyntheticInOutEvents: function(target, e, config) {
        var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires,
            targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
        if (targetChanged) {
          inOpt = { e: e, target: target, previousTarget: oldTarget };
          outOpt = { e: e, target: oldTarget, nextTarget: target };
        }
        inFires = target && targetChanged;
        outFires = oldTarget && targetChanged;
        if (outFires) {
          canvasEvtOut && this.fire(canvasEvtOut, outOpt);
          oldTarget.fire(config.evtOut, outOpt);
        }
        if (inFires) {
          canvasEvtIn && this.fire(canvasEvtIn, inOpt);
          target.fire(config.evtIn, inOpt);
        }
      },

      /**
       * Method that defines actions when an Event Mouse Wheel
       * @param {Event} e Event object fired on mouseup
       */
      __onMouseWheel: function(e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'wheel');
        this._resetTransformEventData();
      },

      /**
       * @private
       * @param {Event} e Event fired on mousemove
       */
      _transformObject: function(e) {
        var pointer = this.getPointer(e),
            transform = this._currentTransform;

        transform.reset = false;
        transform.target.isMoving = true;
        transform.shiftKey = e.shiftKey;
        transform.altKey = e[this.centeredKey];

        this._beforeScaleTransform(e, transform);
        this._performTransformAction(e, transform, pointer);

        transform.actionPerformed && this.requestRenderAll();
      },

      /**
       * @private
       */
      _performTransformAction: function(e, transform, pointer) {
        var x = pointer.x,
            y = pointer.y,
            action = transform.action,
            actionPerformed = false,
            options = {
              target: transform.target,
              e: e,
              transform: transform,
              pointer: pointer
            };

        if (action === 'rotate') {
          (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', options);
        }
        else if (action === 'scale') {
          (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', options);
        }
        else if (action === 'scaleX') {
          (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', options);
        }
        else if (action === 'scaleY') {
          (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', options);
        }
        else if (action === 'skewX') {
          (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', options);
        }
        else if (action === 'skewY') {
          (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', options);
        }
        else {
          actionPerformed = this._translateObject(x, y);
          if (actionPerformed) {
            this._fire('moving', options);
            this.setCursor(options.target.moveCursor || this.moveCursor);
          }
        }
        transform.actionPerformed = transform.actionPerformed || actionPerformed;
      },

      /**
       * @private
       */
      _fire: function(eventName, options) {
        this.fire('object:' + eventName, options);
        options.target.fire(eventName, options);
      },

      /**
       * @private
       */
      _beforeScaleTransform: function(e, transform) {
        if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
          var centerTransform = this._shouldCenterTransform(transform.target);

          // Switch from a normal resize to center-based
          if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
             // Switch from center-based resize to normal one
             (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
          ) {
            this._resetCurrentTransform();
            transform.reset = true;
          }
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {Object} transform current transform
       * @param {Number} x mouse position x from origin
       * @param {Number} y mouse position y from origin
       * @return {Boolean} true if the scaling occurred
       */
      _onScale: function(e, transform, x, y) {
        if (this._isUniscalePossible(e, transform.target)) {
          transform.currentAction = 'scale';
          return this._scaleObject(x, y);
        }
        else {
          // Switch from a normal resize to proportional
          if (!transform.reset && transform.currentAction === 'scale') {
            this._resetCurrentTransform();
          }

          transform.currentAction = 'scaleEqually';
          return this._scaleObject(x, y, 'equally');
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target current target
       * @return {Boolean} true if unproportional scaling is possible
       */
      _isUniscalePossible: function(e, target) {
        return (e[this.uniScaleKey] || this.uniScaleTransform) && !target.get('lockUniScaling');
      },

      /**
       * Sets the cursor depending on where the canvas is being hovered.
       * Note: very buggy in Opera
       * @param {Event} e Event object
       * @param {Object} target Object that the mouse is hovering, if so.
       */
      _setCursorFromEvent: function (e, target) {
        if (!target) {
          this.setCursor(this.defaultCursor);
          return false;
        }
        var hoverCursor = target.hoverCursor || this.hoverCursor,
            activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
              this._activeObject : null,
            // only show proper corner when group selection is not active
            corner = (!activeSelection || !activeSelection.contains(target))
                      && target._findTargetCorner(this.getPointer(e, true));

        if (!corner) {
          if (target.subTargetCheck){
            // hoverCursor should come from top-most subTarget,
            // so we walk the array backwards
            this.targets.concat().reverse().map(function(_target){
              hoverCursor = _target.hoverCursor || hoverCursor;
            });
          }
          this.setCursor(hoverCursor);
        }
        else {
          this.setCursor(this.getCornerCursor(corner, target, e));
        }
      },

      /**
       * @private
       */
      getCornerCursor: function(corner, target, e) {
        if (this.actionIsDisabled(corner, target, e)) {
          return this.notAllowedCursor;
        }
        else if (corner in cursorOffset) {
          return this._getRotatedCornerCursor(corner, target, e);
        }
        else if (corner === 'mtr' && target.hasRotatingPoint) {
          return this.rotationCursor;
        }
        else {
          return this.defaultCursor;
        }
      },

      actionIsDisabled: function(corner, target, e) {
        if (corner === 'mt' || corner === 'mb') {
          return e[this.altActionKey] ? target.lockSkewingX : target.lockScalingY;
        }
        else if (corner === 'ml' || corner === 'mr') {
          return e[this.altActionKey] ? target.lockSkewingY : target.lockScalingX;
        }
        else if (corner === 'mtr') {
          return target.lockRotation;
        }
        else {
          return this._isUniscalePossible(e, target) ?
            target.lockScalingX && target.lockScalingY : target.lockScalingX || target.lockScalingY;
        }
      },

      /**
       * @private
       */
      _getRotatedCornerCursor: function(corner, target, e) {
        var n = Math.round((target.angle % 360) / 45);

        if (n < 0) {
          n += 8; // full circle ahead
        }
        n += cursorOffset[corner];
        if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {
          //if we are holding shift and we are on a mx corner...
          n += 2;
        }
        // normalize n to be from 0 to 7
        n %= 8;

        return this.cursorMap[n];
      }
    });
  })();


  (function() {

    var min = Math.min,
        max = Math.max;

    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       * @return {Boolean}
       */
      _shouldGroup: function(e, target) {
        var activeObject = this._activeObject;
        return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection &&
              (activeObject !== target || activeObject.type === 'activeSelection') && !target.onSelect({ e: e });
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _handleGrouping: function (e, target) {
        var activeObject = this._activeObject;
        // avoid multi select when shift click on a corner
        if (activeObject.__corner) {
          return;
        }
        if (target === activeObject) {
          // if it's a group, find target again, using activeGroup objects
          target = this.findTarget(e, true);
          // if even object is not found or we are on activeObjectCorner, bail out
          if (!target || !target.selectable) {
            return;
          }
        }
        if (activeObject && activeObject.type === 'activeSelection') {
          this._updateActiveSelection(target, e);
        }
        else {
          this._createActiveSelection(target, e);
        }
      },

      /**
       * @private
       */
      _updateActiveSelection: function(target, e) {
        var activeSelection = this._activeObject,
            currentActiveObjects = activeSelection._objects.slice(0);
        if (activeSelection.contains(target)) {
          activeSelection.removeWithUpdate(target);
          this._hoveredTarget = target;
          this._hoveredTargets = this.targets.concat();
          if (activeSelection.size() === 1) {
            // activate last remaining object
            this._setActiveObject(activeSelection.item(0), e);
          }
        }
        else {
          activeSelection.addWithUpdate(target);
          this._hoveredTarget = activeSelection;
          this._hoveredTargets = this.targets.concat();
        }
        this._fireSelectionEvents(currentActiveObjects, e);
      },

      /**
       * @private
       */
      _createActiveSelection: function(target, e) {
        var currentActives = this.getActiveObjects(), group = this._createGroup(target);
        this._hoveredTarget = group;
        // ISSUE 4115: should we consider subTargets here?
        // this._hoveredTargets = [];
        // this._hoveredTargets = this.targets.concat();
        this._setActiveObject(group, e);
        this._fireSelectionEvents(currentActives, e);
      },

      /**
       * @private
       * @param {Object} target
       */
      _createGroup: function(target) {
        var objects = this._objects,
            isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
            groupObjects = isActiveLower
              ? [this._activeObject, target]
              : [target, this._activeObject];
        this._activeObject.isEditing && this._activeObject.exitEditing();
        return new fabric.ActiveSelection(groupObjects, {
          canvas: this
        });
      },

      /**
       * @private
       * @param {Event} e mouse event
       */
      _groupSelectedObjects: function (e) {

        var group = this._collectObjects(e),
            aGroup;

        // do not create group for 1 element only
        if (group.length === 1) {
          this.setActiveObject(group[0], e);
        }
        else if (group.length > 1) {
          aGroup = new fabric.ActiveSelection(group.reverse(), {
            canvas: this
          });
          this.setActiveObject(aGroup, e);
        }
      },

      /**
       * @private
       */
      _collectObjects: function(e) {
        var group = [],
            currentObject,
            x1 = this._groupSelector.ex,
            y1 = this._groupSelector.ey,
            x2 = x1 + this._groupSelector.left,
            y2 = y1 + this._groupSelector.top,
            selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
            selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
            allowIntersect = !this.selectionFullyContained,
            isClick = x1 === x2 && y1 === y2;
        // we iterate reverse order to collect top first in case of click.
        for (var i = this._objects.length; i--; ) {
          currentObject = this._objects[i];

          if (!currentObject || !currentObject.selectable || !currentObject.visible) {
            continue;
          }

          if ((allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2)) ||
              currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
              (allowIntersect && currentObject.containsPoint(selectionX1Y1)) ||
              (allowIntersect && currentObject.containsPoint(selectionX2Y2))
          ) {
            group.push(currentObject);
            // only add one object if it's a click
            if (isClick) {
              break;
            }
          }
        }

        if (group.length > 1) {
          group = group.filter(function(object) {
            return !object.onSelect({ e: e });
          });
        }

        return group;
      },

      /**
       * @private
       */
      _maybeGroupObjects: function(e) {
        if (this.selection && this._groupSelector) {
          this._groupSelectedObjects(e);
        }
        this.setCursor(this.defaultCursor);
        // clear selection and current transformation
        this._groupSelector = null;
      }
    });

  })();


  (function () {
    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

      /**
       * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
       * @param {Object} [options] Options object
       * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
       * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
       * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
       * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
       * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
       * @example <caption>Generate jpeg dataURL with lower quality</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'jpeg',
       *   quality: 0.8
       * });
       * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'png',
       *   left: 100,
       *   top: 100,
       *   width: 200,
       *   height: 200
       * });
       * @example <caption>Generate double scaled png dataURL</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'png',
       *   multiplier: 2
       * });
       */
      toDataURL: function (options) {
        options || (options = { });

        var format = options.format || 'png',
            quality = options.quality || 1,
            multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1),
            canvasEl = this.toCanvasElement(multiplier, options);
        return fabric.util.toDataURL(canvasEl, format, quality);
      },

      /**
       * Create a new HTMLCanvas element painted with the current canvas content.
       * No need to resize the actual one or repaint it.
       * Will transfer object ownership to a new canvas, paint it, and set everything back.
       * This is an intermediary step used to get to a dataUrl but also it is useful to
       * create quick image copies of a canvas without passing for the dataUrl string
       * @param {Number} [multiplier] a zoom factor.
       * @param {Object} [cropping] Cropping informations
       * @param {Number} [cropping.left] Cropping left offset.
       * @param {Number} [cropping.top] Cropping top offset.
       * @param {Number} [cropping.width] Cropping width.
       * @param {Number} [cropping.height] Cropping height.
       */
      toCanvasElement: function(multiplier, cropping) {
        multiplier = multiplier || 1;
        cropping = cropping || { };
        var scaledWidth = (cropping.width || this.width) * multiplier,
            scaledHeight = (cropping.height || this.height) * multiplier,
            zoom = this.getZoom(),
            originalWidth = this.width,
            originalHeight = this.height,
            newZoom = zoom * multiplier,
            vp = this.viewportTransform,
            translateX = (vp[4] - (cropping.left || 0)) * multiplier,
            translateY = (vp[5] - (cropping.top || 0)) * multiplier,
            originalInteractive = this.interactive,
            newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
            originalRetina = this.enableRetinaScaling,
            canvasEl = fabric.util.createCanvasElement(),
            originalContextTop = this.contextTop;
        canvasEl.width = scaledWidth;
        canvasEl.height = scaledHeight;
        this.contextTop = null;
        this.enableRetinaScaling = false;
        this.interactive = false;
        this.viewportTransform = newVp;
        this.width = scaledWidth;
        this.height = scaledHeight;
        this.calcViewportBoundaries();
        this.renderCanvas(canvasEl.getContext('2d'), this._objects);
        this.viewportTransform = vp;
        this.width = originalWidth;
        this.height = originalHeight;
        this.calcViewportBoundaries();
        this.interactive = originalInteractive;
        this.enableRetinaScaling = originalRetina;
        this.contextTop = originalContextTop;
        return canvasEl;
      },
    });

  })();


  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Populates canvas with data from the specified dataless JSON.
     * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
     * @deprecated since 1.2.2
     * @param {String|Object} json JSON string or object
     * @param {Function} callback Callback, invoked when json is parsed
     *                            and corresponding objects (e.g: {@link fabric.Image})
     *                            are initialized
     * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
     * @return {fabric.Canvas} instance
     * @chainable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
     */
    loadFromDatalessJSON: function (json, callback, reviver) {
      return this.loadFromJSON(json, callback, reviver);
    },

    /**
     * Populates canvas with data from the specified JSON.
     * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
     * @param {String|Object} json JSON string or object
     * @param {Function} callback Callback, invoked when json is parsed
     *                            and corresponding objects (e.g: {@link fabric.Image})
     *                            are initialized
     * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
     * @return {fabric.Canvas} instance
     * @chainable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
     * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
     * @example <caption>loadFromJSON</caption>
     * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
     * @example <caption>loadFromJSON with reviver</caption>
     * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
     *   // `o` = json object
     *   // `object` = fabric.Object instance
     *   // ... do some stuff ...
     * });
     */
    loadFromJSON: function (json, callback, reviver) {
      if (!json) {
        return;
      }

      // serialize if it wasn't already
      var serialized = (typeof json === 'string')
        ? JSON.parse(json)
        : fabric.util.object.clone(json);

      var _this = this,
          clipPath = serialized.clipPath,
          renderOnAddRemove = this.renderOnAddRemove;

      this.renderOnAddRemove = false;

      delete serialized.clipPath;

      this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
        _this.clear();
        _this._setBgOverlay(serialized, function () {
          if (clipPath) {
            _this._enlivenObjects([clipPath], function (enlivenedCanvasClip) {
              _this.clipPath = enlivenedCanvasClip[0];
              _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
            });
          }
          else {
            _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
          }
        });
      }, reviver);
      return this;
    },

    /**
     * @private
     * @param {Object} serialized Object with background and overlay information
     * @param {Array} restored canvas objects
     * @param {Function} cached renderOnAddRemove callback
     * @param {Function} callback Invoked after all background and overlay images/patterns loaded
     */
    __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {
      var _this = this;
      enlivenedObjects.forEach(function(obj, index) {
        // we splice the array just in case some custom classes restored from JSON
        // will add more object to canvas at canvas init.
        _this.insertAt(obj, index);
      });
      this.renderOnAddRemove = renderOnAddRemove;
      // remove parts i cannot set as options
      delete serialized.objects;
      delete serialized.backgroundImage;
      delete serialized.overlayImage;
      delete serialized.background;
      delete serialized.overlay;
      // this._initOptions does too many things to just
      // call it. Normally loading an Object from JSON
      // create the Object instance. Here the Canvas is
      // already an instance and we are just loading things over it
      this._setOptions(serialized);
      this.renderAll();
      callback && callback();
    },

    /**
     * @private
     * @param {Object} serialized Object with background and overlay information
     * @param {Function} callback Invoked after all background and overlay images/patterns loaded
     */
    _setBgOverlay: function(serialized, callback) {
      var loaded = {
        backgroundColor: false,
        overlayColor: false,
        backgroundImage: false,
        overlayImage: false
      };

      if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
        callback && callback();
        return;
      }

      var cbIfLoaded = function () {
        if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
          callback && callback();
        }
      };

      this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
      this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
      this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
      this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
    },

    /**
     * @private
     * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
     * @param {(Object|String)} value Value to set
     * @param {Object} loaded Set loaded property to true if property is set
     * @param {Object} callback Callback function to invoke after property is set
     */
    __setBgOverlay: function(property, value, loaded, callback) {
      var _this = this;

      if (!value) {
        loaded[property] = true;
        callback && callback();
        return;
      }

      if (property === 'backgroundImage' || property === 'overlayImage') {
        fabric.util.enlivenObjects([value], function(enlivedObject){
          _this[property] = enlivedObject[0];
          loaded[property] = true;
          callback && callback();
        });
      }
      else {
        this['set' + fabric.util.string.capitalize(property, true)](value, function() {
          loaded[property] = true;
          callback && callback();
        });
      }
    },

    /**
     * @private
     * @param {Array} objects
     * @param {Function} callback
     * @param {Function} [reviver]
     */
    _enlivenObjects: function (objects, callback, reviver) {
      if (!objects || objects.length === 0) {
        callback && callback([]);
        return;
      }

      fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
        callback && callback(enlivenedObjects);
      }, null, reviver);
    },

    /**
     * @private
     * @param {String} format
     * @param {Function} callback
     */
    _toDataURL: function (format, callback) {
      this.clone(function (clone) {
        callback(clone.toDataURL(format));
      });
    },

    /**
     * @private
     * @param {String} format
     * @param {Number} multiplier
     * @param {Function} callback
     */
    _toDataURLWithMultiplier: function (format, multiplier, callback) {
      this.clone(function (clone) {
        callback(clone.toDataURLWithMultiplier(format, multiplier));
      });
    },

    /**
     * Clones canvas instance
     * @param {Object} [callback] Receives cloned instance as a first argument
     * @param {Array} [properties] Array of properties to include in the cloned canvas and children
     */
    clone: function (callback, properties) {
      var data = JSON.stringify(this.toJSON(properties));
      this.cloneWithoutData(function(clone) {
        clone.loadFromJSON(data, function() {
          callback && callback(clone);
        });
      });
    },

    /**
     * Clones canvas instance without cloning existing data.
     * This essentially copies canvas dimensions, clipping properties, etc.
     * but leaves data empty (so that you can populate it with your own)
     * @param {Object} [callback] Receives cloned instance as a first argument
     */
    cloneWithoutData: function(callback) {
      var el = fabric.util.createCanvasElement();

      el.width = this.width;
      el.height = this.height;

      var clone = new fabric.Canvas(el);
      clone.clipTo = this.clipTo;
      if (this.backgroundImage) {
        clone.setBackgroundImage(this.backgroundImage.src, function() {
          clone.renderAll();
          callback && callback(clone);
        });
        clone.backgroundImageOpacity = this.backgroundImageOpacity;
        clone.backgroundImageStretch = this.backgroundImageStretch;
      }
      else {
        callback && callback(clone);
      }
    }
  });


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        toFixed = fabric.util.toFixed,
        capitalize = fabric.util.string.capitalize,
        degreesToRadians = fabric.util.degreesToRadians,
        supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
        objectCaching = !fabric.isLikelyNode,
        ALIASING_LIMIT = 2;

    if (fabric.Object) {
      return;
    }

    /**
     * Root object class from which all 2d shape classes inherit from
     * @class fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
     * @see {@link fabric.Object#initialize} for constructor definition
     *
     * @fires added
     * @fires removed
     *
     * @fires selected
     * @fires deselected
     * @fires modified
     * @fires modified
     * @fires moved
     * @fires scaled
     * @fires rotated
     * @fires skewed
     *
     * @fires rotating
     * @fires scaling
     * @fires moving
     * @fires skewing
     *
     * @fires mousedown
     * @fires mouseup
     * @fires mouseover
     * @fires mouseout
     * @fires mousewheel
     * @fires mousedblclick
     *
     * @fires dragover
     * @fires dragenter
     * @fires dragleave
     * @fires drop
     */
    fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

      /**
       * Type of an object (rect, circle, path, etc.).
       * Note that this property is meant to be read-only and not meant to be modified.
       * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
       * @type String
       * @default
       */
      type:                     'object',

      /**
       * Horizontal origin of transformation of an object (one of "left", "right", "center")
       * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
       * @type String
       * @default
       */
      originX:                  'left',

      /**
       * Vertical origin of transformation of an object (one of "top", "bottom", "center")
       * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
       * @type String
       * @default
       */
      originY:                  'top',

      /**
       * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
       * @type Number
       * @default
       */
      top:                      0,

      /**
       * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
       * @type Number
       * @default
       */
      left:                     0,

      /**
       * Object width
       * @type Number
       * @default
       */
      width:                    0,

      /**
       * Object height
       * @type Number
       * @default
       */
      height:                   0,

      /**
       * Object scale factor (horizontal)
       * @type Number
       * @default
       */
      scaleX:                   1,

      /**
       * Object scale factor (vertical)
       * @type Number
       * @default
       */
      scaleY:                   1,

      /**
       * When true, an object is rendered as flipped horizontally
       * @type Boolean
       * @default
       */
      flipX:                    false,

      /**
       * When true, an object is rendered as flipped vertically
       * @type Boolean
       * @default
       */
      flipY:                    false,

      /**
       * Opacity of an object
       * @type Number
       * @default
       */
      opacity:                  1,

      /**
       * Angle of rotation of an object (in degrees)
       * @type Number
       * @default
       */
      angle:                    0,

      /**
       * Angle of skew on x axes of an object (in degrees)
       * @type Number
       * @default
       */
      skewX:                    0,

      /**
       * Angle of skew on y axes of an object (in degrees)
       * @type Number
       * @default
       */
      skewY:                    0,

      /**
       * Size of object's controlling corners (in pixels)
       * @type Number
       * @default
       */
      cornerSize:               13,

      /**
       * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
       * @type Boolean
       * @default
       */
      transparentCorners:       true,

      /**
       * Default cursor value used when hovering over this object on canvas
       * @type String
       * @default
       */
      hoverCursor:              null,

      /**
       * Default cursor value used when moving this object on canvas
       * @type String
       * @default
       */
      moveCursor:               null,

      /**
       * Padding between object and its controlling borders (in pixels)
       * @type Number
       * @default
       */
      padding:                  0,

      /**
       * Color of controlling borders of an object (when it's active)
       * @type String
       * @default
       */
      borderColor:              'rgba(102,153,255,0.75)',

      /**
       * Array specifying dash pattern of an object's borders (hasBorder must be true)
       * @since 1.6.2
       * @type Array
       */
      borderDashArray:          null,

      /**
       * Color of controlling corners of an object (when it's active)
       * @type String
       * @default
       */
      cornerColor:              'rgba(102,153,255,0.5)',

      /**
       * Color of controlling corners of an object (when it's active and transparentCorners false)
       * @since 1.6.2
       * @type String
       * @default
       */
      cornerStrokeColor:        null,

      /**
       * Specify style of control, 'rect' or 'circle'
       * @since 1.6.2
       * @type String
       */
      cornerStyle:          'rect',

      /**
       * Array specifying dash pattern of an object's control (hasBorder must be true)
       * @since 1.6.2
       * @type Array
       */
      cornerDashArray:          null,

      /**
       * When true, this object will use center point as the origin of transformation
       * when being scaled via the controls.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredScaling:          false,

      /**
       * When true, this object will use center point as the origin of transformation
       * when being rotated via the controls.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredRotation:         true,

      /**
       * Color of object's fill
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      fill:                     'rgb(0,0,0)',

      /**
       * Fill rule used to fill an object
       * accepted values are nonzero, evenodd
       * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
       * @type String
       * @default
       */
      fillRule:                 'nonzero',

      /**
       * Composite rule used for canvas globalCompositeOperation
       * @type String
       * @default
       */
      globalCompositeOperation: 'source-over',

      /**
       * Background color of an object.
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      backgroundColor:          '',

      /**
       * Selection Background color of an object. colored layer behind the object when it is active.
       * does not mix good with globalCompositeOperation methods.
       * @type String
       * @default
       */
      selectionBackgroundColor:          '',

      /**
       * When defined, an object is rendered via stroke and this property specifies its color
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      stroke:                   null,

      /**
       * Width of a stroke used to render this object
       * @type Number
       * @default
       */
      strokeWidth:              1,

      /**
       * Array specifying dash pattern of an object's stroke (stroke must be defined)
       * @type Array
       */
      strokeDashArray:          null,

      /**
       * Line offset of an object's stroke
       * @type Number
       * @default
       */
      strokeDashOffset: 0,

      /**
       * Line endings style of an object's stroke (one of "butt", "round", "square")
       * @type String
       * @default
       */
      strokeLineCap:            'butt',

      /**
       * Corner style of an object's stroke (one of "bevil", "round", "miter")
       * @type String
       * @default
       */
      strokeLineJoin:           'miter',

      /**
       * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
       * @type Number
       * @default
       */
      strokeMiterLimit:         4,

      /**
       * Shadow object representing shadow of this shape
       * @type fabric.Shadow
       * @default
       */
      shadow:                   null,

      /**
       * Opacity of object's controlling borders when object is active and moving
       * @type Number
       * @default
       */
      borderOpacityWhenMoving:  0.4,

      /**
       * Scale factor of object's controlling borders
       * bigger number will make a thicker border
       * border is 1, so this is basically a border tickness
       * since there is no way to change the border itself.
       * @type Number
       * @default
       */
      borderScaleFactor:        1,

      /**
       * Transform matrix (similar to SVG's transform matrix)
       * This property has been depreacted. Since caching and and qrDecompose this
       * property can be handled with the standard top,left,scaleX,scaleY,angle and skewX.
       * A documentation example on how to parse and merge a transformMatrix will be provided before
       * completely removing it in fabric 4.0
       * If you are starting a project now, DO NOT use it.
       * @deprecated since 3.2.0
       * @type Array
       */
      transformMatrix:          null,

      /**
       * Minimum allowed scale value of an object
       * @type Number
       * @default
       */
      minScaleLimit:            0,

      /**
       * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
       * But events still fire on it.
       * @type Boolean
       * @default
       */
      selectable:               true,

      /**
       * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
       * @type Boolean
       * @default
       */
      evented:                  true,

      /**
       * When set to `false`, an object is not rendered on canvas
       * @type Boolean
       * @default
       */
      visible:                  true,

      /**
       * When set to `false`, object's controls are not displayed and can not be used to manipulate object
       * @type Boolean
       * @default
       */
      hasControls:              true,

      /**
       * When set to `false`, object's controlling borders are not rendered
       * @type Boolean
       * @default
       */
      hasBorders:               true,

      /**
       * When set to `false`, object's controlling rotating point will not be visible or selectable
       * @type Boolean
       * @default
       */
      hasRotatingPoint:         true,

      /**
       * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
       * @type Number
       * @default
       */
      rotatingPointOffset:      40,

      /**
       * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
       * @type Boolean
       * @default
       */
      perPixelTargetFind:       false,

      /**
       * When `false`, default object's values are not included in its serialization
       * @type Boolean
       * @default
       */
      includeDefaultValues:     true,

      /**
       * Function that determines clipping of an object (context is passed as a first argument).
       * If you are using code minification, ctx argument can be minified/manglied you should use
       * as a workaround `var ctx = arguments[0];` in the function;
       * Note that context origin is at the object's center point (not left/top corner)
       * @deprecated since 2.0.0
       * @type Function
       */
      clipTo:                   null,

      /**
       * When `true`, object horizontal movement is locked
       * @type Boolean
       * @default
       */
      lockMovementX:            false,

      /**
       * When `true`, object vertical movement is locked
       * @type Boolean
       * @default
       */
      lockMovementY:            false,

      /**
       * When `true`, object rotation is locked
       * @type Boolean
       * @default
       */
      lockRotation:             false,

      /**
       * When `true`, object horizontal scaling is locked
       * @type Boolean
       * @default
       */
      lockScalingX:             false,

      /**
       * When `true`, object vertical scaling is locked
       * @type Boolean
       * @default
       */
      lockScalingY:             false,

      /**
       * When `true`, object non-uniform scaling is locked
       * @type Boolean
       * @default
       */
      lockUniScaling:           false,

      /**
       * When `true`, object horizontal skewing is locked
       * @type Boolean
       * @default
       */
      lockSkewingX:             false,

      /**
       * When `true`, object vertical skewing is locked
       * @type Boolean
       * @default
       */
      lockSkewingY:             false,

      /**
       * When `true`, object cannot be flipped by scaling into negative values
       * @type Boolean
       * @default
       */
      lockScalingFlip:          false,

      /**
       * When `true`, object is not exported in OBJECT/JSON
       * @since 1.6.3
       * @type Boolean
       * @default
       */
      excludeFromExport:        false,

      /**
       * When `true`, object is cached on an additional canvas.
       * When `false`, object is not cached unless necessary ( clipPath )
       * default to true
       * @since 1.7.0
       * @type Boolean
       * @default true
       */
      objectCaching:            objectCaching,

      /**
       * When `true`, object properties are checked for cache invalidation. In some particular
       * situation you may want this to be disabled ( spray brush, very big, groups)
       * or if your application does not allow you to modify properties for groups child you want
       * to disable it for groups.
       * default to false
       * since 1.7.0
       * @type Boolean
       * @default false
       */
      statefullCache:            false,

      /**
       * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
       * too much and will be redrawn with correct details at the end of scaling.
       * this setting is performance and application dependant.
       * default to true
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      noScaleCache:              true,

      /**
       * When `false`, the stoke width will scale with the object.
       * When `true`, the stroke will always match the exact pixel size entered for stroke width.
       * default to false
       * @since 2.6.0
       * @type Boolean
       * @default false
       * @type Boolean
       * @default false
       */
      strokeUniform:              false,

      /**
       * When set to `true`, object's cache will be rerendered next render call.
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      dirty:                true,

      /**
       * keeps the value of the last hovered corner during mouse move.
       * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
       * It should be private, but there is no harm in using it as
       * a read-only property.
       * @type number|string|any
       * @default 0
       */
      __corner: 0,

      /**
       * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
       * @type String
       * @default
       */
      paintFirst:           'fill',

      /**
       * List of properties to consider when checking if state
       * of an object is changed (fabric.Object#hasStateChanged)
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: (
        'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
        'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit ' +
        'angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor ' +
        'skewX skewY fillRule paintFirst clipPath strokeUniform'
      ).split(' '),

      /**
       * List of properties to consider when checking if cache needs refresh
       * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
       * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
       * and refreshed at the next render
       * @type Array
       */
      cacheProperties: (
        'fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform' +
        ' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath'
      ).split(' '),

      /**
       * a fabricObject that, without stroke define a clipping area with their shape. filled in black
       * the clipPath object gets used when the object has rendered, and the context is placed in the center
       * of the object cacheCanvas.
       * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
       * @type fabric.Object
       */
      clipPath: undefined,

      /**
       * Meaningful ONLY when the object is used as clipPath.
       * if true, the clipPath will make the object clip to the outside of the clipPath
       * since 2.4.0
       * @type boolean
       * @default false
       */
      inverted: false,

      /**
       * Meaningful ONLY when the object is used as clipPath.
       * if true, the clipPath will have its top and left relative to canvas, and will
       * not be influenced by the object transform. This will make the clipPath relative
       * to the canvas, but clipping just a particular object.
       * WARNING this is beta, this feature may change or be renamed.
       * since 2.4.0
       * @type boolean
       * @default false
       */
      absolutePositioned: false,

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        if (options) {
          this.setOptions(options);
        }
      },

      /**
       * Create a the canvas used to keep the cached copy of the object
       * @private
       */
      _createCacheCanvas: function() {
        this._cacheProperties = {};
        this._cacheCanvas = fabric.util.createCanvasElement();
        this._cacheContext = this._cacheCanvas.getContext('2d');
        this._updateCacheCanvas();
        // if canvas gets created, is empty, so dirty.
        this.dirty = true;
      },

      /**
       * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
       * and each side do not cross fabric.cacheSideLimit
       * those numbers are configurable so that you can get as much detail as you want
       * making bargain with performances.
       * @param {Object} dims
       * @param {Object} dims.width width of canvas
       * @param {Object} dims.height height of canvas
       * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _limitCacheSize: function(dims) {
        var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
            width = dims.width, height = dims.height,
            max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
        if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
          if (width < min) {
            dims.width = min;
          }
          if (height < min) {
            dims.height = min;
          }
          return dims;
        }
        var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
            capValue = fabric.util.capValue,
            x = capValue(min, limitedDims.x, max),
            y = capValue(min, limitedDims.y, max);
        if (width > x) {
          dims.zoomX /= width / x;
          dims.width = x;
          dims.capped = true;
        }
        if (height > y) {
          dims.zoomY /= height / y;
          dims.height = y;
          dims.capped = true;
        }
        return dims;
      },

      /**
       * Return the dimension and the zoom level needed to create a cache canvas
       * big enough to host the object to be cached.
       * @private
       * @return {Object}.x width of object to be cached
       * @return {Object}.y height of object to be cached
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _getCacheCanvasDimensions: function() {
        var objectScale = this.getTotalObjectScaling(),
            // caculate dimensions without skewing
            dim = this._getTransformedDimensions(0, 0),
            neededX = dim.x * objectScale.scaleX / this.scaleX,
            neededY = dim.y * objectScale.scaleY / this.scaleY;
        return {
          // for sure this ALIASING_LIMIT is slightly creating problem
          // in situation in which the cache canvas gets an upper limit
          // also objectScale contains already scaleX and scaleY
          width: neededX + ALIASING_LIMIT,
          height: neededY + ALIASING_LIMIT,
          zoomX: objectScale.scaleX,
          zoomY: objectScale.scaleY,
          x: neededX,
          y: neededY
        };
      },

      /**
       * Update width and height of the canvas for cache
       * returns true or false if canvas needed resize.
       * @private
       * @return {Boolean} true if the canvas has been resized
       */
      _updateCacheCanvas: function() {
        var targetCanvas = this.canvas;
        if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
          var target = targetCanvas._currentTransform.target,
              action = targetCanvas._currentTransform.action;
          if (this === target && action.slice && action.slice(0, 5) === 'scale') {
            return false;
          }
        }
        var canvas = this._cacheCanvas,
            dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
            minCacheSize = fabric.minCacheSideLimit,
            width = dims.width, height = dims.height, drawingWidth, drawingHeight,
            zoomX = dims.zoomX, zoomY = dims.zoomY,
            dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
            zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
            shouldRedraw = dimensionsChanged || zoomChanged,
            additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
        if (dimensionsChanged) {
          var canvasWidth = this._cacheCanvas.width,
              canvasHeight = this._cacheCanvas.height,
              sizeGrowing = width > canvasWidth || height > canvasHeight,
              sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
                canvasWidth > minCacheSize && canvasHeight > minCacheSize;
          shouldResizeCanvas = sizeGrowing || sizeShrinking;
          if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
            additionalWidth = width * 0.1;
            additionalHeight = height * 0.1;
          }
        }
        if (shouldRedraw) {
          if (shouldResizeCanvas) {
            canvas.width = Math.ceil(width + additionalWidth);
            canvas.height = Math.ceil(height + additionalHeight);
          }
          else {
            this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
            this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
          }
          drawingWidth = dims.x / 2;
          drawingHeight = dims.y / 2;
          this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
          this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
          this.cacheWidth = width;
          this.cacheHeight = height;
          this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
          this._cacheContext.scale(zoomX, zoomY);
          this.zoomX = zoomX;
          this.zoomY = zoomY;
          return true;
        }
        return false;
      },

      /**
       * Sets object's properties from options
       * @param {Object} [options] Options object
       */
      setOptions: function(options) {
        this._setOptions(options);
        this._initGradient(options.fill, 'fill');
        this._initGradient(options.stroke, 'stroke');
        this._initClipping(options);
        this._initPattern(options.fill, 'fill');
        this._initPattern(options.stroke, 'stroke');
      },

      /**
       * Transforms context when rendering an object
       * @param {CanvasRenderingContext2D} ctx Context
       */
      transform: function(ctx) {
        var m;
        if (this.group && !this.group._transformDone) {
          m = this.calcTransformMatrix();
        }
        else {
          m = this.calcOwnMatrix();
        }
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      },

      /**
       * Returns an object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

            object = {
              type:                     this.type,
              version:                  fabric.version,
              originX:                  this.originX,
              originY:                  this.originY,
              left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
              top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
              width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
              height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
              fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
              stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
              strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
              strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
              strokeLineCap:            this.strokeLineCap,
              strokeDashOffset:         this.strokeDashOffset,
              strokeLineJoin:           this.strokeLineJoin,
              // TODO: add this before release
              // strokeUniform:            this.strokeUniform,
              strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
              scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
              scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
              angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
              flipX:                    this.flipX,
              flipY:                    this.flipY,
              opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
              shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
              visible:                  this.visible,
              clipTo:                   this.clipTo && String(this.clipTo),
              backgroundColor:          this.backgroundColor,
              fillRule:                 this.fillRule,
              paintFirst:               this.paintFirst,
              globalCompositeOperation: this.globalCompositeOperation,
              transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,
              skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
              skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS),
            };

        if (this.clipPath) {
          object.clipPath = this.clipPath.toObject(propertiesToInclude);
          object.clipPath.inverted = this.clipPath.inverted;
          object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
        }

        fabric.util.populateWithProperties(this, object, propertiesToInclude);
        if (!this.includeDefaultValues) {
          object = this._removeDefaultValues(object);
        }

        return object;
      },

      /**
       * Returns (dataless) object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        // will be overwritten by subclasses
        return this.toObject(propertiesToInclude);
      },

      /**
       * @private
       * @param {Object} object
       */
      _removeDefaultValues: function(object) {
        var prototype = fabric.util.getKlass(object.type).prototype,
            stateProperties = prototype.stateProperties;
        stateProperties.forEach(function(prop) {
          if (prop === 'left' || prop === 'top') {
            return;
          }
          if (object[prop] === prototype[prop]) {
            delete object[prop];
          }
          var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
                        Object.prototype.toString.call(prototype[prop]) === '[object Array]';

          // basically a check for [] === []
          if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
            delete object[prop];
          }
        });

        return object;
      },

      /**
       * Returns a string representation of an instance
       * @return {String}
       */
      toString: function() {
        return '#<fabric.' + capitalize(this.type) + '>';
      },

      /**
       * Return the object scale factor counting also the group scaling
       * @return {Object} object with scaleX and scaleY properties
       */
      getObjectScaling: function() {
        var options = fabric.util.qrDecompose(this.calcTransformMatrix());
        return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
      },

      /**
       * Return the object scale factor counting also the group scaling, zoom and retina
       * @return {Object} object with scaleX and scaleY properties
       */
      getTotalObjectScaling: function() {
        var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
        if (this.canvas) {
          var zoom = this.canvas.getZoom();
          var retina = this.canvas.getRetinaScaling();
          scaleX *= zoom * retina;
          scaleY *= zoom * retina;
        }
        return { scaleX: scaleX, scaleY: scaleY };
      },

      /**
       * Return the object opacity counting also the group property
       * @return {Number}
       */
      getObjectOpacity: function() {
        var opacity = this.opacity;
        if (this.group) {
          opacity *= this.group.getObjectOpacity();
        }
        return opacity;
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Object} thisArg
       */
      _set: function(key, value) {
        var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
            isChanged = this[key] !== value, groupNeedsUpdate = false;

        if (shouldConstrainValue) {
          value = this._constrainScale(value);
        }
        if (key === 'scaleX' && value < 0) {
          this.flipX = !this.flipX;
          value *= -1;
        }
        else if (key === 'scaleY' && value < 0) {
          this.flipY = !this.flipY;
          value *= -1;
        }
        else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
          value = new fabric.Shadow(value);
        }
        else if (key === 'dirty' && this.group) {
          this.group.set('dirty', value);
        }

        this[key] = value;

        if (isChanged) {
          groupNeedsUpdate = this.group && this.group.isOnACache();
          if (this.cacheProperties.indexOf(key) > -1) {
            this.dirty = true;
            groupNeedsUpdate && this.group.set('dirty', true);
          }
          else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
            this.group.set('dirty', true);
          }
        }

        return this;
      },

      /**
       * This callback function is called by the parent group of an object every
       * time a non-delegated property changes on the group. It is passed the key
       * and value as parameters. Not adding in this function's signature to avoid
       * Travis build error about unused variables.
       */
      setOnGroup: function() {
        // implemented by sub-classes, as needed.
      },

      /**
       * Retrieves viewportTransform from Object's canvas if possible
       * @method getViewportTransform
       * @memberOf fabric.Object.prototype
       * @return {Array}
       */
      getViewportTransform: function() {
        if (this.canvas && this.canvas.viewportTransform) {
          return this.canvas.viewportTransform;
        }
        return fabric.iMatrix.concat();
      },

      /*
       * @private
       * return if the object would be visible in rendering
       * @memberOf fabric.Object.prototype
       * @return {Boolean}
       */
      isNotVisible: function() {
        return this.opacity === 0 ||
          (this.width === 0 && this.height === 0 && this.strokeWidth === 0) ||
          !this.visible;
      },

      /**
       * Renders an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        // do not render if width/height are zeros or object is not visible
        if (this.isNotVisible()) {
          return;
        }
        if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
          return;
        }
        ctx.save();
        this._setupCompositeOperation(ctx);
        this.drawSelectionBackground(ctx);
        this.transform(ctx);
        this._setOpacity(ctx);
        this._setShadow(ctx, this);
        if (this.transformMatrix) {
          ctx.transform.apply(ctx, this.transformMatrix);
        }
        this.clipTo && fabric.util.clipContext(this, ctx);
        if (this.shouldCache()) {
          this.renderCache();
          this.drawCacheOnCanvas(ctx);
        }
        else {
          this._removeCacheCanvas();
          this.dirty = false;
          this.drawObject(ctx);
          if (this.objectCaching && this.statefullCache) {
            this.saveState({ propertySet: 'cacheProperties' });
          }
        }
        this.clipTo && ctx.restore();
        ctx.restore();
      },

      renderCache: function(options) {
        options = options || {};
        if (!this._cacheCanvas) {
          this._createCacheCanvas();
        }
        if (this.isCacheDirty()) {
          this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
          this.drawObject(this._cacheContext, options.forClipping);
          this.dirty = false;
        }
      },

      /**
       * Remove cacheCanvas and its dimensions from the objects
       */
      _removeCacheCanvas: function() {
        this._cacheCanvas = null;
        this.cacheWidth = 0;
        this.cacheHeight = 0;
      },

      /**
       * return true if the object will draw a stroke
       * Does not consider text styles. This is just a shortcut used at rendering time
       * We want it to be an aproximation and be fast.
       * wrote to avoid extra caching, it has to return true when stroke happens,
       * can guess when it will not happen at 100% chance, does not matter if it misses
       * some use case where the stroke is invisible.
       * @since 3.0.0
       * @returns Boolean
       */
      hasStroke: function() {
        return this.stroke && this.stroke !== 'transparent' && this.strokeWidth !== 0;
      },

      /**
       * return true if the object will draw a fill
       * Does not consider text styles. This is just a shortcut used at rendering time
       * We want it to be an aproximation and be fast.
       * wrote to avoid extra caching, it has to return true when fill happens,
       * can guess when it will not happen at 100% chance, does not matter if it misses
       * some use case where the fill is invisible.
       * @since 3.0.0
       * @returns Boolean
       */
      hasFill: function() {
        return this.fill && this.fill !== 'transparent';
      },

      /**
       * When set to `true`, force the object to have its own cache, even if it is inside a group
       * it may be needed when your object behave in a particular way on the cache and always needs
       * its own isolated canvas to render correctly.
       * Created to be overridden
       * since 1.7.12
       * @returns Boolean
       */
      needsItsOwnCache: function() {
        if (this.paintFirst === 'stroke' &&
          this.hasFill() && this.hasStroke() && typeof this.shadow === 'object') {
          return true;
        }
        if (this.clipPath) {
          return true;
        }
        return false;
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
       * @return {Boolean}
       */
      shouldCache: function() {
        this.ownCaching = this.needsItsOwnCache() || (
          this.objectCaching &&
          (!this.group || !this.group.isOnACache())
        );
        return this.ownCaching;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * used by Group.shouldCache to know if child has a shadow recursively
       * @return {Boolean}
       */
      willDrawShadow: function() {
        return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
      },

      /**
       * Execute the drawing operation for an object clipPath
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawClipPathOnCache: function(ctx) {
        var path = this.clipPath;
        ctx.save();
        // DEBUG: uncomment this line, comment the following
        // ctx.globalAlpha = 0.4
        if (path.inverted) {
          ctx.globalCompositeOperation = 'destination-out';
        }
        else {
          ctx.globalCompositeOperation = 'destination-in';
        }
        //ctx.scale(1 / 2, 1 / 2);
        if (path.absolutePositioned) {
          var m = fabric.util.invertTransform(this.calcTransformMatrix());
          ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        path.transform(ctx);
        ctx.scale(1 / path.zoomX, 1 / path.zoomY);
        ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
        ctx.restore();
      },

      /**
       * Execute the drawing operation for an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawObject: function(ctx, forClipping) {
        var originalFill = this.fill, originalStroke = this.stroke;
        if (forClipping) {
          this.fill = 'black';
          this.stroke = '';
          this._setClippingProperties(ctx);
        }
        else {
          this._renderBackground(ctx);
          this._setStrokeStyles(ctx, this);
          this._setFillStyles(ctx, this);
        }
        this._render(ctx);
        this._drawClipPath(ctx);
        this.fill = originalFill;
        this.stroke = originalStroke;
      },

      _drawClipPath: function(ctx) {
        var path = this.clipPath;
        if (!path) { return; }
        // needed to setup a couple of variables
        // path canvas gets overridden with this one.
        // TODO find a better solution?
        path.canvas = this.canvas;
        path.shouldCache();
        path._transformDone = true;
        path.renderCache({ forClipping: true });
        this.drawClipPathOnCache(ctx);
      },

      /**
       * Paint the cached copy of the object on the target context.
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawCacheOnCanvas: function(ctx) {
        ctx.scale(1 / this.zoomX, 1 / this.zoomY);
        ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
      },

      /**
       * Check if cache is dirty
       * @param {Boolean} skipCanvas skip canvas checks because this object is painted
       * on parent canvas.
       */
      isCacheDirty: function(skipCanvas) {
        if (this.isNotVisible()) {
          return false;
        }
        if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
          // in this case the context is already cleared.
          return true;
        }
        else {
          if (this.dirty ||
            (this.clipPath && this.clipPath.absolutePositioned) ||
            (this.statefullCache && this.hasStateChanged('cacheProperties'))
          ) {
            if (this._cacheCanvas && !skipCanvas) {
              var width = this.cacheWidth / this.zoomX;
              var height = this.cacheHeight / this.zoomY;
              this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
            }
            return true;
          }
        }
        return false;
      },

      /**
       * Draws a background for the object big as its untransformed dimensions
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderBackground: function(ctx) {
        if (!this.backgroundColor) {
          return;
        }
        var dim = this._getNonTransformedDimensions();
        ctx.fillStyle = this.backgroundColor;

        ctx.fillRect(
          -dim.x / 2,
          -dim.y / 2,
          dim.x,
          dim.y
        );
        // if there is background color no other shadows
        // should be casted
        this._removeShadow(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _setOpacity: function(ctx) {
        if (this.group && !this.group._transformDone) {
          ctx.globalAlpha = this.getObjectOpacity();
        }
        else {
          ctx.globalAlpha *= this.opacity;
        }
      },

      _setStrokeStyles: function(ctx, decl) {
        if (decl.stroke) {
          ctx.lineWidth = decl.strokeWidth;
          ctx.lineCap = decl.strokeLineCap;
          ctx.lineDashOffset = decl.strokeDashOffset;
          ctx.lineJoin = decl.strokeLineJoin;
          ctx.miterLimit = decl.strokeMiterLimit;
          ctx.strokeStyle = decl.stroke.toLive
            ? decl.stroke.toLive(ctx, this)
            : decl.stroke;
        }
      },

      _setFillStyles: function(ctx, decl) {
        if (decl.fill) {
          ctx.fillStyle = decl.fill.toLive
            ? decl.fill.toLive(ctx, this)
            : decl.fill;
        }
      },

      _setClippingProperties: function(ctx) {
        ctx.globalAlpha = 1;
        ctx.strokeStyle = 'transparent';
        ctx.fillStyle = '#000000';
      },

      /**
       * @private
       * Sets line dash
       * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
       * @param {Array} dashArray array representing dashes
       * @param {Function} alternative function to call if browser does not support lineDash
       */
      _setLineDash: function(ctx, dashArray, alternative) {
        if (!dashArray || dashArray.length === 0) {
          return;
        }
        // Spec requires the concatenation of two copies the dash list when the number of elements is odd
        if (1 & dashArray.length) {
          dashArray.push.apply(dashArray, dashArray);
        }
        if (supportsLineDash) {
          ctx.setLineDash(dashArray);
        }
        else {
          alternative && alternative(ctx);
        }
      },

      /**
       * Renders controls and borders for the object
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [styleOverride] properties to override the object style
       */
      _renderControls: function(ctx, styleOverride) {
        var vpt = this.getViewportTransform(),
            matrix = this.calcTransformMatrix(),
            options, drawBorders, drawControls;
        styleOverride = styleOverride || { };
        drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
        drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
        matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
        options = fabric.util.qrDecompose(matrix);
        ctx.save();
        ctx.translate(options.translateX, options.translateY);
        ctx.lineWidth = 1 * this.borderScaleFactor;
        if (!this.group) {
          ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
        }
        if (styleOverride.forActiveSelection) {
          ctx.rotate(degreesToRadians(options.angle));
          drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
        }
        else {
          ctx.rotate(degreesToRadians(this.angle));
          drawBorders && this.drawBorders(ctx, styleOverride);
        }
        drawControls && this.drawControls(ctx, styleOverride);
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _setShadow: function(ctx) {
        if (!this.shadow) {
          return;
        }

        var shadow = this.shadow, canvas = this.canvas, scaling,
            multX = (canvas && canvas.viewportTransform[0]) || 1,
            multY = (canvas && canvas.viewportTransform[3]) || 1;
        if (shadow.nonScaling) {
          scaling = { scaleX: 1, scaleY: 1 };
        }
        else {
          scaling = this.getObjectScaling();
        }
        if (canvas && canvas._isRetinaScaling()) {
          multX *= fabric.devicePixelRatio;
          multY *= fabric.devicePixelRatio;
        }
        ctx.shadowColor = shadow.color;
        ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant *
          (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
        ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
        ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _removeShadow: function(ctx) {
        if (!this.shadow) {
          return;
        }

        ctx.shadowColor = '';
        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} filler fabric.Pattern or fabric.Gradient
       * @return {Object} offset.offsetX offset for text rendering
       * @return {Object} offset.offsetY offset for text rendering
       */
      _applyPatternGradientTransform: function(ctx, filler) {
        if (!filler || !filler.toLive) {
          return { offsetX: 0, offsetY: 0 };
        }
        var t = filler.gradientTransform || filler.patternTransform;
        var offsetX = -this.width / 2 + filler.offsetX || 0,
            offsetY = -this.height / 2 + filler.offsetY || 0;

        if (filler.gradientUnits === 'percentage') {
          ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
        }
        else {
          ctx.transform(1, 0, 0, 1, offsetX, offsetY);
        }
        if (t) {
          ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
        }
        return { offsetX: offsetX, offsetY: offsetY };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderPaintInOrder: function(ctx) {
        if (this.paintFirst === 'stroke') {
          this._renderStroke(ctx);
          this._renderFill(ctx);
        }
        else {
          this._renderFill(ctx);
          this._renderStroke(ctx);
        }
      },

      /**
       * @private
       * function that actually render something on the context.
       * empty here to allow Obects to work on tests to benchmark fabric functionalites
       * not related to rendering
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(/* ctx */) {

      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderFill: function(ctx) {
        if (!this.fill) {
          return;
        }

        ctx.save();
        this._applyPatternGradientTransform(ctx, this.fill);
        if (this.fillRule === 'evenodd') {
          ctx.fill('evenodd');
        }
        else {
          ctx.fill();
        }
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderStroke: function(ctx) {
        if (!this.stroke || this.strokeWidth === 0) {
          return;
        }

        if (this.shadow && !this.shadow.affectStroke) {
          this._removeShadow(ctx);
        }

        ctx.save();
        if (this.strokeUniform && this.group) {
          var scaling = this.getObjectScaling();
          ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
        }
        else if (this.strokeUniform) {
          ctx.scale(1 / this.scaleX, 1 / this.scaleY);
        }
        this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
        if (this.stroke.toLive && this.stroke.gradientUnits === 'percentage') {
          // need to transform gradient in a pattern.
          // this is a slow process. If you are hitting this codepath, and the object
          // is not using caching, you should consider switching it on.
          // we need a canvas as big as the current object caching canvas.
          this._applyPatternForTransformedGradient(ctx, this.stroke);
        }
        else {
          this._applyPatternGradientTransform(ctx, this.stroke);
        }
        ctx.stroke();
        ctx.restore();
      },

      /**
       * This function try to patch the missing gradientTransform on canvas gradients.
       * transforming a context to transform the gradient, is going to transform the stroke too.
       * we want to transform the gradient but not the stroke operation, so we create
       * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
       * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
       * is limited.
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {fabric.Gradient} filler a fabric gradient instance
       */
      _applyPatternForTransformedGradient: function(ctx, filler) {
        var dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
            pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(),
            width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
        pCanvas.width = width;
        pCanvas.height = height;
        pCtx = pCanvas.getContext('2d');
        pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
        pCtx.lineTo(0, height); pCtx.closePath();
        pCtx.translate(width / 2, height / 2);
        pCtx.scale(
          dims.zoomX / this.scaleX / retinaScaling,
          dims.zoomY / this.scaleY / retinaScaling
        );
        this._applyPatternGradientTransform(pCtx, filler);
        pCtx.fillStyle = filler.toLive(ctx);
        pCtx.fill();
        ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
        ctx.scale(
          retinaScaling * this.scaleX / dims.zoomX,
          retinaScaling * this.scaleY / dims.zoomY
        );
        ctx.strokeStyle = pCtx.createPattern(pCanvas, 'no-repeat');
      },

      /**
       * This function is an helper for svg import. it returns the center of the object in the svg
       * untransformed coordinates
       * @private
       * @return {Object} center point from element coordinates
       */
      _findCenterFromElement: function() {
        return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
      },

      /**
       * This function is an helper for svg import. it decompose the transformMatrix
       * and assign properties to object.
       * untransformed coordinates
       * @private
       * @chainable
       */
      _assignTransformMatrixProps: function() {
        if (this.transformMatrix) {
          var options = fabric.util.qrDecompose(this.transformMatrix);
          this.flipX = false;
          this.flipY = false;
          this.set('scaleX', options.scaleX);
          this.set('scaleY', options.scaleY);
          this.angle = options.angle;
          this.skewX = options.skewX;
          this.skewY = 0;
        }
      },

      /**
       * This function is an helper for svg import. it removes the transform matrix
       * and set to object properties that fabricjs can handle
       * @private
       * @param {Object} preserveAspectRatioOptions
       * @return {thisArg}
       */
      _removeTransformMatrix: function(preserveAspectRatioOptions) {
        var center = this._findCenterFromElement();
        if (this.transformMatrix) {
          this._assignTransformMatrixProps();
          center = fabric.util.transformPoint(center, this.transformMatrix);
        }
        this.transformMatrix = null;
        if (preserveAspectRatioOptions) {
          this.scaleX *= preserveAspectRatioOptions.scaleX;
          this.scaleY *= preserveAspectRatioOptions.scaleY;
          this.cropX = preserveAspectRatioOptions.cropX;
          this.cropY = preserveAspectRatioOptions.cropY;
          center.x += preserveAspectRatioOptions.offsetLeft;
          center.y += preserveAspectRatioOptions.offsetTop;
          this.width = preserveAspectRatioOptions.width;
          this.height = preserveAspectRatioOptions.height;
        }
        this.setPositionByOrigin(center, 'center', 'center');
      },

      /**
       * Clones an instance, using a callback method will work for every object.
       * @param {Function} callback Callback is invoked with a clone as a first argument
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       */
      clone: function(callback, propertiesToInclude) {
        var objectForm = this.toObject(propertiesToInclude);
        if (this.constructor.fromObject) {
          this.constructor.fromObject(objectForm, callback);
        }
        else {
          fabric.Object._fromObject('Object', objectForm, callback);
        }
      },

      /**
       * Creates an instance of fabric.Image out of an object
       * could make use of both toDataUrl or toCanvasElement.
       * @param {Function} callback callback, invoked with an instance as a first argument
       * @param {Object} [options] for clone as image, passed to toDataURL
       * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
       * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
       * @param {Number} [options.multiplier=1] Multiplier to scale by
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
       * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
       * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
       * @return {fabric.Object} thisArg
       */
      cloneAsImage: function(callback, options) {
        var canvasEl = this.toCanvasElement(options);
        if (callback) {
          callback(new fabric.Image(canvasEl));
        }
        return this;
      },

      /**
       * Converts an object into a HTMLCanvas element
       * @param {Object} options Options object
       * @param {Number} [options.multiplier=1] Multiplier to scale by
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
       * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
       * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
       * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
       */
      toCanvasElement: function(options) {
        options || (options = { });

        var utils = fabric.util, origParams = utils.saveObjectTransform(this),
            originalGroup = this.group,
            originalShadow = this.shadow, abs = Math.abs,
            multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);
        delete this.group;
        if (options.withoutTransform) {
          utils.resetObjectTransform(this);
        }
        if (options.withoutShadow) {
          this.shadow = null;
        }

        var el = fabric.util.createCanvasElement(),
            // skip canvas zoom and calculate with setCoords now.
            boundingRect = this.getBoundingRect(true, true),
            shadow = this.shadow, scaling,
            shadowOffset = { x: 0, y: 0 }, shadowBlur,
            width, height;

        if (shadow) {
          shadowBlur = shadow.blur;
          if (shadow.nonScaling) {
            scaling = { scaleX: 1, scaleY: 1 };
          }
          else {
            scaling = this.getObjectScaling();
          }
          // consider non scaling shadow.
          shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * (abs(scaling.scaleX));
          shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * (abs(scaling.scaleY));
        }
        width = boundingRect.width + shadowOffset.x;
        height = boundingRect.height + shadowOffset.y;
        // if the current width/height is not an integer
        // we need to make it so.
        el.width = Math.ceil(width);
        el.height = Math.ceil(height);
        var canvas = new fabric.StaticCanvas(el, {
          enableRetinaScaling: false,
          renderOnAddRemove: false,
          skipOffscreen: false,
        });
        if (options.format === 'jpeg') {
          canvas.backgroundColor = '#fff';
        }
        this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

        var originalCanvas = this.canvas;
        canvas.add(this);
        var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
        this.shadow = originalShadow;
        this.set('canvas', originalCanvas);
        if (originalGroup) {
          this.group = originalGroup;
        }
        this.set(origParams).setCoords();
        // canvas.dispose will call image.dispose that will nullify the elements
        // since this canvas is a simple element for the process, we remove references
        // to objects in this way in order to avoid object trashing.
        canvas._objects = [];
        canvas.dispose();
        canvas = null;

        return canvasEl;
      },

      /**
       * Converts an object into a data-url-like string
       * @param {Object} options Options object
       * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
       * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
       * @param {Number} [options.multiplier=1] Multiplier to scale by
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
       * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
       * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
       * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
       */
      toDataURL: function(options) {
        options || (options = { });
        return fabric.util.toDataURL(this.toCanvasElement(options), options.format || 'png', options.quality || 1);
      },

      /**
       * Returns true if specified type is identical to the type of an instance
       * @param {String} type Type to check against
       * @return {Boolean}
       */
      isType: function(type) {
        return this.type === type;
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity of this instance (is 1 unless subclassed)
       */
      complexity: function() {
        return 1;
      },

      /**
       * Returns a JSON representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} JSON
       */
      toJSON: function(propertiesToInclude) {
        // delegate, not alias
        return this.toObject(propertiesToInclude);
      },

      /**
       * Sets gradient (fill or stroke) of an object
       * percentages for x1,x2,y1,y2,r1,r2 together with gradientUnits 'pixels', are not supported.
       * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
       * @param {String} property Property name 'stroke' or 'fill'
       * @param {Object} [options] Options object
       * @param {String} [options.type] Type of gradient 'radial' or 'linear'
       * @param {Number} [options.x1=0] x-coordinate of start point
       * @param {Number} [options.y1=0] y-coordinate of start point
       * @param {Number} [options.x2=0] x-coordinate of end point
       * @param {Number} [options.y2=0] y-coordinate of end point
       * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
       * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
       * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
       * @param {Object} [options.gradientTransform] transformMatrix for gradient
       * @return {fabric.Object} thisArg
       * @chainable
       * @deprecated since 3.4.0
       * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
       * @example <caption>Set linear gradient</caption>
       * object.setGradient('fill', {
       *   type: 'linear',
       *   x1: -object.width / 2,
       *   y1: 0,
       *   x2: object.width / 2,
       *   y2: 0,
       *   colorStops: {
       *     0: 'red',
       *     0.5: '#005555',
       *     1: 'rgba(0,0,255,0.5)'
       *   }
       * });
       * canvas.renderAll();
       * @example <caption>Set radial gradient</caption>
       * object.setGradient('fill', {
       *   type: 'radial',
       *   x1: 0,
       *   y1: 0,
       *   x2: 0,
       *   y2: 0,
       *   r1: object.width / 2,
       *   r2: 10,
       *   colorStops: {
       *     0: 'red',
       *     0.5: '#005555',
       *     1: 'rgba(0,0,255,0.5)'
       *   }
       * });
       * canvas.renderAll();
       */
      setGradient: function(property, options) {
        options || (options = { });

        var gradient = { colorStops: [] };

        gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
        gradient.coords = {
          x1: options.x1,
          y1: options.y1,
          x2: options.x2,
          y2: options.y2
        };
        gradient.gradientUnits = options.gradientUnits || 'pixels';
        if (options.r1 || options.r2) {
          gradient.coords.r1 = options.r1;
          gradient.coords.r2 = options.r2;
        }

        gradient.gradientTransform = options.gradientTransform;
        fabric.Gradient.prototype.addColorStop.call(gradient, options.colorStops);

        return this.set(property, fabric.Gradient.forObject(this, gradient));
      },

      /**
       * Sets pattern fill of an object
       * @param {Object} options Options object
       * @param {(String|HTMLImageElement)} options.source Pattern source
       * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
       * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
       * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
       * @param {Function} [callback] Callback to invoke when image set as a pattern
       * @return {fabric.Object} thisArg
       * @chainable
       * @deprecated since 3.5.0
       * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
       * @example <caption>Set pattern</caption>
       * object.setPatternFill({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
       *   repeat: 'repeat'
       * },canvas.renderAll.bind(canvas));
       */
      setPatternFill: function(options, callback) {
        return this.set('fill', new fabric.Pattern(options, callback));
      },

      /**
       * Sets {@link fabric.Object#shadow|shadow} of an object
       * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
       * @param {String} [options.color=rgb(0,0,0)] Shadow color
       * @param {Number} [options.blur=0] Shadow blur
       * @param {Number} [options.offsetX=0] Shadow horizontal offset
       * @param {Number} [options.offsetY=0] Shadow vertical offset
       * @return {fabric.Object} thisArg
       * @chainable
       * @deprecated since 3.5.0
       * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
       * @example <caption>Set shadow with string notation</caption>
       * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
       * canvas.renderAll();
       * @example <caption>Set shadow with object notation</caption>
       * object.setShadow({
       *   color: 'red',
       *   blur: 10,
       *   offsetX: 20,
       *   offsetY: 20
       * });
       * canvas.renderAll();
       */
      setShadow: function(options) {
        return this.set('shadow', options ? new fabric.Shadow(options) : null);
      },

      /**
       * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
       * @param {String} color Color value
       * @return {fabric.Object} thisArg
       * @deprecated since 3.5.0
       * @chainable
       */
      setColor: function(color) {
        this.set('fill', color);
        return this;
      },

      /**
       * Sets "angle" of an instance with centered rotation
       * @param {Number} angle Angle value (in degrees)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      rotate: function(angle) {
        var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

        if (shouldCenterOrigin) {
          this._setOriginToCenter();
        }

        this.set('angle', angle);

        if (shouldCenterOrigin) {
          this._resetOrigin();
        }

        return this;
      },

      /**
       * Centers object horizontally on canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      centerH: function () {
        this.canvas && this.canvas.centerObjectH(this);
        return this;
      },

      /**
       * Centers object horizontally on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenterH: function () {
        this.canvas && this.canvas.viewportCenterObjectH(this);
        return this;
      },

      /**
       * Centers object vertically on canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      centerV: function () {
        this.canvas && this.canvas.centerObjectV(this);
        return this;
      },

      /**
       * Centers object vertically on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenterV: function () {
        this.canvas && this.canvas.viewportCenterObjectV(this);
        return this;
      },

      /**
       * Centers object vertically and horizontally on canvas to which is was added last
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      center: function () {
        this.canvas && this.canvas.centerObject(this);
        return this;
      },

      /**
       * Centers object on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenter: function () {
        this.canvas && this.canvas.viewportCenterObject(this);
        return this;
      },

      /**
       * Returns coordinates of a pointer relative to an object
       * @param {Event} e Event to operate upon
       * @param {Object} [pointer] Pointer to operate upon (instead of event)
       * @return {Object} Coordinates of a pointer (x, y)
       */
      getLocalPointer: function(e, pointer) {
        pointer = pointer || this.canvas.getPointer(e);
        var pClicked = new fabric.Point(pointer.x, pointer.y),
            objectLeftTop = this._getLeftTopCoords();
        if (this.angle) {
          pClicked = fabric.util.rotatePoint(
            pClicked, objectLeftTop, degreesToRadians(-this.angle));
        }
        return {
          x: pClicked.x - objectLeftTop.x,
          y: pClicked.y - objectLeftTop.y
        };
      },

      /**
       * Sets canvas globalCompositeOperation for specific object
       * custom composition operation for the particular object can be specified using globalCompositeOperation property
       * @param {CanvasRenderingContext2D} ctx Rendering canvas context
       */
      _setupCompositeOperation: function (ctx) {
        if (this.globalCompositeOperation) {
          ctx.globalCompositeOperation = this.globalCompositeOperation;
        }
      }
    });

    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

    extend(fabric.Object.prototype, fabric.Observable);

    /**
     * Defines the number of fraction digits to use when serializing object values.
     * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
     * @static
     * @memberOf fabric.Object
     * @constant
     * @type Number
     */
    fabric.Object.NUM_FRACTION_DIGITS = 2;

    fabric.Object._fromObject = function(className, object, callback, extraParam) {
      var klass = fabric[className];
      object = clone(object, true);
      fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
        if (typeof patterns[0] !== 'undefined') {
          object.fill = patterns[0];
        }
        if (typeof patterns[1] !== 'undefined') {
          object.stroke = patterns[1];
        }
        fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
          object.clipPath = enlivedProps[0];
          var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
          callback && callback(instance);
        });
      });
    };

    /**
     * Unique id used internally when creating SVG elements
     * @static
     * @memberOf fabric.Object
     * @type Number
     */
    fabric.Object.__uid = 0;
  })( exports );


  (function() {

    var degreesToRadians = fabric.util.degreesToRadians,
        originXOffset = {
          left: -0.5,
          center: 0,
          right: 0.5
        },
        originYOffset = {
          top: -0.5,
          center: 0,
          bottom: 0.5
        };

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Translates the coordinates from a set of origin to another (based on the object's dimensions)
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
       * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
        var x = point.x,
            y = point.y,
            offsetX, offsetY, dim;

        if (typeof fromOriginX === 'string') {
          fromOriginX = originXOffset[fromOriginX];
        }
        else {
          fromOriginX -= 0.5;
        }

        if (typeof toOriginX === 'string') {
          toOriginX = originXOffset[toOriginX];
        }
        else {
          toOriginX -= 0.5;
        }

        offsetX = toOriginX - fromOriginX;

        if (typeof fromOriginY === 'string') {
          fromOriginY = originYOffset[fromOriginY];
        }
        else {
          fromOriginY -= 0.5;
        }

        if (typeof toOriginY === 'string') {
          toOriginY = originYOffset[toOriginY];
        }
        else {
          toOriginY -= 0.5;
        }

        offsetY = toOriginY - fromOriginY;

        if (offsetX || offsetY) {
          dim = this._getTransformedDimensions();
          x = point.x + offsetX * dim.x;
          y = point.y + offsetY * dim.y;
        }

        return new fabric.Point(x, y);
      },

      /**
       * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToCenterPoint: function(point, originX, originY) {
        var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
        if (this.angle) {
          return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
        }
        return p;
      },

      /**
       * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
       * @param {fabric.Point} center The point which corresponds to center of the object
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToOriginPoint: function(center, originX, originY) {
        var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
        if (this.angle) {
          return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
        }
        return p;
      },

      /**
       * Returns the real center coordinates of the object
       * @return {fabric.Point}
       */
      getCenterPoint: function() {
        var leftTop = new fabric.Point(this.left, this.top);
        return this.translateToCenterPoint(leftTop, this.originX, this.originY);
      },

      /**
       * Returns the coordinates of the object based on center coordinates
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @return {fabric.Point}
       */
      // getOriginPoint: function(center) {
      //   return this.translateToOriginPoint(center, this.originX, this.originY);
      // },

      /**
       * Returns the coordinates of the object as if it has a different origin
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      getPointByOrigin: function(originX, originY) {
        var center = this.getCenterPoint();
        return this.translateToOriginPoint(center, originX, originY);
      },

      /**
       * Returns the point in local coordinates
       * @param {fabric.Point} point The point relative to the global coordinate system
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      toLocalPoint: function(point, originX, originY) {
        var center = this.getCenterPoint(),
            p, p2;

        if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
          p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
        }
        else {
          p = new fabric.Point(this.left, this.top);
        }

        p2 = new fabric.Point(point.x, point.y);
        if (this.angle) {
          p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
        }
        return p2.subtractEquals(p);
      },

      /**
       * Returns the point in global coordinates
       * @param {fabric.Point} The point relative to the local coordinate system
       * @return {fabric.Point}
       */
      // toGlobalPoint: function(point) {
      //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
      // },

      /**
       * Sets the position of the object taking into consideration the object's origin
       * @param {fabric.Point} pos The new position of the object
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {void}
       */
      setPositionByOrigin: function(pos, originX, originY) {
        var center = this.translateToCenterPoint(pos, originX, originY),
            position = this.translateToOriginPoint(center, this.originX, this.originY);
        this.set('left', position.x);
        this.set('top', position.y);
      },

      /**
       * @param {String} to One of 'left', 'center', 'right'
       */
      adjustPosition: function(to) {
        var angle = degreesToRadians(this.angle),
            hypotFull = this.getScaledWidth(),
            xFull = fabric.util.cos(angle) * hypotFull,
            yFull = fabric.util.sin(angle) * hypotFull,
            offsetFrom, offsetTo;

        //TODO: this function does not consider mixed situation like top, center.
        if (typeof this.originX === 'string') {
          offsetFrom = originXOffset[this.originX];
        }
        else {
          offsetFrom = this.originX - 0.5;
        }
        if (typeof to === 'string') {
          offsetTo = originXOffset[to];
        }
        else {
          offsetTo = to - 0.5;
        }
        this.left += xFull * (offsetTo - offsetFrom);
        this.top += yFull * (offsetTo - offsetFrom);
        this.setCoords();
        this.originX = to;
      },

      /**
       * Sets the origin/position of the object to it's center point
       * @private
       * @return {void}
       */
      _setOriginToCenter: function() {
        this._originalOriginX = this.originX;
        this._originalOriginY = this.originY;

        var center = this.getCenterPoint();

        this.originX = 'center';
        this.originY = 'center';

        this.left = center.x;
        this.top = center.y;
      },

      /**
       * Resets the origin/position of the object to it's original origin
       * @private
       * @return {void}
       */
      _resetOrigin: function() {
        var originPoint = this.translateToOriginPoint(
          this.getCenterPoint(),
          this._originalOriginX,
          this._originalOriginY);

        this.originX = this._originalOriginX;
        this.originY = this._originalOriginY;

        this.left = originPoint.x;
        this.top = originPoint.y;

        this._originalOriginX = null;
        this._originalOriginY = null;
      },

      /**
       * @private
       */
      _getLeftTopCoords: function() {
        return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
      },
    });

  })();


  (function() {

    function getCoords(coords) {
      return [
        new fabric.Point(coords.tl.x, coords.tl.y),
        new fabric.Point(coords.tr.x, coords.tr.y),
        new fabric.Point(coords.br.x, coords.br.y),
        new fabric.Point(coords.bl.x, coords.bl.y)
      ];
    }

    var degreesToRadians = fabric.util.degreesToRadians,
        multiplyMatrices = fabric.util.multiplyTransformMatrices,
        transformPoint = fabric.util.transformPoint;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Describe object's corner position in canvas element coordinates.
       * properties are tl,mt,tr,ml,mr,bl,mb,br,mtr for the main controls.
       * each property is an object with x, y and corner.
       * The `corner` property contains in a similar manner the 4 points of the
       * interactive area of the corner.
       * The coordinates depends from this properties: width, height, scaleX, scaleY
       * skewX, skewY, angle, strokeWidth, viewportTransform, top, left, padding.
       * The coordinates get updated with @method setCoords.
       * You can calculate them without updating with @method calcCoords;
       * @memberOf fabric.Object.prototype
       */
      oCoords: null,

      /**
       * Describe object's corner position in canvas object absolute coordinates
       * properties are tl,tr,bl,br and describe the four main corner.
       * each property is an object with x, y, instance of Fabric.Point.
       * The coordinates depends from this properties: width, height, scaleX, scaleY
       * skewX, skewY, angle, strokeWidth, top, left.
       * Those coordinates are useful to understand where an object is. They get updated
       * with oCoords but they do not need to be updated when zoom or panning change.
       * The coordinates get updated with @method setCoords.
       * You can calculate them without updating with @method calcCoords(true);
       * @memberOf fabric.Object.prototype
       */
      aCoords: null,

      /**
       * storage for object transform matrix
       */
      ownMatrixCache: null,

      /**
       * storage for object full transform matrix
       */
      matrixCache: null,

      /**
       * return correct set of coordinates for intersection
       */
      getCoords: function(absolute, calculate) {
        if (!this.oCoords) {
          this.setCoords();
        }
        var coords = absolute ? this.aCoords : this.oCoords;
        return getCoords(calculate ? this.calcCoords(absolute) : coords);
      },

      /**
       * Checks if object intersects with an area formed by 2 points
       * @param {Object} pointTL top-left point of area
       * @param {Object} pointBR bottom-right point of area
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object intersects with an area formed by 2 points
       */
      intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
        var coords = this.getCoords(absolute, calculate),
            intersection = fabric.Intersection.intersectPolygonRectangle(
              coords,
              pointTL,
              pointBR
            );
        return intersection.status === 'Intersection';
      },

      /**
       * Checks if object intersects with another object
       * @param {Object} other Object to test
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object intersects with another object
       */
      intersectsWithObject: function(other, absolute, calculate) {
        var intersection = fabric.Intersection.intersectPolygonPolygon(
          this.getCoords(absolute, calculate),
          other.getCoords(absolute, calculate)
        );

        return intersection.status === 'Intersection'
          || other.isContainedWithinObject(this, absolute, calculate)
          || this.isContainedWithinObject(other, absolute, calculate);
      },

      /**
       * Checks if object is fully contained within area of another object
       * @param {Object} other Object to test
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully contained within area of another object
       */
      isContainedWithinObject: function(other, absolute, calculate) {
        var points = this.getCoords(absolute, calculate),
            i = 0, lines = other._getImageLines(
              calculate ? other.calcCoords(absolute) : absolute ? other.aCoords : other.oCoords
            );
        for (; i < 4; i++) {
          if (!other.containsPoint(points[i], lines)) {
            return false;
          }
        }
        return true;
      },

      /**
       * Checks if object is fully contained within area formed by 2 points
       * @param {Object} pointTL top-left point of area
       * @param {Object} pointBR bottom-right point of area
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully contained within area formed by 2 points
       */
      isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
        var boundingRect = this.getBoundingRect(absolute, calculate);

        return (
          boundingRect.left >= pointTL.x &&
          boundingRect.left + boundingRect.width <= pointBR.x &&
          boundingRect.top >= pointTL.y &&
          boundingRect.top + boundingRect.height <= pointBR.y
        );
      },

      /**
       * Checks if point is inside the object
       * @param {fabric.Point} point Point to check against
       * @param {Object} [lines] object returned from @method _getImageLines
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if point is inside the object
       */
      containsPoint: function(point, lines, absolute, calculate) {
        var lines = lines || this._getImageLines(
              calculate ? this.calcCoords(absolute) : absolute ? this.aCoords : this.oCoords
            ),
            xPoints = this._findCrossPoints(point, lines);

        // if xPoints is odd then point is inside the object
        return (xPoints !== 0 && xPoints % 2 === 1);
      },

      /**
       * Checks if object is contained within the canvas with current viewportTransform
       * the check is done stopping at first point that appears on screen
       * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
       * @return {Boolean} true if object is fully or partially contained within canvas
       */
      isOnScreen: function(calculate) {
        if (!this.canvas) {
          return false;
        }
        var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
        var points = this.getCoords(true, calculate), point;
        for (var i = 0; i < 4; i++) {
          point = points[i];
          if (point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y) {
            return true;
          }
        }
        // no points on screen, check intersection with absolute coordinates
        if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
          return true;
        }
        return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
      },

      /**
       * Checks if the object contains the midpoint between canvas extremities
       * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
       * @private
       * @param {Fabric.Point} pointTL Top Left point
       * @param {Fabric.Point} pointBR Top Right point
       * @param {Boolean} calculate use coordinates of current position instead of .oCoords
       * @return {Boolean} true if the object contains the point
       */
      _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
        // worst case scenario the object is so big that contains the screen
        var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
        if (this.containsPoint(centerPoint, null, true, calculate)) {
          return true;
        }
        return false;
      },

      /**
       * Checks if object is partially contained within the canvas with current viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is partially contained within canvas
       */
      isPartiallyOnScreen: function(calculate) {
        if (!this.canvas) {
          return false;
        }
        var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
        if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
          return true;
        }
        return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
      },

      /**
       * Method that returns an object with the object edges in it, given the coordinates of the corners
       * @private
       * @param {Object} oCoords Coordinates of the object corners
       */
      _getImageLines: function(oCoords) {
        return {
          topline: {
            o: oCoords.tl,
            d: oCoords.tr
          },
          rightline: {
            o: oCoords.tr,
            d: oCoords.br
          },
          bottomline: {
            o: oCoords.br,
            d: oCoords.bl
          },
          leftline: {
            o: oCoords.bl,
            d: oCoords.tl
          }
        };
      },

      /**
       * Helper method to determine how many cross points are between the 4 object edges
       * and the horizontal line determined by a point on canvas
       * @private
       * @param {fabric.Point} point Point to check
       * @param {Object} lines Coordinates of the object being evaluated
       */
      // remove yi, not used but left code here just in case.
      _findCrossPoints: function(point, lines) {
        var b1, b2, a1, a2, xi, // yi,
            xcount = 0,
            iLine;

        for (var lineKey in lines) {
          iLine = lines[lineKey];
          // optimisation 1: line below point. no cross
          if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
            continue;
          }
          // optimisation 2: line above point. no cross
          if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
            continue;
          }
          // optimisation 3: vertical line case
          if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
            xi = iLine.o.x;
            // yi = point.y;
          }
          // calculate the intersection point
          else {
            b1 = 0;
            b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
            a1 = point.y - b1 * point.x;
            a2 = iLine.o.y - b2 * iLine.o.x;

            xi = -(a1 - a2) / (b1 - b2);
            // yi = a1 + b1 * xi;
          }
          // dont count xi < point.x cases
          if (xi >= point.x) {
            xcount += 1;
          }
          // optimisation 4: specific for square images
          if (xcount === 2) {
            break;
          }
        }
        return xcount;
      },

      /**
       * Returns coordinates of object's bounding rectangle (left, top, width, height)
       * the box is intended as aligned to axis of canvas.
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
       * @return {Object} Object with left, top, width, height properties
       */
      getBoundingRect: function(absolute, calculate) {
        var coords = this.getCoords(absolute, calculate);
        return fabric.util.makeBoundingBoxFromPoints(coords);
      },

      /**
       * Returns width of an object's bounding box counting transformations
       * before 2.0 it was named getWidth();
       * @return {Number} width value
       */
      getScaledWidth: function() {
        return this._getTransformedDimensions().x;
      },

      /**
       * Returns height of an object bounding box counting transformations
       * before 2.0 it was named getHeight();
       * @return {Number} height value
       */
      getScaledHeight: function() {
        return this._getTransformedDimensions().y;
      },

      /**
       * Makes sure the scale is valid and modifies it if necessary
       * @private
       * @param {Number} value
       * @return {Number}
       */
      _constrainScale: function(value) {
        if (Math.abs(value) < this.minScaleLimit) {
          if (value < 0) {
            return -this.minScaleLimit;
          }
          else {
            return this.minScaleLimit;
          }
        }
        else if (value === 0) {
          return 0.0001;
        }
        return value;
      },

      /**
       * Scales an object (equally by x and y)
       * @param {Number} value Scale factor
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scale: function(value) {
        this._set('scaleX', value);
        this._set('scaleY', value);
        return this.setCoords();
      },

      /**
       * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
       * @param {Number} value New width value
       * @param {Boolean} absolute ignore viewport
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scaleToWidth: function(value, absolute) {
        // adjust to bounding rect factor so that rotated shapes would fit as well
        var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
        return this.scale(value / this.width / boundingRectFactor);
      },

      /**
       * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
       * @param {Number} value New height value
       * @param {Boolean} absolute ignore viewport
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scaleToHeight: function(value, absolute) {
        // adjust to bounding rect factor so that rotated shapes would fit as well
        var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
        return this.scale(value / this.height / boundingRectFactor);
      },

      /**
       * Calculates and returns the .coords of an object.
       * @return {Object} Object with tl, tr, br, bl ....
       * @chainable
       */
      calcCoords: function(absolute) {
        var rotateMatrix = this._calcRotateMatrix(),
            translateMatrix = this._calcTranslateMatrix(),
            startMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
            vpt = this.getViewportTransform(),
            finalMatrix = absolute ? startMatrix : multiplyMatrices(vpt, startMatrix),
            dim = this._getTransformedDimensions(),
            w = dim.x / 2, h = dim.y / 2,
            tl = transformPoint({ x: -w, y: -h }, finalMatrix),
            tr = transformPoint({ x: w, y: -h }, finalMatrix),
            bl = transformPoint({ x: -w, y: h }, finalMatrix),
            br = transformPoint({ x: w, y: h }, finalMatrix);
        if (!absolute) {
          var padding = this.padding, angle = degreesToRadians(this.angle),
              cos = fabric.util.cos(angle), sin = fabric.util.sin(angle),
              cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
              cosPMinusSinP = cosP - sinP;
          if (padding) {
            tl.x -= cosPMinusSinP;
            tl.y -= cosPSinP;
            tr.x += cosPSinP;
            tr.y -= cosPMinusSinP;
            bl.x -= cosPSinP;
            bl.y += cosPMinusSinP;
            br.x += cosPMinusSinP;
            br.y += cosPSinP;
          }
          var ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),
              mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),
              mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),
              mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),
              mtr = new fabric.Point(mt.x + sin * this.rotatingPointOffset, mt.y - cos * this.rotatingPointOffset);
        }

        // if (!absolute) {
        //   var canvas = this.canvas;
        //   setTimeout(function() {
        //     canvas.contextTop.clearRect(0, 0, 700, 700);
        //     canvas.contextTop.fillStyle = 'green';
        //     canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
        //     canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
        //     canvas.contextTop.fillRect(br.x, br.y, 3, 3);
        //     canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
        //     canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
        //     canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
        //     canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
        //     canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
        //     canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
        //   }, 50);
        // }

        var coords = {
          // corners
          tl: tl, tr: tr, br: br, bl: bl,
        };
        if (!absolute) {
          // middle
          coords.ml = ml;
          coords.mt = mt;
          coords.mr = mr;
          coords.mb = mb;
          // rotating point
          coords.mtr = mtr;
        }
        return coords;
      },

      /**
       * Sets corner position coordinates based on current angle, width and height.
       * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}
       * @param {Boolean} [ignoreZoom] set oCoords with or without the viewport transform.
       * @param {Boolean} [skipAbsolute] skip calculation of aCoords, useful in setViewportTransform
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setCoords: function(ignoreZoom, skipAbsolute) {
        this.oCoords = this.calcCoords(ignoreZoom);
        if (!skipAbsolute) {
          this.aCoords = this.calcCoords(true);
        }

        // set coordinates of the draggable boxes in the corners used to scale/rotate the image
        ignoreZoom || (this._setCornerCoords && this._setCornerCoords());

        return this;
      },

      /**
       * calculate rotation matrix of an object
       * @return {Array} rotation matrix for the object
       */
      _calcRotateMatrix: function() {
        return fabric.util.calcRotateMatrix(this);
      },

      /**
       * calculate the translation matrix for an object transform
       * @return {Array} rotation matrix for the object
       */
      _calcTranslateMatrix: function() {
        var center = this.getCenterPoint();
        return [1, 0, 0, 1, center.x, center.y];
      },

      transformMatrixKey: function(skipGroup) {
        var sep = '_', prefix = '';
        if (!skipGroup && this.group) {
          prefix = this.group.transformMatrixKey(skipGroup) + sep;
        }      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
          sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
          sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
      },

      /**
       * calculate transform matrix that represents the current transformations from the
       * object's properties.
       * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
       * @return {Array} transform matrix for the object
       */
      calcTransformMatrix: function(skipGroup) {
        if (skipGroup) {
          return this.calcOwnMatrix();
        }
        var key = this.transformMatrixKey(), cache = this.matrixCache || (this.matrixCache = {});
        if (cache.key === key) {
          return cache.value;
        }
        var matrix = this.calcOwnMatrix();
        if (this.group) {
          matrix = multiplyMatrices(this.group.calcTransformMatrix(), matrix);
        }
        cache.key = key;
        cache.value = matrix;
        return matrix;
      },

      /**
       * calculate transform matrix that represents the current transformations from the
       * object's properties, this matrix does not include the group transformation
       * @return {Array} transform matrix for the object
       */
      calcOwnMatrix: function() {
        var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
        if (cache.key === key) {
          return cache.value;
        }
        var tMatrix = this._calcTranslateMatrix();
        this.translateX = tMatrix[4];
        this.translateY = tMatrix[5];
        cache.key = key;
        cache.value = fabric.util.composeMatrix(this);
        return cache.value;
      },

      /*
       * Calculate object dimensions from its properties
       * @private
       * @deprecated since 3.4.0, please use fabric.util._calcDimensionsTransformMatrix
       * not including or including flipX, flipY to emulate the flipping boolean
       * @return {Object} .x width dimension
       * @return {Object} .y height dimension
       */
      _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
        return fabric.util.calcDimensionsMatrix({
          skewX: skewX,
          skewY: skewY,
          scaleX: this.scaleX * (flipping && this.flipX ? -1 : 1),
          scaleY: this.scaleY * (flipping && this.flipY ? -1 : 1)
        });
      },

      /*
       * Calculate object dimensions from its properties
       * @private
       * @return {Object} .x width dimension
       * @return {Object} .y height dimension
       */
      _getNonTransformedDimensions: function() {
        var strokeWidth = this.strokeWidth,
            w = this.width + strokeWidth,
            h = this.height + strokeWidth;
        return { x: w, y: h };
      },

      /*
       * Calculate object bounding box dimensions from its properties scale, skew.
       * The skewX and skewY parameters are used in the skewing logic path and
       * do not provide something useful to common use cases.
       * @param {Number} [skewX], a value to override current skewX
       * @param {Number} [skewY], a value to override current skewY
       * @private
       * @return {Object} .x width dimension
       * @return {Object} .y height dimension
       */
      _getTransformedDimensions: function(skewX, skewY) {
        if (typeof skewX === 'undefined') {
          skewX = this.skewX;
        }
        if (typeof skewY === 'undefined') {
          skewY = this.skewY;
        }
        var dimensions = this._getNonTransformedDimensions(), dimX, dimY,
            noSkew = skewX === 0 && skewY === 0;

        if (this.strokeUniform) {
          dimX = this.width;
          dimY = this.height;
        }
        else {
          dimX = dimensions.x;
          dimY = dimensions.y;
        }
        if (noSkew) {
          return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
        }
        else {
          dimX /= 2;
          dimY /= 2;
        }
        var points = [
              {
                x: -dimX,
                y: -dimY
              },
              {
                x: dimX,
                y: -dimY
              },
              {
                x: -dimX,
                y: dimY
              },
              {
                x: dimX,
                y: dimY
              }],
            transformMatrix = fabric.util.calcDimensionsMatrix({
              scaleX: this.scaleX,
              scaleY: this.scaleY,
              skewX: skewX,
              skewY: skewY,
            }),
            bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);
        return this._finalizeDimensions(bbox.width, bbox.height);
      },

      /*
       * Calculate object bounding box dimensions from its properties scale, skew.
       * @param Number width width of the bbox
       * @param Number height height of the bbox
       * @private
       * @return {Object} .x finalized width dimension
       * @return {Object} .y finalized height dimension
       */
      _finalizeDimensions: function(width, height) {
        return this.strokeUniform ?
          { x: width + this.strokeWidth, y: height + this.strokeWidth }
          :
          { x: width, y: height };
      },
      /*
       * Calculate object dimensions for controls, including padding and canvas zoom.
       * private
       */
      _calculateCurrentDimensions: function()  {
        var vpt = this.getViewportTransform(),
            dim = this._getTransformedDimensions(),
            p = fabric.util.transformPoint(dim, vpt, true);

        return p.scalarAdd(2 * this.padding);
      },
    });
  })();


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Moves an object to the bottom of the stack of drawn objects
     * @return {fabric.Object} thisArg
     * @chainable
     */
    sendToBack: function() {
      if (this.group) {
        fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
      }
      else if (this.canvas) {
        this.canvas.sendToBack(this);
      }
      return this;
    },

    /**
     * Moves an object to the top of the stack of drawn objects
     * @return {fabric.Object} thisArg
     * @chainable
     */
    bringToFront: function() {
      if (this.group) {
        fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
      }
      else if (this.canvas) {
        this.canvas.bringToFront(this);
      }
      return this;
    },

    /**
     * Moves an object down in stack of drawn objects
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    sendBackwards: function(intersecting) {
      if (this.group) {
        fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
      }
      else if (this.canvas) {
        this.canvas.sendBackwards(this, intersecting);
      }
      return this;
    },

    /**
     * Moves an object up in stack of drawn objects
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    bringForward: function(intersecting) {
      if (this.group) {
        fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
      }
      else if (this.canvas) {
        this.canvas.bringForward(this, intersecting);
      }
      return this;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {Number} index New position of object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    moveTo: function(index) {
      if (this.group && this.group.type !== 'activeSelection') {
        fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
      }
      else if (this.canvas) {
        this.canvas.moveTo(this, index);
      }
      return this;
    }
  });


  /* _TO_SVG_START_ */
  (function() {
    function getSvgColorString(prop, value) {
      if (!value) {
        return prop + ': none; ';
      }
      else if (value.toLive) {
        return prop + ': url(#SVGID_' + value.id + '); ';
      }
      else {
        var color = new fabric.Color(value),
            str = prop + ': ' + color.toRgb() + '; ',
            opacity = color.getAlpha();
        if (opacity !== 1) {
          //change the color in rgb + opacity
          str += prop + '-opacity: ' + opacity.toString() + '; ';
        }
        return str;
      }
    }

    var toFixed = fabric.util.toFixed;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
      /**
       * Returns styles-string for svg-export
       * @param {Boolean} skipShadow a boolean to skip shadow filter output
       * @return {String}
       */
      getSvgStyles: function(skipShadow) {

        var fillRule = this.fillRule ? this.fillRule : 'nonzero',
            strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
            strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
            strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : '0',
            strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
            strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
            strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
            opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
            visibility = this.visible ? '' : ' visibility: hidden;',
            filter = skipShadow ? '' : this.getSvgFilter(),
            fill = getSvgColorString('fill', this.fill),
            stroke = getSvgColorString('stroke', this.stroke);

        return [
          stroke,
          'stroke-width: ', strokeWidth, '; ',
          'stroke-dasharray: ', strokeDashArray, '; ',
          'stroke-linecap: ', strokeLineCap, '; ',
          'stroke-dashoffset: ', strokeDashOffset, '; ',
          'stroke-linejoin: ', strokeLineJoin, '; ',
          'stroke-miterlimit: ', strokeMiterLimit, '; ',
          fill,
          'fill-rule: ', fillRule, '; ',
          'opacity: ', opacity, ';',
          filter,
          visibility
        ].join('');
      },

      /**
       * Returns styles-string for svg-export
       * @param {Object} style the object from which to retrieve style properties
       * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
       * @return {String}
       */
      getSvgSpanStyles: function(style, useWhiteSpace) {
        var term = '; ';
        var fontFamily = style.fontFamily ?
          'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
            '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
        var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
            fontFamily = fontFamily,
            fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
            fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
            fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
            fill = style.fill ? getSvgColorString('fill', style.fill) : '',
            stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
            textDecoration = this.getSvgTextDecoration(style),
            deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
        if (textDecoration) {
          textDecoration = 'text-decoration: ' + textDecoration + term;
        }

        return [
          stroke,
          strokeWidth,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration,
          fill,
          deltaY,
          useWhiteSpace ? 'white-space: pre; ' : ''
        ].join('');
      },

      /**
       * Returns text-decoration property for svg-export
       * @param {Object} style the object from which to retrieve style properties
       * @return {String}
       */
      getSvgTextDecoration: function(style) {
        return ['overline', 'underline', 'line-through'].filter(function(decoration) {
          return style[decoration.replace('-', '')];
        }).join(' ');
      },

      /**
       * Returns filter for svg shadow
       * @return {String}
       */
      getSvgFilter: function() {
        return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
      },

      /**
       * Returns id attribute for svg output
       * @return {String}
       */
      getSvgCommons: function() {
        return [
          this.id ? 'id="' + this.id + '" ' : '',
          this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : '',
        ].join('');
      },

      /**
       * Returns transform-string for svg-export
       * @param {Boolean} use the full transform or the single object one.
       * @return {String}
       */
      getSvgTransform: function(full, additionalTransform) {
        var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(),
            svgTransform = 'transform="' + fabric.util.matrixToSVG(transform);
        return svgTransform +
          (additionalTransform || '') + this.getSvgTransformMatrix() + '" ';
      },

      /**
       * Returns transform-string for svg-export from the transform matrix of single elements
       * @return {String}
       */
      getSvgTransformMatrix: function() {
        return this.transformMatrix ? ' ' + fabric.util.matrixToSVG(this.transformMatrix) : '';
      },

      _setSVGBg: function(textBgRects) {
        if (this.backgroundColor) {
          var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
          textBgRects.push(
            '\t\t<rect ',
            this._getFillAttributes(this.backgroundColor),
            ' x="',
            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
            '" y="',
            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
            '" width="',
            toFixed(this.width, NUM_FRACTION_DIGITS),
            '" height="',
            toFixed(this.height, NUM_FRACTION_DIGITS),
            '"></rect>\n');
        }
      },

      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver: reviver });
      },

      /**
       * Returns svg clipPath representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toClipPathSVG: function(reviver) {
        return '\t' + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver: reviver });
      },

      /**
       * @private
       */
      _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
        options = options || {};
        var reviver = options.reviver,
            additionalTransform = options.additionalTransform || '',
            commonPieces = [
              this.getSvgTransform(true, additionalTransform),
              this.getSvgCommons(),
            ].join(''),
            // insert commons in the markup, style and svgCommons
            index = objectMarkup.indexOf('COMMON_PARTS');
        objectMarkup[index] = commonPieces;
        return reviver ? reviver(objectMarkup.join('')) : objectMarkup.join('');
      },

      /**
       * @private
       */
      _createBaseSVGMarkup: function(objectMarkup, options) {
        options = options || {};
        var noStyle = options.noStyle,
            reviver = options.reviver,
            styleInfo = noStyle ? '' : 'style="' + this.getSvgStyles() + '" ',
            shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : '',
            clipPath = this.clipPath,
            vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : '',
            absoluteClipPath = clipPath && clipPath.absolutePositioned,
            stroke = this.stroke, fill = this.fill, shadow = this.shadow,
            commonPieces, markup = [], clipPathMarkup,
            // insert commons in the markup, style and svgCommons
            index = objectMarkup.indexOf('COMMON_PARTS'),
            additionalTransform = options.additionalTransform;
        if (clipPath) {
          clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
          clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' +
            clipPath.toClipPathSVG(reviver) +
            '</clipPath>\n';
        }
        if (absoluteClipPath) {
          markup.push(
            '<g ', shadowInfo, this.getSvgCommons(), ' >\n'
          );
        }
        markup.push(
          '<g ',
          this.getSvgTransform(false),
          !absoluteClipPath ? shadowInfo + this.getSvgCommons() : '',
          ' >\n'
        );
        commonPieces = [
          styleInfo,
          vectorEffect,
          noStyle ? '' : this.addPaintOrder(), ' ',
          additionalTransform ? 'transform="' + additionalTransform + '" ' : '',
        ].join('');
        objectMarkup[index] = commonPieces;
        if (fill && fill.toLive) {
          markup.push(fill.toSVG(this));
        }
        if (stroke && stroke.toLive) {
          markup.push(stroke.toSVG(this));
        }
        if (shadow) {
          markup.push(shadow.toSVG(this));
        }
        if (clipPath) {
          markup.push(clipPathMarkup);
        }
        markup.push(objectMarkup.join(''));
        markup.push('</g>\n');
        absoluteClipPath && markup.push('</g>\n');
        return reviver ? reviver(markup.join('')) : markup.join('');
      },

      addPaintOrder: function() {
        return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
      }
    });
  })();
  /* _TO_SVG_END_ */


  (function() {

    var extend = fabric.util.object.extend,
        originalSet = 'stateProperties';

    /*
      Depends on `stateProperties`
    */
    function saveProps(origin, destination, props) {
      var tmpObj = { }, deep = true;
      props.forEach(function(prop) {
        tmpObj[prop] = origin[prop];
      });
      extend(origin[destination], tmpObj, deep);
    }

    function _isEqual(origValue, currentValue, firstPass) {
      if (origValue === currentValue) {
        // if the objects are identical, return
        return true;
      }
      else if (Array.isArray(origValue)) {
        if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
          return false;
        }
        for (var i = 0, len = origValue.length; i < len; i++) {
          if (!_isEqual(origValue[i], currentValue[i])) {
            return false;
          }
        }
        return true;
      }
      else if (origValue && typeof origValue === 'object') {
        var keys = Object.keys(origValue), key;
        if (!currentValue ||
            typeof currentValue !== 'object' ||
            (!firstPass && keys.length !== Object.keys(currentValue).length)
        ) {
          return false;
        }
        for (var i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          // since clipPath is in the statefull cache list and the clipPath objects
          // would be iterated as an object, this would lead to possible infinite recursion
          if (key === 'canvas') {
            continue;
          }
          if (!_isEqual(origValue[key], currentValue[key])) {
            return false;
          }
        }
        return true;
      }
    }


    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Returns true if object state (one of its state properties) was changed
       * @param {String} [propertySet] optional name for the set of property we want to save
       * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
       */
      hasStateChanged: function(propertySet) {
        propertySet = propertySet || originalSet;
        var dashedPropertySet = '_' + propertySet;
        if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
          return true;
        }
        return !_isEqual(this[dashedPropertySet], this, true);
      },

      /**
       * Saves state of an object
       * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
       * @return {fabric.Object} thisArg
       */
      saveState: function(options) {
        var propertySet = options && options.propertySet || originalSet,
            destination = '_' + propertySet;
        if (!this[destination]) {
          return this.setupState(options);
        }
        saveProps(this, destination, this[propertySet]);
        if (options && options.stateProperties) {
          saveProps(this, destination, options.stateProperties);
        }
        return this;
      },

      /**
       * Setups state of an object
       * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
       * @return {fabric.Object} thisArg
       */
      setupState: function(options) {
        options = options || { };
        var propertySet = options.propertySet || originalSet;
        options.propertySet = propertySet;
        this['_' + propertySet] = { };
        this.saveState(options);
        return this;
      }
    });
  })();


  (function() {

    var degreesToRadians = fabric.util.degreesToRadians;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * The object interactivity controls.
       * @private
       */
      _controlsVisibility: null,

      /**
       * Determines which corner has been clicked
       * @private
       * @param {Object} pointer The pointer indicating the mouse position
       * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
       */
      _findTargetCorner: function(pointer) {
        // objects in group, anykind, are not self modificable,
        // must not return an hovered corner.
        if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
          return false;
        }

        var ex = pointer.x,
            ey = pointer.y,
            xPoints,
            lines;
        this.__corner = 0;
        for (var i in this.oCoords) {

          if (!this.isControlVisible(i)) {
            continue;
          }

          if (i === 'mtr' && !this.hasRotatingPoint) {
            continue;
          }

          if (this.get('lockUniScaling') &&
             (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
            continue;
          }

          lines = this._getImageLines(this.oCoords[i].corner);

          // debugging

          // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

          xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
          if (xPoints !== 0 && xPoints % 2 === 1) {
            this.__corner = i;
            return i;
          }
        }
        return false;
      },

      /**
       * Sets the coordinates of the draggable boxes in the corners of
       * the image used to scale/rotate it.
       * @private
       */
      _setCornerCoords: function() {
        var coords = this.oCoords,
            newTheta = degreesToRadians(45 - this.angle),
            /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
            /* 0.707106 stands for sqrt(2)/2 */
            cornerHypotenuse = this.cornerSize * 0.707106,
            cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta),
            sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta),
            x, y;

        for (var point in coords) {
          x = coords[point].x;
          y = coords[point].y;
          coords[point].corner = {
            tl: {
              x: x - sinHalfOffset,
              y: y - cosHalfOffset
            },
            tr: {
              x: x + cosHalfOffset,
              y: y - sinHalfOffset
            },
            bl: {
              x: x - cosHalfOffset,
              y: y + sinHalfOffset
            },
            br: {
              x: x + sinHalfOffset,
              y: y + cosHalfOffset
            }
          };
        }
      },

      /**
       * Draws a colored layer behind the object, inside its selection borders.
       * Requires public options: padding, selectionBackgroundColor
       * this function is called when the context is transformed
       * has checks to be skipped when the object is on a staticCanvas
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawSelectionBackground: function(ctx) {
        if (!this.selectionBackgroundColor ||
          (this.canvas && !this.canvas.interactive) ||
          (this.canvas && this.canvas._activeObject !== this)
        ) {
          return this;
        }
        ctx.save();
        var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
            vpt = this.canvas.viewportTransform;
        ctx.translate(center.x, center.y);
        ctx.scale(1 / vpt[0], 1 / vpt[3]);
        ctx.rotate(degreesToRadians(this.angle));
        ctx.fillStyle = this.selectionBackgroundColor;
        ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
        ctx.restore();
        return this;
      },

      /**
       * Draws borders of an object's bounding box.
       * Requires public properties: width, height
       * Requires public options: padding, borderColor
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawBorders: function(ctx, styleOverride) {
        styleOverride = styleOverride || {};
        var wh = this._calculateCurrentDimensions(),
            strokeWidth = this.borderScaleFactor,
            width = wh.x + strokeWidth,
            height = wh.y + strokeWidth,
            drawRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
              styleOverride.hasRotatingPoint : this.hasRotatingPoint,
            hasControls = typeof styleOverride.hasControls !== 'undefined' ?
              styleOverride.hasControls : this.hasControls,
            rotatingPointOffset = typeof styleOverride.rotatingPointOffset !== 'undefined' ?
              styleOverride.rotatingPointOffset : this.rotatingPointOffset;

        ctx.save();
        ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
        this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);

        ctx.strokeRect(
          -width / 2,
          -height / 2,
          width,
          height
        );

        if (drawRotatingPoint && this.isControlVisible('mtr') && hasControls) {

          var rotateHeight = -height / 2;

          ctx.beginPath();
          ctx.moveTo(0, rotateHeight);
          ctx.lineTo(0, rotateHeight - rotatingPointOffset);
          ctx.stroke();
        }

        ctx.restore();
        return this;
      },

      /**
       * Draws borders of an object's bounding box when it is inside a group.
       * Requires public properties: width, height
       * Requires public options: padding, borderColor
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {object} options object representing current object parameters
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawBordersInGroup: function(ctx, options, styleOverride) {
        styleOverride = styleOverride || {};
        var p = { x: this.width, y: this.height },
            matrix = fabric.util.composeMatrix({
              scaleX: options.scaleX,
              scaleY: options.scaleY,
              skewX: options.skewX
            }),
            wh = fabric.util.transformPoint(p, matrix),
            strokeWidth = this.strokeWidth,
            borderScaleFactor = this.borderScaleFactor,
            width =
              wh.x + strokeWidth * (this.strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor,
            height =
              wh.y + strokeWidth * (this.strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
        ctx.save();
        this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);
        ctx.strokeStyle = styleOverride.borderColor || this.borderColor;

        ctx.strokeRect(
          -width / 2,
          -height / 2,
          width,
          height
        );

        ctx.restore();
        return this;
      },

      /**
       * Draws corners of an object's bounding box.
       * Requires public properties: width, height
       * Requires public options: cornerSize, padding
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawControls: function(ctx, styleOverride) {
        styleOverride = styleOverride || {};
        var wh = this._calculateCurrentDimensions(),
            width = wh.x,
            height = wh.y,
            scaleOffset = styleOverride.cornerSize || this.cornerSize,
            left = -(width + scaleOffset) / 2,
            top = -(height + scaleOffset) / 2,
            transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
              styleOverride.transparentCorners : this.transparentCorners,
            hasRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
              styleOverride.hasRotatingPoint : this.hasRotatingPoint,
            methodName = transparentCorners ? 'stroke' : 'fill';

        ctx.save();
        ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
        if (!this.transparentCorners) {
          ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
        }
        this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);

        // top-left
        this._drawControl('tl', ctx, methodName,
          left,
          top, styleOverride);

        // top-right
        this._drawControl('tr', ctx, methodName,
          left + width,
          top, styleOverride);

        // bottom-left
        this._drawControl('bl', ctx, methodName,
          left,
          top + height, styleOverride);

        // bottom-right
        this._drawControl('br', ctx, methodName,
          left + width,
          top + height, styleOverride);

        if (!this.get('lockUniScaling')) {

          // middle-top
          this._drawControl('mt', ctx, methodName,
            left + width / 2,
            top, styleOverride);

          // middle-bottom
          this._drawControl('mb', ctx, methodName,
            left + width / 2,
            top + height, styleOverride);

          // middle-right
          this._drawControl('mr', ctx, methodName,
            left + width,
            top + height / 2, styleOverride);

          // middle-left
          this._drawControl('ml', ctx, methodName,
            left,
            top + height / 2, styleOverride);
        }

        // middle-top-rotate
        if (hasRotatingPoint) {
          this._drawControl('mtr', ctx, methodName,
            left + width / 2,
            top - this.rotatingPointOffset, styleOverride);
        }

        ctx.restore();

        return this;
      },

      /**
       * @private
       */
      _drawControl: function(control, ctx, methodName, left, top, styleOverride) {
        styleOverride = styleOverride || {};
        if (!this.isControlVisible(control)) {
          return;
        }
        var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
        switch (styleOverride.cornerStyle || this.cornerStyle) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
            ctx[methodName]();
            if (stroke) {
              ctx.stroke();
            }
            break;
          default:
            this.transparentCorners || ctx.clearRect(left, top, size, size);
            ctx[methodName + 'Rect'](left, top, size, size);
            if (stroke) {
              ctx.strokeRect(left, top, size, size);
            }
        }
      },

      /**
       * Returns true if the specified control is visible, false otherwise.
       * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
       * @returns {Boolean} true if the specified control is visible, false otherwise
       */
      isControlVisible: function(controlName) {
        return this._getControlsVisibility()[controlName];
      },

      /**
       * Sets the visibility of the specified control.
       * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
       * @param {Boolean} visible true to set the specified control visible, false otherwise
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setControlVisible: function(controlName, visible) {
        this._getControlsVisibility()[controlName] = visible;
        return this;
      },

      /**
       * Sets the visibility state of object controls.
       * @param {Object} [options] Options object
       * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
       * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
       * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
       * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
       * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
       * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
       * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
       * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
       * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setControlsVisibility: function(options) {
        options || (options = { });

        for (var p in options) {
          this.setControlVisible(p, options[p]);
        }
        return this;
      },

      /**
       * Returns the instance of the control visibility set for this object.
       * @private
       * @returns {Object}
       */
      _getControlsVisibility: function() {
        if (!this._controlsVisibility) {
          this._controlsVisibility = {
            tl: true,
            tr: true,
            br: true,
            bl: true,
            ml: true,
            mt: true,
            mr: true,
            mb: true,
            mtr: true
          };
        }
        return this._controlsVisibility;
      },

      /**
       * This callback function is called every time _discardActiveObject or _setActiveObject
       * try to to deselect this object. If the function returns true, the process is cancelled
       * @param {Object} [options] options sent from the upper functions
       * @param {Event} [options.e] event if the process is generated by an event
       */
      onDeselect: function() {
        // implemented by sub-classes, as needed.
      },


      /**
       * This callback function is called every time _discardActiveObject or _setActiveObject
       * try to to select this object. If the function returns true, the process is cancelled
       * @param {Object} [options] options sent from the upper functions
       * @param {Event} [options.e] event if the process is generated by an event
       */
      onSelect: function() {
        // implemented by sub-classes, as needed.
      }
    });
  })();


  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Animation duration (in ms) for fx* methods
     * @type Number
     * @default
     */
    FX_DURATION: 500,

    /**
     * Centers object horizontally with animation.
     * @param {fabric.Object} object Object to center
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxCenterObjectH: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.left,
        endValue: this.getCenter().left,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('left', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function() {
          object.setCoords();
          onComplete();
        }
      });

      return this;
    },

    /**
     * Centers object vertically with animation.
     * @param {fabric.Object} object Object to center
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxCenterObjectV: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.top,
        endValue: this.getCenter().top,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('top', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function() {
          object.setCoords();
          onComplete();
        }
      });

      return this;
    },

    /**
     * Same as `fabric.Canvas#remove` but animated
     * @param {fabric.Object} object Object to remove
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxRemove: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.opacity,
        endValue: 0,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('opacity', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function () {
          _this.remove(object);
          onComplete();
        }
      });

      return this;
    }
  });

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Animates object's properties
     * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
     * @param {Number|Object} value Value to animate property to (if string was given first) or options object
     * @return {fabric.Object} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
     * @chainable
     *
     * As object — multiple properties
     *
     * object.animate({ left: ..., top: ... });
     * object.animate({ left: ..., top: ... }, { duration: ... });
     *
     * As string — one property
     *
     * object.animate('left', ...);
     * object.animate('left', { duration: ... });
     *
     */
    animate: function() {
      if (arguments[0] && typeof arguments[0] === 'object') {
        var propsToAnimate = [], prop, skipCallbacks;
        for (prop in arguments[0]) {
          propsToAnimate.push(prop);
        }
        for (var i = 0, len = propsToAnimate.length; i < len; i++) {
          prop = propsToAnimate[i];
          skipCallbacks = i !== len - 1;
          this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
        }
      }
      else {
        this._animate.apply(this, arguments);
      }
      return this;
    },

    /**
     * @private
     * @param {String} property Property to animate
     * @param {String} to Value to animate to
     * @param {Object} [options] Options object
     * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
     */
    _animate: function(property, to, options, skipCallbacks) {
      var _this = this, propPair;

      to = to.toString();

      if (!options) {
        options = { };
      }
      else {
        options = fabric.util.object.clone(options);
      }

      if (~property.indexOf('.')) {
        propPair = property.split('.');
      }

      var currentValue = propPair
        ? this.get(propPair[0])[propPair[1]]
        : this.get(property);

      if (!('from' in options)) {
        options.from = currentValue;
      }

      if (~to.indexOf('=')) {
        to = currentValue + parseFloat(to.replace('=', ''));
      }
      else {
        to = parseFloat(to);
      }

      fabric.util.animate({
        startValue: options.from,
        endValue: to,
        byValue: options.by,
        easing: options.easing,
        duration: options.duration,
        abort: options.abort && function() {
          return options.abort.call(_this);
        },
        onChange: function(value, valueProgress, timeProgress) {
          if (propPair) {
            _this[propPair[0]][propPair[1]] = value;
          }
          else {
            _this.set(property, value);
          }
          if (skipCallbacks) {
            return;
          }
          options.onChange && options.onChange(value, valueProgress, timeProgress);
        },
        onComplete: function(value, valueProgress, timeProgress) {
          if (skipCallbacks) {
            return;
          }

          _this.setCoords();
          options.onComplete && options.onComplete(value, valueProgress, timeProgress);
        }
      });
    }
  });


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
        supportsLineDash = fabric.StaticCanvas.supports('setLineDash');

    if (fabric.Line) {
      fabric.warn('fabric.Line is already defined');
      return;
    }

    /**
     * Line class
     * @class fabric.Line
     * @extends fabric.Object
     * @see {@link fabric.Line#initialize} for constructor definition
     */
    fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'line',

      /**
       * x value or first line edge
       * @type Number
       * @default
       */
      x1: 0,

      /**
       * y value or first line edge
       * @type Number
       * @default
       */
      y1: 0,

      /**
       * x value or second line edge
       * @type Number
       * @default
       */
      x2: 0,

      /**
       * y value or second line edge
       * @type Number
       * @default
       */
      y2: 0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),

      /**
       * Constructor
       * @param {Array} [points] Array of points
       * @param {Object} [options] Options object
       * @return {fabric.Line} thisArg
       */
      initialize: function(points, options) {
        if (!points) {
          points = [0, 0, 0, 0];
        }

        this.callSuper('initialize', options);

        this.set('x1', points[0]);
        this.set('y1', points[1]);
        this.set('x2', points[2]);
        this.set('y2', points[3]);

        this._setWidthHeight(options);
      },

      /**
       * @private
       * @param {Object} [options] Options
       */
      _setWidthHeight: function(options) {
        options || (options = { });

        this.width = Math.abs(this.x2 - this.x1);
        this.height = Math.abs(this.y2 - this.y1);

        this.left = 'left' in options
          ? options.left
          : this._getLeftToOriginX();

        this.top = 'top' in options
          ? options.top
          : this._getTopToOriginY();
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);
        if (typeof coordProps[key] !== 'undefined') {
          this._setWidthHeight();
        }
        return this;
      },

      /**
       * @private
       * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
       */
      _getLeftToOriginX: makeEdgeToOriginGetter(
        { // property names
          origin: 'originX',
          axis1: 'x1',
          axis2: 'x2',
          dimension: 'width'
        },
        { // possible values of origin
          nearest: 'left',
          center: 'center',
          farthest: 'right'
        }
      ),

      /**
       * @private
       * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
       */
      _getTopToOriginY: makeEdgeToOriginGetter(
        { // property names
          origin: 'originY',
          axis1: 'y1',
          axis2: 'y2',
          dimension: 'height'
        },
        { // possible values of origin
          nearest: 'top',
          center: 'center',
          farthest: 'bottom'
        }
      ),

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();

        if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
          // move from center (of virtual box) to its left/top corner
          // we can't assume x1, y1 is top left and x2, y2 is bottom right
          var p = this.calcLinePoints();
          ctx.moveTo(p.x1, p.y1);
          ctx.lineTo(p.x2, p.y2);
        }

        ctx.lineWidth = this.strokeWidth;

        // TODO: test this
        // make sure setting "fill" changes color of a line
        // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
        var origStrokeStyle = ctx.strokeStyle;
        ctx.strokeStyle = this.stroke || ctx.fillStyle;
        this.stroke && this._renderStroke(ctx);
        ctx.strokeStyle = origStrokeStyle;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var p = this.calcLinePoints();

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
        ctx.closePath();
      },

      /**
       * This function is an helper for svg import. it returns the center of the object in the svg
       * untransformed coordinates
       * @private
       * @return {Object} center point from element coordinates
       */
      _findCenterFromElement: function() {
        return {
          x: (this.x1 + this.x2) / 2,
          y: (this.y1 + this.y2) / 2,
        };
      },

      /**
       * Returns object representation of an instance
       * @methd toObject
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
      },

      /*
       * Calculate object dimensions from its properties
       * @private
       */
      _getNonTransformedDimensions: function() {
        var dim = this.callSuper('_getNonTransformedDimensions');
        if (this.strokeLineCap === 'butt') {
          if (this.width === 0) {
            dim.y -= this.strokeWidth;
          }
          if (this.height === 0) {
            dim.x -= this.strokeWidth;
          }
        }
        return dim;
      },

      /**
       * Recalculates line points given width and height
       * @private
       */
      calcLinePoints: function() {
        var xMult = this.x1 <= this.x2 ? -1 : 1,
            yMult = this.y1 <= this.y2 ? -1 : 1,
            x1 = (xMult * this.width * 0.5),
            y1 = (yMult * this.height * 0.5),
            x2 = (xMult * this.width * -0.5),
            y2 = (yMult * this.height * -0.5);

        return {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        };
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        var p = this.calcLinePoints();
        return [
          '<line ', 'COMMON_PARTS',
          'x1="', p.x1,
          '" y1="', p.y1,
          '" x2="', p.x2,
          '" y2="', p.y2,
          '" />\n'
        ];
      },
      /* _TO_SVG_END_ */
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
     * @static
     * @memberOf fabric.Line
     * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
     */
    fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

    /**
     * Returns fabric.Line instance from an SVG element
     * @static
     * @memberOf fabric.Line
     * @param {SVGElement} element Element to parse
     * @param {Object} [options] Options object
     * @param {Function} [callback] callback function invoked after parsing
     */
    fabric.Line.fromElement = function(element, callback, options) {
      options = options || { };
      var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
          points = [
            parsedAttributes.x1 || 0,
            parsedAttributes.y1 || 0,
            parsedAttributes.x2 || 0,
            parsedAttributes.y2 || 0
          ];
      callback(new fabric.Line(points, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Line instance from an object representation
     * @static
     * @memberOf fabric.Line
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     */
    fabric.Line.fromObject = function(object, callback) {
      function _callback(instance) {
        delete instance.points;
        callback && callback(instance);
      }    var options = clone(object, true);
      options.points = [object.x1, object.y1, object.x2, object.y2];
      fabric.Object._fromObject('Line', options, _callback, 'points');
    };

    /**
     * Produces a function that calculates distance from canvas edge to Line origin.
     */
    function makeEdgeToOriginGetter(propertyNames, originValues) {
      var origin = propertyNames.origin,
          axis1 = propertyNames.axis1,
          axis2 = propertyNames.axis2,
          dimension = propertyNames.dimension,
          nearest = originValues.nearest,
          center = originValues.center,
          farthest = originValues.farthest;

      return function() {
        switch (this.get(origin)) {
          case nearest:
            return Math.min(this.get(axis1), this.get(axis2));
          case center:
            return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
          case farthest:
            return Math.max(this.get(axis1), this.get(axis2));
        }
      };

    }

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        pi = Math.PI;

    if (fabric.Circle) {
      fabric.warn('fabric.Circle is already defined.');
      return;
    }

    /**
     * Circle class
     * @class fabric.Circle
     * @extends fabric.Object
     * @see {@link fabric.Circle#initialize} for constructor definition
     */
    fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'circle',

      /**
       * Radius of this circle
       * @type Number
       * @default
       */
      radius: 0,

      /**
       * Start angle of the circle, moving clockwise
       * deprectated type, this should be in degree, this was an oversight.
       * probably will change to degrees in next major version
       * @type Number
       * @default 0
       */
      startAngle: 0,

      /**
       * End angle of the circle
       * deprectated type, this should be in degree, this was an oversight.
       * probably will change to degrees in next major version
       * @type Number
       * @default 2Pi
       */
      endAngle: pi * 2,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Circle} thisArg
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);

        if (key === 'radius') {
          this.setRadius(value);
        }

        return this;
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */

      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        var svgString, x = 0, y = 0,
            angle = (this.endAngle - this.startAngle) % ( 2 * pi);

        if (angle === 0) {
          svgString = [
            '<circle ', 'COMMON_PARTS',
            'cx="' + x + '" cy="' + y + '" ',
            'r="', this.radius,
            '" />\n'
          ];
        }
        else {
          var startX = fabric.util.cos(this.startAngle) * this.radius,
              startY = fabric.util.sin(this.startAngle) * this.radius,
              endX = fabric.util.cos(this.endAngle) * this.radius,
              endY = fabric.util.sin(this.endAngle) * this.radius,
              largeFlag = angle > pi ? '1' : '0';
          svgString = [
            '<path d="M ' + startX + ' ' + startY,
            ' A ' + this.radius + ' ' + this.radius,
            ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
            '" ', 'COMMON_PARTS', ' />\n'
          ];
        }
        return svgString;
      },
      /* _TO_SVG_END_ */

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();
        ctx.arc(
          0,
          0,
          this.radius,
          this.startAngle,
          this.endAngle, false);
        this._renderPaintInOrder(ctx);
      },

      /**
       * Returns horizontal radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRadiusX: function() {
        return this.get('radius') * this.get('scaleX');
      },

      /**
       * Returns vertical radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRadiusY: function() {
        return this.get('radius') * this.get('scaleY');
      },

      /**
       * Sets radius of an object (and updates width accordingly)
       * @return {fabric.Circle} thisArg
       */
      setRadius: function(value) {
        this.radius = value;
        return this.set('width', value * 2).set('height', value * 2);
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
     * @static
     * @memberOf fabric.Circle
     * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
     */
    fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

    /**
     * Returns {@link fabric.Circle} instance from an SVG element
     * @static
     * @memberOf fabric.Circle
     * @param {SVGElement} element Element to parse
     * @param {Function} [callback] Options callback invoked after parsing is finished
     * @param {Object} [options] Options object
     * @throws {Error} If value of `r` attribute is missing or invalid
     */
    fabric.Circle.fromElement = function(element, callback) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

      if (!isValidRadius(parsedAttributes)) {
        throw new Error('value of `r` attribute is required and can not be negative');
      }

      parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
      parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
      callback(new fabric.Circle(parsedAttributes));
    };

    /**
     * @private
     */
    function isValidRadius(attributes) {
      return (('radius' in attributes) && (attributes.radius >= 0));
    }
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Circle} instance from an object representation
     * @static
     * @memberOf fabric.Circle
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     * @return {Object} Instance of fabric.Circle
     */
    fabric.Circle.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Circle', object, callback);
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Triangle) {
      fabric.warn('fabric.Triangle is already defined');
      return;
    }

    /**
     * Triangle class
     * @class fabric.Triangle
     * @extends fabric.Object
     * @return {fabric.Triangle} thisArg
     * @see {@link fabric.Triangle#initialize} for constructor definition
     */
    fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'triangle',

      /**
       * Width is set to 100 to compensate the old initialize code that was setting it to 100
       * @type Number
       * @default
       */
      width: 100,

      /**
       * Height is set to 100 to compensate the old initialize code that was setting it to 100
       * @type Number
       * @default
       */
      height: 100,

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        var widthBy2 = this.width / 2,
            heightBy2 = this.height / 2;

        ctx.beginPath();
        ctx.moveTo(-widthBy2, heightBy2);
        ctx.lineTo(0, -heightBy2);
        ctx.lineTo(widthBy2, heightBy2);
        ctx.closePath();

        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var widthBy2 = this.width / 2,
            heightBy2 = this.height / 2;

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
        ctx.closePath();
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        var widthBy2 = this.width / 2,
            heightBy2 = this.height / 2,
            points = [
              -widthBy2 + ' ' + heightBy2,
              '0 ' + -heightBy2,
              widthBy2 + ' ' + heightBy2
            ].join(',');
        return [
          '<polygon ', 'COMMON_PARTS',
          'points="', points,
          '" />'
        ];
      },
      /* _TO_SVG_END_ */
    });

    /**
     * Returns {@link fabric.Triangle} instance from an object representation
     * @static
     * @memberOf fabric.Triangle
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     */
    fabric.Triangle.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Triangle', object, callback);
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        piBy2   = Math.PI * 2;

    if (fabric.Ellipse) {
      fabric.warn('fabric.Ellipse is already defined.');
      return;
    }

    /**
     * Ellipse class
     * @class fabric.Ellipse
     * @extends fabric.Object
     * @return {fabric.Ellipse} thisArg
     * @see {@link fabric.Ellipse#initialize} for constructor definition
     */
    fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'ellipse',

      /**
       * Horizontal radius
       * @type Number
       * @default
       */
      rx:   0,

      /**
       * Vertical radius
       * @type Number
       * @default
       */
      ry:   0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @return {fabric.Ellipse} thisArg
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        this.set('rx', options && options.rx || 0);
        this.set('ry', options && options.ry || 0);
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Ellipse} thisArg
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);
        switch (key) {

          case 'rx':
            this.rx = value;
            this.set('width', value * 2);
            break;

          case 'ry':
            this.ry = value;
            this.set('height', value * 2);
            break;

        }
        return this;
      },

      /**
       * Returns horizontal radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRx: function() {
        return this.get('rx') * this.get('scaleX');
      },

      /**
       * Returns Vertical radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRy: function() {
        return this.get('ry') * this.get('scaleY');
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        return [
          '<ellipse ', 'COMMON_PARTS',
          'cx="0" cy="0" ',
          'rx="', this.rx,
          '" ry="', this.ry,
          '" />\n'
        ];
      },
      /* _TO_SVG_END_ */

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();
        ctx.save();
        ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
        ctx.arc(
          0,
          0,
          this.rx,
          0,
          piBy2,
          false);
        ctx.restore();
        this._renderPaintInOrder(ctx);
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
     * @static
     * @memberOf fabric.Ellipse
     * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
     */
    fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

    /**
     * Returns {@link fabric.Ellipse} instance from an SVG element
     * @static
     * @memberOf fabric.Ellipse
     * @param {SVGElement} element Element to parse
     * @param {Function} [callback] Options callback invoked after parsing is finished
     * @return {fabric.Ellipse}
     */
    fabric.Ellipse.fromElement = function(element, callback) {

      var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

      parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
      parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
      callback(new fabric.Ellipse(parsedAttributes));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Ellipse} instance from an object representation
     * @static
     * @memberOf fabric.Ellipse
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     * @return {fabric.Ellipse}
     */
    fabric.Ellipse.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Ellipse', object, callback);
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend;

    if (fabric.Rect) {
      fabric.warn('fabric.Rect is already defined');
      return;
    }

    /**
     * Rectangle class
     * @class fabric.Rect
     * @extends fabric.Object
     * @return {fabric.Rect} thisArg
     * @see {@link fabric.Rect#initialize} for constructor definition
     */
    fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

      /**
       * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'rect',

      /**
       * Horizontal border radius
       * @type Number
       * @default
       */
      rx:   0,

      /**
       * Vertical border radius
       * @type Number
       * @default
       */
      ry:   0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        this._initRxRy();
      },

      /**
       * Initializes rx/ry attributes
       * @private
       */
      _initRxRy: function() {
        if (this.rx && !this.ry) {
          this.ry = this.rx;
        }
        else if (this.ry && !this.rx) {
          this.rx = this.ry;
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {

        // 1x1 case (used in spray brush) optimization was removed because
        // with caching and higher zoom level this makes more damage than help

        var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
            ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
            w = this.width,
            h = this.height,
            x = -this.width / 2,
            y = -this.height / 2,
            isRounded = rx !== 0 || ry !== 0,
            /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
            k = 1 - 0.5522847498;
        ctx.beginPath();

        ctx.moveTo(x + rx, y);

        ctx.lineTo(x + w - rx, y);
        isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

        ctx.lineTo(x + w, y + h - ry);
        isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

        ctx.lineTo(x + rx, y + h);
        isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

        ctx.lineTo(x, y + ry);
        isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

        ctx.closePath();

        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var x = -this.width / 2,
            y = -this.height / 2,
            w = this.width,
            h = this.height;

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
        ctx.closePath();
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        var x = -this.width / 2, y = -this.height / 2;
        return [
          '<rect ', 'COMMON_PARTS',
          'x="', x, '" y="', y,
          '" rx="', this.rx, '" ry="', this.ry,
          '" width="', this.width, '" height="', this.height,
          '" />\n'
        ];
      },
      /* _TO_SVG_END_ */
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
     * @static
     * @memberOf fabric.Rect
     * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
     */
    fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

    /**
     * Returns {@link fabric.Rect} instance from an SVG element
     * @static
     * @memberOf fabric.Rect
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Rect.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options = options || { };

      var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);

      parsedAttributes.left = parsedAttributes.left || 0;
      parsedAttributes.top  = parsedAttributes.top  || 0;
      parsedAttributes.height  = parsedAttributes.height || 0;
      parsedAttributes.width  = parsedAttributes.width || 0;
      var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
      rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
      callback(rect);
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Rect} instance from an object representation
     * @static
     * @memberOf fabric.Rect
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
     */
    fabric.Rect.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Rect', object, callback);
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        min = fabric.util.array.min,
        max = fabric.util.array.max,
        toFixed = fabric.util.toFixed;

    if (fabric.Polyline) {
      fabric.warn('fabric.Polyline is already defined');
      return;
    }

    /**
     * Polyline class
     * @class fabric.Polyline
     * @extends fabric.Object
     * @see {@link fabric.Polyline#initialize} for constructor definition
     */
    fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'polyline',

      /**
       * Points array
       * @type Array
       * @default
       */
      points: null,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),

      /**
       * Constructor
       * @param {Array} points Array of points (where each point is an object with x and y)
       * @param {Object} [options] Options object
       * @return {fabric.Polyline} thisArg
       * @example
       * var poly = new fabric.Polyline([
       *     { x: 10, y: 10 },
       *     { x: 50, y: 30 },
       *     { x: 40, y: 70 },
       *     { x: 60, y: 50 },
       *     { x: 100, y: 150 },
       *     { x: 40, y: 100 }
       *   ], {
       *   stroke: 'red',
       *   left: 100,
       *   top: 100
       * });
       */
      initialize: function(points, options) {
        options = options || {};
        this.points = points || [];
        this.callSuper('initialize', options);
        this._setPositionDimensions(options);
      },

      _setPositionDimensions: function(options) {
        var calcDim = this._calcDimensions(options), correctLeftTop;
        this.width = calcDim.width;
        this.height = calcDim.height;
        if (!options.fromSVG) {
          correctLeftTop = this.translateToGivenOrigin(
            { x: calcDim.left - this.strokeWidth / 2, y: calcDim.top - this.strokeWidth / 2 },
            'left',
            'top',
            this.originX,
            this.originY
          );
        }
        if (typeof options.left === 'undefined') {
          this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
        }
        if (typeof options.top === 'undefined') {
          this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
        }
        this.pathOffset = {
          x: calcDim.left + this.width / 2,
          y: calcDim.top + this.height / 2
        };
      },

      /**
       * Calculate the polygon min and max point from points array,
       * returning an object with left, top, widht, height to measure the
       * polygon size
       * @return {Object} object.left X coordinate of the polygon leftmost point
       * @return {Object} object.top Y coordinate of the polygon topmost point
       * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
       * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
       * @private
       */
      _calcDimensions: function() {

        var points = this.points,
            minX = min(points, 'x') || 0,
            minY = min(points, 'y') || 0,
            maxX = max(points, 'x') || 0,
            maxY = max(points, 'y') || 0,
            width = (maxX - minX),
            height = (maxY - minY);

        return {
          left: minX,
          top: minY,
          width: width,
          height: height
        };
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return extend(this.callSuper('toObject', propertiesToInclude), {
          points: this.points.concat()
        });
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

        for (var i = 0, len = this.points.length; i < len; i++) {
          points.push(
            toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
            toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
          );
        }
        return [
          '<' + this.type + ' ', 'COMMON_PARTS',
          'points="', points.join(''),
          '" />\n'
        ];
      },
      /* _TO_SVG_END_ */


      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      commonRender: function(ctx) {
        var point, len = this.points.length,
            x = this.pathOffset.x,
            y = this.pathOffset.y;

        if (!len || isNaN(this.points[len - 1].y)) {
          // do not draw if no points or odd points
          // NaN comes from parseFloat of a empty string in parser
          return false;
        }
        ctx.beginPath();
        ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
        for (var i = 0; i < len; i++) {
          point = this.points[i];
          ctx.lineTo(point.x - x, point.y - y);
        }
        return true;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (!this.commonRender(ctx)) {
          return;
        }
        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var p1, p2;

        ctx.beginPath();
        for (var i = 0, len = this.points.length; i < len; i++) {
          p1 = this.points[i];
          p2 = this.points[i + 1] || p1;
          fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
        }
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity of this instance
       */
      complexity: function() {
        return this.get('points').length;
      }
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
     * @static
     * @memberOf fabric.Polyline
     * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
     */
    fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

    /**
     * Returns fabric.Polyline instance from an SVG element
     * @static
     * @memberOf fabric.Polyline
     * @param {SVGElement} element Element to parser
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Polyline.fromElementGenerator = function(_class) {
      return function(element, callback, options) {
        if (!element) {
          return callback(null);
        }
        options || (options = { });

        var points = fabric.parsePointsAttribute(element.getAttribute('points')),
            parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);
        parsedAttributes.fromSVG = true;
        callback(new fabric[_class](points, extend(parsedAttributes, options)));
      };
    };

    fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator('Polyline');

    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Polyline instance from an object representation
     * @static
     * @memberOf fabric.Polyline
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Polyline.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Polyline', object, callback, 'points');
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Polygon) {
      fabric.warn('fabric.Polygon is already defined');
      return;
    }

    /**
     * Polygon class
     * @class fabric.Polygon
     * @extends fabric.Polyline
     * @see {@link fabric.Polygon#initialize} for constructor definition
     */
    fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'polygon',

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (!this.commonRender(ctx)) {
          return;
        }
        ctx.closePath();
        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        this.callSuper('_renderDashedStroke', ctx);
        ctx.closePath();
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
     * @static
     * @memberOf fabric.Polygon
     * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
     */
    fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

    /**
     * Returns {@link fabric.Polygon} instance from an SVG element
     * @static
     * @memberOf fabric.Polygon
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator('Polygon');
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Polygon instance from an object representation
     * @static
     * @memberOf fabric.Polygon
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Polygon.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Polygon', object, callback, 'points');
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        min = fabric.util.array.min,
        max = fabric.util.array.max,
        extend = fabric.util.object.extend,
        _toString = Object.prototype.toString,
        drawArc = fabric.util.drawArc,
        toFixed = fabric.util.toFixed,
        commandLengths = {
          m: 2,
          l: 2,
          h: 1,
          v: 1,
          c: 6,
          s: 4,
          q: 4,
          t: 2,
          a: 7
        },
        repeatedCommands = {
          m: 'l',
          M: 'L'
        };

    if (fabric.Path) {
      fabric.warn('fabric.Path is already defined');
      return;
    }

    /**
     * Path class
     * @class fabric.Path
     * @extends fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
     * @see {@link fabric.Path#initialize} for constructor definition
     */
    fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'path',

      /**
       * Array of path points
       * @type Array
       * @default
       */
      path: null,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),

      stateProperties: fabric.Object.prototype.stateProperties.concat('path'),

      /**
       * Constructor
       * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
       * @param {Object} [options] Options object
       * @return {fabric.Path} thisArg
       */
      initialize: function(path, options) {
        options = options || { };
        this.callSuper('initialize', options);

        if (!path) {
          path = [];
        }

        var fromArray = _toString.call(path) === '[object Array]';

        this.path = fromArray
          ? path
          // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
          : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

        if (!this.path) {
          return;
        }

        if (!fromArray) {
          this.path = this._parsePath();
        }

        fabric.Polyline.prototype._setPositionDimensions.call(this, options);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render path on
       */
      _renderPathCommands: function(ctx) {
        var current, // current instruction
            previous = null,
            subpathStartX = 0,
            subpathStartY = 0,
            x = 0, // current x
            y = 0, // current y
            controlX = 0, // current control point x
            controlY = 0, // current control point y
            tempX,
            tempY,
            l = -this.pathOffset.x,
            t = -this.pathOffset.y;

        ctx.beginPath();

        for (var i = 0, len = this.path.length; i < len; ++i) {

          current = this.path[i];

          switch (current[0]) { // first letter

            case 'l': // lineto, relative
              x += current[1];
              y += current[2];
              ctx.lineTo(x + l, y + t);
              break;

            case 'L': // lineto, absolute
              x = current[1];
              y = current[2];
              ctx.lineTo(x + l, y + t);
              break;

            case 'h': // horizontal lineto, relative
              x += current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'H': // horizontal lineto, absolute
              x = current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'v': // vertical lineto, relative
              y += current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'V': // verical lineto, absolute
              y = current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'm': // moveTo, relative
              x += current[1];
              y += current[2];
              subpathStartX = x;
              subpathStartY = y;
              ctx.moveTo(x + l, y + t);
              break;

            case 'M': // moveTo, absolute
              x = current[1];
              y = current[2];
              subpathStartX = x;
              subpathStartY = y;
              ctx.moveTo(x + l, y + t);
              break;

            case 'c': // bezierCurveTo, relative
              tempX = x + current[5];
              tempY = y + current[6];
              controlX = x + current[3];
              controlY = y + current[4];
              ctx.bezierCurveTo(
                x + current[1] + l, // x1
                y + current[2] + t, // y1
                controlX + l, // x2
                controlY + t, // y2
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'C': // bezierCurveTo, absolute
              x = current[5];
              y = current[6];
              controlX = current[3];
              controlY = current[4];
              ctx.bezierCurveTo(
                current[1] + l,
                current[2] + t,
                controlX + l,
                controlY + t,
                x + l,
                y + t
              );
              break;

            case 's': // shorthand cubic bezierCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              ctx.bezierCurveTo(
                controlX + l,
                controlY + t,
                x + current[1] + l,
                y + current[2] + t,
                tempX + l,
                tempY + t
              );
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = x + current[1];
              controlY = y + current[2];

              x = tempX;
              y = tempY;
              break;

            case 'S': // shorthand cubic bezierCurveTo, absolute
              tempX = current[3];
              tempY = current[4];
              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              ctx.bezierCurveTo(
                controlX + l,
                controlY + t,
                current[1] + l,
                current[2] + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;

              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = current[1];
              controlY = current[2];

              break;

            case 'q': // quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              controlX = x + current[1];
              controlY = y + current[2];

              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'Q': // quadraticCurveTo, absolute
              tempX = current[3];
              tempY = current[4];

              ctx.quadraticCurveTo(
                current[1] + l,
                current[2] + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              controlX = current[1];
              controlY = current[2];
              break;

            case 't': // shorthand quadraticCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[1];
              tempY = y + current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;

              break;

            case 'T':
              tempX = current[1];
              tempY = current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'a':
              // TODO: optimize this
              drawArc(ctx, x + l, y + t, [
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + x + l,
                current[7] + y + t
              ]);
              x += current[6];
              y += current[7];
              break;

            case 'A':
              // TODO: optimize this
              drawArc(ctx, x + l, y + t, [
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + l,
                current[7] + t
              ]);
              x = current[6];
              y = current[7];
              break;

            case 'z':
            case 'Z':
              x = subpathStartX;
              y = subpathStartY;
              ctx.closePath();
              break;
          }
          previous = current;
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render path on
       */
      _render: function(ctx) {
        this._renderPathCommands(ctx);
        this._renderPaintInOrder(ctx);
      },

      /**
       * Returns string representation of an instance
       * @return {String} string representation of an instance
       */
      toString: function() {
        return '#<fabric.Path (' + this.complexity() +
          '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return extend(this.callSuper('toObject', propertiesToInclude), {
          path: this.path.map(function(item) { return item.slice(); }),
        });
      },

      /**
       * Returns dataless object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
        if (o.sourcePath) {
          delete o.path;
        }
        return o;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        var path = this.path.map(function(path) {
          return path.join(' ');
        }).join(' ');
        return [
          '<path ', 'COMMON_PARTS',
          'd="', path,
          '" stroke-linecap="round" ',
          '/>\n'
        ];
      },

      _getOffsetTransform: function() {
        var digits = fabric.Object.NUM_FRACTION_DIGITS;
        return ' translate(' + toFixed(-this.pathOffset.x, digits) + ', ' +
            toFixed(-this.pathOffset.y, digits) + ')';
      },

      /**
       * Returns svg clipPath representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toClipPathSVG: function(reviver) {
        var additionalTransform = this._getOffsetTransform();
        return '\t' + this._createBaseClipPathSVGMarkup(
          this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform }
        );
      },

      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var additionalTransform = this._getOffsetTransform();
        return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform  });
      },
      /* _TO_SVG_END_ */

      /**
       * Returns number representation of an instance complexity
       * @return {Number} complexity of this instance
       */
      complexity: function() {
        return this.path.length;
      },

      /**
       * @private
       */
      _parsePath: function() {
        var result = [],
            coords = [],
            currentPath,
            parsed,
            re = fabric.rePathCommand,
            match,
            coordsStr;

        for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
          currentPath = this.path[i];

          coordsStr = currentPath.slice(1).trim();
          coords.length = 0;

          while ((match = re.exec(coordsStr))) {
            coords.push(match[0]);
          }

          coordsParsed = [currentPath.charAt(0)];

          for (var j = 0, jlen = coords.length; j < jlen; j++) {
            parsed = parseFloat(coords[j]);
            if (!isNaN(parsed)) {
              coordsParsed.push(parsed);
            }
          }

          var command = coordsParsed[0],
              commandLength = commandLengths[command.toLowerCase()],
              repeatedCommand = repeatedCommands[command] || command;

          if (coordsParsed.length - 1 > commandLength) {
            for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
              result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
              command = repeatedCommand;
            }
          }
          else {
            result.push(coordsParsed);
          }
        }

        return result;
      },

      /**
       * @private
       */
      _calcDimensions: function() {

        var aX = [],
            aY = [],
            current, // current instruction
            previous = null,
            subpathStartX = 0,
            subpathStartY = 0,
            x = 0, // current x
            y = 0, // current y
            controlX = 0, // current control point x
            controlY = 0, // current control point y
            tempX,
            tempY,
            bounds;

        for (var i = 0, len = this.path.length; i < len; ++i) {

          current = this.path[i];

          switch (current[0]) { // first letter

            case 'l': // lineto, relative
              x += current[1];
              y += current[2];
              bounds = [];
              break;

            case 'L': // lineto, absolute
              x = current[1];
              y = current[2];
              bounds = [];
              break;

            case 'h': // horizontal lineto, relative
              x += current[1];
              bounds = [];
              break;

            case 'H': // horizontal lineto, absolute
              x = current[1];
              bounds = [];
              break;

            case 'v': // vertical lineto, relative
              y += current[1];
              bounds = [];
              break;

            case 'V': // verical lineto, absolute
              y = current[1];
              bounds = [];
              break;

            case 'm': // moveTo, relative
              x += current[1];
              y += current[2];
              subpathStartX = x;
              subpathStartY = y;
              bounds = [];
              break;

            case 'M': // moveTo, absolute
              x = current[1];
              y = current[2];
              subpathStartX = x;
              subpathStartY = y;
              bounds = [];
              break;

            case 'c': // bezierCurveTo, relative
              tempX = x + current[5];
              tempY = y + current[6];
              controlX = x + current[3];
              controlY = y + current[4];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                x + current[1], // x1
                y + current[2], // y1
                controlX, // x2
                controlY, // y2
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'C': // bezierCurveTo, absolute
              controlX = current[3];
              controlY = current[4];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                current[1],
                current[2],
                controlX,
                controlY,
                current[5],
                current[6]
              );
              x = current[5];
              y = current[6];
              break;

            case 's': // shorthand cubic bezierCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                x + current[1],
                y + current[2],
                tempX,
                tempY
              );
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = x + current[1];
              controlY = y + current[2];
              x = tempX;
              y = tempY;
              break;

            case 'S': // shorthand cubic bezierCurveTo, absolute
              tempX = current[3];
              tempY = current[4];
              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                current[1],
                current[2],
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = current[1];
              controlY = current[2];
              break;

            case 'q': // quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];
              controlX = x + current[1];
              controlY = y + current[2];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'Q': // quadraticCurveTo, absolute
              controlX = current[1];
              controlY = current[2];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                current[3],
                current[4]
              );
              x = current[3];
              y = current[4];
              break;

            case 't': // shorthand quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[1];
              tempY = y + current[2];
              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;

              break;

            case 'T':
              tempX = current[1];
              tempY = current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'a':
              // TODO: optimize this
              bounds = fabric.util.getBoundsOfArc(x, y,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + x,
                current[7] + y
              );
              x += current[6];
              y += current[7];
              break;

            case 'A':
              // TODO: optimize this
              bounds = fabric.util.getBoundsOfArc(x, y,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6],
                current[7]
              );
              x = current[6];
              y = current[7];
              break;

            case 'z':
            case 'Z':
              x = subpathStartX;
              y = subpathStartY;
              break;
          }
          previous = current;
          bounds.forEach(function (point) {
            aX.push(point.x);
            aY.push(point.y);
          });
          aX.push(x);
          aY.push(y);
        }

        var minX = min(aX) || 0,
            minY = min(aY) || 0,
            maxX = max(aX) || 0,
            maxY = max(aY) || 0,
            deltaX = maxX - minX,
            deltaY = maxY - minY;

        return {
          left: minX,
          top: minY,
          width: deltaX,
          height: deltaY
        };
      }
    });

    /**
     * Creates an instance of fabric.Path from an object
     * @static
     * @memberOf fabric.Path
     * @param {Object} object
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Path.fromObject = function(object, callback) {
      if (typeof object.sourcePath === 'string') {
        var pathUrl = object.sourcePath;
        fabric.loadSVGFromURL(pathUrl, function (elements) {
          var path = elements[0];
          path.setOptions(object);
          callback && callback(path);
        });
      }
      else {
        fabric.Object._fromObject('Path', object, callback, 'path');
      }
    };

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
     * @static
     * @memberOf fabric.Path
     * @see http://www.w3.org/TR/SVG/paths.html#PathElement
     */
    fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

    /**
     * Creates an instance of fabric.Path from an SVG <path> element
     * @static
     * @memberOf fabric.Path
     * @param {SVGElement} element to parse
     * @param {Function} callback Callback to invoke when an fabric.Path instance is created
     * @param {Object} [options] Options object
     * @param {Function} [callback] Options callback invoked after parsing is finished
     */
    fabric.Path.fromElement = function(element, callback, options) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
      parsedAttributes.fromSVG = true;
      callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        min = fabric.util.array.min,
        max = fabric.util.array.max;

    if (fabric.Group) {
      return;
    }

    /**
     * Group class
     * @class fabric.Group
     * @extends fabric.Object
     * @mixes fabric.Collection
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
     * @see {@link fabric.Group#initialize} for constructor definition
     */
    fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'group',

      /**
       * Width of stroke
       * @type Number
       * @default
       */
      strokeWidth: 0,

      /**
       * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
       * @type Boolean
       * @default
       */
      subTargetCheck: false,

      /**
       * Groups are container, do not render anything on theyr own, ence no cache properties
       * @type Array
       * @default
       */
      cacheProperties: [],

      /**
       * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
       * available setting this boolean to true.
       * @type Boolean
       * @since 2.0.0
       * @default
       */
      useSetOnGroup: false,

      /**
       * Constructor
       * @param {Object} objects Group objects
       * @param {Object} [options] Options object
       * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
       * @return {Object} thisArg
       */
      initialize: function(objects, options, isAlreadyGrouped) {
        options = options || {};
        this._objects = [];
        // if objects enclosed in a group have been grouped already,
        // we cannot change properties of objects.
        // Thus we need to set options to group without objects,
        isAlreadyGrouped && this.callSuper('initialize', options);
        this._objects = objects || [];
        for (var i = this._objects.length; i--; ) {
          this._objects[i].group = this;
        }

        if (!isAlreadyGrouped) {
          var center = options && options.centerPoint;
          // we want to set origins before calculating the bounding box.
          // so that the topleft can be set with that in mind.
          // if specific top and left are passed, are overwritten later
          // with the callSuper('initialize', options)
          if (options.originX !== undefined) {
            this.originX = options.originX;
          }
          if (options.originY !== undefined) {
            this.originY = options.originY;
          }
          // if coming from svg i do not want to calc bounds.
          // i assume width and height are passed along options
          center || this._calcBounds();
          this._updateObjectsCoords(center);
          delete options.centerPoint;
          this.callSuper('initialize', options);
        }
        else {
          this._updateObjectsACoords();
        }

        this.setCoords();
      },

      /**
       * @private
       * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
       */
      _updateObjectsACoords: function() {
        var ignoreZoom = true, skipAbsolute = true;
        for (var i = this._objects.length; i--; ){
          this._objects[i].setCoords(ignoreZoom, skipAbsolute);
        }
      },

      /**
       * @private
       * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
       */
      _updateObjectsCoords: function(center) {
        var center = center || this.getCenterPoint();
        for (var i = this._objects.length; i--; ){
          this._updateObjectCoords(this._objects[i], center);
        }
      },

      /**
       * @private
       * @param {Object} object
       * @param {fabric.Point} center, current center of group.
       */
      _updateObjectCoords: function(object, center) {
        var objectLeft = object.left,
            objectTop = object.top,
            ignoreZoom = true, skipAbsolute = true;

        object.set({
          left: objectLeft - center.x,
          top: objectTop - center.y
        });
        object.group = this;
        object.setCoords(ignoreZoom, skipAbsolute);
      },

      /**
       * Returns string represenation of a group
       * @return {String}
       */
      toString: function() {
        return '#<fabric.Group: (' + this.complexity() + ')>';
      },

      /**
       * Adds an object to a group; Then recalculates group's dimension, position.
       * @param {Object} object
       * @return {fabric.Group} thisArg
       * @chainable
       */
      addWithUpdate: function(object) {
        this._restoreObjectsState();
        fabric.util.resetObjectTransform(this);
        if (object) {
          this._objects.push(object);
          object.group = this;
          object._set('canvas', this.canvas);
        }
        this._calcBounds();
        this._updateObjectsCoords();
        this.setCoords();
        this.dirty = true;
        return this;
      },

      /**
       * Removes an object from a group; Then recalculates group's dimension, position.
       * @param {Object} object
       * @return {fabric.Group} thisArg
       * @chainable
       */
      removeWithUpdate: function(object) {
        this._restoreObjectsState();
        fabric.util.resetObjectTransform(this);

        this.remove(object);
        this._calcBounds();
        this._updateObjectsCoords();
        this.setCoords();
        this.dirty = true;
        return this;
      },

      /**
       * @private
       */
      _onObjectAdded: function(object) {
        this.dirty = true;
        object.group = this;
        object._set('canvas', this.canvas);
      },

      /**
       * @private
       */
      _onObjectRemoved: function(object) {
        this.dirty = true;
        delete object.group;
      },

      /**
       * @private
       */
      _set: function(key, value) {
        var i = this._objects.length;
        if (this.useSetOnGroup) {
          while (i--) {
            this._objects[i].setOnGroup(key, value);
          }
        }
        if (key === 'canvas') {
          while (i--) {
            this._objects[i]._set(key, value);
          }
        }
        fabric.Object.prototype._set.call(this, key, value);
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var _includeDefaultValues = this.includeDefaultValues;
        var objsToObject = this._objects.map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = _includeDefaultValues;
          var _obj = obj.toObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
        var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);
        obj.objects = objsToObject;
        return obj;
      },

      /**
       * Returns object representation of an instance, in dataless mode.
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        var objsToObject, sourcePath = this.sourcePath;
        if (sourcePath) {
          objsToObject = sourcePath;
        }
        else {
          var _includeDefaultValues = this.includeDefaultValues;
          objsToObject = this._objects.map(function(obj) {
            var originalDefaults = obj.includeDefaultValues;
            obj.includeDefaultValues = _includeDefaultValues;
            var _obj = obj.toDatalessObject(propertiesToInclude);
            obj.includeDefaultValues = originalDefaults;
            return _obj;
          });
        }
        var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
        obj.objects = objsToObject;
        return obj;
      },

      /**
       * Renders instance on a given context
       * @param {CanvasRenderingContext2D} ctx context to render instance on
       */
      render: function(ctx) {
        this._transformDone = true;
        this.callSuper('render', ctx);
        this._transformDone = false;
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group is already cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        var ownCache = fabric.Object.prototype.shouldCache.call(this);
        if (ownCache) {
          for (var i = 0, len = this._objects.length; i < len; i++) {
            if (this._objects[i].willDrawShadow()) {
              this.ownCaching = false;
              return false;
            }
          }
        }
        return ownCache;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * @return {Boolean}
       */
      willDrawShadow: function() {
        if (fabric.Object.prototype.willDrawShadow.call(this)) {
          return true;
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            return true;
          }
        }
        return false;
      },

      /**
       * Check if this group or its parent group are caching, recursively up
       * @return {Boolean}
       */
      isOnACache: function() {
        return this.ownCaching || (this.group && this.group.isOnACache());
      },

      /**
       * Execute the drawing operation for an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawObject: function(ctx) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          this._objects[i].render(ctx);
        }
        this._drawClipPath(ctx);
      },

      /**
       * Check if cache is dirty
       */
      isCacheDirty: function(skipCanvas) {
        if (this.callSuper('isCacheDirty', skipCanvas)) {
          return true;
        }
        if (!this.statefullCache) {
          return false;
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].isCacheDirty(true)) {
            if (this._cacheCanvas) {
              // if this group has not a cache canvas there is nothing to clean
              var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
              this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
            }
            return true;
          }
        }
        return false;
      },

      /**
       * Retores original state of each of group objects (original state is that which was before group was created).
       * @private
       * @return {fabric.Group} thisArg
       * @chainable
       */
      _restoreObjectsState: function() {
        this._objects.forEach(this._restoreObjectState, this);
        return this;
      },

      /**
       * Realises the transform from this group onto the supplied object
       * i.e. it tells you what would happen if the supplied object was in
       * the group, and then the group was destroyed. It mutates the supplied
       * object.
       * @param {fabric.Object} object
       * @return {fabric.Object} transformedObject
       */
      realizeTransform: function(object) {
        var matrix = object.calcTransformMatrix(),
            options = fabric.util.qrDecompose(matrix),
            center = new fabric.Point(options.translateX, options.translateY);
        object.flipX = false;
        object.flipY = false;
        object.set('scaleX', options.scaleX);
        object.set('scaleY', options.scaleY);
        object.skewX = options.skewX;
        object.skewY = options.skewY;
        object.angle = options.angle;
        object.setPositionByOrigin(center, 'center', 'center');
        return object;
      },

      /**
       * Restores original state of a specified object in group
       * @private
       * @param {fabric.Object} object
       * @return {fabric.Group} thisArg
       */
      _restoreObjectState: function(object) {
        this.realizeTransform(object);
        object.setCoords();
        delete object.group;
        return this;
      },

      /**
       * Destroys a group (restoring state of its objects)
       * @return {fabric.Group} thisArg
       * @chainable
       */
      destroy: function() {
        // when group is destroyed objects needs to get a repaint to be eventually
        // displayed on canvas.
        this._objects.forEach(function(object) {
          object.set('dirty', true);
        });
        return this._restoreObjectsState();
      },

      /**
       * make a group an active selection, remove the group from canvas
       * the group has to be on canvas for this to work.
       * @return {fabric.ActiveSelection} thisArg
       * @chainable
       */
      toActiveSelection: function() {
        if (!this.canvas) {
          return;
        }
        var objects = this._objects, canvas = this.canvas;
        this._objects = [];
        var options = this.toObject();
        delete options.objects;
        var activeSelection = new fabric.ActiveSelection([]);
        activeSelection.set(options);
        activeSelection.type = 'activeSelection';
        canvas.remove(this);
        objects.forEach(function(object) {
          object.group = activeSelection;
          object.dirty = true;
          canvas.add(object);
        });
        activeSelection.canvas = canvas;
        activeSelection._objects = objects;
        canvas._activeObject = activeSelection;
        activeSelection.setCoords();
        return activeSelection;
      },

      /**
       * Destroys a group (restoring state of its objects)
       * @return {fabric.Group} thisArg
       * @chainable
       */
      ungroupOnCanvas: function() {
        return this._restoreObjectsState();
      },

      /**
       * Sets coordinates of all objects inside group
       * @return {fabric.Group} thisArg
       * @chainable
       */
      setObjectsCoords: function() {
        var ignoreZoom = true, skipAbsolute = true;
        this.forEachObject(function(object) {
          object.setCoords(ignoreZoom, skipAbsolute);
        });
        return this;
      },

      /**
       * @private
       */
      _calcBounds: function(onlyWidthHeight) {
        var aX = [],
            aY = [],
            o, prop,
            props = ['tr', 'br', 'bl', 'tl'],
            i = 0, iLen = this._objects.length,
            j, jLen = props.length,
            ignoreZoom = true;

        for ( ; i < iLen; ++i) {
          o = this._objects[i];
          o.setCoords(ignoreZoom);
          for (j = 0; j < jLen; j++) {
            prop = props[j];
            aX.push(o.oCoords[prop].x);
            aY.push(o.oCoords[prop].y);
          }
        }

        this._getBounds(aX, aY, onlyWidthHeight);
      },

      /**
       * @private
       */
      _getBounds: function(aX, aY, onlyWidthHeight) {
        var minXY = new fabric.Point(min(aX), min(aY)),
            maxXY = new fabric.Point(max(aX), max(aY)),
            top = minXY.y || 0, left = minXY.x || 0,
            width = (maxXY.x - minXY.x) || 0,
            height = (maxXY.y - minXY.y) || 0;
        this.width = width;
        this.height = height;
        if (!onlyWidthHeight) {
          // the bounding box always finds the topleft most corner.
          // whatever is the group origin, we set up here the left/top position.
          this.setPositionByOrigin({ x: left, y: top }, 'left', 'top');
        }
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      _toSVG: function(reviver) {
        var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];

        for (var i = 0, len = this._objects.length; i < len; i++) {
          svgString.push('\t\t', this._objects[i].toSVG(reviver));
        }
        svgString.push('</g>\n');
        return svgString;
      },

      /**
       * Returns styles-string for svg-export, specific version for group
       * @return {String}
       */
      getSvgStyles: function() {
        var opacity = typeof this.opacity !== 'undefined' && this.opacity !== 1 ?
              'opacity: ' + this.opacity + ';' : '',
            visibility = this.visible ? '' : ' visibility: hidden;';
        return [
          opacity,
          this.getSvgFilter(),
          visibility
        ].join('');
      },

      /**
       * Returns svg clipPath representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toClipPathSVG: function(reviver) {
        var svgString = [];

        for (var i = 0, len = this._objects.length; i < len; i++) {
          svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
        }

        return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
      },
      /* _TO_SVG_END_ */
    });

    /**
     * Returns {@link fabric.Group} instance from an object representation
     * @static
     * @memberOf fabric.Group
     * @param {Object} object Object to create a group from
     * @param {Function} [callback] Callback to invoke when an group instance is created
     */
    fabric.Group.fromObject = function(object, callback) {
      var objects = object.objects,
          options = fabric.util.object.clone(object, true);
      delete options.objects;
      if (typeof objects === 'string') {
        // it has to be an url or something went wrong.
        fabric.loadSVGFromURL(objects, function (elements) {
          var group = fabric.util.groupSVGElements(elements, object, objects);
          group.set(options);
          callback && callback(group);
        });
        return;
      }
      fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
        fabric.util.enlivenObjects([object.clipPath], function(enlivedClipPath) {
          var options = fabric.util.object.clone(object, true);
          options.clipPath = enlivedClipPath[0];
          delete options.objects;
          callback && callback(new fabric.Group(enlivenedObjects, options, true));
        });
      });
    };

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.ActiveSelection) {
      return;
    }

    /**
     * Group class
     * @class fabric.ActiveSelection
     * @extends fabric.Group
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
     * @see {@link fabric.ActiveSelection#initialize} for constructor definition
     */
    fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'activeSelection',

      /**
       * Constructor
       * @param {Object} objects ActiveSelection objects
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(objects, options) {
        options = options || {};
        this._objects = objects || [];
        for (var i = this._objects.length; i--; ) {
          this._objects[i].group = this;
        }

        if (options.originX) {
          this.originX = options.originX;
        }
        if (options.originY) {
          this.originY = options.originY;
        }
        this._calcBounds();
        this._updateObjectsCoords();
        fabric.Object.prototype.initialize.call(this, options);
        this.setCoords();
      },

      /**
       * Change te activeSelection to a normal group,
       * High level function that automatically adds it to canvas as
       * active object. no events fired.
       * @since 2.0.0
       * @return {fabric.Group}
       */
      toGroup: function() {
        var objects = this._objects.concat();
        this._objects = [];
        var options = fabric.Object.prototype.toObject.call(this);
        var newGroup = new fabric.Group([]);
        delete options.type;
        newGroup.set(options);
        objects.forEach(function(object) {
          object.canvas.remove(object);
          object.group = newGroup;
        });
        newGroup._objects = objects;
        if (!this.canvas) {
          return newGroup;
        }
        var canvas = this.canvas;
        canvas.add(newGroup);
        canvas._activeObject = newGroup;
        newGroup.setCoords();
        return newGroup;
      },

      /**
       * If returns true, deselection is cancelled.
       * @since 2.0.0
       * @return {Boolean} [cancel]
       */
      onDeselect: function() {
        this.destroy();
        return false;
      },

      /**
       * Returns string representation of a group
       * @return {String}
       */
      toString: function() {
        return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        return false;
      },

      /**
       * Check if this group or its parent group are caching, recursively up
       * @return {Boolean}
       */
      isOnACache: function() {
        return false;
      },

      /**
       * Renders controls and borders for the object
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [styleOverride] properties to override the object style
       * @param {Object} [childrenOverride] properties to override the children overrides
       */
      _renderControls: function(ctx, styleOverride, childrenOverride) {
        ctx.save();
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
        this.callSuper('_renderControls', ctx, styleOverride);
        childrenOverride = childrenOverride || { };
        if (typeof childrenOverride.hasControls === 'undefined') {
          childrenOverride.hasControls = false;
        }
        if (typeof childrenOverride.hasRotatingPoint === 'undefined') {
          childrenOverride.hasRotatingPoint = false;
        }
        childrenOverride.forActiveSelection = true;
        for (var i = 0, len = this._objects.length; i < len; i++) {
          this._objects[i]._renderControls(ctx, childrenOverride);
        }
        ctx.restore();
      },
    });

    /**
     * Returns {@link fabric.ActiveSelection} instance from an object representation
     * @static
     * @memberOf fabric.ActiveSelection
     * @param {Object} object Object to create a group from
     * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
     */
    fabric.ActiveSelection.fromObject = function(object, callback) {
      fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
        delete object.objects;
        callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
      });
    };

  })( exports );


  (function(global) {

    var extend = fabric.util.object.extend;

    if (!global.fabric) {
      global.fabric = { };
    }

    if (global.fabric.Image) {
      fabric.warn('fabric.Image is already defined.');
      return;
    }

    /**
     * Image class
     * @class fabric.Image
     * @extends fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
     * @see {@link fabric.Image#initialize} for constructor definition
     */
    fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'image',

      /**
       * crossOrigin value (one of "", "anonymous", "use-credentials")
       * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
       * @type String
       * @default
       */
      crossOrigin: '',

      /**
       * Width of a stroke.
       * For image quality a stroke multiple of 2 gives better results.
       * @type Number
       * @default
       */
      strokeWidth: 0,

      /**
       * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.
       * This allows for relative urls as image src.
       * @since 2.7.0
       * @type Boolean
       * @default
       */
      srcFromAttribute: false,

      /**
       * private
       * contains last value of scaleX to detect
       * if the Image got resized after the last Render
       * @type Number
       */
      _lastScaleX: 1,

      /**
       * private
       * contains last value of scaleY to detect
       * if the Image got resized after the last Render
       * @type Number
       */
      _lastScaleY: 1,

      /**
       * private
       * contains last value of scaling applied by the apply filter chain
       * @type Number
       */
      _filterScalingX: 1,

      /**
       * private
       * contains last value of scaling applied by the apply filter chain
       * @type Number
       */
      _filterScalingY: 1,

      /**
       * minimum scale factor under which any resizeFilter is triggered to resize the image
       * 0 will disable the automatic resize. 1 will trigger automatically always.
       * number bigger than 1 are not implemented yet.
       * @type Number
       */
      minimumScaleTrigger: 0.5,

      /**
       * List of properties to consider when checking if
       * state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),

      /**
       * key used to retrieve the texture representing this image
       * @since 2.0.0
       * @type String
       * @default
       */
      cacheKey: '',

      /**
       * Image crop in pixels from original image size.
       * @since 2.0.0
       * @type Number
       * @default
       */
      cropX: 0,

      /**
       * Image crop in pixels from original image size.
       * @since 2.0.0
       * @type Number
       * @default
       */
      cropY: 0,

      /**
       * Constructor
       * @param {HTMLImageElement | String} element Image element
       * @param {Object} [options] Options object
       * @param {function} [callback] callback function to call after eventual filters applied.
       * @return {fabric.Image} thisArg
       */
      initialize: function(element, options) {
        options || (options = { });
        this.filters = [];
        this.cacheKey = 'texture' + fabric.Object.__uid++;
        this.callSuper('initialize', options);
        this._initElement(element, options);
      },

      /**
       * Returns image element which this instance if based on
       * @return {HTMLImageElement} Image element
       */
      getElement: function() {
        return this._element || {};
      },

      /**
       * Sets image element for this instance to a specified one.
       * If filters defined they are applied to new image.
       * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
       * @param {HTMLImageElement} element
       * @param {Object} [options] Options object
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setElement: function(element, options) {
        this.removeTexture(this.cacheKey);
        this.removeTexture(this.cacheKey + '_filtered');
        this._element = element;
        this._originalElement = element;
        this._initConfig(options);
        if (this.filters.length !== 0) {
          this.applyFilters();
        }
        // resizeFilters work on the already filtered copy.
        // we need to apply resizeFilters AFTER normal filters.
        // applyResizeFilters is run more often than normal fiters
        // and is triggered by user interactions rather than dev code
        if (this.resizeFilter) {
          this.applyResizeFilters();
        }
        return this;
      },

      /**
       * Delete a single texture if in webgl mode
       */
      removeTexture: function(key) {
        var backend = fabric.filterBackend;
        if (backend && backend.evictCachesForKey) {
          backend.evictCachesForKey(key);
        }
      },

      /**
       * Delete textures, reference to elements and eventually JSDOM cleanup
       */
      dispose: function() {
        this.removeTexture(this.cacheKey);
        this.removeTexture(this.cacheKey + '_filtered');
        this._cacheContext = undefined;
        ['_originalElement', '_element', '_filteredEl', '_cacheCanvas'].forEach((function(element) {
          fabric.util.cleanUpJsdomNode(this[element]);
          this[element] = undefined;
        }).bind(this));
      },

      /**
       * Sets crossOrigin value (on an instance and corresponding image element)
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
        this._element.crossOrigin = value;

        return this;
      },

      /**
       * Returns original size of an image
       * @return {Object} Object with "width" and "height" properties
       */
      getOriginalSize: function() {
        var element = this.getElement();
        return {
          width: element.naturalWidth || element.width,
          height: element.naturalHeight || element.height
        };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _stroke: function(ctx) {
        if (!this.stroke || this.strokeWidth === 0) {
          return;
        }
        var w = this.width / 2, h = this.height / 2;
        ctx.beginPath();
        ctx.moveTo(-w, -h);
        ctx.lineTo(w, -h);
        ctx.lineTo(w, h);
        ctx.lineTo(-w, h);
        ctx.lineTo(-w, -h);
        ctx.closePath();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var x = -this.width / 2,
            y = -this.height / 2,
            w = this.width,
            h = this.height;

        ctx.save();
        this._setStrokeStyles(ctx, this);

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
        ctx.closePath();
        ctx.restore();
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var filters = [];

        this.filters.forEach(function(filterObj) {
          if (filterObj) {
            filters.push(filterObj.toObject());
          }
        });
        var object = extend(
          this.callSuper(
            'toObject',
            ['crossOrigin', 'cropX', 'cropY'].concat(propertiesToInclude)
          ), {
            src: this.getSrc(),
            filters: filters,
          });
        if (this.resizeFilter) {
          object.resizeFilter = this.resizeFilter.toObject();
        }
        return object;
      },

      /**
       * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,hight.
       * @return {Boolean}
       */
      hasCrop: function() {
        return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @return {Array} an array of strings with the specific svg representation
       * of the instance
       */
      _toSVG: function() {
        var svgString = [], imageMarkup = [], strokeSvg,
            x = -this.width / 2, y = -this.height / 2, clipPath = '';
        if (this.hasCrop()) {
          var clipPathId = fabric.Object.__uid++;
          svgString.push(
            '<clipPath id="imageCrop_' + clipPathId + '">\n',
            '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
            '</clipPath>\n'
          );
          clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
        }
        imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(true),
          '" x="', x - this.cropX, '" y="', y - this.cropY,
          // we're essentially moving origin of transformation from top/left corner to the center of the shape
          // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
          // so that object's center aligns with container's left/top
          '" width="', this._element.width || this._element.naturalWidth,
          '" height="', this._element.height || this._element.height,
          '"', clipPath,
          '></image>\n');

        if (this.stroke || this.strokeDashArray) {
          var origFill = this.fill;
          this.fill = null;
          strokeSvg = [
            '\t<rect ',
            'x="', x, '" y="', y,
            '" width="', this.width, '" height="', this.height,
            '" style="', this.getSvgStyles(),
            '"/>\n'
          ];
          this.fill = origFill;
        }
        if (this.paintFirst !== 'fill') {
          svgString = svgString.concat(strokeSvg, imageMarkup);
        }
        else {
          svgString = svgString.concat(imageMarkup, strokeSvg);
        }
        return svgString;
      },
      /* _TO_SVG_END_ */

      /**
       * Returns source of an image
       * @param {Boolean} filtered indicates if the src is needed for svg
       * @return {String} Source of an image
       */
      getSrc: function(filtered) {
        var element = filtered ? this._element : this._originalElement;
        if (element) {
          if (element.toDataURL) {
            return element.toDataURL();
          }

          if (this.srcFromAttribute) {
            return element.getAttribute('src');
          }
          else {
            return element.src;
          }
        }
        else {
          return this.src || '';
        }
      },

      /**
       * Sets source of an image
       * @param {String} src Source string (URL)
       * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
       * @param {Object} [options] Options object
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setSrc: function(src, callback, options) {
        fabric.util.loadImage(src, function(img) {
          this.setElement(img, options);
          this._setWidthHeight();
          callback && callback(this);
        }, this, options && options.crossOrigin);
        return this;
      },

      /**
       * Returns string representation of an instance
       * @return {String} String representation of an instance
       */
      toString: function() {
        return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
      },

      applyResizeFilters: function() {
        var filter = this.resizeFilter,
            minimumScale = this.minimumScaleTrigger,
            objectScale = this.getTotalObjectScaling(),
            scaleX = objectScale.scaleX,
            scaleY = objectScale.scaleY,
            elementToFilter = this._filteredEl || this._originalElement;
        if (this.group) {
          this.set('dirty', true);
        }
        if (!filter || (scaleX > minimumScale && scaleY > minimumScale)) {
          this._element = elementToFilter;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          this._lastScaleX = scaleX;
          this._lastScaleY = scaleY;
          return;
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        var canvasEl = fabric.util.createCanvasElement(),
            cacheKey = this._filteredEl ? (this.cacheKey + '_filtered') : this.cacheKey,
            sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
        canvasEl.width = sourceWidth;
        canvasEl.height = sourceHeight;
        this._element = canvasEl;
        this._lastScaleX = filter.scaleX = scaleX;
        this._lastScaleY = filter.scaleY = scaleY;
        fabric.filterBackend.applyFilters(
          [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);
        this._filterScalingX = canvasEl.width / this._originalElement.width;
        this._filterScalingY = canvasEl.height / this._originalElement.height;
      },

      /**
       * Applies filters assigned to this image (from "filters" array) or from filter param
       * @method applyFilters
       * @param {Array} filters to be applied
       * @param {Boolean} forResizing specify if the filter operation is a resize operation
       * @return {thisArg} return the fabric.Image object
       * @chainable
       */
      applyFilters: function(filters) {

        filters = filters || this.filters || [];
        filters = filters.filter(function(filter) { return filter && !filter.isNeutralState(); });
        this.set('dirty', true);

        // needs to clear out or WEBGL will not resize correctly
        this.removeTexture(this.cacheKey + '_filtered');

        if (filters.length === 0) {
          this._element = this._originalElement;
          this._filteredEl = null;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          return this;
        }

        var imgElement = this._originalElement,
            sourceWidth = imgElement.naturalWidth || imgElement.width,
            sourceHeight = imgElement.naturalHeight || imgElement.height;

        if (this._element === this._originalElement) {
          // if the element is the same we need to create a new element
          var canvasEl = fabric.util.createCanvasElement();
          canvasEl.width = sourceWidth;
          canvasEl.height = sourceHeight;
          this._element = canvasEl;
          this._filteredEl = canvasEl;
        }
        else {
          // clear the existing element to get new filter data
          // also dereference the eventual resized _element
          this._element = this._filteredEl;
          this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
          // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y
          this._lastScaleX = 1;
          this._lastScaleY = 1;
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        fabric.filterBackend.applyFilters(
          filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
        if (this._originalElement.width !== this._element.width ||
          this._originalElement.height !== this._element.height) {
          this._filterScalingX = this._element.width / this._originalElement.width;
          this._filterScalingY = this._element.height / this._originalElement.height;
        }
        return this;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
          this.applyResizeFilters();
        }
        this._stroke(ctx);
        this._renderPaintInOrder(ctx);
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * This is the special image version where we would like to avoid caching where possible.
       * Essentially images do not benefit from caching. They may require caching, and in that
       * case we do it. Also caching an image usually ends in a loss of details.
       * A full performance audit should be done.
       * @return {Boolean}
       */
      shouldCache: function() {
        return this.needsItsOwnCache();
      },

      _renderFill: function(ctx) {
        var elementToDraw = this._element,
            w = this.width, h = this.height,
            sW = Math.min(elementToDraw.naturalWidth || elementToDraw.width, w * this._filterScalingX),
            sH = Math.min(elementToDraw.naturalHeight || elementToDraw.height, h * this._filterScalingY),
            x = -w / 2, y = -h / 2,
            sX = Math.max(0, this.cropX * this._filterScalingX),
            sY = Math.max(0, this.cropY * this._filterScalingY);

        elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, w, h);
      },

      /**
       * needed to check if image needs resize
       * @private
       */
      _needsResize: function() {
        var scale = this.getTotalObjectScaling();
        return (scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY);
      },

      /**
       * @private
       */
      _resetWidthHeight: function() {
        this.set(this.getOriginalSize());
      },

      /**
       * The Image class's initialization method. This method is automatically
       * called by the constructor.
       * @private
       * @param {HTMLImageElement|String} element The element representing the image
       * @param {Object} [options] Options object
       */
      _initElement: function(element, options) {
        this.setElement(fabric.util.getById(element), options);
        fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
      },

      /**
       * @private
       * @param {Object} [options] Options object
       */
      _initConfig: function(options) {
        options || (options = { });
        this.setOptions(options);
        this._setWidthHeight(options);
        if (this._element && this.crossOrigin) {
          this._element.crossOrigin = this.crossOrigin;
        }
      },

      /**
       * @private
       * @param {Array} filters to be initialized
       * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
       */
      _initFilters: function(filters, callback) {
        if (filters && filters.length) {
          fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
            callback && callback(enlivenedObjects);
          }, 'fabric.Image.filters');
        }
        else {
          callback && callback();
        }
      },

      /**
       * @private
       * Set the width and the height of the image object, using the element or the
       * options.
       * @param {Object} [options] Object with width/height properties
       */
      _setWidthHeight: function(options) {
        options || (options = { });
        var el = this.getElement();
        this.width = options.width || el.naturalWidth || el.width || 0;
        this.height = options.height || el.naturalHeight || el.height || 0;
      },

      /**
       * Calculate offset for center and scale factor for the image in order to respect
       * the preserveAspectRatio attribute
       * @private
       * @return {Object}
       */
      parsePreserveAspectRatioAttribute: function() {
        var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),
            rWidth = this._element.width, rHeight = this._element.height,
            scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,
            offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
        if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
          if (pAR.meetOrSlice === 'meet') {
            scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
            offset = (pWidth - rWidth * scaleX) / 2;
            if (pAR.alignX === 'Min') {
              offsetLeft = -offset;
            }
            if (pAR.alignX === 'Max') {
              offsetLeft = offset;
            }
            offset = (pHeight - rHeight * scaleY) / 2;
            if (pAR.alignY === 'Min') {
              offsetTop = -offset;
            }
            if (pAR.alignY === 'Max') {
              offsetTop = offset;
            }
          }
          if (pAR.meetOrSlice === 'slice') {
            scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
            offset = rWidth - pWidth / scaleX;
            if (pAR.alignX === 'Mid') {
              cropX = offset / 2;
            }
            if (pAR.alignX === 'Max') {
              cropX = offset;
            }
            offset = rHeight - pHeight / scaleY;
            if (pAR.alignY === 'Mid') {
              cropY = offset / 2;
            }
            if (pAR.alignY === 'Max') {
              cropY = offset;
            }
            rWidth = pWidth / scaleX;
            rHeight = pHeight / scaleY;
          }
        }
        else {
          scaleX = pWidth / rWidth;
          scaleY = pHeight / rHeight;
        }
        return {
          width: rWidth,
          height: rHeight,
          scaleX: scaleX,
          scaleY: scaleY,
          offsetLeft: offsetLeft,
          offsetTop: offsetTop,
          cropX: cropX,
          cropY: cropY
        };
      }
    });

    /**
     * Default CSS class name for canvas
     * @static
     * @type String
     * @default
     */
    fabric.Image.CSS_CANVAS = 'canvas-img';

    /**
     * Alias for getSrc
     * @static
     */
    fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

    /**
     * Creates an instance of fabric.Image from its object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} callback Callback to invoke when an image instance is created
     */
    fabric.Image.fromObject = function(_object, callback) {
      var object = fabric.util.object.clone(_object);
      fabric.util.loadImage(object.src, function(img, error) {
        if (error) {
          callback && callback(null, error);
          return;
        }
        fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
          object.filters = filters || [];
          fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
            object.resizeFilter = resizeFilters[0];
            fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
              object.clipPath = enlivedProps[0];
              var image = new fabric.Image(img, object);
              callback(image);
            });
          });
        });
      }, null, object.crossOrigin);
    };

    /**
     * Creates an instance of fabric.Image from an URL string
     * @static
     * @param {String} url URL to create an image from
     * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
     * @param {Object} [imgOptions] Options object
     */
    fabric.Image.fromURL = function(url, callback, imgOptions) {
      fabric.util.loadImage(url, function(img) {
        callback && callback(new fabric.Image(img, imgOptions));
      }, null, imgOptions && imgOptions.crossOrigin);
    };

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
     * @static
     * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
     */
    fabric.Image.ATTRIBUTE_NAMES =
      fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href crossOrigin'.split(' '));

    /**
     * Returns {@link fabric.Image} instance from an SVG element
     * @static
     * @param {SVGElement} element Element to parse
     * @param {Object} [options] Options object
     * @param {Function} callback Callback to execute when fabric.Image object is created
     * @return {fabric.Image} Instance of fabric.Image
     */
    fabric.Image.fromElement = function(element, callback, options) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
      fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
        extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    };
    /* _FROM_SVG_END_ */

  })( exports );


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * @private
     * @return {Number} angle value
     */
    _getAngleValueForStraighten: function() {
      var angle = this.angle % 360;
      if (angle > 0) {
        return Math.round((angle - 1) / 90) * 90;
      }
      return Math.round(angle / 90) * 90;
    },

    /**
     * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    straighten: function() {
      this.rotate(this._getAngleValueForStraighten());
      return this;
    },

    /**
     * Same as {@link fabric.Object.prototype.straighten} but with animation
     * @param {Object} callbacks Object with callback functions
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Object} thisArg
     * @chainable
     */
    fxStraighten: function(callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: this.get('angle'),
        endValue: this._getAngleValueForStraighten(),
        duration: this.FX_DURATION,
        onChange: function(value) {
          _this.rotate(value);
          onChange();
        },
        onComplete: function() {
          _this.setCoords();
          onComplete();
        },
      });

      return this;
    }
  });

  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Straightens object, then rerenders canvas
     * @param {fabric.Object} object Object to straighten
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    straightenObject: function (object) {
      object.straighten();
      this.requestRenderAll();
      return this;
    },

    /**
     * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
     * @param {fabric.Object} object Object to straighten
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxStraightenObject: function (object) {
      object.fxStraighten({
        onChange: this.requestRenderAllBound
      });
      return this;
    }
  });


  (function() {

    /**
     * Tests if webgl supports certain precision
     * @param {WebGL} Canvas WebGL context to test on
     * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'
     * @returns {Boolean} Whether the user's browser WebGL supports given precision.
     */
    function testPrecision(gl, precision){
      var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentSource);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        return false;
      }
      return true;
    }

    /**
     * Indicate whether this filtering backend is supported by the user's browser.
     * @param {Number} tileSize check if the tileSize is supported
     * @returns {Boolean} Whether the user's browser supports WebGL.
     */
    fabric.isWebglSupported = function(tileSize) {
      if (fabric.isLikelyNode) {
        return false;
      }
      tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
      var canvas = document.createElement('canvas');
      var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      var isSupported = false;
      // eslint-disable-next-line
      if (gl) {
        fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        isSupported = fabric.maxTextureSize >= tileSize;
        var precisions = ['highp', 'mediump', 'lowp'];
        for (var i = 0; i < 3; i++){
          if (testPrecision(gl, precisions[i])){
            fabric.webGlPrecision = precisions[i];
            break;
          }      }
      }
      this.isSupported = isSupported;
      return isSupported;
    };

    fabric.WebglFilterBackend = WebglFilterBackend;

    /**
     * WebGL filter backend.
     */
    function WebglFilterBackend(options) {
      if (options && options.tileSize) {
        this.tileSize = options.tileSize;
      }
      this.setupGLContext(this.tileSize, this.tileSize);
      this.captureGPUInfo();
    }
    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

      tileSize: 2048,

      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you problably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {

      },

      /**
       * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
       */
      setupGLContext: function(width, height) {
        this.dispose();
        this.createWebGLCanvas(width, height);
        // eslint-disable-next-line
        this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
        this.chooseFastestCopyGLTo2DMethod(width, height);
      },

      /**
       * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
       * putImageData is faster than drawImage for that specific operation.
       */
      chooseFastestCopyGLTo2DMethod: function(width, height) {
        var canMeasurePerf = typeof window.performance !== 'undefined', canUseImageData;
        try {
          new ImageData(1, 1);
          canUseImageData = true;
        }
        catch (e) {
          canUseImageData = false;
        }
        // eslint-disable-next-line no-undef
        var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
        // eslint-disable-next-line no-undef
        var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

        if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
          return;
        }

        var targetCanvas = fabric.util.createCanvasElement();
        // eslint-disable-next-line no-undef
        var imageBuffer = new ArrayBuffer(width * height * 4);
        if (fabric.forceGLPutImageData) {
          this.imageBuffer = imageBuffer;
          this.copyGLTo2D = copyGLTo2DPutImageData;
          return;
        }
        var testContext = {
          imageBuffer: imageBuffer,
          destinationWidth: width,
          destinationHeight: height,
          targetCanvas: targetCanvas
        };
        var startTime, drawImageTime, putImageDataTime;
        targetCanvas.width = width;
        targetCanvas.height = height;

        startTime = window.performance.now();
        copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
        drawImageTime = window.performance.now() - startTime;

        startTime = window.performance.now();
        copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
        putImageDataTime = window.performance.now() - startTime;

        if (drawImageTime > putImageDataTime) {
          this.imageBuffer = imageBuffer;
          this.copyGLTo2D = copyGLTo2DPutImageData;
        }
        else {
          this.copyGLTo2D = copyGLTo2DDrawImage;
        }
      },

      /**
       * Create a canvas element and associated WebGL context and attaches them as
       * class properties to the GLFilterBackend class.
       */
      createWebGLCanvas: function(width, height) {
        var canvas = fabric.util.createCanvasElement();
        canvas.width = width;
        canvas.height = height;
        var glOptions = {
              alpha: true,
              premultipliedAlpha: false,
              depth: false,
              stencil: false,
              antialias: false
            },
            gl = canvas.getContext('webgl', glOptions);
        if (!gl) {
          gl = canvas.getContext('experimental-webgl', glOptions);
        }
        if (!gl) {
          return;
        }
        gl.clearColor(0, 0, 0, 0);
        // this canvas can fire webglcontextlost and webglcontextrestored
        this.canvas = canvas;
        this.gl = gl;
      },

      /**
       * Attempts to apply the requested filters to the source provided, drawing the filtered output
       * to the provided target canvas.
       *
       * @param {Array} filters The filters to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
       * @param {Number} width The width of the source input.
       * @param {Number} height The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
       * omitted, caching will be skipped.
       */
      applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
        var gl = this.gl;
        var cachedTexture;
        if (cacheKey) {
          cachedTexture = this.getCachedTexture(cacheKey, source);
        }
        var pipelineState = {
          originalWidth: source.width || source.originalWidth,
          originalHeight: source.height || source.originalHeight,
          sourceWidth: width,
          sourceHeight: height,
          destinationWidth: width,
          destinationHeight: height,
          context: gl,
          sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
          targetTexture: this.createTexture(gl, width, height),
          originalTexture: cachedTexture ||
            this.createTexture(gl, width, height, !cachedTexture && source),
          passes: filters.length,
          webgl: true,
          aPosition: this.aPosition,
          programCache: this.programCache,
          pass: 0,
          filterBackend: this,
          targetCanvas: targetCanvas
        };
        var tempFbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
        filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
        resizeCanvasIfNeeded(pipelineState);
        this.copyGLTo2D(gl, pipelineState);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.deleteTexture(pipelineState.sourceTexture);
        gl.deleteTexture(pipelineState.targetTexture);
        gl.deleteFramebuffer(tempFbo);
        targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
        return pipelineState;
      },

      /**
       * Detach event listeners, remove references, and clean up caches.
       */
      dispose: function() {
        if (this.canvas) {
          this.canvas = null;
          this.gl = null;
        }
        this.clearWebGLCaches();
      },

      /**
       * Wipe out WebGL-related caches.
       */
      clearWebGLCaches: function() {
        this.programCache = {};
        this.textureCache = {};
      },

      /**
       * Create a WebGL texture object.
       *
       * Accepts specific dimensions to initialize the textuer to or a source image.
       *
       * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
       * @param {Number} width The width to initialize the texture at.
       * @param {Number} height The height to initialize the texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
       * @returns {WebGLTexture}
       */
      createTexture: function(gl, width, height, textureImageSource) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (textureImageSource) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
        }
        else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        return texture;
      },

      /**
       * Can be optionally used to get a texture from the cache array
       *
       * If an existing texture is not found, a new texture is created and cached.
       *
       * @param {String} uniqueId A cache key to use to find an existing texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
       * texture cache entry if one does not already exist.
       */
      getCachedTexture: function(uniqueId, textureImageSource) {
        if (this.textureCache[uniqueId]) {
          return this.textureCache[uniqueId];
        }
        else {
          var texture = this.createTexture(
            this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
          this.textureCache[uniqueId] = texture;
          return texture;
        }
      },

      /**
       * Clear out cached resources related to a source image that has been
       * filtered previously.
       *
       * @param {String} cacheKey The cache key provided when the source image was filtered.
       */
      evictCachesForKey: function(cacheKey) {
        if (this.textureCache[cacheKey]) {
          this.gl.deleteTexture(this.textureCache[cacheKey]);
          delete this.textureCache[cacheKey];
        }
      },

      copyGLTo2D: copyGLTo2DDrawImage,

      /**
       * Attempt to extract GPU information strings from a WebGL context.
       *
       * Useful information when debugging or blacklisting specific GPUs.
       *
       * @returns {Object} A GPU info object with renderer and vendor strings.
       */
      captureGPUInfo: function() {
        if (this.gpuInfo) {
          return this.gpuInfo;
        }
        var gl = this.gl, gpuInfo = { renderer: '', vendor: '' };
        if (!gl) {
          return gpuInfo;
        }
        var ext = gl.getExtension('WEBGL_debug_renderer_info');
        if (ext) {
          var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
          var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
          if (renderer) {
            gpuInfo.renderer = renderer.toLowerCase();
          }
          if (vendor) {
            gpuInfo.vendor = vendor.toLowerCase();
          }
        }
        this.gpuInfo = gpuInfo;
        return gpuInfo;
      },
    };
  })();

  function resizeCanvasIfNeeded(pipelineState) {
    var targetCanvas = pipelineState.targetCanvas,
        width = targetCanvas.width, height = targetCanvas.height,
        dWidth = pipelineState.destinationWidth,
        dHeight = pipelineState.destinationHeight;

    if (width !== dWidth || height !== dHeight) {
      targetCanvas.width = dWidth;
      targetCanvas.height = dHeight;
    }
  }

  /**
   * Copy an input WebGL canvas on to an output 2D canvas.
   *
   * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
   * desired output image appearing in the bottom-left corner of the WebGL canvas.
   *
   * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
   * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
   * @param {Object} pipelineState The 2D target canvas to copy on to.
   */
  function copyGLTo2DDrawImage(gl, pipelineState) {
    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,
        ctx = targetCanvas.getContext('2d');
    ctx.translate(0, targetCanvas.height); // move it down again
    ctx.scale(1, -1); // vertical flip
    // where is my image on the big glcanvas?
    var sourceY = glCanvas.height - targetCanvas.height;
    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
      targetCanvas.width, targetCanvas.height);
  }

  /**
   * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
   * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
   *
   * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
   * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
   * @param {Object} pipelineState The 2D target canvas to copy on to.
   */
  function copyGLTo2DPutImageData(gl, pipelineState) {
    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),
        dWidth = pipelineState.destinationWidth,
        dHeight = pipelineState.destinationHeight,
        numBytes = dWidth * dHeight * 4;

    // eslint-disable-next-line no-undef
    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
    // eslint-disable-next-line no-undef
    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);

    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
    var imgData = new ImageData(u8Clamped, dWidth, dHeight);
    ctx.putImageData(imgData, 0, 0);
  }


  (function() {

    var noop = function() {};

    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

    /**
     * Canvas 2D filter backend.
     */
    function Canvas2dFilterBackend() {}
    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
      evictCachesForKey: noop,
      dispose: noop,
      clearWebGLCaches: noop,

      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you probably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {

      },

      /**
       * Apply a set of filters against a source image and draw the filtered output
       * to the provided destination canvas.
       *
       * @param {EnhancedFilter} filters The filter to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
       * @param {Number} sourceWidth The width of the source input.
       * @param {Number} sourceHeight The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       */
      applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
        var ctx = targetCanvas.getContext('2d');
        ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
        var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var pipelineState = {
          sourceWidth: sourceWidth,
          sourceHeight: sourceHeight,
          imageData: imageData,
          originalEl: sourceElement,
          originalImageData: originalImageData,
          canvasEl: targetCanvas,
          ctx: ctx,
          filterBackend: this,
        };
        filters.forEach(function(filter) { filter.applyTo(pipelineState); });
        if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
          targetCanvas.width = pipelineState.imageData.width;
          targetCanvas.height = pipelineState.imageData.height;
        }
        ctx.putImageData(pipelineState.imageData, 0, 0);
        return pipelineState;
      },

    };
  })();


  /**
   * @namespace fabric.Image.filters
   * @memberOf fabric.Image
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   */
  fabric.Image = fabric.Image || { };
  fabric.Image.filters = fabric.Image.filters || { };

  /**
   * Root filter class from which all filter classes inherit from
   * @class fabric.Image.filters.BaseFilter
   * @memberOf fabric.Image.filters
   */
  fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'BaseFilter',

    /**
     * Array of attributes to send with buffers. do not modify
     * @private
     */

    vertexSource: 'attribute vec2 aPosition;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vTexCoord = aPosition;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    fragmentSource: 'precision highp float;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform sampler2D uTexture;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
      '}',

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Sets filter's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Compile this filter's shader program.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
     * @param {String} fragmentSource fragmentShader source for compilation
     * @param {String} vertexSource vertexShader source for compilation
     */
    createProgram: function(gl, fragmentSource, vertexSource) {
      fragmentSource = fragmentSource || this.fragmentSource;
      vertexSource = vertexSource || this.vertexSource;
      if (fabric.webGlPrecision !== 'highp'){
        fragmentSource = fragmentSource.replace(
          /precision highp float/g,
          'precision ' + fabric.webGlPrecision + ' float'
        );
      }
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vertexSource);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Vertex shader compile error for ' + this.type + ': ' +
          gl.getShaderInfoLog(vertexShader)
        );
      }

      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentSource);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Fragment shader compile error for ' + this.type + ': ' +
          gl.getShaderInfoLog(fragmentShader)
        );
      }

      var program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Shader link error for "${this.type}" ' +
          gl.getProgramInfoLog(program)
        );
      }

      var attributeLocations = this.getAttributeLocations(gl, program);
      var uniformLocations = this.getUniformLocations(gl, program) || { };
      uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
      uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
      return {
        program: program,
        attributeLocations: attributeLocations,
        uniformLocations: uniformLocations
      };
    },

    /**
     * Return a map of attribute names to WebGLAttributeLocation objects.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
     * @returns {Object} A map of attribute names to attribute locations.
     */
    getAttributeLocations: function(gl, program) {
      return {
        aPosition: gl.getAttribLocation(program, 'aPosition'),
      };
    },

    /**
     * Return a map of uniform names to WebGLUniformLocation objects.
     *
     * Intended to be overridden by subclasses.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
     * @returns {Object} A map of uniform names to uniform locations.
     */
    getUniformLocations: function (/* gl, program */) {
      // in case i do not need any special uniform i need to return an empty object
      return { };
    },

    /**
     * Send attribute data from this filter to its shader program on the GPU.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {Object} attributeLocations A map of shader attribute names to their locations.
     */
    sendAttributeData: function(gl, attributeLocations, aPositionData) {
      var attributeLocation = attributeLocations.aPosition;
      var buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(attributeLocation);
      gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
    },

    _setupFrameBuffer: function(options) {
      var gl = options.context, width, height;
      if (options.passes > 1) {
        width = options.destinationWidth;
        height = options.destinationHeight;
        if (options.sourceWidth !== width || options.sourceHeight !== height) {
          gl.deleteTexture(options.targetTexture);
          options.targetTexture = options.filterBackend.createTexture(gl, width, height);
        }
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
          options.targetTexture, 0);
      }
      else {
        // draw last filter on canvas and not to framebuffer.
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.finish();
      }
    },

    _swapTextures: function(options) {
      options.passes--;
      options.pass++;
      var temp = options.targetTexture;
      options.targetTexture = options.sourceTexture;
      options.sourceTexture = temp;
    },

    /**
     * Generic isNeutral implementation for one parameter based filters.
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * Other filters may need their own verison ( ColorMatrix, HueRotation, gamma, ComposedFilter )
     * @param {Object} options
     **/
    isNeutralState: function(/* options */) {
      var main = this.mainParameter,
          _class = fabric.Image.filters[this.type].prototype;
      if (main) {
        if (Array.isArray(_class[main])) {
          for (var i = _class[main].length; i--;) {
            if (this[main][i] !== _class[main][i]) {
              return false;
            }
          }
          return true;
        }
        else {
          return _class[main] === this[main];
        }
      }
      else {
        return false;
      }
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      if (options.webgl) {
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else {
        this.applyTo2d(options);
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      if (!options.programCache.hasOwnProperty(this.type)) {
        options.programCache[this.type] = this.createProgram(options.context);
      }
      return options.programCache[this.type];
    },

    /**
     * Apply this filter using webgl.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.originalTexture The texture of the original input image.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyToWebGL: function(options) {
      var gl = options.context;
      var shader = this.retrieveShader(options);
      if (options.pass === 0 && options.originalTexture) {
        gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
      }
      else {
        gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
      }
      gl.useProgram(shader.program);
      this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);

      gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
      gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

      this.sendUniformData(gl, shader.uniformLocations);
      gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    },

    bindAdditionalTexture: function(gl, texture, textureUnit) {
      gl.activeTexture(textureUnit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      // reset active texture to 0 as usual
      gl.activeTexture(gl.TEXTURE0);
    },

    unbindAdditionalTexture: function(gl, textureUnit) {
      gl.activeTexture(textureUnit);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.activeTexture(gl.TEXTURE0);
    },

    getMainParameter: function() {
      return this[this.mainParameter];
    },

    setMainParameter: function(value) {
      this[this.mainParameter] = value;
    },

    /**
     * Send uniform data from this filter to its shader program on the GPU.
     *
     * Intended to be overridden by subclasses.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {Object} uniformLocations A map of shader uniform names to their locations.
     */
    sendUniformData: function(/* gl, uniformLocations */) {
      // Intentionally left blank.  Override me in subclasses.
    },

    /**
     * If needed by a 2d filter, this functions can create an helper canvas to be used
     * remember that options.targetCanvas is available for use till end of chain.
     */
    createHelpLayer: function(options) {
      if (!options.helpLayer) {
        var helpLayer = document.createElement('canvas');
        helpLayer.width = options.sourceWidth;
        helpLayer.height = options.sourceHeight;
        options.helpLayer = helpLayer;
      }
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      var object = { type: this.type }, mainP = this.mainParameter;
      if (mainP) {
        object[mainP] = this[mainP];
      }
      return object;
    },

    /**
     * Returns a JSON representation of an instance
     * @return {Object} JSON
     */
    toJSON: function() {
      // delegate, not alias
      return this.toObject();
    }
  });

  fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
    var filter = new fabric.Image.filters[object.type](object);
    callback && callback(filter);
    return filter;
  };


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Color Matrix filter class
     * @class fabric.Image.filters.ColorMatrix
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
     * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
     * @example <caption>Kodachrome filter</caption>
     * var filter = new fabric.Image.filters.ColorMatrix({
     *  matrix: [
         1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
         -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
         -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
         0, 0, 0, 1, 0
        ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'ColorMatrix',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'uniform mat4 uColorMatrix;\n' +
        'uniform vec4 uConstants;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color *= uColorMatrix;\n' +
          'color += uConstants;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Colormatrix for pixels.
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * 0.0039215686 is the part of 1 that get translated to 1 in 2d
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ],

      mainParameter: 'matrix',

      /**
       * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario
       * to save some calculation
       */
      colorsOnly: true,

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        // create a new array instead mutating the prototype with push
        this.matrix = this.matrix.slice(0);
      },

      /**
       * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data,
            iLen = data.length,
            m = this.matrix,
            r, g, b, a, i, colorsOnly = this.colorsOnly;

        for (i = 0; i < iLen; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          if (colorsOnly) {
            data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
            data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
            data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
          }
          else {
            a = data[i + 3];
            data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
            data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
            data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
            data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
          uConstants: gl.getUniformLocation(program, 'uConstants'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var m = this.matrix,
            matrix = [
              m[0], m[1], m[2], m[3],
              m[5], m[6], m[7], m[8],
              m[10], m[11], m[12], m[13],
              m[15], m[16], m[17], m[18]
            ],
            constants = [m[4], m[9], m[14], m[19]];
        gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
        gl.uniform4fv(uniformLocations.uConstants, constants);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] function to invoke after filter creation
     * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
     */
    fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Brightness filter class
     * @class fabric.Image.filters.Brightness
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Brightness({
     *   brightness: 0.05
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Brightness',

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uBrightness;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb += uBrightness;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Brightness value, from -1 to 1.
       * translated to -255 to 255 for 2d
       * 0.0039215686 is the part of 1 that get translated to 1 in 2d
       * @param {Number} brightness
       * @default
       */
      brightness: 0,

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'brightness',

      /**
      * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
      */
      applyTo2d: function(options) {
        if (this.brightness === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i, len = data.length,
            brightness = Math.round(this.brightness * 255);
        for (i = 0; i < len; i += 4) {
          data[i] = data[i] + brightness;
          data[i + 1] = data[i + 1] + brightness;
          data[i + 2] = data[i + 2] + brightness;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uBrightness: gl.getUniformLocation(program, 'uBrightness'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uBrightness, this.brightness);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
     */
    fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
     * @class fabric.Image.filters.Convolute
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example <caption>Sharpen filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 0, -1,  0,
     *            -1,  5, -1,
     *             0, -1,  0 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Blur filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 1/9, 1/9, 1/9,
     *             1/9, 1/9, 1/9,
     *             1/9, 1/9, 1/9 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Emboss filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 1,   1,  1,
     *             1, 0.7, -1,
     *            -1,  -1, -1 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Emboss filter with opaqueness</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   opaque: true,
     *   matrix: [ 1,   1,  1,
     *             1, 0.7, -1,
     *            -1,  -1, -1 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Convolute',

      /*
       * Opaque value (true/false)
       */
      opaque: false,

      /*
       * matrix for the filter, max 9x9
       */
      matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: {
        Convolute_3_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[9];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_3_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[9];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_5_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[25];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_5_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[25];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_7_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[49];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_7_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[49];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_9_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[81];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_9_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[81];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
      },

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Convolute.prototype
       * @param {Object} [options] Options object
       * @param {Boolean} [options.opaque=false] Opaque value (true/false)
       * @param {Array} [options.matrix] Filter matrix
       */


      /**
      * Retrieves the cached shader.
      * @param {Object} options
      * @param {WebGLRenderingContext} options.context The GL context used for rendering.
      * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
      */
      retrieveShader: function(options) {
        var size = Math.sqrt(this.matrix.length);
        var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);
        var shaderSource = this.fragmentSource[cacheKey];
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data,
            weights = this.matrix,
            side = Math.round(Math.sqrt(weights.length)),
            halfSide = Math.floor(side / 2),
            sw = imageData.width,
            sh = imageData.height,
            output = options.ctx.createImageData(sw, sh),
            dst = output.data,
            // go through the destination image pixels
            alphaFac = this.opaque ? 1 : 0,
            r, g, b, a, dstOff,
            scx, scy, srcOff, wt,
            x, y, cx, cy;

        for (y = 0; y < sh; y++) {
          for (x = 0; x < sw; x++) {
            dstOff = (y * sw + x) * 4;
            // calculate the weighed sum of the source image pixels that
            // fall under the convolution matrix
            r = 0; g = 0; b = 0; a = 0;

            for (cy = 0; cy < side; cy++) {
              for (cx = 0; cx < side; cx++) {
                scy = y + cy - halfSide;
                scx = x + cx - halfSide;

                // eslint-disable-next-line max-depth
                if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {
                  continue;
                }

                srcOff = (scy * sw + scx) * 4;
                wt = weights[cy * side + cx];

                r += data[srcOff] * wt;
                g += data[srcOff + 1] * wt;
                b += data[srcOff + 2] * wt;
                // eslint-disable-next-line max-depth
                if (!alphaFac) {
                  a += data[srcOff + 3] * wt;
                }
              }
            }
            dst[dstOff] = r;
            dst[dstOff + 1] = g;
            dst[dstOff + 2] = b;
            if (!alphaFac) {
              dst[dstOff + 3] = a;
            }
            else {
              dst[dstOff + 3] = data[dstOff + 3];
            }
          }
        }
        options.imageData = output;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uMatrix: gl.getUniformLocation(program, 'uMatrix'),
          uOpaque: gl.getUniformLocation(program, 'uOpaque'),
          uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
          uSize: gl.getUniformLocation(program, 'uSize'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          opaque: this.opaque,
          matrix: this.matrix
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
     */
    fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Grayscale image filter class
     * @class fabric.Image.filters.Grayscale
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Grayscale();
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Grayscale',

      fragmentSource: {
        average: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'float average = (color.r + color.b + color.g) / 3.0;\n' +
            'gl_FragColor = vec4(average, average, average, color.a);\n' +
          '}',
        lightness: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform int uMode;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 col = texture2D(uTexture, vTexCoord);\n' +
            'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
            'gl_FragColor = vec4(average, average, average, col.a);\n' +
          '}',
        luminosity: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform int uMode;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 col = texture2D(uTexture, vTexCoord);\n' +
            'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
            'gl_FragColor = vec4(average, average, average, col.a);\n' +
          '}',
      },


      /**
       * Grayscale mode, between 'average', 'lightness', 'luminosity'
       * @param {String} type
       * @default
       */
      mode: 'average',

      mainParameter: 'mode',

      /**
       * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, i,
            len = data.length, value,
            mode = this.mode;
        for (i = 0; i < len; i += 4) {
          if (mode === 'average') {
            value = (data[i] + data[i + 1] + data[i + 2]) / 3;
          }
          else if (mode === 'lightness') {
            value = (Math.min(data[i], data[i + 1], data[i + 2]) +
              Math.max(data[i], data[i + 1], data[i + 2])) / 2;
          }
          else if (mode === 'luminosity') {
            value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
          }
          data[i] = value;
          data[i + 1] = value;
          data[i + 2] = value;
        }
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          var shaderSource = this.fragmentSource[this.mode];
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uMode: gl.getUniformLocation(program, 'uMode'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        // default average mode.
        var mode = 1;
        gl.uniform1i(uniformLocations.uMode, mode);
      },

      /**
       * Grayscale filter isNeutralState implementation
       * The filter is never neutral
       * on the image
       **/
      isNeutralState: function() {
        return false;
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
     */
    fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Invert filter class
     * @class fabric.Image.filters.Invert
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Invert();
     * object.filters.push(filter);
     * object.applyFilters(canvas.renderAll.bind(canvas));
     */
    filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Invert',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uInvert;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'if (uInvert == 1) {\n' +
            'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
          '} else {\n' +
            'gl_FragColor = color;\n' +
          '}\n' +
        '}',

      /**
       * Filter invert. if false, does nothing
       * @param {Boolean} invert
       * @default
       */
      invert: true,

      mainParameter: 'invert',

      /**
       * Apply the Invert operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, i,
            len = data.length;
        for (i = 0; i < len; i += 4) {
          data[i] = 255 - data[i];
          data[i + 1] = 255 - data[i + 1];
          data[i + 2] = 255 - data[i + 2];
        }
      },

      /**
       * Invert filter isNeutralState implementation
       * Used only in image applyFilters to discard filters that will not have an effect
       * on the image
       * @param {Object} options
       **/
      isNeutralState: function() {
        return !this.invert;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uInvert: gl.getUniformLocation(program, 'uInvert'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1i(uniformLocations.uInvert, this.invert);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
     */
    fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Noise filter class
     * @class fabric.Image.filters.Noise
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Noise({
     *   noise: 700
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Noise',

      /**
       * Fragment source for the noise program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uStepH;\n' +
        'uniform float uNoise;\n' +
        'uniform float uSeed;\n' +
        'varying vec2 vTexCoord;\n' +
        'float rand(vec2 co, float seed, float vScale) {\n' +
          'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
        '}\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'noise',

      /**
       * Noise value, from
       * @param {Number} noise
       * @default
       */
      noise: 0,

      /**
       * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.noise === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i, len = data.length,
            noise = this.noise, rand;

        for (i = 0, len = data.length; i < len; i += 4) {

          rand = (0.5 - Math.random()) * noise;

          data[i] += rand;
          data[i + 1] += rand;
          data[i + 2] += rand;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uNoise: gl.getUniformLocation(program, 'uNoise'),
          uSeed: gl.getUniformLocation(program, 'uSeed'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
        gl.uniform1f(uniformLocations.uSeed, Math.random());
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          noise: this.noise
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
     */
    fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Pixelate filter class
     * @class fabric.Image.filters.Pixelate
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Pixelate({
     *   blocksize: 8
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Pixelate',

      blocksize: 4,

      mainParameter: 'blocksize',

      /**
       * Fragment source for the Pixelate program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uBlocksize;\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'float blockW = uBlocksize * uStepW;\n' +
          'float blockH = uBlocksize * uStepW;\n' +
          'int posX = int(vTexCoord.x / blockW);\n' +
          'int posY = int(vTexCoord.y / blockH);\n' +
          'float fposX = float(posX);\n' +
          'float fposY = float(posY);\n' +
          'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
          'vec4 color = texture2D(uTexture, squareCoords);\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data,
            iLen = imageData.height,
            jLen = imageData.width,
            index, i, j, r, g, b, a,
            _i, _j, _iLen, _jLen;

        for (i = 0; i < iLen; i += this.blocksize) {
          for (j = 0; j < jLen; j += this.blocksize) {

            index = (i * 4) * jLen + (j * 4);

            r = data[index];
            g = data[index + 1];
            b = data[index + 2];
            a = data[index + 3];

            _iLen = Math.min(i + this.blocksize, iLen);
            _jLen = Math.min(j + this.blocksize, jLen);
            for (_i = i; _i < _iLen; _i++) {
              for (_j = j; _j < _jLen; _j++) {
                index = (_i * 4) * jLen + (_j * 4);
                data[index] = r;
                data[index + 1] = g;
                data[index + 2] = b;
                data[index + 3] = a;
              }
            }
          }
        }
      },

      /**
       * Indicate when the filter is not gonna apply changes to the image
       **/
      isNeutralState: function() {
        return this.blocksize === 1;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
          uStepW: gl.getUniformLocation(program, 'uStepW'),
          uStepH: gl.getUniformLocation(program, 'uStepH'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
     */
    fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Remove white filter class
     * @class fabric.Image.filters.RemoveColor
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.RemoveColor({
     *   threshold: 0.2,
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'RemoveColor',

      /**
       * Color to remove, in any format understood by fabric.Color.
       * @param {String} type
       * @default
       */
      color: '#FFFFFF',

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uLow;\n' +
        'uniform vec4 uHigh;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
            'gl_FragColor.a = 0.0;\n' +
          '}\n' +
        '}',

      /**
       * distance to actual color, as value up or down from each r,g,b
       * between 0 and 1
       **/
      distance: 0.02,

      /**
       * For color to remove inside distance, use alpha channel for a smoother deletion
       * NOT IMPLEMENTED YET
       **/
      useAlpha: false,

      /**
       * Constructor
       * @memberOf fabric.Image.filters.RemoveWhite.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.color=#RRGGBB] Threshold value
       * @param {Number} [options.distance=10] Distance value
       */

      /**
       * Applies filter to canvas element
       * @param {Object} canvasEl Canvas element to apply filter to
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, i,
            distance = this.distance * 255,
            r, g, b,
            source = new fabric.Color(this.color).getSource(),
            lowC = [
              source[0] - distance,
              source[1] - distance,
              source[2] - distance,
            ],
            highC = [
              source[0] + distance,
              source[1] + distance,
              source[2] + distance,
            ];


        for (i = 0; i < data.length; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];

          if (r > lowC[0] &&
              g > lowC[1] &&
              b > lowC[2] &&
              r < highC[0] &&
              g < highC[1] &&
              b < highC[2]) {
            data[i + 3] = 0;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uLow: gl.getUniformLocation(program, 'uLow'),
          uHigh: gl.getUniformLocation(program, 'uHigh'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var source = new fabric.Color(this.color).getSource(),
            distance = parseFloat(this.distance),
            lowC = [
              0 + source[0] / 255 - distance,
              0 + source[1] / 255 - distance,
              0 + source[2] / 255 - distance,
              1
            ],
            highC = [
              source[0] / 255 + distance,
              source[1] / 255 + distance,
              source[2] / 255 + distance,
              1
            ];
        gl.uniform4fv(uniformLocations.uLow, lowC);
        gl.uniform4fv(uniformLocations.uHigh, highC);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          color: this.color,
          distance: this.distance
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
     */
    fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    var matrices = {
      Brownie: [
        0.59970,0.34553,-0.27082,0,0.186,
        -0.03770,0.86095,0.15059,0,-0.1449,
        0.24113,-0.07441,0.44972,0,-0.02965,
        0,0,0,1,0
      ],
      Vintage: [
        0.62793,0.32021,-0.03965,0,0.03784,
        0.02578,0.64411,0.03259,0,0.02926,
        0.04660,-0.08512,0.52416,0,0.02023,
        0,0,0,1,0
      ],
      Kodachrome: [
        1.12855,-0.39673,-0.03992,0,0.24991,
        -0.16404,1.08352,-0.05498,0,0.09698,
        -0.16786,-0.56034,1.60148,0,0.13972,
        0,0,0,1,0
      ],
      Technicolor: [
        1.91252,-0.85453,-0.09155,0,0.04624,
        -0.30878,1.76589,-0.10601,0,-0.27589,
        -0.23110,-0.75018,1.84759,0,0.12137,
        0,0,0,1,0
      ],
      Polaroid: [
        1.438,-0.062,-0.062,0,0,
        -0.122,1.378,-0.122,0,0,
        -0.016,-0.016,1.483,0,0,
        0,0,0,1,0
      ],
      Sepia: [
        0.393, 0.769, 0.189, 0, 0,
        0.349, 0.686, 0.168, 0, 0,
        0.272, 0.534, 0.131, 0, 0,
        0, 0, 0, 1, 0
      ],
      BlackWhite: [
        1.5, 1.5, 1.5, 0, -1,
        1.5, 1.5, 1.5, 0, -1,
        1.5, 1.5, 1.5, 0, -1,
        0, 0, 0, 1, 0,
      ]
    };

    for (var key in matrices) {
      filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: key,

        /**
         * Colormatrix for the effect
         * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
         * outside the -1, 1 range.
         * @param {Array} matrix array of 20 numbers.
         * @default
         */
        matrix: matrices[key],

        /**
         * Lock the matrix export for this kind of static, parameter less filters.
         */
        mainParameter: false,
        /**
         * Lock the colormatrix on the color part, skipping alpha
         */
        colorsOnly: true,

      });
      fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
    }
  })( exports );


  (function(global) {

    var fabric = global.fabric,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Color Blend filter class
     * @class fabric.Image.filter.BlendColor
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @example
     * var filter = new fabric.Image.filters.BlendColor({
     *  color: '#000',
     *  mode: 'multiply'
     * });
     *
     * var filter = new fabric.Image.filters.BlendImage({
     *  image: fabricImageObject,
     *  mode: 'multiply',
     *  alpha: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */

    filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
      type: 'BlendColor',

      /**
       * Color to make the blend operation with. default to a reddish color since black or white
       * gives always strong result.
       **/
      color: '#F95C63',

      /**
       * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
       * darken, lighten, overlay, exclusion, tint.
       **/
      mode: 'multiply',

      /**
       * alpha value. represent the strength of the blend color operation.
       **/
      alpha: 1,

      /**
       * Fragment source for the Multiply program
       */
      fragmentSource: {
        multiply: 'gl_FragColor.rgb *= uColor.rgb;\n',
        screen: 'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n',
        add: 'gl_FragColor.rgb += uColor.rgb;\n',
        diff: 'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n',
        subtract: 'gl_FragColor.rgb -= uColor.rgb;\n',
        lighten: 'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n',
        darken: 'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n',
        exclusion: 'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n',
        overlay: 'if (uColor.r < 0.5) {\n' +
            'gl_FragColor.r *= 2.0 * uColor.r;\n' +
          '} else {\n' +
            'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
          '}\n' +
          'if (uColor.g < 0.5) {\n' +
            'gl_FragColor.g *= 2.0 * uColor.g;\n' +
          '} else {\n' +
            'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
          '}\n' +
          'if (uColor.b < 0.5) {\n' +
            'gl_FragColor.b *= 2.0 * uColor.b;\n' +
          '} else {\n' +
            'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
          '}\n',
        tint: 'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
          'gl_FragColor.rgb += uColor.rgb;\n',
      },

      /**
       * build the fragment source for the filters, joining the common part with
       * the specific one.
       * @param {String} mode the mode of the filter, a key of this.fragmentSource
       * @return {String} the source to be compiled
       * @private
       */
      buildSource: function(mode) {
        return 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'gl_FragColor = color;\n' +
            'if (color.a > 0.0) {\n' +
              this.fragmentSource[mode] +
            '}\n' +
          '}';
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode, shaderSource;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          shaderSource = this.buildSource(this.mode);
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, iLen = data.length,
            tr, tg, tb,
            r, g, b,
            source, alpha1 = 1 - this.alpha;

        source = new fabric.Color(this.color).getSource();
        tr = source[0] * this.alpha;
        tg = source[1] * this.alpha;
        tb = source[2] * this.alpha;

        for (var i = 0; i < iLen; i += 4) {

          r = data[i];
          g = data[i + 1];
          b = data[i + 2];

          switch (this.mode) {
            case 'multiply':
              data[i] = r * tr / 255;
              data[i + 1] = g * tg / 255;
              data[i + 2] = b * tb / 255;
              break;
            case 'screen':
              data[i] = 255 - (255 - r) * (255 - tr) / 255;
              data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
              data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
              break;
            case 'add':
              data[i] = r + tr;
              data[i + 1] = g + tg;
              data[i + 2] = b + tb;
              break;
            case 'diff':
            case 'difference':
              data[i] = Math.abs(r - tr);
              data[i + 1] = Math.abs(g - tg);
              data[i + 2] = Math.abs(b - tb);
              break;
            case 'subtract':
              data[i] = r - tr;
              data[i + 1] = g - tg;
              data[i + 2] = b - tb;
              break;
            case 'darken':
              data[i] = Math.min(r, tr);
              data[i + 1] = Math.min(g, tg);
              data[i + 2] = Math.min(b, tb);
              break;
            case 'lighten':
              data[i] = Math.max(r, tr);
              data[i + 1] = Math.max(g, tg);
              data[i + 2] = Math.max(b, tb);
              break;
            case 'overlay':
              data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
              data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
              data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
              break;
            case 'exclusion':
              data[i] = tr + r - ((2 * tr * r) / 255);
              data[i + 1] = tg + g - ((2 * tg * g) / 255);
              data[i + 2] = tb + b - ((2 * tb * b) / 255);
              break;
            case 'tint':
              data[i] = tr + r * alpha1;
              data[i + 1] = tg + g * alpha1;
              data[i + 2] = tb + b * alpha1;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uColor: gl.getUniformLocation(program, 'uColor'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var source = new fabric.Color(this.color).getSource();
        source[0] = this.alpha * source[0] / 255;
        source[1] = this.alpha * source[1] / 255;
        source[2] = this.alpha * source[2] / 255;
        source[3] = this.alpha;
        gl.uniform4fv(uniformLocations.uColor, source);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          color: this.color,
          mode: this.mode,
          alpha: this.alpha
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
     */
    fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric = global.fabric,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Image Blend filter class
     * @class fabric.Image.filter.BlendImage
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @example
     * var filter = new fabric.Image.filters.BlendColor({
     *  color: '#000',
     *  mode: 'multiply'
     * });
     *
     * var filter = new fabric.Image.filters.BlendImage({
     *  image: fabricImageObject,
     *  mode: 'multiply',
     *  alpha: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */

    filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
      type: 'BlendImage',

      /**
       * Color to make the blend operation with. default to a reddish color since black or white
       * gives always strong result.
       **/
      image: null,

      /**
       * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
       * darken, lighten, overlay, exclusion, tint.
       **/
      mode: 'multiply',

      /**
       * alpha value. represent the strength of the blend image operation.
       * not implemented.
       **/
      alpha: 1,

      vertexSource: 'attribute vec2 aPosition;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'uniform mat3 uTransformMatrix;\n' +
        'void main() {\n' +
          'vTexCoord = aPosition;\n' +
          'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n' +
          'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
        '}',

      /**
       * Fragment source for the Multiply program
       */
      fragmentSource: {
        multiply: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform sampler2D uImage;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'varying vec2 vTexCoord2;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
            'color.rgba *= color2.rgba;\n' +
            'gl_FragColor = color;\n' +
          '}',
        mask: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform sampler2D uImage;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'varying vec2 vTexCoord2;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
            'color.a = color2.a;\n' +
            'gl_FragColor = color;\n' +
          '}',
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode;
        var shaderSource = this.fragmentSource[this.mode];
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      applyToWebGL: function(options) {
        // load texture to blend.
        var gl = options.context,
            texture = this.createTexture(options.filterBackend, this.image);
        this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
        this.callSuper('applyToWebGL', options);
        this.unbindAdditionalTexture(gl, gl.TEXTURE1);
      },

      createTexture: function(backend, image) {
        return backend.getCachedTexture(image.cacheKey, image._element);
      },

      /**
       * Calculate a transformMatrix to adapt the image to blend over
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      calculateMatrix: function() {
        var image = this.image,
            width = image._element.width,
            height = image._element.height;
        return [
          1 / image.scaleX, 0, 0,
          0, 1 / image.scaleY, 0,
          -image.left / width, -image.top / height, 1
        ];
      },

      /**
       * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            resources = options.filterBackend.resources,
            data = imageData.data, iLen = data.length,
            width = imageData.width,
            height = imageData.height,
            tr, tg, tb, ta,
            r, g, b, a,
            canvas1, context, image = this.image, blendData;

        if (!resources.blendImage) {
          resources.blendImage = fabric.util.createCanvasElement();
        }
        canvas1 = resources.blendImage;
        context = canvas1.getContext('2d');
        if (canvas1.width !== width || canvas1.height !== height) {
          canvas1.width = width;
          canvas1.height = height;
        }
        else {
          context.clearRect(0, 0, width, height);
        }
        context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
        context.drawImage(image._element, 0, 0, width, height);
        blendData = context.getImageData(0, 0, width, height).data;
        for (var i = 0; i < iLen; i += 4) {

          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          a = data[i + 3];

          tr = blendData[i];
          tg = blendData[i + 1];
          tb = blendData[i + 2];
          ta = blendData[i + 3];

          switch (this.mode) {
            case 'multiply':
              data[i] = r * tr / 255;
              data[i + 1] = g * tg / 255;
              data[i + 2] = b * tb / 255;
              data[i + 3] = a * ta / 255;
              break;
            case 'mask':
              data[i + 3] = ta;
              break;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
          uImage: gl.getUniformLocation(program, 'uImage'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var matrix = this.calculateMatrix();
        gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
        gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          image: this.image && this.image.toObject(),
          mode: this.mode,
          alpha: this.alpha
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} callback to be invoked after filter creation
     * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
     */
    fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
      fabric.Image.fromObject(object.image, function(image) {
        var options = fabric.util.object.clone(object);
        options.image = image;
        callback(new fabric.Image.filters.BlendImage(options));
      });
    };

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
        sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
        ceil = Math.ceil,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Resize image filter class
     * @class fabric.Image.filters.Resize
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Resize();
     * object.filters.push(filter);
     * object.applyFilters(canvas.renderAll.bind(canvas));
     */
    filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Resize',

      /**
       * Resize type
       * for webgl resizeType is just lanczos, for canvas2d can be:
       * bilinear, hermite, sliceHack, lanczos.
       * @param {String} resizeType
       * @default
       */
      resizeType: 'hermite',

      /**
       * Scale factor for resizing, x axis
       * @param {Number} scaleX
       * @default
       */
      scaleX: 1,

      /**
       * Scale factor for resizing, y axis
       * @param {Number} scaleY
       * @default
       */
      scaleY: 1,

      /**
       * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos
       * @param {Number} lanczosLobes
       * @default
       */
      lanczosLobes: 3,


      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uDelta: gl.getUniformLocation(program, 'uDelta'),
          uTaps: gl.getUniformLocation(program, 'uTaps'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
        gl.uniform1fv(uniformLocations.uTaps, this.taps);
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          var fragmentShader = this.generateShader(filterWindow);
          options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
        }
        return options.programCache[cacheKey];
      },

      getFilterWindow: function() {
        var scale = this.tempScale;
        return Math.ceil(this.lanczosLobes / scale);
      },

      getTaps: function() {
        var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,
            filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
        for (var i = 1; i <= filterWindow; i++) {
          taps[i - 1] = lobeFunction(i * scale);
        }
        return taps;
      },

      /**
       * Generate vertex and shader sources from the necessary steps numbers
       * @param {Number} filterWindow
       */
      generateShader: function(filterWindow) {
        var offsets = new Array(filterWindow),
            fragmentShader = this.fragmentSourceTOP, filterWindow;

        for (var i = 1; i <= filterWindow; i++) {
          offsets[i - 1] = i + '.0 * uDelta';
        }

        fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';
        fragmentShader += 'void main() {\n';
        fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';
        fragmentShader += '  float sum = 1.0;\n';

        offsets.forEach(function(offset, i) {
          fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';
          fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';
          fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';
        });
        fragmentShader += '  gl_FragColor = color / sum;\n';
        fragmentShader += '}';
        return fragmentShader;
      },

      fragmentSourceTOP: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec2 uDelta;\n' +
        'varying vec2 vTexCoord;\n',

      /**
       * Apply the resize filter to the image
       * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyTo: function(options) {
        if (options.webgl) {
          options.passes++;
          this.width = options.sourceWidth;
          this.horizontal = true;
          this.dW = Math.round(this.width * this.scaleX);
          this.dH = options.sourceHeight;
          this.tempScale = this.dW / this.width;
          this.taps = this.getTaps();
          options.destinationWidth = this.dW;
          this._setupFrameBuffer(options);
          this.applyToWebGL(options);
          this._swapTextures(options);
          options.sourceWidth = options.destinationWidth;

          this.height = options.sourceHeight;
          this.horizontal = false;
          this.dH = Math.round(this.height * this.scaleY);
          this.tempScale = this.dH / this.height;
          this.taps = this.getTaps();
          options.destinationHeight = this.dH;
          this._setupFrameBuffer(options);
          this.applyToWebGL(options);
          this._swapTextures(options);
          options.sourceHeight = options.destinationHeight;
        }
        else {
          this.applyTo2d(options);
        }
      },

      isNeutralState: function() {
        return this.scaleX === 1 && this.scaleY === 1;
      },

      lanczosCreate: function(lobes) {
        return function(x) {
          if (x >= lobes || x <= -lobes) {
            return 0.0;
          }
          if (x < 1.19209290E-07 && x > -1.19209290E-07) {
            return 1.0;
          }
          x *= Math.PI;
          var xx = x / lobes;
          return (sin(x) / x) * sin(xx) / xx;
        };
      },

      /**
       * Applies filter to canvas element
       * @memberOf fabric.Image.filters.Resize.prototype
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} scaleX
       * @param {Number} scaleY
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            scaleX = this.scaleX,
            scaleY = this.scaleY;

        this.rcpScaleX = 1 / scaleX;
        this.rcpScaleY = 1 / scaleY;

        var oW = imageData.width, oH = imageData.height,
            dW = round(oW * scaleX), dH = round(oH * scaleY),
            newData;

        if (this.resizeType === 'sliceHack') {
          newData = this.sliceByTwo(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'hermite') {
          newData = this.hermiteFastResize(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'bilinear') {
          newData = this.bilinearFiltering(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'lanczos') {
          newData = this.lanczosResize(options, oW, oH, dW, dH);
        }
        options.imageData = newData;
      },

      /**
       * Filter sliceByTwo
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      sliceByTwo: function(options, oW, oH, dW, dH) {
        var imageData = options.imageData,
            mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
            stepH = oH * mult, resources = fabric.filterBackend.resources,
            tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
        if (!resources.sliceByTwo) {
          resources.sliceByTwo = document.createElement('canvas');
        }
        tmpCanvas = resources.sliceByTwo;
        if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
          tmpCanvas.width = oW * 1.5;
          tmpCanvas.height = oH;
        }
        ctx = tmpCanvas.getContext('2d');
        ctx.clearRect(0, 0, oW * 1.5, oH);
        ctx.putImageData(imageData, 0, 0);

        dW = floor(dW);
        dH = floor(dH);

        while (!doneW || !doneH) {
          oW = stepW;
          oH = stepH;
          if (dW < floor(stepW * mult)) {
            stepW = floor(stepW * mult);
          }
          else {
            stepW = dW;
            doneW = true;
          }
          if (dH < floor(stepH * mult)) {
            stepH = floor(stepH * mult);
          }
          else {
            stepH = dH;
            doneH = true;
          }
          ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
          sX = dX;
          sY = dY;
          dY += stepH;
        }
        return ctx.getImageData(sX, sY, dW, dH);
      },

      /**
       * Filter lanczosResize
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      lanczosResize: function(options, oW, oH, dW, dH) {

        function process(u) {
          var v, i, weight, idx, a, red, green,
              blue, alpha, fX, fY;
          center.x = (u + 0.5) * ratioX;
          icenter.x = floor(center.x);
          for (v = 0; v < dH; v++) {
            center.y = (v + 0.5) * ratioY;
            icenter.y = floor(center.y);
            a = 0; red = 0; green = 0; blue = 0; alpha = 0;
            for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
              if (i < 0 || i >= oW) {
                continue;
              }
              fX = floor(1000 * abs(i - center.x));
              if (!cacheLanc[fX]) {
                cacheLanc[fX] = { };
              }
              for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
                if (j < 0 || j >= oH) {
                  continue;
                }
                fY = floor(1000 * abs(j - center.y));
                if (!cacheLanc[fX][fY]) {
                  cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
                }
                weight = cacheLanc[fX][fY];
                if (weight > 0) {
                  idx = (j * oW + i) * 4;
                  a += weight;
                  red += weight * srcData[idx];
                  green += weight * srcData[idx + 1];
                  blue += weight * srcData[idx + 2];
                  alpha += weight * srcData[idx + 3];
                }
              }
            }
            idx = (v * dW + u) * 4;
            destData[idx] = red / a;
            destData[idx + 1] = green / a;
            destData[idx + 2] = blue / a;
            destData[idx + 3] = alpha / a;
          }

          if (++u < dW) {
            return process(u);
          }
          else {
            return destImg;
          }
        }

        var srcData = options.imageData.data,
            destImg = options.ctx.createImageData(dW, dH),
            destData = destImg.data,
            lanczos = this.lanczosCreate(this.lanczosLobes),
            ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
            rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
            range2X = ceil(ratioX * this.lanczosLobes / 2),
            range2Y = ceil(ratioY * this.lanczosLobes / 2),
            cacheLanc = { }, center = { }, icenter = { };

        return process(0);
      },

      /**
       * bilinearFiltering
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      bilinearFiltering: function(options, oW, oH, dW, dH) {
        var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
            color, offset = 0, origPix, ratioX = this.rcpScaleX,
            ratioY = this.rcpScaleY,
            w4 = 4 * (oW - 1), img = options.imageData,
            pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
            destPixels = destImage.data;
        for (i = 0; i < dH; i++) {
          for (j = 0; j < dW; j++) {
            x = floor(ratioX * j);
            y = floor(ratioY * i);
            xDiff = ratioX * j - x;
            yDiff = ratioY * i - y;
            origPix = 4 * (y * oW + x);

            for (chnl = 0; chnl < 4; chnl++) {
              a = pixels[origPix + chnl];
              b = pixels[origPix + 4 + chnl];
              c = pixels[origPix + w4 + chnl];
              d = pixels[origPix + w4 + 4 + chnl];
              color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                      c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
              destPixels[offset++] = color;
            }
          }
        }
        return destImage;
      },

      /**
       * hermiteFastResize
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      hermiteFastResize: function(options, oW, oH, dW, dH) {
        var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
            ratioWHalf = ceil(ratioW / 2),
            ratioHHalf = ceil(ratioH / 2),
            img = options.imageData, data = img.data,
            img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
        for (var j = 0; j < dH; j++) {
          for (var i = 0; i < dW; i++) {
            var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
                gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
            for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
              var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                  centerX = (i + 0.5) * ratioW, w0 = dy * dy;
              for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
                var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                    w = sqrt(w0 + dx * dx);
                /* eslint-disable max-depth */
                if (w > 1 && w < -1) {
                  continue;
                }
                //hermite filter
                weight = 2 * w * w * w - 3 * w * w + 1;
                if (weight > 0) {
                  dx = 4 * (xx + yy * oW);
                  //alpha
                  gxA += weight * data[dx + 3];
                  weightsAlpha += weight;
                  //colors
                  if (data[dx + 3] < 255) {
                    weight = weight * data[dx + 3] / 250;
                  }
                  gxR += weight * data[dx];
                  gxG += weight * data[dx + 1];
                  gxB += weight * data[dx + 2];
                  weights += weight;
                }
                /* eslint-enable max-depth */
              }
            }
            data2[x2] = gxR / weights;
            data2[x2 + 1] = gxG / weights;
            data2[x2 + 2] = gxB / weights;
            data2[x2 + 3] = gxA / weightsAlpha;
          }
        }
        return img2;
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          scaleX: this.scaleX,
          scaleY: this.scaleY,
          resizeType: this.resizeType,
          lanczosLobes: this.lanczosLobes
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
     */
    fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Contrast filter class
     * @class fabric.Image.filters.Contrast
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Contrast({
     *   contrast: 40
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Contrast',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uContrast;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
          'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
          'gl_FragColor = color;\n' +
        '}',

      contrast: 0,

      mainParameter: 'contrast',

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Contrast.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
       */

      /**
        * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
        *
        * @param {Object} options
        * @param {ImageData} options.imageData The Uint8Array to be filtered.
        */
      applyTo2d: function(options) {
        if (this.contrast === 0) {
          return;
        }
        var imageData = options.imageData, i, len,
            data = imageData.data, len = data.length,
            contrast = Math.floor(this.contrast * 255),
            contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

        for (i = 0; i < len; i += 4) {
          data[i] = contrastF * (data[i] - 128) + 128;
          data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
          data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uContrast: gl.getUniformLocation(program, 'uContrast'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uContrast, this.contrast);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
     */
    fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Saturate filter class
     * @class fabric.Image.filters.Saturation
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Saturation({
     *   saturation: 100
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Saturation',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uSaturation;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float rgMax = max(color.r, color.g);\n' +
          'float rgbMax = max(rgMax, color.b);\n' +
          'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
          'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
          'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
          'gl_FragColor = color;\n' +
        '}',

      saturation: 0,

      mainParameter: 'saturation',

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Saturate.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
       */

      /**
       * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.saturation === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, len = data.length,
            adjust = -this.saturation, i, max;

        for (i = 0; i < len; i += 4) {
          max = Math.max(data[i], data[i + 1], data[i + 2]);
          data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
          data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
          data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uSaturation: gl.getUniformLocation(program, 'uSaturation'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
     */
    fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Blur filter class
     * @class fabric.Image.filters.Blur
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Blur({
     *   blur: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

      type: 'Blur',

      /*
  'gl_FragColor = vec4(0.0);',
  'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
  'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
  'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
  'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
  'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
  'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
  'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
  'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
  'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
  'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
  'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
  'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
  'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
  'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
  'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
  */

      /* eslint-disable max-len */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec2 uDelta;\n' +
        'varying vec2 vTexCoord;\n' +
        'const float nSamples = 15.0;\n' +
        'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
        'float random(vec3 scale) {\n' +
          /* use the fragment position for a different seed per-pixel */
          'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
        '}\n' +
        'void main() {\n' +
          'vec4 color = vec4(0.0);\n' +
          'float total = 0.0;\n' +
          'float offset = random(v3offset);\n' +
          'for (float t = -nSamples; t <= nSamples; t++) {\n' +
            'float percent = (t + offset - 0.5) / nSamples;\n' +
            'float weight = 1.0 - abs(percent);\n' +
            'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
            'total += weight;\n' +
          '}\n' +
          'gl_FragColor = color / total;\n' +
        '}',
      /* eslint-enable max-len */

      /**
       * blur value, in percentage of image dimensions.
       * specific to keep the image blur constant at different resolutions
       * range bewteen 0 and 1.
       */
      blur: 0,

      mainParameter: 'blur',

      applyTo: function(options) {
        if (options.webgl) {
          // this aspectRatio is used to give the same blur to vertical and horizontal
          this.aspectRatio = options.sourceWidth / options.sourceHeight;
          options.passes++;
          this._setupFrameBuffer(options);
          this.horizontal = true;
          this.applyToWebGL(options);
          this._swapTextures(options);
          this._setupFrameBuffer(options);
          this.horizontal = false;
          this.applyToWebGL(options);
          this._swapTextures(options);
        }
        else {
          this.applyTo2d(options);
        }
      },

      applyTo2d: function(options) {
        // paint canvasEl with current image data.
        //options.ctx.putImageData(options.imageData, 0, 0);
        options.imageData = this.simpleBlur(options);
      },

      simpleBlur: function(options) {
        var resources = options.filterBackend.resources, canvas1, canvas2,
            width = options.imageData.width,
            height = options.imageData.height;

        if (!resources.blurLayer1) {
          resources.blurLayer1 = fabric.util.createCanvasElement();
          resources.blurLayer2 = fabric.util.createCanvasElement();
        }
        canvas1 = resources.blurLayer1;
        canvas2 = resources.blurLayer2;
        if (canvas1.width !== width || canvas1.height !== height) {
          canvas2.width = canvas1.width = width;
          canvas2.height = canvas1.height = height;
        }
        var ctx1 = canvas1.getContext('2d'),
            ctx2 = canvas2.getContext('2d'),
            nSamples = 15,
            random, percent, j, i,
            blur = this.blur * 0.06 * 0.5;

        // load first canvas
        ctx1.putImageData(options.imageData, 0, 0);
        ctx2.clearRect(0, 0, width, height);

        for (i = -nSamples; i <= nSamples; i++) {
          random = (Math.random() - 0.5) / 4;
          percent = i / nSamples;
          j = blur * percent * width + random;
          ctx2.globalAlpha = 1 - Math.abs(percent);
          ctx2.drawImage(canvas1, j, random);
          ctx1.drawImage(canvas2, 0, 0);
          ctx2.globalAlpha = 1;
          ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        }
        for (i = -nSamples; i <= nSamples; i++) {
          random = (Math.random() - 0.5) / 4;
          percent = i / nSamples;
          j = blur * percent * height + random;
          ctx2.globalAlpha = 1 - Math.abs(percent);
          ctx2.drawImage(canvas1, random, j);
          ctx1.drawImage(canvas2, 0, 0);
          ctx2.globalAlpha = 1;
          ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        }
        options.ctx.drawImage(canvas1, 0, 0);
        var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
        ctx1.globalAlpha = 1;
        ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
        return newImageData;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          delta: gl.getUniformLocation(program, 'uDelta'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var delta = this.chooseRightDelta();
        gl.uniform2fv(uniformLocations.delta, delta);
      },

      /**
       * choose right value of image percentage to blur with
       * @returns {Array} a numeric array with delta values
       */
      chooseRightDelta: function() {
        var blurScale = 1, delta = [0, 0], blur;
        if (this.horizontal) {
          if (this.aspectRatio > 1) {
            // image is wide, i want to shrink radius horizontal
            blurScale = 1 / this.aspectRatio;
          }
        }
        else {
          if (this.aspectRatio < 1) {
            // image is tall, i want to shrink radius vertical
            blurScale = this.aspectRatio;
          }
        }
        blur = blurScale * this.blur * 0.12;
        if (this.horizontal) {
          delta[0] = blur;
        }
        else {
          delta[1] = blur;
        }
        return delta;
      },
    });

    /**
     * Deserialize a JSON definition of a BlurFilter into a concrete instance.
     */
    filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Gamma filter class
     * @class fabric.Image.filters.Gamma
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Gamma({
     *   brightness: 200
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Gamma',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec3 uGamma;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec3 correction = (1.0 / uGamma);\n' +
          'color.r = pow(color.r, correction.r);\n' +
          'color.g = pow(color.g, correction.g);\n' +
          'color.b = pow(color.b, correction.b);\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.rgb *= color.a;\n' +
        '}',

      /**
       * Gamma array value, from 0.01 to 2.2.
       * @param {Array} gamma
       * @default
       */
      gamma: [1, 1, 1],

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'gamma',

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        this.gamma = [1, 1, 1];
        filters.BaseFilter.prototype.initialize.call(this, options);
      },

      /**
       * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData, data = imageData.data,
            gamma = this.gamma, len = data.length,
            rInv = 1 / gamma[0], gInv = 1 / gamma[1],
            bInv = 1 / gamma[2], i;

        if (!this.rVals) {
          // eslint-disable-next-line
          this.rVals = new Uint8Array(256);
          // eslint-disable-next-line
          this.gVals = new Uint8Array(256);
          // eslint-disable-next-line
          this.bVals = new Uint8Array(256);
        }

        // This is an optimization - pre-compute a look-up table for each color channel
        // instead of performing these pow calls for each pixel in the image.
        for (i = 0, len = 256; i < len; i++) {
          this.rVals[i] = Math.pow(i / 255, rInv) * 255;
          this.gVals[i] = Math.pow(i / 255, gInv) * 255;
          this.bVals[i] = Math.pow(i / 255, bInv) * 255;
        }
        for (i = 0, len = data.length; i < len; i += 4) {
          data[i] = this.rVals[data[i]];
          data[i + 1] = this.gVals[data[i + 1]];
          data[i + 2] = this.bVals[data[i + 2]];
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uGamma: gl.getUniformLocation(program, 'uGamma'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform3fv(uniformLocations.uGamma, this.gamma);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
     */
    fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * A container class that knows how to apply a sequence of filters to an input image.
     */
    filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

      type: 'Composed',

      /**
       * A non sparse array of filters to apply
       */
      subFilters: [],

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        // create a new array instead mutating the prototype with push
        this.subFilters = this.subFilters.slice(0);
      },

      /**
       * Apply this container's filters to the input image provided.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be applied.
       */
      applyTo: function(options) {
        options.passes += this.subFilters.length - 1;
        this.subFilters.forEach(function(filter) {
          filter.applyTo(options);
        });
      },

      /**
       * Serialize this filter into JSON.
       *
       * @returns {Object} A JSON representation of this filter.
       */
      toObject: function() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
        });
      },

      isNeutralState: function() {
        return !this.subFilters.some(function(filter) { return !filter.isNeutralState(); });
      }
    });

    /**
     * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
     */
    fabric.Image.filters.Composed.fromObject = function(object, callback) {
      var filters = object.subFilters || [],
          subFilters = filters.map(function(filter) {
            return new fabric.Image.filters[filter.type](filter);
          }),
          instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
      callback && callback(instance);
      return instance;
    };
  })( exports );


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * HueRotation filter class
     * @class fabric.Image.filters.HueRotation
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.HueRotation({
     *   rotation: -0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'HueRotation',

      /**
       * HueRotation value, from -1 to 1.
       * the unit is radians
       * @param {Number} myParameter
       * @default
       */
      rotation: 0,

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'rotation',

      calculateMatrix: function() {
        var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad),
            aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
        this.matrix = [
          1, 0, 0, 0, 0,
          0, 1, 0, 0, 0,
          0, 0, 1, 0, 0,
          0, 0, 0, 1, 0
        ];
        this.matrix[0] = cos + OneMinusCos / 3;
        this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[6] = cos + aThird * OneMinusCos;
        this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[12] = cos + aThird * OneMinusCos;
      },

      /**
       * HueRotation isNeutralState implementation
       * Used only in image applyFilters to discard filters that will not have an effect
       * on the image
       * @param {Object} options
       **/
      isNeutralState: function(options) {
        this.calculateMatrix();
        return filters.BaseFilter.prototype.isNeutralState.call(this, options);
      },

      /**
       * Apply this filter to the input image data provided.
       *
       * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyTo: function(options) {
        this.calculateMatrix();
        filters.BaseFilter.prototype.applyTo.call(this, options);
      },

    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
     */
    fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })( exports );


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        clone = fabric.util.object.clone;

    if (fabric.Text) {
      fabric.warn('fabric.Text is already defined');
      return;
    }

    /**
     * Text class
     * @class fabric.Text
     * @extends fabric.Object
     * @return {fabric.Text} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
     * @see {@link fabric.Text#initialize} for constructor definition
     */
    fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

      /**
       * Properties which when set cause object to change dimensions
       * @type Array
       * @private
       */
      _dimensionAffectingProps: [
        'fontSize',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'lineHeight',
        'text',
        'charSpacing',
        'textAlign',
        'styles',
      ],

      /**
       * @private
       */
      _reNewline: /\r?\n/,

      /**
       * Use this regular expression to filter for whitespaces that is not a new line.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reSpacesAndTabs: /[ \t\r]/g,

      /**
       * Use this regular expression to filter for whitespace that is not a new line.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reSpaceAndTab: /[ \t\r]/,

      /**
       * Use this regular expression to filter consecutive groups of non spaces.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reWords: /\S+/g,

      /**
       * Type of an object
       * @type String
       * @default
       */
      type:                 'text',

      /**
       * Font size (in pixels)
       * @type Number
       * @default
       */
      fontSize:             40,

      /**
       * Font weight (e.g. bold, normal, 400, 600, 800)
       * @type {(Number|String)}
       * @default
       */
      fontWeight:           'normal',

      /**
       * Font family
       * @type String
       * @default
       */
      fontFamily:           'Times New Roman',

      /**
       * Text decoration underline.
       * @type Boolean
       * @default
       */
      underline:       false,

      /**
       * Text decoration overline.
       * @type Boolean
       * @default
       */
      overline:       false,

      /**
       * Text decoration linethrough.
       * @type Boolean
       * @default
       */
      linethrough:       false,

      /**
       * Text alignment. Possible values: "left", "center", "right", "justify",
       * "justify-left", "justify-center" or "justify-right".
       * @type String
       * @default
       */
      textAlign:            'left',

      /**
       * Font style . Possible values: "", "normal", "italic" or "oblique".
       * @type String
       * @default
       */
      fontStyle:            'normal',

      /**
       * Line height
       * @type Number
       * @default
       */
      lineHeight:           1.16,

      /**
       * Superscript schema object (minimum overlap)
       * @type {Object}
       * @default
       */
      superscript: {
        size:      0.60, // fontSize factor
        baseline: -0.35  // baseline-shift factor (upwards)
      },

      /**
       * Subscript schema object (minimum overlap)
       * @type {Object}
       * @default
       */
      subscript: {
        size:      0.60, // fontSize factor
        baseline:  0.11  // baseline-shift factor (downwards)
      },

      /**
       * Background color of text lines
       * @type String
       * @default
       */
      textBackgroundColor:  '',

      /**
       * List of properties to consider when checking if
       * state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('fontFamily',
        'fontWeight',
        'fontSize',
        'text',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'fontStyle',
        'lineHeight',
        'textBackgroundColor',
        'charSpacing',
        'styles'),

      /**
       * List of properties to consider when checking if cache needs refresh
       * @type Array
       */
      cacheProperties: fabric.Object.prototype.cacheProperties.concat('fontFamily',
        'fontWeight',
        'fontSize',
        'text',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'fontStyle',
        'lineHeight',
        'textBackgroundColor',
        'charSpacing',
        'styles'),

      /**
       * When defined, an object is rendered via stroke and this property specifies its color.
       * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
       * @type String
       * @default
       */
      stroke:               null,

      /**
       * Shadow object representing shadow of this shape.
       * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
       * @type fabric.Shadow
       * @default
       */
      shadow:               null,

      /**
       * @private
       */
      _fontSizeFraction: 0.222,

      /**
       * @private
       */
      offsets: {
        underline: 0.10,
        linethrough: -0.315,
        overline: -0.88
      },

      /**
       * Text Line proportion to font Size (in pixels)
       * @type Number
       * @default
       */
      _fontSizeMult:             1.13,

      /**
       * additional space between characters
       * expressed in thousands of em unit
       * @type Number
       * @default
       */
      charSpacing:             0,

      /**
       * Object containing character styles - top-level properties -> line numbers,
       * 2nd-level properties - charater numbers
       * @type Object
       * @default
       */
      styles: null,

      /**
       * Reference to a context to measure text char or couple of chars
       * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
       * once created it will be referenced on fabric._measuringContext to avoide creating a canvas for every
       * text object created.
       * @type {CanvasRenderingContext2D}
       * @default
       */
      _measuringContext: null,

      /**
       * Baseline shift, stlyes only, keep at 0 for the main text object
       * @type {Number}
       * @default
       */
      deltaY: 0,

      /**
       * Array of properties that define a style unit (of 'styles').
       * @type {Array}
       * @default
       */
      _styleProperties: [
        'stroke',
        'strokeWidth',
        'fill',
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'underline',
        'overline',
        'linethrough',
        'deltaY',
        'textBackgroundColor',
      ],

      /**
       * contains characters bounding boxes
       */
      __charBounds: [],

      /**
       * use this size when measuring text. To avoid IE11 rounding errors
       * @type {Number}
       * @default
       * @readonly
       * @private
       */
      CACHE_FONT_SIZE: 400,

      /**
       * contains the min text width to avoid getting 0
       * @type {Number}
       * @default
       */
      MIN_TEXT_WIDTH: 2,

      /**
       * Constructor
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.Text} thisArg
       */
      initialize: function(text, options) {
        this.styles = options ? (options.styles || { }) : { };
        this.text = text;
        this.__skipDimension = true;
        this.callSuper('initialize', options);
        this.__skipDimension = false;
        this.initDimensions();
        this.setCoords();
        this.setupState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Return a contex for measurement of text string.
       * if created it gets stored for reuse
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.Text} thisArg
       */
      getMeasuringContext: function() {
        // if we did not return we have to measure something.
        if (!fabric._measuringContext) {
          fabric._measuringContext = this.canvas && this.canvas.contextCache ||
            fabric.util.createCanvasElement().getContext('2d');
        }
        return fabric._measuringContext;
      },

      /**
       * @private
       * Divides text into lines of text and lines of graphemes.
       */
      _splitText: function() {
        var newLines = this._splitTextIntoLines(this.text);
        this.textLines = newLines.lines;
        this._textLines = newLines.graphemeLines;
        this._unwrappedTextLines = newLines._unwrappedLines;
        this._text = newLines.graphemeText;
        return newLines;
      },

      /**
       * Initialize or update text dimensions.
       * Updates this.width and this.height with the proper values.
       * Does not return dimensions.
       */
      initDimensions: function() {
        if (this.__skipDimension) {
          return;
        }
        this._splitText();
        this._clearCache();
        this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
        if (this.textAlign.indexOf('justify') !== -1) {
          // once text is measured we need to make space fatter to make justified text.
          this.enlargeSpaces();
        }
        this.height = this.calcTextHeight();
        this.saveState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Enlarge space boxes and shift the others
       */
      enlargeSpaces: function() {
        var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          if (this.textAlign !== 'justify' && (i === len - 1 || this.isEndOfWrapping(i))) {
            continue;
          }
          accumulatedSpace = 0;
          line = this._textLines[i];
          currentLineWidth = this.getLineWidth(i);
          if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
            numberOfSpaces = spaces.length;
            diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
            for (var j = 0, jlen = line.length; j <= jlen; j++) {
              charBound = this.__charBounds[i][j];
              if (this._reSpaceAndTab.test(line[j])) {
                charBound.width += diffSpace;
                charBound.kernedWidth += diffSpace;
                charBound.left += accumulatedSpace;
                accumulatedSpace += diffSpace;
              }
              else {
                charBound.left += accumulatedSpace;
              }
            }
          }
        }
      },

      /**
       * Detect if the text line is ended with an hard break
       * text and itext do not have wrapping, return false
       * @return {Boolean}
       */
      isEndOfWrapping: function(lineIndex) {
        return lineIndex === this._textLines.length - 1;
      },

      /**
       * Detect if a line has a linebreak and so we need to account for it when moving
       * and counting style.
       * It return always for text and Itext.
       * @return Number
       */
      missingNewlineOffset: function() {
        return 1;
      },

      /**
       * Returns string representation of an instance
       * @return {String} String representation of text object
       */
      toString: function() {
        return '#<fabric.Text (' + this.complexity() +
          '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
      },

      /**
       * Return the dimension and the zoom level needed to create a cache canvas
       * big enough to host the object to be cached.
       * @private
       * @param {Object} dim.x width of object to be cached
       * @param {Object} dim.y height of object to be cached
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _getCacheCanvasDimensions: function() {
        var dims = this.callSuper('_getCacheCanvasDimensions');
        var fontSize = this.fontSize;
        dims.width += fontSize * dims.zoomX;
        dims.height += fontSize * dims.zoomY;
        return dims;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        this._setTextStyles(ctx);
        this._renderTextLinesBackground(ctx);
        this._renderTextDecoration(ctx, 'underline');
        this._renderText(ctx);
        this._renderTextDecoration(ctx, 'overline');
        this._renderTextDecoration(ctx, 'linethrough');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderText: function(ctx) {
        if (this.paintFirst === 'stroke') {
          this._renderTextStroke(ctx);
          this._renderTextFill(ctx);
        }
        else {
          this._renderTextFill(ctx);
          this._renderTextStroke(ctx);
        }
      },

      /**
       * Set the font parameter of the context with the object properties or with charStyle
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [charStyle] object with font style properties
       * @param {String} [charStyle.fontFamily] Font Family
       * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
       * @param {String} [charStyle.fontWeight] Font weight
       * @param {String} [charStyle.fontStyle] Font style (italic|normal)
       */
      _setTextStyles: function(ctx, charStyle, forMeasuring) {
        ctx.textBaseline = 'alphabetic';
        ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
      },

      /**
       * calculate and return the text Width measuring each line.
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @return {Number} Maximum width of fabric.Text object
       */
      calcTextWidth: function() {
        var maxWidth = this.getLineWidth(0);

        for (var i = 1, len = this._textLines.length; i < len; i++) {
          var currentLineWidth = this.getLineWidth(i);
          if (currentLineWidth > maxWidth) {
            maxWidth = currentLineWidth;
          }
        }
        return maxWidth;
      },

      /**
       * @private
       * @param {String} method Method name ("fillText" or "strokeText")
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} line Text to render
       * @param {Number} left Left position of text
       * @param {Number} top Top position of text
       * @param {Number} lineIndex Index of a line in a text
       */
      _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
        this._renderChars(method, ctx, line, left, top, lineIndex);
      },

      /**
       * Renders the text background for lines, taking care of style
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextLinesBackground: function(ctx) {
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
          return;
        }
        var lineTopOffset = 0, heightOfLine,
            lineLeftOffset, originalFill = ctx.fillStyle,
            line, lastColor,
            leftOffset = this._getLeftOffset(),
            topOffset = this._getTopOffset(),
            boxStart = 0, boxWidth = 0, charBox, currentColor;

        for (var i = 0, len = this._textLines.length; i < len; i++) {
          heightOfLine = this.getHeightOfLine(i);
          if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
            lineTopOffset += heightOfLine;
            continue;
          }
          line = this._textLines[i];
          lineLeftOffset = this._getLineLeftOffset(i);
          boxWidth = 0;
          boxStart = 0;
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
          for (var j = 0, jlen = line.length; j < jlen; j++) {
            charBox = this.__charBounds[i][j];
            currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
            if (currentColor !== lastColor) {
              ctx.fillStyle = lastColor;
              lastColor && ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                topOffset + lineTopOffset,
                boxWidth,
                heightOfLine / this.lineHeight
              );
              boxStart = charBox.left;
              boxWidth = charBox.width;
              lastColor = currentColor;
            }
            else {
              boxWidth += charBox.kernedWidth;
            }
          }
          if (currentColor) {
            ctx.fillStyle = currentColor;
            ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              topOffset + lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
          }
          lineTopOffset += heightOfLine;
        }
        ctx.fillStyle = originalFill;
        // if there is text background color no
        // other shadows should be casted
        this._removeShadow(ctx);
      },

      /**
       * @private
       * @param {Object} decl style declaration for cache
       * @param {String} decl.fontFamily fontFamily
       * @param {String} decl.fontStyle fontStyle
       * @param {String} decl.fontWeight fontWeight
       * @return {Object} reference to cache
       */
      getFontCache: function(decl) {
        var fontFamily = decl.fontFamily.toLowerCase();
        if (!fabric.charWidthsCache[fontFamily]) {
          fabric.charWidthsCache[fontFamily] = { };
        }
        var cache = fabric.charWidthsCache[fontFamily],
            cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
        if (!cache[cacheProp]) {
          cache[cacheProp] = { };
        }
        return cache[cacheProp];
      },

      /**
       * apply all the character style to canvas for rendering
       * @private
       * @param {String} _char
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} [decl]
       */
      _applyCharStyles: function(method, ctx, lineIndex, charIndex, styleDeclaration) {

        this._setFillStyles(ctx, styleDeclaration);
        this._setStrokeStyles(ctx, styleDeclaration);

        ctx.font = this._getFontDeclaration(styleDeclaration);
      },

      /**
       * measure and return the width of a single character.
       * possibly overridden to accommodate different measure logic or
       * to hook some external lib for character measurement
       * @private
       * @param {String} _char, char to be measured
       * @param {Object} charStyle style of char to be measured
       * @param {String} [previousChar] previous char
       * @param {Object} [prevCharStyle] style of previous char
       */
      _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
        // first i try to return from cache
        var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
            previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
            stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
            fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;

        if (previousChar && fontCache[previousChar] !== undefined) {
          previousWidth = fontCache[previousChar];
        }
        if (fontCache[_char] !== undefined) {
          kernedWidth = width = fontCache[_char];
        }
        if (stylesAreEqual && fontCache[couple] !== undefined) {
          coupleWidth = fontCache[couple];
          kernedWidth = coupleWidth - previousWidth;
        }
        if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {
          var ctx = this.getMeasuringContext();
          // send a TRUE to specify measuring font size CACHE_FONT_SIZE
          this._setTextStyles(ctx, charStyle, true);
        }
        if (width === undefined) {
          kernedWidth = width = ctx.measureText(_char).width;
          fontCache[_char] = width;
        }
        if (previousWidth === undefined && stylesAreEqual && previousChar) {
          previousWidth = ctx.measureText(previousChar).width;
          fontCache[previousChar] = previousWidth;
        }
        if (stylesAreEqual && coupleWidth === undefined) {
          // we can measure the kerning couple and subtract the width of the previous character
          coupleWidth = ctx.measureText(couple).width;
          fontCache[couple] = coupleWidth;
          kernedWidth = coupleWidth - previousWidth;
        }
        return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
      },

      /**
       * Computes height of character at given position
       * @param {Number} line the line index number
       * @param {Number} _char the character index number
       * @return {Number} fontSize of the character
       */
      getHeightOfChar: function(line, _char) {
        return this.getValueOfPropertyAt(line, _char, 'fontSize');
      },

      /**
       * measure a text line measuring all characters.
       * @param {Number} lineIndex line number
       * @return {Number} Line width
       */
      measureLine: function(lineIndex) {
        var lineInfo = this._measureLine(lineIndex);
        if (this.charSpacing !== 0) {
          lineInfo.width -= this._getWidthOfCharSpacing();
        }
        if (lineInfo.width < 0) {
          lineInfo.width = 0;
        }
        return lineInfo;
      },

      /**
       * measure every grapheme of a line, populating __charBounds
       * @param {Number} lineIndex
       * @return {Object} object.width total width of characters
       * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
       */
      _measureLine: function(lineIndex) {
        var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
            graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length);

        this.__charBounds[lineIndex] = lineBounds;
        for (i = 0; i < line.length; i++) {
          grapheme = line[i];
          graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
          lineBounds[i] = graphemeInfo;
          width += graphemeInfo.kernedWidth;
          prevGrapheme = grapheme;
        }
        // this latest bound box represent the last character of the line
        // to simplify cursor handling in interactive mode.
        lineBounds[i] = {
          left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
          width: 0,
          kernedWidth: 0,
          height: this.fontSize
        };
        return { width: width, numOfSpaces: numOfSpaces };
      },

      /**
       * Measure and return the info of a single grapheme.
       * needs the the info of previous graphemes already filled
       * @private
       * @param {String} grapheme to be measured
       * @param {Number} lineIndex index of the line where the char is
       * @param {Number} charIndex position in the line
       * @param {String} [prevGrapheme] character preceding the one to be measured
       */
      _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
        var style = this.getCompleteStyleDeclaration(lineIndex, charIndex),
            prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
            info = this._measureChar(grapheme, style, prevGrapheme, prevStyle),
            kernedWidth = info.kernedWidth,
            width = info.width, charSpacing;

        if (this.charSpacing !== 0) {
          charSpacing = this._getWidthOfCharSpacing();
          width += charSpacing;
          kernedWidth += charSpacing;
        }

        var box = {
          width: width,
          left: 0,
          height: style.fontSize,
          kernedWidth: kernedWidth,
          deltaY: style.deltaY,
        };
        if (charIndex > 0 && !skipLeft) {
          var previousBox = this.__charBounds[lineIndex][charIndex - 1];
          box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
        }
        return box;
      },

      /**
       * Calculate height of line at 'lineIndex'
       * @param {Number} lineIndex index of line to calculate
       * @return {Number}
       */
      getHeightOfLine: function(lineIndex) {
        if (this.__lineHeights[lineIndex]) {
          return this.__lineHeights[lineIndex];
        }

        var line = this._textLines[lineIndex],
            // char 0 is measured before the line cycle because it nneds to char
            // emptylines
            maxHeight = this.getHeightOfChar(lineIndex, 0);
        for (var i = 1, len = line.length; i < len; i++) {
          maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
        }

        return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
      },

      /**
       * Calculate text box height
       */
      calcTextHeight: function() {
        var lineHeight, height = 0;
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          lineHeight = this.getHeightOfLine(i);
          height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
        }
        return height;
      },

      /**
       * @private
       * @return {Number} Left offset
       */
      _getLeftOffset: function() {
        return -this.width / 2;
      },

      /**
       * @private
       * @return {Number} Top offset
       */
      _getTopOffset: function() {
        return -this.height / 2;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} filler fabric.Pattern or fabric.Gradient
       * @return {Object} offset.offsetX offset for text rendering
       * @return {Object} offset.offsetY offset for text rendering
       */
      _applyPatternGradientTransform: function(ctx, filler) {
        if (!filler || !filler.toLive) {
          return { offsetX: 0, offsetY: 0 };
        }
        var offsetX = -this.width / 2 + filler.offsetX || 0,
            offsetY = -this.height / 2 + filler.offsetY || 0;

        ctx.transform(1, 0, 0, 1, offsetX, offsetY);
        return { offsetX: offsetX, offsetY: offsetY };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} method Method name ("fillText" or "strokeText")
       */
      _renderTextCommon: function(ctx, method) {
        ctx.save();
        var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset(),
            offsets = this._applyPatternGradientTransform(ctx, method === 'fillText' ? this.fill : this.stroke);
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          var heightOfLine = this.getHeightOfLine(i),
              maxHeight = heightOfLine / this.lineHeight,
              leftOffset = this._getLineLeftOffset(i);
          this._renderTextLine(
            method,
            ctx,
            this._textLines[i],
            left + leftOffset - offsets.offsetX,
            top + lineHeights + maxHeight - offsets.offsetY,
            i
          );
          lineHeights += heightOfLine;
        }
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextFill: function(ctx) {
        if (!this.fill && !this.styleHas('fill')) {
          return;
        }

        this._renderTextCommon(ctx, 'fillText');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextStroke: function(ctx) {
        if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
          return;
        }

        if (this.shadow && !this.shadow.affectStroke) {
          this._removeShadow(ctx);
        }

        ctx.save();
        this._setLineDash(ctx, this.strokeDashArray);
        ctx.beginPath();
        this._renderTextCommon(ctx, 'strokeText');
        ctx.closePath();
        ctx.restore();
      },

      /**
       * @private
       * @param {String} method
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} line Content of the line
       * @param {Number} left
       * @param {Number} top
       * @param {Number} lineIndex
       * @param {Number} charOffset
       */
      _renderChars: function(method, ctx, line, left, top, lineIndex) {
        // set proper line offset
        var lineHeight = this.getHeightOfLine(lineIndex),
            isJustify = this.textAlign.indexOf('justify') !== -1,
            actualStyle,
            nextStyle,
            charsToRender = '',
            charBox,
            boxWidth = 0,
            timeToRender,
            shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex);

        ctx.save();
        top -= lineHeight * this._fontSizeFraction / this.lineHeight;
        if (shortCut) {
          // render all the line in one pass without checking
          this._renderChar(method, ctx, lineIndex, 0, this.textLines[lineIndex], left, top, lineHeight);
          ctx.restore();
          return;
        }
        for (var i = 0, len = line.length - 1; i <= len; i++) {
          timeToRender = i === len || this.charSpacing;
          charsToRender += line[i];
          charBox = this.__charBounds[lineIndex][i];
          if (boxWidth === 0) {
            left += charBox.kernedWidth - charBox.width;
            boxWidth += charBox.width;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
          if (isJustify && !timeToRender) {
            if (this._reSpaceAndTab.test(line[i])) {
              timeToRender = true;
            }
          }
          if (!timeToRender) {
            // if we have charSpacing, we render char by char
            actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
            nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
            timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
          }
          if (timeToRender) {
            this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);
            charsToRender = '';
            actualStyle = nextStyle;
            left += boxWidth;
            boxWidth = 0;
          }
        }
        ctx.restore();
      },

      /**
       * @private
       * @param {String} method
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {String} _char
       * @param {Number} left Left coordinate
       * @param {Number} top Top coordinate
       * @param {Number} lineHeight Height of the line
       */
      _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
        var decl = this._getStyleDeclaration(lineIndex, charIndex),
            fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
            shouldFill = method === 'fillText' && fullDecl.fill,
            shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth;

        if (!shouldStroke && !shouldFill) {
          return;
        }
        decl && ctx.save();

        this._applyCharStyles(method, ctx, lineIndex, charIndex, fullDecl);

        if (decl && decl.textBackgroundColor) {
          this._removeShadow(ctx);
        }
        if (decl && decl.deltaY) {
          top += decl.deltaY;
        }

        shouldFill && ctx.fillText(_char, left, top);
        shouldStroke && ctx.strokeText(_char, left, top);
        decl && ctx.restore();
      },

      /**
       * Turns the character into a 'superior figure' (i.e. 'superscript')
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      setSuperscript: function(start, end) {
        return this._setScript(start, end, this.superscript);
      },

      /**
       * Turns the character into an 'inferior figure' (i.e. 'subscript')
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      setSubscript: function(start, end) {
        return this._setScript(start, end, this.subscript);
      },

      /**
       * Applies 'schema' at given position
       * @private
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @param {Number} schema
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      _setScript: function(start, end, schema) {
        var loc = this.get2DCursorLocation(start, true),
            fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'fontSize'),
            dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),
            style = { fontSize: fontSize * schema.size, deltaY: dy + fontSize * schema.baseline };
        this.setSelectionStyles(style, start, end);
        return this;
      },

      /**
       * @private
       * @param {Object} prevStyle
       * @param {Object} thisStyle
       */
      _hasStyleChanged: function(prevStyle, thisStyle) {
        return prevStyle.fill !== thisStyle.fill ||
                prevStyle.stroke !== thisStyle.stroke ||
                prevStyle.strokeWidth !== thisStyle.strokeWidth ||
                prevStyle.fontSize !== thisStyle.fontSize ||
                prevStyle.fontFamily !== thisStyle.fontFamily ||
                prevStyle.fontWeight !== thisStyle.fontWeight ||
                prevStyle.fontStyle !== thisStyle.fontStyle ||
                prevStyle.deltaY !== thisStyle.deltaY;
      },

      /**
       * @private
       * @param {Object} prevStyle
       * @param {Object} thisStyle
       */
      _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
        return this._hasStyleChanged(prevStyle, thisStyle) ||
          prevStyle.overline !== thisStyle.overline ||
          prevStyle.underline !== thisStyle.underline ||
          prevStyle.linethrough !== thisStyle.linethrough;
      },

      /**
       * @private
       * @param {Number} lineIndex index text line
       * @return {Number} Line left offset
       */
      _getLineLeftOffset: function(lineIndex) {
        var lineWidth = this.getLineWidth(lineIndex);
        if (this.textAlign === 'center') {
          return (this.width - lineWidth) / 2;
        }
        if (this.textAlign === 'right') {
          return this.width - lineWidth;
        }
        if (this.textAlign === 'justify-center' && this.isEndOfWrapping(lineIndex)) {
          return (this.width - lineWidth) / 2;
        }
        if (this.textAlign === 'justify-right' && this.isEndOfWrapping(lineIndex)) {
          return this.width - lineWidth;
        }
        return 0;
      },

      /**
       * @private
       */
      _clearCache: function() {
        this.__lineWidths = [];
        this.__lineHeights = [];
        this.__charBounds = [];
      },

      /**
       * @private
       */
      _shouldClearDimensionCache: function() {
        var shouldClear = this._forceClearCache;
        shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
        if (shouldClear) {
          this.dirty = true;
          this._forceClearCache = false;
        }
        return shouldClear;
      },

      /**
       * Measure a single line given its index. Used to calculate the initial
       * text bounding box. The values are calculated and stored in __lineWidths cache.
       * @private
       * @param {Number} lineIndex line number
       * @return {Number} Line width
       */
      getLineWidth: function(lineIndex) {
        if (this.__lineWidths[lineIndex]) {
          return this.__lineWidths[lineIndex];
        }

        var width, line = this._textLines[lineIndex], lineInfo;

        if (line === '') {
          width = 0;
        }
        else {
          lineInfo = this.measureLine(lineIndex);
          width = lineInfo.width;
        }
        this.__lineWidths[lineIndex] = width;
        return width;
      },

      _getWidthOfCharSpacing: function() {
        if (this.charSpacing !== 0) {
          return this.fontSize * this.charSpacing / 1000;
        }
        return 0;
      },

      /**
       * Retrieves the value of property at given character position
       * @param {Number} lineIndex the line number
       * @param {Number} charIndex the charater number
       * @param {String} property the property name
       * @returns the value of 'property'
       */
      getValueOfPropertyAt: function(lineIndex, charIndex, property) {
        var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
        if (charStyle && typeof charStyle[property] !== 'undefined') {
          return charStyle[property];
        }
        return this[property];
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextDecoration: function(ctx, type) {
        if (!this[type] && !this.styleHas(type)) {
          return;
        }
        var heightOfLine, size, _size,
            lineLeftOffset, dy, _dy,
            line, lastDecoration,
            leftOffset = this._getLeftOffset(),
            topOffset = this._getTopOffset(), top,
            boxStart, boxWidth, charBox, currentDecoration,
            maxHeight, currentFill, lastFill,
            charSpacing = this._getWidthOfCharSpacing();

        for (var i = 0, len = this._textLines.length; i < len; i++) {
          heightOfLine = this.getHeightOfLine(i);
          if (!this[type] && !this.styleHas(type, i)) {
            topOffset += heightOfLine;
            continue;
          }
          line = this._textLines[i];
          maxHeight = heightOfLine / this.lineHeight;
          lineLeftOffset = this._getLineLeftOffset(i);
          boxStart = 0;
          boxWidth = 0;
          lastDecoration = this.getValueOfPropertyAt(i, 0, type);
          lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
          top = topOffset + maxHeight * (1 - this._fontSizeFraction);
          size = this.getHeightOfChar(i, 0);
          dy = this.getValueOfPropertyAt(i, 0, 'deltaY');
          for (var j = 0, jlen = line.length; j < jlen; j++) {
            charBox = this.__charBounds[i][j];
            currentDecoration = this.getValueOfPropertyAt(i, j, type);
            currentFill = this.getValueOfPropertyAt(i, j, 'fill');
            _size = this.getHeightOfChar(i, j);
            _dy = this.getValueOfPropertyAt(i, j, 'deltaY');
            if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) &&
                boxWidth > 0) {
              ctx.fillStyle = lastFill;
              lastDecoration && lastFill && ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                top + this.offsets[type] * size + dy,
                boxWidth,
                this.fontSize / 15
              );
              boxStart = charBox.left;
              boxWidth = charBox.width;
              lastDecoration = currentDecoration;
              lastFill = currentFill;
              size = _size;
              dy = _dy;
            }
            else {
              boxWidth += charBox.kernedWidth;
            }
          }
          ctx.fillStyle = currentFill;
          currentDecoration && currentFill && ctx.fillRect(
            leftOffset + lineLeftOffset + boxStart,
            top + this.offsets[type] * size + dy,
            boxWidth - charSpacing,
            this.fontSize / 15
          );
          topOffset += heightOfLine;
        }
        // if there is text background color no
        // other shadows should be casted
        this._removeShadow(ctx);
      },

      /**
       * return font declaration string for canvas context
       * @param {Object} [styleObject] object
       * @returns {String} font declaration formatted for canvas context.
       */
      _getFontDeclaration: function(styleObject, forMeasuring) {
        var style = styleObject || this, family = this.fontFamily,
            fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
        var fontFamily = family === undefined ||
        family.indexOf('\'') > -1 || family.indexOf(',') > -1 ||
        family.indexOf('"') > -1 || fontIsGeneric
          ? style.fontFamily : '"' + style.fontFamily + '"';
        return [
          // node-canvas needs "weight style", while browsers need "style weight"
          // verify if this can be fixed in JSDOM
          (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
          (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
          forMeasuring ? this.CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
          fontFamily
        ].join(' ');
      },

      /**
       * Renders text instance on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        // do not render if object is not visible
        if (!this.visible) {
          return;
        }
        if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
          return;
        }
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
        }
        this.callSuper('render', ctx);
      },

      /**
       * Returns the text as an array of lines.
       * @param {String} text text to split
       * @returns {Array} Lines in the text
       */
      _splitTextIntoLines: function(text) {
        var lines = text.split(this._reNewline),
            newLines = new Array(lines.length),
            newLine = ['\n'],
            newText = [];
        for (var i = 0; i < lines.length; i++) {
          newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
          newText = newText.concat(newLines[i], newLine);
        }
        newText.pop();
        return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var additionalProperties = [
          'text',
          'fontSize',
          'fontWeight',
          'fontFamily',
          'fontStyle',
          'lineHeight',
          'underline',
          'overline',
          'linethrough',
          'textAlign',
          'textBackgroundColor',
          'charSpacing',
        ].concat(propertiesToInclude);
        var obj = this.callSuper('toObject', additionalProperties);
        obj.styles = clone(this.styles, true);
        return obj;
      },

      /**
       * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
       * @param {String|Object} key Property name or object (if object, iterate over the object properties)
       * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      set: function(key, value) {
        this.callSuper('set', key, value);
        var needsDims = false;
        if (typeof key === 'object') {
          for (var _key in key) {
            needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
          }
        }
        else {
          needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
        }
        if (needsDims) {
          this.initDimensions();
          this.setCoords();
        }
        return this;
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity
       */
      complexity: function() {
        return 1;
      }
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
     * @static
     * @memberOf fabric.Text
     * @see: http://www.w3.org/TR/SVG/text.html#TextElement
     */
    fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
      'x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));

    /**
     * Default SVG font size
     * @static
     * @memberOf fabric.Text
     */
    fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

    /**
     * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
     * @static
     * @memberOf fabric.Text
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Text.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }

      var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
          parsedAnchor = parsedAttributes.textAnchor || 'left';
      options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

      options.top = options.top || 0;
      options.left = options.left || 0;
      if (parsedAttributes.textDecoration) {
        var textDecoration = parsedAttributes.textDecoration;
        if (textDecoration.indexOf('underline') !== -1) {
          options.underline = true;
        }
        if (textDecoration.indexOf('overline') !== -1) {
          options.overline = true;
        }
        if (textDecoration.indexOf('line-through') !== -1) {
          options.linethrough = true;
        }
        delete options.textDecoration;
      }
      if ('dx' in parsedAttributes) {
        options.left += parsedAttributes.dx;
      }
      if ('dy' in parsedAttributes) {
        options.top += parsedAttributes.dy;
      }
      if (!('fontSize' in options)) {
        options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }

      var textContent = '';

      // The XML is not properly parsed in IE9 so a workaround to get
      // textContent is through firstChild.data. Another workaround would be
      // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
      if (!('textContent' in element)) {
        if ('firstChild' in element && element.firstChild !== null) {
          if ('data' in element.firstChild && element.firstChild.data !== null) {
            textContent = element.firstChild.data;
          }
        }
      }
      else {
        textContent = element.textContent;
      }

      textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
      var originalStrokeWidth = options.strokeWidth;
      options.strokeWidth = 0;

      var text = new fabric.Text(textContent, options),
          textHeightScaleFactor = text.getScaledHeight() / text.height,
          lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
          scaledDiff = lineHeightDiff * textHeightScaleFactor,
          textHeight = text.getScaledHeight() + scaledDiff,
          offX = 0;
      /*
        Adjust positioning:
          x/y attributes in SVG correspond to the bottom-left corner of text bounding box
          fabric output by default at top, left.
      */
      if (parsedAnchor === 'center') {
        offX = text.getScaledWidth() / 2;
      }
      if (parsedAnchor === 'right') {
        offX = text.getScaledWidth();
      }
      text.set({
        left: text.left - offX,
        top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
        strokeWidth: typeof originalStrokeWidth !== 'undefined' ? originalStrokeWidth : 1,
      });
      callback(text);
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Text instance from an object representation
     * @static
     * @memberOf fabric.Text
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
     */
    fabric.Text.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Text', object, callback, 'text');
    };

    fabric.Text.genericFonts = ['sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'];

    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

  })( exports );


  (function() {
    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
      /**
       * Returns true if object has no styling or no styling in a line
       * @param {Number} lineIndex , lineIndex is on wrapped lines.
       * @return {Boolean}
       */
      isEmptyStyles: function(lineIndex) {
        if (!this.styles) {
          return true;
        }
        if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
          return true;
        }
        var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        for (var p1 in obj) {
          for (var p2 in obj[p1]) {
            // eslint-disable-next-line no-unused-vars
            for (var p3 in obj[p1][p2]) {
              return false;
            }
          }
        }
        return true;
      },

      /**
       * Returns true if object has a style property or has it ina specified line
       * This function is used to detect if a text will use a particular property or not.
       * @param {String} property to check for
       * @param {Number} lineIndex to check the style on
       * @return {Boolean}
       */
      styleHas: function(property, lineIndex) {
        if (!this.styles || !property || property === '') {
          return false;
        }
        if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
          return false;
        }
        var obj = typeof lineIndex === 'undefined' ? this.styles : { 0: this.styles[lineIndex] };
        // eslint-disable-next-line
        for (var p1 in obj) {
          // eslint-disable-next-line
          for (var p2 in obj[p1]) {
            if (typeof obj[p1][p2][property] !== 'undefined') {
              return true;
            }
          }
        }
        return false;
      },

      /**
       * Check if characters in a text have a value for a property
       * whose value matches the textbox's value for that property.  If so,
       * the character-level property is deleted.  If the character
       * has no other properties, then it is also deleted.  Finally,
       * if the line containing that character has no other characters
       * then it also is deleted.
       *
       * @param {string} property The property to compare between characters and text.
       */
      cleanStyle: function(property) {
        if (!this.styles || !property || property === '') {
          return false;
        }
        var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue,
            allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
        // eslint-disable-next-line
        for (var p1 in obj) {
          letterCount = 0;
          // eslint-disable-next-line
          for (var p2 in obj[p1]) {
            var styleObject = obj[p1][p2],
                stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);

            stylesCount++;

            if (stylePropertyHasBeenSet) {
              if (!stylePropertyValue) {
                stylePropertyValue = styleObject[property];
              }
              else if (styleObject[property] !== stylePropertyValue) {
                allStyleObjectPropertiesMatch = false;
              }

              if (styleObject[property] === this[property]) {
                delete styleObject[property];
              }
            }
            else {
              allStyleObjectPropertiesMatch = false;
            }

            if (Object.keys(styleObject).length !== 0) {
              letterCount++;
            }
            else {
              delete obj[p1][p2];
            }
          }

          if (letterCount === 0) {
            delete obj[p1];
          }
        }
        // if every grapheme has the same style set then
        // delete those styles and set it on the parent
        for (var i = 0; i < this._textLines.length; i++) {
          graphemeCount += this._textLines[i].length;
        }
        if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
          this[property] = stylePropertyValue;
          this.removeStyle(property);
        }
      },

      /**
       * Remove a style property or properties from all individual character styles
       * in a text object.  Deletes the character style object if it contains no other style
       * props.  Deletes a line style object if it contains no other character styles.
       *
       * @param {String} props The property to remove from character styles.
       */
      removeStyle: function(property) {
        if (!this.styles || !property || property === '') {
          return;
        }
        var obj = this.styles, line, lineNum, charNum;
        for (lineNum in obj) {
          line = obj[lineNum];
          for (charNum in line) {
            delete line[charNum][property];
            if (Object.keys(line[charNum]).length === 0) {
              delete line[charNum];
            }
          }
          if (Object.keys(line).length === 0) {
            delete obj[lineNum];
          }
        }
      },

      /**
       * @private
       */
      _extendStyles: function(index, styles) {
        var loc = this.get2DCursorLocation(index);

        if (!this._getLineStyle(loc.lineIndex)) {
          this._setLineStyle(loc.lineIndex);
        }

        if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
          this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
        }

        fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
      },

      /**
       * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
       * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
       * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. usefull to manage styles.
       */
      get2DCursorLocation: function(selectionStart, skipWrapping) {
        if (typeof selectionStart === 'undefined') {
          selectionStart = this.selectionStart;
        }
        var lines = skipWrapping ? this._unwrappedTextLines : this._textLines,
            len = lines.length;
        for (var i = 0; i < len; i++) {
          if (selectionStart <= lines[i].length) {
            return {
              lineIndex: i,
              charIndex: selectionStart
            };
          }
          selectionStart -= lines[i].length + this.missingNewlineOffset(i);
        }
        return {
          lineIndex: i - 1,
          charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
        };
      },

      /**
       * Gets style of a current selection/cursor (at the start position)
       * if startIndex or endIndex are not provided, slectionStart or selectionEnd will be used.
       * @param {Number} [startIndex] Start index to get styles at
       * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
       * @param {Boolean} [complete] get full style or not
       * @return {Array} styles an array with one, zero or more Style objects
       */
      getSelectionStyles: function(startIndex, endIndex, complete) {
        if (typeof startIndex === 'undefined') {
          startIndex = this.selectionStart || 0;
        }
        if (typeof endIndex === 'undefined') {
          endIndex = this.selectionEnd || startIndex;
        }
        var styles = [];
        for (var i = startIndex; i < endIndex; i++) {
          styles.push(this.getStyleAtPosition(i, complete));
        }
        return styles;
      },

      /**
       * Gets style of a current selection/cursor position
       * @param {Number} position  to get styles at
       * @param {Boolean} [complete] full style if true
       * @return {Object} style Style object at a specified index
       * @private
       */
      getStyleAtPosition: function(position, complete) {
        var loc = this.get2DCursorLocation(position),
            style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
              this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
        return style || {};
      },

      /**
       * Sets style of a current selection, if no selection exist, do not set anything.
       * @param {Object} [styles] Styles object
       * @param {Number} [startIndex] Start index to get styles at
       * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
       * @return {fabric.IText} thisArg
       * @chainable
       */
      setSelectionStyles: function(styles, startIndex, endIndex) {
        if (typeof startIndex === 'undefined') {
          startIndex = this.selectionStart || 0;
        }
        if (typeof endIndex === 'undefined') {
          endIndex = this.selectionEnd || startIndex;
        }
        for (var i = startIndex; i < endIndex; i++) {
          this._extendStyles(i, styles);
        }
        /* not included in _extendStyles to avoid clearing cache more than once */
        this._forceClearCache = true;
        return this;
      },

      /**
       * get the reference, not a clone, of the style object for a given character
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @return {Object} style object
       */
      _getStyleDeclaration: function(lineIndex, charIndex) {
        var lineStyle = this.styles && this.styles[lineIndex];
        if (!lineStyle) {
          return null;
        }
        return lineStyle[charIndex];
      },

      /**
       * return a new object that contains all the style property for a character
       * the object returned is newly created
       * @param {Number} lineIndex of the line where the character is
       * @param {Number} charIndex position of the character on the line
       * @return {Object} style object
       */
      getCompleteStyleDeclaration: function(lineIndex, charIndex) {
        var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
            styleObject = { }, prop;
        for (var i = 0; i < this._styleProperties.length; i++) {
          prop = this._styleProperties[i];
          styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
        }
        return styleObject;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} style
       * @private
       */
      _setStyleDeclaration: function(lineIndex, charIndex, style) {
        this.styles[lineIndex][charIndex] = style;
      },

      /**
       *
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _deleteStyleDeclaration: function(lineIndex, charIndex) {
        delete this.styles[lineIndex][charIndex];
      },

      /**
       * @param {Number} lineIndex
       * @return {Boolean} if the line exists or not
       * @private
       */
      _getLineStyle: function(lineIndex) {
        return !!this.styles[lineIndex];
      },

      /**
       * Set the line style to an empty object so that is initialized
       * @param {Number} lineIndex
       * @private
       */
      _setLineStyle: function(lineIndex) {
        this.styles[lineIndex] = {};
      },

      /**
       * @param {Number} lineIndex
       * @private
       */
      _deleteLineStyle: function(lineIndex) {
        delete this.styles[lineIndex];
      }
    });
  })();


  (function() {

    function parseDecoration(object) {
      if (object.textDecoration) {
        object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
        object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
        object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
        delete object.textDecoration;
      }
    }

    /**
     * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
     * prefix when observing canvas.
     * @class fabric.IText
     * @extends fabric.Text
     * @mixes fabric.Observable
     *
     * @fires changed
     * @fires selection:changed
     * @fires editing:entered
     * @fires editing:exited
     *
     * @return {fabric.IText} thisArg
     * @see {@link fabric.IText#initialize} for constructor definition
     *
     * <p>Supported key combinations:</p>
     * <pre>
     *   Move cursor:                    left, right, up, down
     *   Select character:               shift + left, shift + right
     *   Select text vertically:         shift + up, shift + down
     *   Move cursor by word:            alt + left, alt + right
     *   Select words:                   shift + alt + left, shift + alt + right
     *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
     *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
     *   Jump to start/end of text:      cmd + up, cmd + down
     *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
     *   Delete character:               backspace
     *   Delete word:                    alt + backspace
     *   Delete line:                    cmd + backspace
     *   Forward delete:                 delete
     *   Copy text:                      ctrl/cmd + c
     *   Paste text:                     ctrl/cmd + v
     *   Cut text:                       ctrl/cmd + x
     *   Select entire text:             ctrl/cmd + a
     *   Quit editing                    tab or esc
     * </pre>
     *
     * <p>Supported mouse/touch combination</p>
     * <pre>
     *   Position cursor:                click/touch
     *   Create selection:               click/touch & drag
     *   Create selection:               click & shift + click
     *   Select word:                    double click
     *   Select line:                    triple click
     * </pre>
     */
    fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'i-text',

      /**
       * Index where text selection starts (or where cursor is when there is no selection)
       * @type Number
       * @default
       */
      selectionStart: 0,

      /**
       * Index where text selection ends
       * @type Number
       * @default
       */
      selectionEnd: 0,

      /**
       * Color of text selection
       * @type String
       * @default
       */
      selectionColor: 'rgba(17,119,255,0.3)',

      /**
       * Indicates whether text is in editing mode
       * @type Boolean
       * @default
       */
      isEditing: false,

      /**
       * Indicates whether a text can be edited
       * @type Boolean
       * @default
       */
      editable: true,

      /**
       * Border color of text object while it's in editing mode
       * @type String
       * @default
       */
      editingBorderColor: 'rgba(102,153,255,0.25)',

      /**
       * Width of cursor (in px)
       * @type Number
       * @default
       */
      cursorWidth: 2,

      /**
       * Color of default cursor (when not overwritten by character style)
       * @type String
       * @default
       */
      cursorColor: '#333',

      /**
       * Delay between cursor blink (in ms)
       * @type Number
       * @default
       */
      cursorDelay: 1000,

      /**
       * Duration of cursor fadein (in ms)
       * @type Number
       * @default
       */
      cursorDuration: 600,

      /**
       * Indicates whether internal text char widths can be cached
       * @type Boolean
       * @default
       */
      caching: true,

      /**
       * @private
       */
      _reSpace: /\s|\n/,

      /**
       * @private
       */
      _currentCursorOpacity: 0,

      /**
       * @private
       */
      _selectionDirection: null,

      /**
       * @private
       */
      _abortCursorAnimation: false,

      /**
       * @private
       */
      __widthOfSpace: [],

      /**
       * Helps determining when the text is in composition, so that the cursor
       * rendering is altered.
       */
      inCompositionMode: false,

      /**
       * Constructor
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.IText} thisArg
       */
      initialize: function(text, options) {
        this.callSuper('initialize', text, options);
        this.initBehavior();
      },

      /**
       * Sets selection start (left boundary of a selection)
       * @param {Number} index Index to set selection start to
       */
      setSelectionStart: function(index) {
        index = Math.max(index, 0);
        this._updateAndFire('selectionStart', index);
      },

      /**
       * Sets selection end (right boundary of a selection)
       * @param {Number} index Index to set selection end to
       */
      setSelectionEnd: function(index) {
        index = Math.min(index, this.text.length);
        this._updateAndFire('selectionEnd', index);
      },

      /**
       * @private
       * @param {String} property 'selectionStart' or 'selectionEnd'
       * @param {Number} index new position of property
       */
      _updateAndFire: function(property, index) {
        if (this[property] !== index) {
          this._fireSelectionChanged();
          this[property] = index;
        }
        this._updateTextarea();
      },

      /**
       * Fires the even of selection changed
       * @private
       */
      _fireSelectionChanged: function() {
        this.fire('selection:changed');
        this.canvas && this.canvas.fire('text:selection:changed', { target: this });
      },

      /**
       * Initialize text dimensions. Render all text on given context
       * or on a offscreen canvas to get the text width with measureText.
       * Updates this.width and this.height with the proper values.
       * Does not return dimensions.
       * @private
       */
      initDimensions: function() {
        this.isEditing && this.initDelayedCursor();
        this.clearContextTop();
        this.callSuper('initDimensions');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        this.clearContextTop();
        this.callSuper('render', ctx);
        // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
        // the correct position but not at every cursor animation.
        this.cursorOffsetCache = { };
        this.renderCursorOrSelection();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        this.callSuper('_render', ctx);
      },

      /**
       * Prepare and clean the contextTop
       */
      clearContextTop: function(skipRestore) {
        if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
          return;
        }
        var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
        ctx.save();
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        this.transform(ctx);
        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
        this._clearTextArea(ctx);
        skipRestore || ctx.restore();
      },

      /**
       * Renders cursor or selection (depending on what exists)
       * it does on the contextTop. If contextTop is not available, do nothing.
       */
      renderCursorOrSelection: function() {
        if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
          return;
        }
        var boundaries = this._getCursorBoundaries(),
            ctx = this.canvas.contextTop;
        this.clearContextTop(true);
        if (this.selectionStart === this.selectionEnd) {
          this.renderCursor(boundaries, ctx);
        }
        else {
          this.renderSelection(boundaries, ctx);
        }
        ctx.restore();
      },

      _clearTextArea: function(ctx) {
        // we add 4 pixel, to be sure to do not leave any pixel out
        var width = this.width + 4, height = this.height + 4;
        ctx.clearRect(-width / 2, -height / 2, width, height);
      },

      /**
       * Returns cursor boundaries (left, top, leftOffset, topOffset)
       * @private
       * @param {Array} chars Array of characters
       * @param {String} typeOfBoundaries
       */
      _getCursorBoundaries: function(position) {

        // left/top are left/top of entire text box
        // leftOffset/topOffset are offset from that left/top point of a text box

        if (typeof position === 'undefined') {
          position = this.selectionStart;
        }

        var left = this._getLeftOffset(),
            top = this._getTopOffset(),
            offsets = this._getCursorBoundariesOffsets(position);

        return {
          left: left,
          top: top,
          leftOffset: offsets.left,
          topOffset: offsets.top
        };
      },

      /**
       * @private
       */
      _getCursorBoundariesOffsets: function(position) {
        if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
          return this.cursorOffsetCache;
        }
        var lineLeftOffset,
            lineIndex,
            charIndex,
            topOffset = 0,
            leftOffset = 0,
            boundaries,
            cursorPosition = this.get2DCursorLocation(position);
        charIndex = cursorPosition.charIndex;
        lineIndex = cursorPosition.lineIndex;
        for (var i = 0; i < lineIndex; i++) {
          topOffset += this.getHeightOfLine(i);
        }
        lineLeftOffset = this._getLineLeftOffset(lineIndex);
        var bound = this.__charBounds[lineIndex][charIndex];
        bound && (leftOffset = bound.left);
        if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
          leftOffset -= this._getWidthOfCharSpacing();
        }
        boundaries = {
          top: topOffset,
          left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
        };
        this.cursorOffsetCache = boundaries;
        return this.cursorOffsetCache;
      },

      /**
       * Renders cursor
       * @param {Object} boundaries
       * @param {CanvasRenderingContext2D} ctx transformed context to draw on
       */
      renderCursor: function(boundaries, ctx) {
        var cursorLocation = this.get2DCursorLocation(),
            lineIndex = cursorLocation.lineIndex,
            charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
            charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
            multiplier = this.scaleX * this.canvas.getZoom(),
            cursorWidth = this.cursorWidth / multiplier,
            topOffset = boundaries.topOffset,
            dy = this.getValueOfPropertyAt(lineIndex, charIndex, 'deltaY');

        topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
          - charHeight * (1 - this._fontSizeFraction);

        if (this.inCompositionMode) {
          this.renderSelection(boundaries, ctx);
        }

        ctx.fillStyle = this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
        ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
        ctx.fillRect(
          boundaries.left + boundaries.leftOffset - cursorWidth / 2,
          topOffset + boundaries.top + dy,
          cursorWidth,
          charHeight);
      },

      /**
       * Renders text selection
       * @param {Object} boundaries Object with left/top/leftOffset/topOffset
       * @param {CanvasRenderingContext2D} ctx transformed context to draw on
       */
      renderSelection: function(boundaries, ctx) {

        var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
            selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
            isJustify = this.textAlign.indexOf('justify') !== -1,
            start = this.get2DCursorLocation(selectionStart),
            end = this.get2DCursorLocation(selectionEnd),
            startLine = start.lineIndex,
            endLine = end.lineIndex,
            startChar = start.charIndex < 0 ? 0 : start.charIndex,
            endChar = end.charIndex < 0 ? 0 : end.charIndex;

        for (var i = startLine; i <= endLine; i++) {
          var lineOffset = this._getLineLeftOffset(i) || 0,
              lineHeight = this.getHeightOfLine(i),
              realLineHeight = 0, boxStart = 0, boxEnd = 0;

          if (i === startLine) {
            boxStart = this.__charBounds[startLine][startChar].left;
          }
          if (i >= startLine && i < endLine) {
            boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?
          }
          else if (i === endLine) {
            if (endChar === 0) {
              boxEnd = this.__charBounds[endLine][endChar].left;
            }
            else {
              var charSpacing = this._getWidthOfCharSpacing();
              boxEnd = this.__charBounds[endLine][endChar - 1].left
                + this.__charBounds[endLine][endChar - 1].width - charSpacing;
            }
          }
          realLineHeight = lineHeight;
          if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
            lineHeight /= this.lineHeight;
          }
          if (this.inCompositionMode) {
            ctx.fillStyle = this.compositionColor || 'black';
            ctx.fillRect(
              boundaries.left + lineOffset + boxStart,
              boundaries.top + boundaries.topOffset + lineHeight,
              boxEnd - boxStart,
              1);
          }
          else {
            ctx.fillStyle = this.selectionColor;
            ctx.fillRect(
              boundaries.left + lineOffset + boxStart,
              boundaries.top + boundaries.topOffset,
              boxEnd - boxStart,
              lineHeight);
          }


          boundaries.topOffset += realLineHeight;
        }
      },

      /**
       * High level function to know the height of the cursor.
       * the currentChar is the one that precedes the cursor
       * Returns fontSize of char at the current cursor
       * @return {Number} Character font size
       */
      getCurrentCharFontSize: function() {
        var cp = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
      },

      /**
       * High level function to know the color of the cursor.
       * the currentChar is the one that precedes the cursor
       * Returns color (fill) of char at the current cursor
       * @return {String} Character color (fill)
       */
      getCurrentCharColor: function() {
        var cp = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
      },

      /**
       * Returns the cursor position for the getCurrent.. functions
       * @private
       */
      _getCurrentCharIndex: function() {
        var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
            charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
        return { l: cursorPosition.lineIndex, c: charIndex };
      }
    });

    /**
     * Returns fabric.IText instance from an object representation
     * @static
     * @memberOf fabric.IText
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as argument
     */
    fabric.IText.fromObject = function(object, callback) {
      parseDecoration(object);
      if (object.styles) {
        for (var i in object.styles) {
          for (var j in object.styles[i]) {
            parseDecoration(object.styles[i][j]);
          }
        }
      }
      fabric.Object._fromObject('IText', object, callback, 'text');
    };
  })();


  (function() {

    var clone = fabric.util.object.clone;

    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

      /**
       * Initializes all the interactive behavior of IText
       */
      initBehavior: function() {
        this.initAddedHandler();
        this.initRemovedHandler();
        this.initCursorSelectionHandlers();
        this.initDoubleClickSimulation();
        this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
      },

      onDeselect: function() {
        this.isEditing && this.exitEditing();
        this.selected = false;
      },

      /**
       * Initializes "added" event handler
       */
      initAddedHandler: function() {
        var _this = this;
        this.on('added', function() {
          var canvas = _this.canvas;
          if (canvas) {
            if (!canvas._hasITextHandlers) {
              canvas._hasITextHandlers = true;
              _this._initCanvasHandlers(canvas);
            }
            canvas._iTextInstances = canvas._iTextInstances || [];
            canvas._iTextInstances.push(_this);
          }
        });
      },

      initRemovedHandler: function() {
        var _this = this;
        this.on('removed', function() {
          var canvas = _this.canvas;
          if (canvas) {
            canvas._iTextInstances = canvas._iTextInstances || [];
            fabric.util.removeFromArray(canvas._iTextInstances, _this);
            if (canvas._iTextInstances.length === 0) {
              canvas._hasITextHandlers = false;
              _this._removeCanvasHandlers(canvas);
            }
          }
        });
      },

      /**
       * register canvas event to manage exiting on other instances
       * @private
       */
      _initCanvasHandlers: function(canvas) {
        canvas._mouseUpITextHandler = function() {
          if (canvas._iTextInstances) {
            canvas._iTextInstances.forEach(function(obj) {
              obj.__isMousedown = false;
            });
          }
        };
        canvas.on('mouse:up', canvas._mouseUpITextHandler);
      },

      /**
       * remove canvas event to manage exiting on other instances
       * @private
       */
      _removeCanvasHandlers: function(canvas) {
        canvas.off('mouse:up', canvas._mouseUpITextHandler);
      },

      /**
       * @private
       */
      _tick: function() {
        this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
      },

      /**
       * @private
       */
      _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

        var tickState;

        tickState = {
          isAborted: false,
          abort: function() {
            this.isAborted = true;
          },
        };

        obj.animate('_currentCursorOpacity', targetOpacity, {
          duration: duration,
          onComplete: function() {
            if (!tickState.isAborted) {
              obj[completeMethod]();
            }
          },
          onChange: function() {
            // we do not want to animate a selection, only cursor
            if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
              obj.renderCursorOrSelection();
            }
          },
          abort: function() {
            return tickState.isAborted;
          }
        });
        return tickState;
      },

      /**
       * @private
       */
      _onTickComplete: function() {

        var _this = this;

        if (this._cursorTimeout1) {
          clearTimeout(this._cursorTimeout1);
        }
        this._cursorTimeout1 = setTimeout(function() {
          _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
        }, 100);
      },

      /**
       * Initializes delayed cursor
       */
      initDelayedCursor: function(restart) {
        var _this = this,
            delay = restart ? 0 : this.cursorDelay;

        this.abortCursorAnimation();
        this._currentCursorOpacity = 1;
        this._cursorTimeout2 = setTimeout(function() {
          _this._tick();
        }, delay);
      },

      /**
       * Aborts cursor animation and clears all timeouts
       */
      abortCursorAnimation: function() {
        var shouldClear = this._currentTickState || this._currentTickCompleteState,
            canvas = this.canvas;
        this._currentTickState && this._currentTickState.abort();
        this._currentTickCompleteState && this._currentTickCompleteState.abort();

        clearTimeout(this._cursorTimeout1);
        clearTimeout(this._cursorTimeout2);

        this._currentCursorOpacity = 0;
        // to clear just itext area we need to transform the context
        // it may not be worth it
        if (shouldClear && canvas) {
          canvas.clearContext(canvas.contextTop || canvas.contextContainer);
        }

      },

      /**
       * Selects entire text
       * @return {fabric.IText} thisArg
       * @chainable
       */
      selectAll: function() {
        this.selectionStart = 0;
        this.selectionEnd = this._text.length;
        this._fireSelectionChanged();
        this._updateTextarea();
        return this;
      },

      /**
       * Returns selected text
       * @return {String}
       */
      getSelectedText: function() {
        return this._text.slice(this.selectionStart, this.selectionEnd).join('');
      },

      /**
       * Find new selection index representing start of current word according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findWordBoundaryLeft: function(startFrom) {
        var offset = 0, index = startFrom - 1;

        // remove space before cursor first
        if (this._reSpace.test(this._text[index])) {
          while (this._reSpace.test(this._text[index])) {
            offset++;
            index--;
          }
        }
        while (/\S/.test(this._text[index]) && index > -1) {
          offset++;
          index--;
        }

        return startFrom - offset;
      },

      /**
       * Find new selection index representing end of current word according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findWordBoundaryRight: function(startFrom) {
        var offset = 0, index = startFrom;

        // remove space after cursor first
        if (this._reSpace.test(this._text[index])) {
          while (this._reSpace.test(this._text[index])) {
            offset++;
            index++;
          }
        }
        while (/\S/.test(this._text[index]) && index < this._text.length) {
          offset++;
          index++;
        }

        return startFrom + offset;
      },

      /**
       * Find new selection index representing start of current line according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findLineBoundaryLeft: function(startFrom) {
        var offset = 0, index = startFrom - 1;

        while (!/\n/.test(this._text[index]) && index > -1) {
          offset++;
          index--;
        }

        return startFrom - offset;
      },

      /**
       * Find new selection index representing end of current line according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findLineBoundaryRight: function(startFrom) {
        var offset = 0, index = startFrom;

        while (!/\n/.test(this._text[index]) && index < this._text.length) {
          offset++;
          index++;
        }

        return startFrom + offset;
      },

      /**
       * Finds index corresponding to beginning or end of a word
       * @param {Number} selectionStart Index of a character
       * @param {Number} direction 1 or -1
       * @return {Number} Index of the beginning or end of a word
       */
      searchWordBoundary: function(selectionStart, direction) {
        var text = this._text,
            index     = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart,
            _char     = text[index],
            // wrong
            reNonWord = fabric.reNonWord;

        while (!reNonWord.test(_char) && index > 0 && index < text.length) {
          index += direction;
          _char = text[index];
        }
        if (reNonWord.test(_char)) {
          index += direction === 1 ? 0 : 1;
        }
        return index;
      },

      /**
       * Selects a word based on the index
       * @param {Number} selectionStart Index of a character
       */
      selectWord: function(selectionStart) {
        selectionStart = selectionStart || this.selectionStart;
        var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
            newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

        this.selectionStart = newSelectionStart;
        this.selectionEnd = newSelectionEnd;
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      },

      /**
       * Selects a line based on the index
       * @param {Number} selectionStart Index of a character
       * @return {fabric.IText} thisArg
       * @chainable
       */
      selectLine: function(selectionStart) {
        selectionStart = selectionStart || this.selectionStart;
        var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
            newSelectionEnd = this.findLineBoundaryRight(selectionStart);

        this.selectionStart = newSelectionStart;
        this.selectionEnd = newSelectionEnd;
        this._fireSelectionChanged();
        this._updateTextarea();
        return this;
      },

      /**
       * Enters editing state
       * @return {fabric.IText} thisArg
       * @chainable
       */
      enterEditing: function(e) {
        if (this.isEditing || !this.editable) {
          return;
        }

        if (this.canvas) {
          this.canvas.calcOffset();
          this.exitEditingOnOthers(this.canvas);
        }

        this.isEditing = true;

        this.initHiddenTextarea(e);
        this.hiddenTextarea.focus();
        this.hiddenTextarea.value = this.text;
        this._updateTextarea();
        this._saveEditingProps();
        this._setEditingProps();
        this._textBeforeEdit = this.text;

        this._tick();
        this.fire('editing:entered');
        this._fireSelectionChanged();
        if (!this.canvas) {
          return this;
        }
        this.canvas.fire('text:editing:entered', { target: this });
        this.initMouseMoveHandler();
        this.canvas.requestRenderAll();
        return this;
      },

      exitEditingOnOthers: function(canvas) {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.selected = false;
            if (obj.isEditing) {
              obj.exitEditing();
            }
          });
        }
      },

      /**
       * Initializes "mousemove" event handler
       */
      initMouseMoveHandler: function() {
        this.canvas.on('mouse:move', this.mouseMoveHandler);
      },

      /**
       * @private
       */
      mouseMoveHandler: function(options) {
        if (!this.__isMousedown || !this.isEditing) {
          return;
        }

        var newSelectionStart = this.getSelectionStartFromPointer(options.e),
            currentStart = this.selectionStart,
            currentEnd = this.selectionEnd;
        if (
          (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
          &&
          (currentStart === newSelectionStart || currentEnd === newSelectionStart)
        ) {
          return;
        }
        if (newSelectionStart > this.__selectionStartOnMouseDown) {
          this.selectionStart = this.__selectionStartOnMouseDown;
          this.selectionEnd = newSelectionStart;
        }
        else {
          this.selectionStart = newSelectionStart;
          this.selectionEnd = this.__selectionStartOnMouseDown;
        }
        if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
          this.restartCursorIfNeeded();
          this._fireSelectionChanged();
          this._updateTextarea();
          this.renderCursorOrSelection();
        }
      },

      /**
       * @private
       */
      _setEditingProps: function() {
        this.hoverCursor = 'text';

        if (this.canvas) {
          this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
        }

        this.borderColor = this.editingBorderColor;
        this.hasControls = this.selectable = false;
        this.lockMovementX = this.lockMovementY = true;
      },

      /**
       * convert from textarea to grapheme indexes
       */
      fromStringToGraphemeSelection: function(start, end, text) {
        var smallerTextStart = text.slice(0, start),
            graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
        if (start === end) {
          return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
        }
        var smallerTextEnd = text.slice(start, end),
            graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
      },

      /**
       * convert from fabric to textarea values
       */
      fromGraphemeToStringSelection: function(start, end, _text) {
        var smallerTextStart = _text.slice(0, start),
            graphemeStart = smallerTextStart.join('').length;
        if (start === end) {
          return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
        }
        var smallerTextEnd = _text.slice(start, end),
            graphemeEnd = smallerTextEnd.join('').length;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
      },

      /**
       * @private
       */
      _updateTextarea: function() {
        this.cursorOffsetCache = { };
        if (!this.hiddenTextarea) {
          return;
        }
        if (!this.inCompositionMode) {
          var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
          this.hiddenTextarea.selectionStart = newSelection.selectionStart;
          this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
        }
        this.updateTextareaPosition();
      },

      /**
       * @private
       */
      updateFromTextArea: function() {
        if (!this.hiddenTextarea) {
          return;
        }
        this.cursorOffsetCache = { };
        this.text = this.hiddenTextarea.value;
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
          this.setCoords();
        }
        var newSelection = this.fromStringToGraphemeSelection(
          this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
        this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
        if (!this.inCompositionMode) {
          this.selectionStart = newSelection.selectionStart;
        }
        this.updateTextareaPosition();
      },

      /**
       * @private
       */
      updateTextareaPosition: function() {
        if (this.selectionStart === this.selectionEnd) {
          var style = this._calcTextareaPosition();
          this.hiddenTextarea.style.left = style.left;
          this.hiddenTextarea.style.top = style.top;
        }
      },

      /**
       * @private
       * @return {Object} style contains style for hiddenTextarea
       */
      _calcTextareaPosition: function() {
        if (!this.canvas) {
          return { x: 1, y: 1 };
        }
        var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart,
            boundaries = this._getCursorBoundaries(desiredPosition),
            cursorLocation = this.get2DCursorLocation(desiredPosition),
            lineIndex = cursorLocation.lineIndex,
            charIndex = cursorLocation.charIndex,
            charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
            leftOffset = boundaries.leftOffset,
            m = this.calcTransformMatrix(),
            p = {
              x: boundaries.left + leftOffset,
              y: boundaries.top + boundaries.topOffset + charHeight
            },
            retinaScaling = this.canvas.getRetinaScaling(),
            upperCanvas = this.canvas.upperCanvasEl,
            upperCanvasWidth = upperCanvas.width / retinaScaling,
            upperCanvasHeight = upperCanvas.height / retinaScaling,
            maxWidth = upperCanvasWidth - charHeight,
            maxHeight = upperCanvasHeight - charHeight,
            scaleX = upperCanvas.clientWidth / upperCanvasWidth,
            scaleY = upperCanvas.clientHeight / upperCanvasHeight;

        p = fabric.util.transformPoint(p, m);
        p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
        p.x *= scaleX;
        p.y *= scaleY;
        if (p.x < 0) {
          p.x = 0;
        }
        if (p.x > maxWidth) {
          p.x = maxWidth;
        }
        if (p.y < 0) {
          p.y = 0;
        }
        if (p.y > maxHeight) {
          p.y = maxHeight;
        }

        // add canvas offset on document
        p.x += this.canvas._offset.left;
        p.y += this.canvas._offset.top;

        return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
      },

      /**
       * @private
       */
      _saveEditingProps: function() {
        this._savedProps = {
          hasControls: this.hasControls,
          borderColor: this.borderColor,
          lockMovementX: this.lockMovementX,
          lockMovementY: this.lockMovementY,
          hoverCursor: this.hoverCursor,
          selectable: this.selectable,
          defaultCursor: this.canvas && this.canvas.defaultCursor,
          moveCursor: this.canvas && this.canvas.moveCursor
        };
      },

      /**
       * @private
       */
      _restoreEditingProps: function() {
        if (!this._savedProps) {
          return;
        }

        this.hoverCursor = this._savedProps.hoverCursor;
        this.hasControls = this._savedProps.hasControls;
        this.borderColor = this._savedProps.borderColor;
        this.selectable = this._savedProps.selectable;
        this.lockMovementX = this._savedProps.lockMovementX;
        this.lockMovementY = this._savedProps.lockMovementY;

        if (this.canvas) {
          this.canvas.defaultCursor = this._savedProps.defaultCursor;
          this.canvas.moveCursor = this._savedProps.moveCursor;
        }
      },

      /**
       * Exits from editing state
       * @return {fabric.IText} thisArg
       * @chainable
       */
      exitEditing: function() {
        var isTextChanged = (this._textBeforeEdit !== this.text);
        var hiddenTextarea = this.hiddenTextarea;
        this.selected = false;
        this.isEditing = false;

        this.selectionEnd = this.selectionStart;

        if (hiddenTextarea) {
          hiddenTextarea.blur && hiddenTextarea.blur();
          hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
        }
        this.hiddenTextarea = null;
        this.abortCursorAnimation();
        this._restoreEditingProps();
        this._currentCursorOpacity = 0;
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
          this.setCoords();
        }
        this.fire('editing:exited');
        isTextChanged && this.fire('modified');
        if (this.canvas) {
          this.canvas.off('mouse:move', this.mouseMoveHandler);
          this.canvas.fire('text:editing:exited', { target: this });
          isTextChanged && this.canvas.fire('object:modified', { target: this });
        }
        return this;
      },

      /**
       * @private
       */
      _removeExtraneousStyles: function() {
        for (var prop in this.styles) {
          if (!this._textLines[prop]) {
            delete this.styles[prop];
          }
        }
      },

      /**
       * remove and reflow a style block from start to end.
       * @param {Number} start linear start position for removal (included in removal)
       * @param {Number} end linear end position for removal ( excluded from removal )
       */
      removeStyleFromTo: function(start, end) {
        var cursorStart = this.get2DCursorLocation(start, true),
            cursorEnd = this.get2DCursorLocation(end, true),
            lineStart = cursorStart.lineIndex,
            charStart = cursorStart.charIndex,
            lineEnd = cursorEnd.lineIndex,
            charEnd = cursorEnd.charIndex,
            i, styleObj;
        if (lineStart !== lineEnd) {
          // step1 remove the trailing of lineStart
          if (this.styles[lineStart]) {
            for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
              delete this.styles[lineStart][i];
            }
          }
          // step2 move the trailing of lineEnd to lineStart if needed
          if (this.styles[lineEnd]) {
            for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
              styleObj = this.styles[lineEnd][i];
              if (styleObj) {
                this.styles[lineStart] || (this.styles[lineStart] = { });
                this.styles[lineStart][charStart + i - charEnd] = styleObj;
              }
            }
          }
          // step3 detects lines will be completely removed.
          for (i = lineStart + 1; i <= lineEnd; i++) {
            delete this.styles[i];
          }
          // step4 shift remaining lines.
          this.shiftLineStyles(lineEnd, lineStart - lineEnd);
        }
        else {
          // remove and shift left on the same line
          if (this.styles[lineStart]) {
            styleObj = this.styles[lineStart];
            var diff = charEnd - charStart, numericChar, _char;
            for (i = charStart; i < charEnd; i++) {
              delete styleObj[i];
            }
            for (_char in this.styles[lineStart]) {
              numericChar = parseInt(_char, 10);
              if (numericChar >= charEnd) {
                styleObj[numericChar - diff] = styleObj[_char];
                delete styleObj[_char];
              }
            }
          }
        }
      },

      /**
       * Shifts line styles up or down
       * @param {Number} lineIndex Index of a line
       * @param {Number} offset Can any number?
       */
      shiftLineStyles: function(lineIndex, offset) {
        // shift all line styles by offset upward or downward
        // do not clone deep. we need new array, not new style objects
        var clonedStyles = clone(this.styles);
        for (var line in this.styles) {
          var numericLine = parseInt(line, 10);
          if (numericLine > lineIndex) {
            this.styles[numericLine + offset] = clonedStyles[numericLine];
            if (!clonedStyles[numericLine - offset]) {
              delete this.styles[numericLine];
            }
          }
        }
      },

      restartCursorIfNeeded: function() {
        if (!this._currentTickState || this._currentTickState.isAborted
          || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
        ) {
          this.initDelayedCursor();
        }
      },

      /**
       * Inserts new style object
       * @param {Number} lineIndex Index of a line
       * @param {Number} charIndex Index of a char
       * @param {Number} qty number of lines to add
       * @param {Array} copiedStyle Array of objects styles
       */
      insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
        var currentCharStyle,
            newLineStyles = {},
            somethingAdded = false;

        qty || (qty = 1);
        this.shiftLineStyles(lineIndex, qty);
        if (this.styles[lineIndex]) {
          currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
        }

        // we clone styles of all chars
        // after cursor onto the current line
        for (var index in this.styles[lineIndex]) {
          var numIndex = parseInt(index, 10);
          if (numIndex >= charIndex) {
            somethingAdded = true;
            newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
            // remove lines from the previous line since they're on a new line now
            delete this.styles[lineIndex][index];
          }
        }
        if (somethingAdded) {
          this.styles[lineIndex + qty] = newLineStyles;
        }
        else {
          delete this.styles[lineIndex + qty];
        }
        // for the other lines
        // we clone current char style onto the next (otherwise empty) line
        while (qty > 1) {
          qty--;
          if (copiedStyle && copiedStyle[qty]) {
            this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty]) };
          }
          else if (currentCharStyle) {
            this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
          }
          else {
            delete this.styles[lineIndex + qty];
          }
        }
        this._forceClearCache = true;
      },

      /**
       * Inserts style object for a given line/char index
       * @param {Number} lineIndex Index of a line
       * @param {Number} charIndex Index of a char
       * @param {Number} quantity number Style object to insert, if given
       * @param {Array} copiedStyle array of style objects
       */
      insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
        if (!this.styles) {
          this.styles = {};
        }
        var currentLineStyles       = this.styles[lineIndex],
            currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

        quantity || (quantity = 1);
        // shift all char styles by quantity forward
        // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
        for (var index in currentLineStylesCloned) {
          var numericIndex = parseInt(index, 10);
          if (numericIndex >= charIndex) {
            currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
            // only delete the style if there was nothing moved there
            if (!currentLineStylesCloned[numericIndex - quantity]) {
              delete currentLineStyles[numericIndex];
            }
          }
        }
        this._forceClearCache = true;
        if (copiedStyle) {
          while (quantity--) {
            if (!Object.keys(copiedStyle[quantity]).length) {
              continue;
            }
            if (!this.styles[lineIndex]) {
              this.styles[lineIndex] = {};
            }
            this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
          }
          return;
        }
        if (!currentLineStyles) {
          return;
        }
        var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
        while (newStyle && quantity--) {
          this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
        }
      },

      /**
       * Inserts style object(s)
       * @param {Array} insertedText Characters at the location where style is inserted
       * @param {Number} start cursor index for inserting style
       * @param {Array} [copiedStyle] array of style objects to insert.
       */
      insertNewStyleBlock: function(insertedText, start, copiedStyle) {
        var cursorLoc = this.get2DCursorLocation(start, true),
            addedLines = [0], linesLength = 0;
        for (var i = 0; i < insertedText.length; i++) {
          if (insertedText[i] === '\n') {
            linesLength++;
            addedLines[linesLength] = 0;
          }
          else {
            addedLines[linesLength]++;
          }
        }
        if (addedLines[0] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
          copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
        }
        linesLength && this.insertNewlineStyleObject(
          cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);
        for (var i = 1; i < linesLength; i++) {
          if (addedLines[i] > 0) {
            this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
          }
          else if (copiedStyle) {
            this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
          }
          copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
        }
        // we use i outside the loop to get it like linesLength
        if (addedLines[i] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        }
      },

      /**
       * Set the selectionStart and selectionEnd according to the new position of cursor
       * mimic the key - mouse navigation when shift is pressed.
       */
      setSelectionStartEndWithShift: function(start, end, newSelection) {
        if (newSelection <= start) {
          if (end === start) {
            this._selectionDirection = 'left';
          }
          else if (this._selectionDirection === 'right') {
            this._selectionDirection = 'left';
            this.selectionEnd = start;
          }
          this.selectionStart = newSelection;
        }
        else if (newSelection > start && newSelection < end) {
          if (this._selectionDirection === 'right') {
            this.selectionEnd = newSelection;
          }
          else {
            this.selectionStart = newSelection;
          }
        }
        else {
          // newSelection is > selection start and end
          if (end === start) {
            this._selectionDirection = 'right';
          }
          else if (this._selectionDirection === 'left') {
            this._selectionDirection = 'right';
            this.selectionStart = end;
          }
          this.selectionEnd = newSelection;
        }
      },

      setSelectionInBoundaries: function() {
        var length = this.text.length;
        if (this.selectionStart > length) {
          this.selectionStart = length;
        }
        else if (this.selectionStart < 0) {
          this.selectionStart = 0;
        }
        if (this.selectionEnd > length) {
          this.selectionEnd = length;
        }
        else if (this.selectionEnd < 0) {
          this.selectionEnd = 0;
        }
      }
    });
  })();


  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
    /**
     * Initializes "dbclick" event handler
     */
    initDoubleClickSimulation: function() {

      // for double click
      this.__lastClickTime = +new Date();

      // for triple click
      this.__lastLastClickTime = +new Date();

      this.__lastPointer = { };

      this.on('mousedown', this.onMouseDown);
    },

    /**
     * Default event handler to simulate triple click
     * @private
     */
    onMouseDown: function(options) {
      if (!this.canvas) {
        return;
      }
      this.__newClickTime = +new Date();
      var newPointer = options.pointer;
      if (this.isTripleClick(newPointer)) {
        this.fire('tripleclick', options);
        this._stopEvent(options.e);
      }
      this.__lastLastClickTime = this.__lastClickTime;
      this.__lastClickTime = this.__newClickTime;
      this.__lastPointer = newPointer;
      this.__lastIsEditing = this.isEditing;
      this.__lastSelected = this.selected;
    },

    isTripleClick: function(newPointer) {
      return this.__newClickTime - this.__lastClickTime < 500 &&
          this.__lastClickTime - this.__lastLastClickTime < 500 &&
          this.__lastPointer.x === newPointer.x &&
          this.__lastPointer.y === newPointer.y;
    },

    /**
     * @private
     */
    _stopEvent: function(e) {
      e.preventDefault && e.preventDefault();
      e.stopPropagation && e.stopPropagation();
    },

    /**
     * Initializes event handlers related to cursor or selection
     */
    initCursorSelectionHandlers: function() {
      this.initMousedownHandler();
      this.initMouseupHandler();
      this.initClicks();
    },

    /**
     * Default handler for double click, select a word
     */
    doubleClickHandler: function(options) {
      if (!this.isEditing) {
        return;
      }
      this.selectWord(this.getSelectionStartFromPointer(options.e));
    },

    /**
     * Default handler for triple click, select a line
     */
    tripleClickHandler: function(options) {
      if (!this.isEditing) {
        return;
      }
      this.selectLine(this.getSelectionStartFromPointer(options.e));
    },

    /**
     * Initializes double and triple click event handlers
     */
    initClicks: function() {
      this.on('mousedblclick', this.doubleClickHandler);
      this.on('tripleclick', this.tripleClickHandler);
    },

    /**
     * Default event handler for the basic functionalities needed on _mouseDown
     * can be overridden to do something different.
     * Scope of this implementation is: find the click position, set selectionStart
     * find selectionEnd, initialize the drawing of either cursor or selection area
     */
    _mouseDownHandler: function(options) {
      if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
        return;
      }

      this.__isMousedown = true;

      if (this.selected) {
        this.setCursorByClick(options.e);
      }

      if (this.isEditing) {
        this.__selectionStartOnMouseDown = this.selectionStart;
        if (this.selectionStart === this.selectionEnd) {
          this.abortCursorAnimation();
        }
        this.renderCursorOrSelection();
      }
    },

    /**
     * Default event handler for the basic functionalities needed on mousedown:before
     * can be overridden to do something different.
     * Scope of this implementation is: verify the object is already selected when mousing down
     */
    _mouseDownHandlerBefore: function(options) {
      if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
        return;
      }
      // we want to avoid that an object that was selected and then becomes unselectable,
      // may trigger editing mode in some way.
      this.selected = this === this.canvas._activeObject;
    },

    /**
     * Initializes "mousedown" event handler
     */
    initMousedownHandler: function() {
      this.on('mousedown', this._mouseDownHandler);
      this.on('mousedown:before', this._mouseDownHandlerBefore);
    },

    /**
     * Initializes "mouseup" event handler
     */
    initMouseupHandler: function() {
      this.on('mouseup', this.mouseUpHandler);
    },

    /**
     * standard hander for mouse up, overridable
     * @private
     */
    mouseUpHandler: function(options) {
      this.__isMousedown = false;
      if (!this.editable || this.group ||
        (options.transform && options.transform.actionPerformed) ||
        (options.e.button && options.e.button !== 1)) {
        return;
      }

      if (this.canvas) {
        var currentActive = this.canvas._activeObject;
        if (currentActive && currentActive !== this) {
          // avoid running this logic when there is an active object
          // this because is possible with shift click and fast clicks,
          // to rapidly deselect and reselect this object and trigger an enterEdit
          return;
        }
      }

      if (this.__lastSelected && !this.__corner) {
        this.selected = false;
        this.__lastSelected = false;
        this.enterEditing(options.e);
        if (this.selectionStart === this.selectionEnd) {
          this.initDelayedCursor(true);
        }
        else {
          this.renderCursorOrSelection();
        }
      }
      else {
        this.selected = true;
      }
    },

    /**
     * Changes cursor location in a text depending on passed pointer (x/y) object
     * @param {Event} e Event object
     */
    setCursorByClick: function(e) {
      var newSelection = this.getSelectionStartFromPointer(e),
          start = this.selectionStart, end = this.selectionEnd;
      if (e.shiftKey) {
        this.setSelectionStartEndWithShift(start, end, newSelection);
      }
      else {
        this.selectionStart = newSelection;
        this.selectionEnd = newSelection;
      }
      if (this.isEditing) {
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Returns index of a character corresponding to where an object was clicked
     * @param {Event} e Event object
     * @return {Number} Index of a character
     */
    getSelectionStartFromPointer: function(e) {
      var mouseOffset = this.getLocalPointer(e),
          prevWidth = 0,
          width = 0,
          height = 0,
          charIndex = 0,
          lineIndex = 0,
          lineLeftOffset,
          line;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        if (height <= mouseOffset.y) {
          height += this.getHeightOfLine(i) * this.scaleY;
          lineIndex = i;
          if (i > 0) {
            charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);
          }
        }
        else {
          break;
        }
      }
      lineLeftOffset = this._getLineLeftOffset(lineIndex);
      width = lineLeftOffset * this.scaleX;
      line = this._textLines[lineIndex];
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        prevWidth = width;
        // i removed something about flipX here, check.
        width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
        if (width <= mouseOffset.x) {
          charIndex++;
        }
        else {
          break;
        }
      }
      return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
    },

    /**
     * @private
     */
    _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
      // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
      var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
          distanceBtwNextCharAndCursor = width - mouseOffset.x,
          offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
            distanceBtwNextCharAndCursor < 0 ? 0 : 1,
          newSelectionStart = index + offset;
      // if object is horizontally flipped, mirror cursor location from the end
      if (this.flipX) {
        newSelectionStart = jlen - newSelectionStart;
      }

      if (newSelectionStart > this._text.length) {
        newSelectionStart = this._text.length;
      }

      return newSelectionStart;
    }
  });


  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes hidden textarea (needed to bring up keyboard in iOS)
     */
    initHiddenTextarea: function() {
      this.hiddenTextarea = fabric.document.createElement('textarea');
      this.hiddenTextarea.setAttribute('autocapitalize', 'off');
      this.hiddenTextarea.setAttribute('autocorrect', 'off');
      this.hiddenTextarea.setAttribute('autocomplete', 'off');
      this.hiddenTextarea.setAttribute('spellcheck', 'false');
      this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
      this.hiddenTextarea.setAttribute('wrap', 'off');
      var style = this._calcTextareaPosition();
      // line-height: 1px; was removed from the style to fix this:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=870966
      this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
      '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
      ' paddingｰtop: ' + style.fontSize + ';';
      fabric.document.body.appendChild(this.hiddenTextarea);

      fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

      if (!this._clickHandlerInitialized && this.canvas) {
        fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
        this._clickHandlerInitialized = true;
      }
    },

    /**
     * For functionalities on keyDown
     * Map a special key to a function of the instance/prototype
     * If you need different behaviour for ESC or TAB or arrows, you have to change
     * this map setting the name of a function that you build on the fabric.Itext or
     * your prototype.
     * the map change will affect all Instances unless you need for only some text Instances
     * in that case you have to clone this object and assign your Instance.
     * this.keysMap = fabric.util.object.clone(this.keysMap);
     * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
     */
    keysMap: {
      9:  'exitEditing',
      27: 'exitEditing',
      33: 'moveCursorUp',
      34: 'moveCursorDown',
      35: 'moveCursorRight',
      36: 'moveCursorLeft',
      37: 'moveCursorLeft',
      38: 'moveCursorUp',
      39: 'moveCursorRight',
      40: 'moveCursorDown',
    },

    /**
     * For functionalities on keyUp + ctrl || cmd
     */
    ctrlKeysMapUp: {
      67: 'copy',
      88: 'cut'
    },

    /**
     * For functionalities on keyDown + ctrl || cmd
     */
    ctrlKeysMapDown: {
      65: 'selectAll'
    },

    onClick: function() {
      // No need to trigger click event here, focus is enough to have the keyboard appear on Android
      this.hiddenTextarea && this.hiddenTextarea.focus();
    },

    /**
     * Handles keyup event
     * @param {Event} e Event object
     */
    onKeyDown: function(e) {
      if (!this.isEditing || this.inCompositionMode) {
        return;
      }
      if (e.keyCode in this.keysMap) {
        this[this.keysMap[e.keyCode]](e);
      }
      else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
        this[this.ctrlKeysMapDown[e.keyCode]](e);
      }
      else {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      if (e.keyCode >= 33 && e.keyCode <= 40) {
        // if i press an arrow key just update selection
        this.clearContextTop();
        this.renderCursorOrSelection();
      }
      else {
        this.canvas && this.canvas.requestRenderAll();
      }
    },

    /**
     * Handles keyup event
     * We handle KeyUp because ie11 and edge have difficulties copy/pasting
     * if a copy/cut event fired, keyup is dismissed
     * @param {Event} e Event object
     */
    onKeyUp: function(e) {
      if (!this.isEditing || this._copyDone || this.inCompositionMode) {
        this._copyDone = false;
        return;
      }
      if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
        this[this.ctrlKeysMapUp[e.keyCode]](e);
      }
      else {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      this.canvas && this.canvas.requestRenderAll();
    },

    /**
     * Handles onInput event
     * @param {Event} e Event object
     */
    onInput: function(e) {
      var fromPaste = this.fromPaste;
      this.fromPaste = false;
      e && e.stopPropagation();
      if (!this.isEditing) {
        return;
      }
      // decisions about style changes.
      var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
          charCount = this._text.length,
          nextCharCount = nextText.length,
          removedText, insertedText,
          charDiff = nextCharCount - charCount;
      if (this.hiddenTextarea.value === '') {
        this.styles = { };
        this.updateFromTextArea();
        this.fire('changed');
        if (this.canvas) {
          this.canvas.fire('text:changed', { target: this });
          this.canvas.requestRenderAll();
        }
        return;
      }

      var textareaSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart,
        this.hiddenTextarea.selectionEnd,
        this.hiddenTextarea.value
      );
      var backDelete = this.selectionStart > textareaSelection.selectionStart;

      if (this.selectionStart !== this.selectionEnd) {
        removedText = this._text.slice(this.selectionStart, this.selectionEnd);
        charDiff += this.selectionEnd - this.selectionStart;
      }
      else if (nextCharCount < charCount) {
        if (backDelete) {
          removedText = this._text.slice(this.selectionEnd + charDiff, this.selectionEnd);
        }
        else {
          removedText = this._text.slice(this.selectionStart, this.selectionStart - charDiff);
        }
      }
      insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
      if (removedText && removedText.length) {
        if (this.selectionStart !== this.selectionEnd) {
          this.removeStyleFromTo(this.selectionStart, this.selectionEnd);
        }
        else if (backDelete) {
          // detect differencies between forwardDelete and backDelete
          this.removeStyleFromTo(this.selectionEnd - removedText.length, this.selectionEnd);
        }
        else {
          this.removeStyleFromTo(this.selectionEnd, this.selectionEnd + removedText.length);
        }
      }
      if (insertedText.length) {
        if (fromPaste && insertedText.join('') === fabric.copiedText && !fabric.disableStyleCopyPaste) {
          this.insertNewStyleBlock(insertedText, this.selectionStart, fabric.copiedTextStyle);
        }
        else {
          this.insertNewStyleBlock(insertedText, this.selectionStart);
        }
      }
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
    },
    /**
     * Composition start
     */
    onCompositionStart: function() {
      this.inCompositionMode = true;
    },

    /**
     * Composition end
     */
    onCompositionEnd: function() {
      this.inCompositionMode = false;
    },

    // /**
    //  * Composition update
    //  */
    onCompositionUpdate: function(e) {
      this.compositionStart = e.target.selectionStart;
      this.compositionEnd = e.target.selectionEnd;
      this.updateTextareaPosition();
    },

    /**
     * Copies selected text
     * @param {Event} e Event object
     */
    copy: function() {
      if (this.selectionStart === this.selectionEnd) {
        //do not cut-copy if no selection
        return;
      }

      fabric.copiedText = this.getSelectedText();
      if (!fabric.disableStyleCopyPaste) {
        fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
      }
      else {
        fabric.copiedTextStyle = null;
      }
      this._copyDone = true;
    },

    /**
     * Pastes text
     * @param {Event} e Event object
     */
    paste: function() {
      this.fromPaste = true;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @return {Object} Clipboard data object
     */
    _getClipboardData: function(e) {
      return (e && e.clipboardData) || fabric.window.clipboardData;
    },

    /**
     * Finds the width in pixels before the cursor on the same line
     * @private
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Number} widthBeforeCursor width before cursor
     */
    _getWidthBeforeCursor: function(lineIndex, charIndex) {
      var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

      if (charIndex > 0) {
        bound = this.__charBounds[lineIndex][charIndex - 1];
        widthBeforeCursor += bound.left + bound.width;
      }
      return widthBeforeCursor;
    },

    /**
     * Gets start offset of a selection
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    getDownCursorOffset: function(e, isRight) {
      var selectionProp = this._getSelectionForOffset(e, isRight),
          cursorLocation = this.get2DCursorLocation(selectionProp),
          lineIndex = cursorLocation.lineIndex;
      // if on last line, down cursor goes to end of line
      if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
        // move to the end of a text
        return this._text.length - selectionProp;
      }
      var charIndex = cursorLocation.charIndex,
          widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
          indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
          textAfterCursor = this._textLines[lineIndex].slice(charIndex);
      return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
    },

    /**
     * private
     * Helps finding if the offset should be counted from Start or End
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    _getSelectionForOffset: function(e, isRight) {
      if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
        return this.selectionEnd;
      }
      else {
        return this.selectionStart;
      }
    },

    /**
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    getUpCursorOffset: function(e, isRight) {
      var selectionProp = this._getSelectionForOffset(e, isRight),
          cursorLocation = this.get2DCursorLocation(selectionProp),
          lineIndex = cursorLocation.lineIndex;
      if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
        // if on first line, up cursor goes to start of line
        return -selectionProp;
      }
      var charIndex = cursorLocation.charIndex,
          widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
          indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
          textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
          missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
      // return a negative offset
      return -this._textLines[lineIndex - 1].length
       + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
    },

    /**
     * for a given width it founds the matching character.
     * @private
     */
    _getIndexOnLine: function(lineIndex, width) {

      var line = this._textLines[lineIndex],
          lineLeftOffset = this._getLineLeftOffset(lineIndex),
          widthOfCharsOnLine = lineLeftOffset,
          indexOnLine = 0, charWidth, foundMatch;

      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charWidth = this.__charBounds[lineIndex][j].width;
        widthOfCharsOnLine += charWidth;
        if (widthOfCharsOnLine > width) {
          foundMatch = true;
          var leftEdge = widthOfCharsOnLine - charWidth,
              rightEdge = widthOfCharsOnLine,
              offsetFromLeftEdge = Math.abs(leftEdge - width),
              offsetFromRightEdge = Math.abs(rightEdge - width);

          indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
          break;
        }
      }

      // reached end
      if (!foundMatch) {
        indexOnLine = line.length - 1;
      }

      return indexOnLine;
    },


    /**
     * Moves cursor down
     * @param {Event} e Event object
     */
    moveCursorDown: function(e) {
      if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
        return;
      }
      this._moveCursorUpOrDown('Down', e);
    },

    /**
     * Moves cursor up
     * @param {Event} e Event object
     */
    moveCursorUp: function(e) {
      if (this.selectionStart === 0 && this.selectionEnd === 0) {
        return;
      }
      this._moveCursorUpOrDown('Up', e);
    },

    /**
     * Moves cursor up or down, fires the events
     * @param {String} direction 'Up' or 'Down'
     * @param {Event} e Event object
     */
    _moveCursorUpOrDown: function(direction, e) {
      // getUpCursorOffset
      // getDownCursorOffset
      var action = 'get' + direction + 'CursorOffset',
          offset = this[action](e, this._selectionDirection === 'right');
      if (e.shiftKey) {
        this.moveCursorWithShift(offset);
      }
      else {
        this.moveCursorWithoutShift(offset);
      }
      if (offset !== 0) {
        this.setSelectionInBoundaries();
        this.abortCursorAnimation();
        this._currentCursorOpacity = 1;
        this.initDelayedCursor();
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Moves cursor with shift
     * @param {Number} offset
     */
    moveCursorWithShift: function(offset) {
      var newSelection = this._selectionDirection === 'left'
        ? this.selectionStart + offset
        : this.selectionEnd + offset;
      this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
      return offset !== 0;
    },

    /**
     * Moves cursor up without shift
     * @param {Number} offset
     */
    moveCursorWithoutShift: function(offset) {
      if (offset < 0) {
        this.selectionStart += offset;
        this.selectionEnd = this.selectionStart;
      }
      else {
        this.selectionEnd += offset;
        this.selectionStart = this.selectionEnd;
      }
      return offset !== 0;
    },

    /**
     * Moves cursor left
     * @param {Event} e Event object
     */
    moveCursorLeft: function(e) {
      if (this.selectionStart === 0 && this.selectionEnd === 0) {
        return;
      }
      this._moveCursorLeftOrRight('Left', e);
    },

    /**
     * @private
     * @return {Boolean} true if a change happened
     */
    _move: function(e, prop, direction) {
      var newValue;
      if (e.altKey) {
        newValue = this['findWordBoundary' + direction](this[prop]);
      }
      else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
        newValue = this['findLineBoundary' + direction](this[prop]);
      }
      else {
        this[prop] += direction === 'Left' ? -1 : 1;
        return true;
      }
      if (typeof newValue !== undefined && this[prop] !== newValue) {
        this[prop] = newValue;
        return true;
      }
    },

    /**
     * @private
     */
    _moveLeft: function(e, prop) {
      return this._move(e, prop, 'Left');
    },

    /**
     * @private
     */
    _moveRight: function(e, prop) {
      return this._move(e, prop, 'Right');
    },

    /**
     * Moves cursor left without keeping selection
     * @param {Event} e
     */
    moveCursorLeftWithoutShift: function(e) {
      var change = true;
      this._selectionDirection = 'left';

      // only move cursor when there is no selection,
      // otherwise we discard it, and leave cursor on same place
      if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
        change = this._moveLeft(e, 'selectionStart');

      }
      this.selectionEnd = this.selectionStart;
      return change;
    },

    /**
     * Moves cursor left while keeping selection
     * @param {Event} e
     */
    moveCursorLeftWithShift: function(e) {
      if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
        return this._moveLeft(e, 'selectionEnd');
      }
      else if (this.selectionStart !== 0){
        this._selectionDirection = 'left';
        return this._moveLeft(e, 'selectionStart');
      }
    },

    /**
     * Moves cursor right
     * @param {Event} e Event object
     */
    moveCursorRight: function(e) {
      if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
        return;
      }
      this._moveCursorLeftOrRight('Right', e);
    },

    /**
     * Moves cursor right or Left, fires event
     * @param {String} direction 'Left', 'Right'
     * @param {Event} e Event object
     */
    _moveCursorLeftOrRight: function(direction, e) {
      var actionName = 'moveCursor' + direction + 'With';
      this._currentCursorOpacity = 1;

      if (e.shiftKey) {
        actionName += 'Shift';
      }
      else {
        actionName += 'outShift';
      }
      if (this[actionName](e)) {
        this.abortCursorAnimation();
        this.initDelayedCursor();
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Moves cursor right while keeping selection
     * @param {Event} e
     */
    moveCursorRightWithShift: function(e) {
      if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
        return this._moveRight(e, 'selectionStart');
      }
      else if (this.selectionEnd !== this._text.length) {
        this._selectionDirection = 'right';
        return this._moveRight(e, 'selectionEnd');
      }
    },

    /**
     * Moves cursor right without keeping selection
     * @param {Event} e Event object
     */
    moveCursorRightWithoutShift: function(e) {
      var changed = true;
      this._selectionDirection = 'right';

      if (this.selectionStart === this.selectionEnd) {
        changed = this._moveRight(e, 'selectionStart');
        this.selectionEnd = this.selectionStart;
      }
      else {
        this.selectionStart = this.selectionEnd;
      }
      return changed;
    },

    /**
     * Removes characters from start/end
     * start/end ar per grapheme position in _text array.
     *
     * @param {Number} start
     * @param {Number} end default to start + 1
     */
    removeChars: function(start, end) {
      if (typeof end === 'undefined') {
        end = start + 1;
      }
      this.removeStyleFromTo(start, end);
      this._text.splice(start, end - start);
      this.text = this._text.join('');
      this.set('dirty', true);
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this._removeExtraneousStyles();
    },

    /**
     * insert characters at start position, before start position.
     * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
     * if style array is provided, it must be as the same length of text in graphemes
     * if end is provided and is bigger than start, old text is replaced.
     * start/end ar per grapheme position in _text array.
     *
     * @param {String} text text to insert
     * @param {Array} style array of style objects
     * @param {Number} start
     * @param {Number} end default to start + 1
     */
    insertChars: function(text, style, start, end) {
      if (typeof end === 'undefined') {
        end = start;
      }
      if (end > start) {
        this.removeStyleFromTo(start, end);
      }
      var graphemes = fabric.util.string.graphemeSplit(text);
      this.insertNewStyleBlock(graphemes, start, style);
      this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
      this.text = this._text.join('');
      this.set('dirty', true);
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this._removeExtraneousStyles();
    },

  });


  /* _TO_SVG_START_ */
  (function() {
    var toFixed = fabric.util.toFixed,
        multipleSpacesRegex = /  +/g;

    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      _toSVG: function() {
        var offsets = this._getSVGLeftTopOffsets(),
            textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
        return this._wrapSVGTextAndBg(textAndBg);
      },

      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        return this._createBaseSVGMarkup(
          this._toSVG(),
          { reviver: reviver, noStyle: true, withShadow: true }
        );
      },

      /**
       * @private
       */
      _getSVGLeftTopOffsets: function() {
        return {
          textLeft: -this.width / 2,
          textTop: -this.height / 2,
          lineTop: this.getHeightOfLine(0)
        };
      },

      /**
       * @private
       */
      _wrapSVGTextAndBg: function(textAndBg) {
        var noShadow = true,
            textDecoration = this.getSvgTextDecoration(this);
        return [
          textAndBg.textBgRects.join(''),
          '\t\t<text xml:space="preserve" ',
          (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
          (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
          (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
          (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
          (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
          'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
          textAndBg.textSpans.join(''),
          '</text>\n'
        ];
      },

      /**
       * @private
       * @param {Number} textTopOffset Text top offset
       * @param {Number} textLeftOffset Text left offset
       * @return {Object}
       */
      _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
        var textSpans = [],
            textBgRects = [],
            height = textTopOffset, lineOffset;
        // bounding-box background
        this._setSVGBg(textBgRects);

        // text and text-background
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          lineOffset = this._getLineLeftOffset(i);
          if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
            this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
          }
          this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
          height += this.getHeightOfLine(i);
        }

        return {
          textSpans: textSpans,
          textBgRects: textBgRects
        };
      },

      /**
       * @private
       */
      _createTextCharSpan: function(_char, styleDecl, left, top) {
        var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
            styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
            fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
            dy = styleDecl.deltaY, dySpan = '',
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        if (dy) {
          dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
        }
        return [
          '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
          toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
          fillStyles, '>',
          fabric.util.string.escapeXml(_char),
          '</tspan>'
        ].join('');
      },

      _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
        // set proper line offset
        var lineHeight = this.getHeightOfLine(lineIndex),
            isJustify = this.textAlign.indexOf('justify') !== -1,
            actualStyle,
            nextStyle,
            charsToRender = '',
            charBox, style,
            boxWidth = 0,
            line = this._textLines[lineIndex],
            timeToRender;

        textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
        for (var i = 0, len = line.length - 1; i <= len; i++) {
          timeToRender = i === len || this.charSpacing;
          charsToRender += line[i];
          charBox = this.__charBounds[lineIndex][i];
          if (boxWidth === 0) {
            textLeftOffset += charBox.kernedWidth - charBox.width;
            boxWidth += charBox.width;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
          if (isJustify && !timeToRender) {
            if (this._reSpaceAndTab.test(line[i])) {
              timeToRender = true;
            }
          }
          if (!timeToRender) {
            // if we have charSpacing, we render char by char
            actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
            nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
            timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
          }
          if (timeToRender) {
            style = this._getStyleDeclaration(lineIndex, i) || { };
            textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
            charsToRender = '';
            actualStyle = nextStyle;
            textLeftOffset += boxWidth;
            boxWidth = 0;
          }
        }
      },

      _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        textBgRects.push(
          '\t\t<rect ',
          this._getFillAttributes(color),
          ' x="',
          toFixed(left, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(top, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      },

      _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
        var line = this._textLines[i],
            heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
            boxWidth = 0,
            boxStart = 0,
            charBox, currentColor,
            lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (currentColor !== lastColor) {
            lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
              textTopOffset, boxWidth, heightOfLine);
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
          textTopOffset, boxWidth, heightOfLine);
      },

      /**
       * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
       * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
       *
       * @private
       * @param {*} value
       * @return {String}
       */
      _getFillAttributes: function(value) {
        var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
        if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
          return 'fill="' + value + '"';
        }
        return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
      },

      /**
       * @private
       */
      _getSVGLineTopOffset: function(lineIndex) {
        var lineTopOffset = 0, lastHeight = 0;
        for (var j = 0; j < lineIndex; j++) {
          lineTopOffset += this.getHeightOfLine(j);
        }
        lastHeight = this.getHeightOfLine(j);
        return {
          lineTop: lineTopOffset,
          offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
        };
      },

      /**
       * Returns styles-string for svg-export
       * @param {Boolean} skipShadow a boolean to skip shadow filter output
       * @return {String}
       */
      getSvgStyles: function(skipShadow) {
        var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
        return svgStyle + ' white-space: pre;';
      },
    });
  })();
  /* _TO_SVG_END_ */


  (function(global) {

    var fabric = global.fabric || (global.fabric = {});

    /**
     * Textbox class, based on IText, allows the user to resize the text rectangle
     * and wraps lines automatically. Textboxes have their Y scaling locked, the
     * user can only change width. Height is adjusted automatically based on the
     * wrapping of lines.
     * @class fabric.Textbox
     * @extends fabric.IText
     * @mixes fabric.Observable
     * @return {fabric.Textbox} thisArg
     * @see {@link fabric.Textbox#initialize} for constructor definition
     */
    fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'textbox',

      /**
       * Minimum width of textbox, in pixels.
       * @type Number
       * @default
       */
      minWidth: 20,

      /**
       * Minimum calculated width of a textbox, in pixels.
       * fixed to 2 so that an empty textbox cannot go to 0
       * and is still selectable without text.
       * @type Number
       * @default
       */
      dynamicMinWidth: 2,

      /**
       * Cached array of text wrapping.
       * @type Array
       */
      __cachedLines: null,

      /**
       * Override standard Object class values
       */
      lockScalingFlip: true,

      /**
       * Override standard Object class values
       * Textbox needs this on false
       */
      noScaleCache: false,

      /**
       * Properties which when set cause object to change dimensions
       * @type Object
       * @private
       */
      _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),

      /**
       * Use this regular expression to split strings in breakable lines
       * @private
       */
      _wordJoiners: /[ \t\r]/,

      /**
       * Use this boolean property in order to split strings that have no white space concept.
       * this is a cheap way to help with chinese/japaense
       * @type Boolean
       * @since 2.6.0
       */
      splitByGrapheme: false,

      /**
       * Unlike superclass's version of this function, Textbox does not update
       * its width.
       * @private
       * @override
       */
      initDimensions: function() {
        if (this.__skipDimension) {
          return;
        }
        this.isEditing && this.initDelayedCursor();
        this.clearContextTop();
        this._clearCache();
        // clear dynamicMinWidth as it will be different after we re-wrap line
        this.dynamicMinWidth = 0;
        // wrap lines
        this._styleMap = this._generateStyleMap(this._splitText());
        // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
        if (this.dynamicMinWidth > this.width) {
          this._set('width', this.dynamicMinWidth);
        }
        if (this.textAlign.indexOf('justify') !== -1) {
          // once text is measured we need to make space fatter to make justified text.
          this.enlargeSpaces();
        }
        // clear cache and re-calculate height
        this.height = this.calcTextHeight();
        this.saveState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Generate an object that translates the style object so that it is
       * broken up by visual lines (new lines and automatic wrapping).
       * The original text styles object is broken up by actual lines (new lines only),
       * which is only sufficient for Text / IText
       * @private
       */
      _generateStyleMap: function(textInfo) {
        var realLineCount     = 0,
            realLineCharCount = 0,
            charCount         = 0,
            map               = {};

        for (var i = 0; i < textInfo.graphemeLines.length; i++) {
          if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
            realLineCharCount = 0;
            charCount++;
            realLineCount++;
          }
          else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
            // this case deals with space's that are removed from end of lines when wrapping
            realLineCharCount++;
            charCount++;
          }

          map[i] = { line: realLineCount, offset: realLineCharCount };

          charCount += textInfo.graphemeLines[i].length;
          realLineCharCount += textInfo.graphemeLines[i].length;
        }

        return map;
      },

      /**
       * Returns true if object has a style property or has it on a specified line
       * @param {Number} lineIndex
       * @return {Boolean}
       */
      styleHas: function(property, lineIndex) {
        if (this._styleMap && !this.isWrapping) {
          var map = this._styleMap[lineIndex];
          if (map) {
            lineIndex = map.line;
          }
        }
        return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
      },

      /**
       * Returns true if object has no styling or no styling in a line
       * @param {Number} lineIndex , lineIndex is on wrapped lines.
       * @return {Boolean}
       */
      isEmptyStyles: function(lineIndex) {
        if (!this.styles) {
          return true;
        }
        var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false,
            map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
        if (map) {
          lineIndex = map.line;
          offset = map.offset;
        }
        if (mapNextLine) {
          nextLineIndex = mapNextLine.line;
          shouldLimit = nextLineIndex === lineIndex;
          nextOffset = mapNextLine.offset;
        }
        obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        for (var p1 in obj) {
          for (var p2 in obj[p1]) {
            if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
              // eslint-disable-next-line no-unused-vars
              for (var p3 in obj[p1][p2]) {
                return false;
              }
            }
          }
        }
        return true;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _getStyleDeclaration: function(lineIndex, charIndex) {
        if (this._styleMap && !this.isWrapping) {
          var map = this._styleMap[lineIndex];
          if (!map) {
            return null;
          }
          lineIndex = map.line;
          charIndex = map.offset + charIndex;
        }
        return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} style
       * @private
       */
      _setStyleDeclaration: function(lineIndex, charIndex, style) {
        var map = this._styleMap[lineIndex];
        lineIndex = map.line;
        charIndex = map.offset + charIndex;

        this.styles[lineIndex][charIndex] = style;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _deleteStyleDeclaration: function(lineIndex, charIndex) {
        var map = this._styleMap[lineIndex];
        lineIndex = map.line;
        charIndex = map.offset + charIndex;
        delete this.styles[lineIndex][charIndex];
      },

      /**
       * probably broken need a fix
       * Returns the real style line that correspond to the wrapped lineIndex line
       * Used just to verify if the line does exist or not.
       * @param {Number} lineIndex
       * @returns {Boolean} if the line exists or not
       * @private
       */
      _getLineStyle: function(lineIndex) {
        var map = this._styleMap[lineIndex];
        return !!this.styles[map.line];
      },

      /**
       * Set the line style to an empty object so that is initialized
       * @param {Number} lineIndex
       * @param {Object} style
       * @private
       */
      _setLineStyle: function(lineIndex) {
        var map = this._styleMap[lineIndex];
        this.styles[map.line] = {};
      },

      /**
       * Wraps text using the 'width' property of Textbox. First this function
       * splits text on newlines, so we preserve newlines entered by the user.
       * Then it wraps each line using the width of the Textbox by calling
       * _wrapLine().
       * @param {Array} lines The string array of text that is split into lines
       * @param {Number} desiredWidth width you want to wrap to
       * @returns {Array} Array of lines
       */
      _wrapText: function(lines, desiredWidth) {
        var wrapped = [], i;
        this.isWrapping = true;
        for (i = 0; i < lines.length; i++) {
          wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
        }
        this.isWrapping = false;
        return wrapped;
      },

      /**
       * Helper function to measure a string of text, given its lineIndex and charIndex offset
       * it gets called when charBounds are not available yet.
       * @param {CanvasRenderingContext2D} ctx
       * @param {String} text
       * @param {number} lineIndex
       * @param {number} charOffset
       * @returns {number}
       * @private
       */
      _measureWord: function(word, lineIndex, charOffset) {
        var width = 0, prevGrapheme, skipLeft = true;
        charOffset = charOffset || 0;
        for (var i = 0, len = word.length; i < len; i++) {
          var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
          width += box.kernedWidth;
          prevGrapheme = word[i];
        }
        return width;
      },

      /**
       * Wraps a line of text using the width of the Textbox and a context.
       * @param {Array} line The grapheme array that represent the line
       * @param {Number} lineIndex
       * @param {Number} desiredWidth width you want to wrap the line to
       * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
       * @returns {Array} Array of line(s) into which the given text is wrapped
       * to.
       */
      _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
        var lineWidth = 0,
            splitByGrapheme = this.splitByGrapheme,
            graphemeLines = [],
            line = [],
            // spaces in different languges?
            words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners),
            word = '',
            offset = 0,
            infix = splitByGrapheme ? '' : ' ',
            wordWidth = 0,
            infixWidth = 0,
            largestWordWidth = 0,
            lineJustStarted = true,
            additionalSpace = splitByGrapheme ? 0 : this._getWidthOfCharSpacing(),
            reservedSpace = reservedSpace || 0;
        // fix a difference between split and graphemeSplit
        if (words.length === 0) {
          words.push([]);
        }
        desiredWidth -= reservedSpace;
        for (var i = 0; i < words.length; i++) {
          // if using splitByGrapheme words are already in graphemes.
          word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);
          wordWidth = this._measureWord(word, lineIndex, offset);
          offset += word.length;

          lineWidth += infixWidth + wordWidth - additionalSpace;

          if (lineWidth >= desiredWidth && !lineJustStarted) {
            graphemeLines.push(line);
            line = [];
            lineWidth = wordWidth;
            lineJustStarted = true;
          }
          else {
            lineWidth += additionalSpace;
          }

          if (!lineJustStarted && !splitByGrapheme) {
            line.push(infix);
          }
          line = line.concat(word);

          infixWidth = this._measureWord([infix], lineIndex, offset);
          offset++;
          lineJustStarted = false;
          // keep track of largest word
          if (wordWidth > largestWordWidth) {
            largestWordWidth = wordWidth;
          }
        }

        i && graphemeLines.push(line);

        if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
          this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
        }

        return graphemeLines;
      },

      /**
       * Detect if the text line is ended with an hard break
       * text and itext do not have wrapping, return false
       * @param {Number} lineIndex text to split
       * @return {Boolean}
       */
      isEndOfWrapping: function(lineIndex) {
        if (!this._styleMap[lineIndex + 1]) {
          // is last line, return true;
          return true;
        }
        if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
          // this is last line before a line break, return true;
          return true;
        }
        return false;
      },

      /**
       * Detect if a line has a linebreak and so we need to account for it when moving
       * and counting style.
       * @return Number
       */
      missingNewlineOffset: function(lineIndex) {
        if (this.splitByGrapheme) {
          return this.isEndOfWrapping(lineIndex) ? 1 : 0;
        }
        return 1;
      },

      /**
      * Gets lines of text to render in the Textbox. This function calculates
      * text wrapping on the fly every time it is called.
      * @param {String} text text to split
      * @returns {Array} Array of lines in the Textbox.
      * @override
      */
      _splitTextIntoLines: function(text) {
        var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
            graphemeLines = this._wrapText(newText.lines, this.width),
            lines = new Array(graphemeLines.length);
        for (var i = 0; i < graphemeLines.length; i++) {
          lines[i] = graphemeLines[i].join('');
        }
        newText.lines = lines;
        newText.graphemeLines = graphemeLines;
        return newText;
      },

      getMinWidth: function() {
        return Math.max(this.minWidth, this.dynamicMinWidth);
      },

      _removeExtraneousStyles: function() {
        var linesToKeep = {};
        for (var prop in this._styleMap) {
          if (this._textLines[prop]) {
            linesToKeep[this._styleMap[prop].line] = 1;
          }
        }
        for (var prop in this.styles) {
          if (!linesToKeep[prop]) {
            delete this.styles[prop];
          }
        }
      },

      /**
       * Returns object representation of an instance
       * @method toObject
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['minWidth', 'splitByGrapheme'].concat(propertiesToInclude));
      }
    });

    /**
     * Returns fabric.Textbox instance from an object representation
     * @static
     * @memberOf fabric.Textbox
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
     */
    fabric.Textbox.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Textbox', object, callback, 'text');
    };
  })( exports );
  });
  var fabric_2 = fabric_1.fabric;

  var Viewer2D = function (_EventDispatcher) {
      inherits(Viewer2D, _EventDispatcher);

      function Viewer2D(canvasHolder, floorplan, options) {
          classCallCheck(this, Viewer2D);

          var _this = possibleConstructorReturn(this, (Viewer2D.__proto__ || Object.getPrototypeOf(Viewer2D)).call(this));

          _this.__canvas = new fabric_2.Canvas('bp3djs-viewer2d');

          var rect = new fabric_2.Rect({ left: 100, top: 100, fill: 'blue', width: 20, height: 20 });
          _this.__canvas.add(rect);
          return _this;
      }

      createClass(Viewer2D, [{
          key: '__initializeViewerAndEvents',
          value: function __initializeViewerAndEvents() {}
      }, {
          key: '_zoomViewer',
          value: function _zoomViewer(e) {}
      }, {
          key: 'updateStageSize',
          value: function updateStageSize() {

              var w = window.innerWidth;
              var h = window.innerHeight;

              this._parent.css({ width: window.innerWidth, height: window.innerHeight });

              this.height = h;
              this.width = w;
          }
      }]);
      return Viewer2D;
  }(EventDispatcher);

  //Classes from core module
  //


  ///** VestaDesigner core application. */
  var BlueprintJS = function () {
    /**
     * Creates an instance of BlueprintJS. This is the entry point for the application
     *
     * @param {Object} - options The initialization options.
     * @param {string} options.floorplannerElement - Id of the html element to use as canvas. Needs to exist in the html
     * @param {string} options.threeElement - Id of the html element to use as canvas. Needs to exist in the html and should be #idofhtmlelement
     * @param {string} options.threeCanvasElement - Id of the html element to use as threejs-canvas. This is created automatically
     * @param {string} options.textureDir - path to texture directory. No effect
     * @param {boolean} options.widget - If widget mode then disable the controller from interactions
     * @example
     * let blueprint3d = new BP3DJS.BlueprintJS(opts);
     */
    function BlueprintJS(options) {
      classCallCheck(this, BlueprintJS);

      Configuration.setValue(configDimUnit, dimCentiMeter);

      /**
       * @property {Object} options
       * @type {Object}
       **/
      this.options = options;
      /**
       * @property {Model} model
       * @type {Model}
       **/
      this.model = new Model(options.textureDir);
      /**
       * @property {Main} three
       * @type {Main}
       **/
      // this.three = new Main(this.model, options.threeElement, options.threeCanvasElement, {});
      /**
       * @property {Main} three
       * @type {Main}
       **/
      this.three = new Viewer3D(this.model, options.threeElement, this.options);
      this.view_now = 2;

      if (!options.widget) {
        /**
         * @property {Floorplanner2D} floorplanner
         * @type {Floorplanner2D}
         **/
        // this.floorplanner = new Floorplanner2D(options.floorplannerElement, this.model.floorplan);
        this.floorplanner = new Viewer2D(options.floorplannerElement, this.model.floorplan, this.options);
      }
      // else {
      //     this.three.getController().enabled = false;
      // }
    }

    createClass(BlueprintJS, [{
      key: 'switchView',
      value: function switchView() {
        if (this.view_now === 3 && !this.options.widget) {
          this.view_now = 2;
        }
        if (this.view_now === 2 && !this.options.widget) {
          this.view_now = 3;
        }
      }
    }]);
    return BlueprintJS;
  }();

  exports.BlueprintJS = BlueprintJS;
  exports.Configuration = Configuration;
  exports.Corner = Corner;
  exports.Dimensioning = Dimensioning;
  exports.ELogContext = ELogContext;
  exports.ELogLevel = ELogLevel;
  exports.EVENT_ACTION = EVENT_ACTION;
  exports.EVENT_CAMERA_ACTIVE_STATUS = EVENT_CAMERA_ACTIVE_STATUS;
  exports.EVENT_CAMERA_MOVED = EVENT_CAMERA_MOVED;
  exports.EVENT_CAMERA_VIEW_CHANGE = EVENT_CAMERA_VIEW_CHANGE;
  exports.EVENT_CHANGED = EVENT_CHANGED;
  exports.EVENT_CORNER_2D_CLICKED = EVENT_CORNER_2D_CLICKED;
  exports.EVENT_CORNER_2D_DOUBLE_CLICKED = EVENT_CORNER_2D_DOUBLE_CLICKED;
  exports.EVENT_CORNER_2D_HOVER = EVENT_CORNER_2D_HOVER;
  exports.EVENT_CORNER_ATTRIBUTES_CHANGED = EVENT_CORNER_ATTRIBUTES_CHANGED;
  exports.EVENT_DELETED = EVENT_DELETED;
  exports.EVENT_FLOOR_CLICKED = EVENT_FLOOR_CLICKED;
  exports.EVENT_FPS_EXIT = EVENT_FPS_EXIT;
  exports.EVENT_GLTF_READY = EVENT_GLTF_READY;
  exports.EVENT_ITEM_LOADED = EVENT_ITEM_LOADED;
  exports.EVENT_ITEM_LOADING = EVENT_ITEM_LOADING;
  exports.EVENT_ITEM_REMOVED = EVENT_ITEM_REMOVED;
  exports.EVENT_ITEM_SELECTED = EVENT_ITEM_SELECTED;
  exports.EVENT_ITEM_UNSELECTED = EVENT_ITEM_UNSELECTED;
  exports.EVENT_LOADED = EVENT_LOADED;
  exports.EVENT_LOADING = EVENT_LOADING;
  exports.EVENT_MODE_RESET = EVENT_MODE_RESET;
  exports.EVENT_MOVED = EVENT_MOVED;
  exports.EVENT_NEW = EVENT_NEW;
  exports.EVENT_NEW_ROOMS_ADDED = EVENT_NEW_ROOMS_ADDED;
  exports.EVENT_NOTHING_CLICKED = EVENT_NOTHING_CLICKED;
  exports.EVENT_REDRAW = EVENT_REDRAW;
  exports.EVENT_ROOM_2D_CLICKED = EVENT_ROOM_2D_CLICKED;
  exports.EVENT_ROOM_2D_DOUBLE_CLICKED = EVENT_ROOM_2D_DOUBLE_CLICKED;
  exports.EVENT_ROOM_2D_HOVER = EVENT_ROOM_2D_HOVER;
  exports.EVENT_ROOM_ATTRIBUTES_CHANGED = EVENT_ROOM_ATTRIBUTES_CHANGED;
  exports.EVENT_ROOM_CLICKED = EVENT_ROOM_CLICKED;
  exports.EVENT_ROOM_NAME_CHANGED = EVENT_ROOM_NAME_CHANGED;
  exports.EVENT_SAVED = EVENT_SAVED;
  exports.EVENT_UPDATED = EVENT_UPDATED;
  exports.EVENT_WALL_2D_CLICKED = EVENT_WALL_2D_CLICKED;
  exports.EVENT_WALL_2D_DOUBLE_CLICKED = EVENT_WALL_2D_DOUBLE_CLICKED;
  exports.EVENT_WALL_2D_HOVER = EVENT_WALL_2D_HOVER;
  exports.EVENT_WALL_ATTRIBUTES_CHANGED = EVENT_WALL_ATTRIBUTES_CHANGED;
  exports.EVENT_WALL_CLICKED = EVENT_WALL_CLICKED;
  exports.Edge3D = Edge3D;
  exports.Factory = Factory;
  exports.Floor3D = Floor3D;
  exports.FloorItem = FloorItem;
  exports.Floorplan = Floorplan;
  exports.HalfEdge = HalfEdge;
  exports.InWallFloorItem = InWallFloorItem;
  exports.InWallItem = InWallItem;
  exports.Item = Item;
  exports.Lights3D = Lights3D;
  exports.Metadata = Metadata;
  exports.Model = Model;
  exports.OBJExporter = OBJExporter;
  exports.OnFloorItem = OnFloorItem;
  exports.Region = Region;
  exports.RoofItem = RoofItem;
  exports.Room = Room;
  exports.Scene = Scene$1;
  exports.Skybox = Skybox;
  exports.Utils = Utils;
  exports.VIEW_FRONT = VIEW_FRONT;
  exports.VIEW_ISOMETRY = VIEW_ISOMETRY;
  exports.VIEW_LEFT = VIEW_LEFT;
  exports.VIEW_RIGHT = VIEW_RIGHT;
  exports.VIEW_TOP = VIEW_TOP;
  exports.Version = Version;
  exports.Viewer3D = Viewer3D;
  exports.Wall = Wall;
  exports.WallFloorItem = WallFloorItem;
  exports.WallItem = WallItem;
  exports.WallTypes = WallTypes;
  exports.cmPerFoot = cmPerFoot;
  exports.cmPerPixel = cmPerPixel;
  exports.config = config;
  exports.configDimUnit = configDimUnit;
  exports.configSystemUI = configSystemUI;
  exports.configWallHeight = configWallHeight;
  exports.configWallThickness = configWallThickness;
  exports.cornerTolerance = cornerTolerance;
  exports.decimals = decimals;
  exports.defaultFloorPlanTolerance = defaultFloorPlanTolerance;
  exports.defaultRoomTexture = defaultRoomTexture;
  exports.defaultWallTexture = defaultWallTexture;
  exports.dimCentiMeter = dimCentiMeter;
  exports.dimFeetAndInch = dimFeetAndInch;
  exports.dimInch = dimInch;
  exports.dimMeter = dimMeter;
  exports.dimMilliMeter = dimMilliMeter;
  exports.dimensioningOptions = dimensioningOptions;
  exports.gridSpacing = gridSpacing;
  exports.isLogging = isLogging;
  exports.item_types = item_types;
  exports.log = log;
  exports.logContext = logContext;
  exports.pixelsPerCm = pixelsPerCm;
  exports.pixelsPerFoot = pixelsPerFoot;
  exports.scale = scale;
  exports.snapToGrid = snapToGrid;
  exports.snapTolerance = snapTolerance;
  exports.wallInformation = wallInformation;

  return exports;

}({}));
